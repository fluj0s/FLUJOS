lx4380 data sheet lexra inc release 21 february 25 2002 lexra proprietary and confidentiallx4380 data sheet revision 14 for rtl release 21 lexra proprietary and confidential copyright 2001 lexra inc all rights reserved mips mips16 mips abi mips i mips ii mips iv mips v mips32 r3000 r4000 and other mips common law marks are trademarks andor registered trademarks of mips technologies inc lexra inc is not associated with mips technologies inc in any way smoothcore and radiax are trademarks of lexra increlease 21 lexra proprietary confidential ilx4380 table of contents 1 product overview 1 11 introduction 1 12 lx4380 processor overview 2 13 system level building blocks 3 131 multiplyaccumulate mac 4 132 memory management unit mmu 4 133 local memory interface lmi 4 134 coprocessor interface ci 4 135 custom engine interface cei 5 136 cache bus cbus interface 5 137 lexra bus controller lbc 5 138 ejtag debug support 5 139 building block integration 5 14 rtl core smoothcore licensing models 5 15 eda tool support 6 2 architecture 7 21 hardware architecture 7 22 seven stage pipeline 8 23 ralu data path 8 24 system control coprocessor cp0 8 3 risc programming model 11 31 summary of basic risc instructions 11 311 alu instructions 12 312 load and store instructions 14 313 conditional move instructions 15 314 branch and jump instructions 16 315 control instructions 17 316 coprocessor instructions 18 32 opcode extension using the custom engine interface cei 20 33 simple memory management unit 21 34 exception processing 22 341 exception processing registers 23 342 exception processing entry and exit 24 35 lowoverhead prioritized interrupts 25 36 coprocessors 26 4 integer multiplyaccumulate 29 41 mac overview 29 42 mac instructions 30 43 mac pipeline 33 44 accessing hi and after multiply instructions 34 45 divider overview and register usage 35 5 memory management unit mmu 37 51 memory regions 37 52 registers 38 53 tlb instructions 41ii lexra proprietary confidential release 21lx4380 54 mapped address translation 41 55 stalls 42 56 mmu exceptions 42 57 instruction and data tlbs 43 58 comparison of lx4380 mmu features 43 59 use restrictions after tlb modification 43 510 use restrictions after asid modification 44 511 determining the number of tlb entries via software 44 6 coprocessor interface 45 61 attaching coprocessor using the coprocessor interface ci 45 62 coprocessor interface ci signals 45 63 coprocessor write operations 46 64 coprocessor read operations 46 65 coprocessor interface and pipeline stages 47 651 pipeline holds 48 652 pipeline invalidation 48 7 local memory 51 71 local memory overview 51 72 cache control register cctl 52 73 cache instruction 54 74 instruction cache icache lmi 54 75 instruction memory imem lmi 56 76 data cache dcache lmi 57 77 scratch pad data memory dmem lmi 61 8 cbus interface 63 81 system interface configuration 63 82 cbus interface write buffer and outoforder processing 64 83 cbus line read interleave order 64 84 cbus byte alignment 65 85 cbus interface signal list 66 86 cbus transaction types 67 87 cbus protocol 67 88 cbus transaction timing diagrams 67 881 backtoback single writes with busy 67 882 line writes 68 883 backtoback single read requests with busy 69 884 line read request 69 885 returning read data 70 886 latency of cbus transactions 70 9 lexra system bus lbus 73 91 connecting the lx4380 to internal devices 73 92 terminology 74 93 bus operations 74 931 single data read 75 932 line read 75 933 burst read 75 934 single data write 76 935 line write 76 936 burst write 76release 21 lexra proprietary confidential iiilx4380 94 signal descriptions 77 95 lbus commands 78 96 lbus byte alignment 79 97 lexra bus controller 80 971 lbc commands 80 972 write buffer 80 973 lbc read buffer 80 98 transaction descriptions 81 981 single data read with waits 82 982 single data read with target wait 82 983 line read with waits 83 984 line read with target waits 84 985 line read with initiator waits 84 986 burst read 85 987 single data write with waits 85 988 single data write with waits 86 989 line write with waits 86 9810 line write with target waits 87 9811 line write with initiator waits 87 9812 burst write 87 99 lbc signals 87 910 arbitration 88 9101 lbus rules 88 9102 lbc behavior 89 911 connecting the lbc to lbus 89 10 ejtag debug 91 101 overview 91 1011 ieee jtagspecific pinout 92 102 program counter pc trace 93 1021 pc trace dclk debug clock 93 1022 pc trace pcst program counter status trace 93 1023 pc trace tpc target program counter 93 1024 singleprocessor pc trace pinout 94 1025 vectored interrupts and pc trace 94 1026 demultiplexing of tdo and tdi during pc trace 95 appendix instruction formats 97 a1 major opcodes 97 a2 major opcodes 97 a3 lexop instructions 98 a4 lexop2 instructions 99 a5 cop0 instructions 100 a6 special instructions 101 a7 special2 instructions 102 appendix b lconfig forms 103 b1 configuration options for the lx4380 processor 103 appendix c port descriptions 105 appendix d pipeline stalls 111 d1 stall definitions 111 d2 instruction groupings 111iv lexra proprietary confidential release 21lx4380 d3 nonsequential program flow issue stalls 111 d4 loadstore rules 112 d5 mac ops interlock matrix 113 d6 mvcz stall 113 d7 tlbw stall 113 d8 mmu stalls 114 d9 cache miss stalls 115 d10 pipeline diagrams for nonsequential program flow issue stalls 115 d11 pipeline diagram for mac ops interlock stall 117 d12 pipeline diagram for mvcz stall 117 d13 pipeline diagram for tlbw stall 117 d14 pipeline diagrams for dtlb stalls 117 d15 pipeline diagrams for cache misses 119release 21 lexra proprietary confidential vlx4380 list of tables table 1 eda tool support6 table 2 cp0 registers9 table 3 extended cp0 registers10 table 4 alu instructions12 table 5 load and store instructions14 table 6 conditional move instructions15 table 7 branch and jump instructions16 table 8 control instructions17 table 9 coprocessor instructions18 table 10 custom engine interface operations20 table 11 smmu address translation21 table 12 list of exceptions22 table 13 prioritized interrupt exception vectors26 table 14 32bit multiply and divide instructions30 table 15 16bit multiply and multiplyaccumulate instructions31 table 16 32bit multiplyaccumulate instructions32 table 17 mmu address translation37 table 18 tlb exceptions42 table 19 coprocessor interface signals45 table 20 local memory interface modules52 table 21 icache configurations55 table 22 icache ram interfaces55 table 23 imem configurations56 table 24 imem ram interfaces57 table 25 dcache configurations58 table 26 dcache ram interfaces58 table 27 data cache operations and results60 table 28 dmem configurations61 table 29 dmem ram interfaces61 table 30 line read interleave order65 table 31 cbus byte lane assignment65 table 32 cbus signal list66 table 33 line read interleave order75 table 34 lbus signal description77 table 35 lbus byte lane assignment79 table 36 lbus commands issued by the lbc80 table 37 lbc interface signals88 table 38 ejtag pinout92 table 39 ejtag ac characteristics92 table 40 ejtag synthesis constraints92 table 41 singleprocessor pc trace pinout94 table 42 singleprocessor pc trace ac characteristics94 table 43 major opcode instruction formats97 table 44 major opcode bit encodings97 table 45 lexop instruction formats98 table 46 lexop subop bit encodings98 table 47 lexop2 load instruction formats99 table 48 lexop2 subop bit encodings99 table 49 cop0 instruction formats100 table 50 cop0 subop bit encodings100 table 51 special instruction formats101vi lexra proprietary confidential release 21lx4380 table 52 special subop bit encodings101 table 53 special2 instruction formats102 table 54 special2 subop bit encodings102 table 55 configuration options103 table 56 lx4380 processor port summary105 table 57 instruction groupings for stall definition111 table 58 cycles required between mac instructions113release 21 lexra proprietary confidential viilx4380 list of figures figure 1 lx4380 processor overview2 figure 2 processor core module partitioning7 figure 3 mac data paths29 figure 4 coprocessor write46 figure 5 coprocessor read47 figure 6 exception during coprocessor read49 figure 7 invalidation of coprocessor read49 figure 8 lx4380 system interface configurations63 figure 9 cbus backtoback single writes with busy68 figure 10 cbus line write68 figure 11 cbus backtoback single read requests with busy69 figure 12 cbus line read request69 figure 13 cbus read data and dbusy70 figure 14 read data for line read request70 figure 15 latency of cbus transactions70 figure 16 lexra system bus lbus diagram73viii lexra proprietary confidential release 21lx4380release 21 lexra proprietary confidential 1lx4380 section 1 product overview 1 product overview 11 introduction this data sheet describes lexras lx4380 processor core risc processor developed for intellectual propertyiplicensing thelx4380isacarefullyengineeredextensiontotheinstustrystarndardmipsi isathemajorsubsystemsarethecpucorelocalmemoryinterfaceslmiandlbuscontrollerlbc the technology includes optional interfaces to customerdefined coprocessors ci12 and custom engine ce that provide extensions to the instruction set the lx4380 is an upgrade to the lx4189 adding 7stage pipeline optional data cache support for write back policy and 2way set associativity and an optional memory management unit featuresintroducedinlexrasriscproductlinesupportsystemonchipsocdesignincludingcustomer defined coprocessors and customer extensions to the mips isa are standard in the lx4380 configuration options include enhanced jtag ejtag support for debug and incircuit emulation ice because the lx4380 executes the mips instruction set1 wide variety of thirdparty software tools are available including compilers operating systems debuggers and incircuit emulators the assembler extensions andacycle accurate instructionset simulator iss aresuppliedby lexraprogrammers can use offtheshelf c compilers for initial coding then replace performancecritical loops with optimized assembler code code development tool support is provided by lexra and by thirdparties for gnu tools and by greenhills software for the multi 2000 ide key features complete processor core highperformance 7stage pipeline executes mipsi isa extensive thirdparty tool support system level building blocks optional r3000style mmu or simplified mmmu smmu optional multiply accumulate unit mac local instruction andor cache interfaces configurable sizes local data memory andor cache interfaces configurable sizes optional customerdefined coprocessors optional customerdefined instruction extensions system bus controller optional ejtag draft 200 support for debugging 1 except unaligned loads stores which are executed as nops2 lexra proprietary confidential release 21section 1 product overview lx4380 portable rtl model available as synthesizable rtl portable to any 018 µm015µm or 013µm process support for any thirdparty logic and sram libraries foundry partners include tsmc and umc easy asic integration exclusive use of positiveedge clocking fully synchronous design system level building blocks provide easy asic interfaces supports for popular eda tools userconfigurable local memory reset method clock distribution userconfigurable ejtag breakpoints over 30 other configuration options 12 lx4380 processor overview the lx4380 is risc processor that executes the mipsi instruction set1along with lexras extensions the clocking pipeline structure pinout and memory interfaces have all been developed by lexra to reflect systemonsilicon design needs deep submicron process technology as well as design methodology advances figure1 shows the structure of the lx4380 processor figure 1 lx4380 processor overview mips i execution the lx4380 supports the mipsi programming model two source operands can be supplied and one destination update performed per cycle the second operand is either register or 16bit immediatetheinstructionsetincludesawideselectionofaluoperationsexecutedbytheralulexras proprietary register based alu the ralu also generates memory addresses for 8bit 16bit and 32bit register loads from stores to memory by adding register base to an immediate offset branches are based on comparisons between registers rather than flags and are therefore easy to relocate optional links following jump or branch instructions assist with subroutine programming 1 the mips unaligned load and store instructions lwl lwr swl swr are executed as nopsinst ramicache ram inst lmi data lmi data ramdcache ramlx4380 cpu corecustom engine cisceidata bus coprocessors 12lbcsystem bus denotes customer logicmmudebug probeejtag instruction bus cbicbusrelease 21 lexra proprietary confidential 3lx4380 section 1 product overview pipeline lx4380 instructions are executed by sevenstage pipeline that has been designed so that all transactions internal to the lx4380 as well as at the interfaces occur on the positive edge of the processor clock twophase clocks are not used the sevenstage pipeline allocates full addressregistertodata outputregister clock cycle to both local instruction access and data access as result the memories have the best timing specification possible and are decoupled from critical paths internal to the processor exception handling the mips r3000 exception model is supported exceptions include both instruction synchronous trapsas well as hardware and software interrupts the cp0 status register controls the interrupt mask and operating mode exceptions are prioritized when an exception is taken control is transferred to the exception vector the current instruction address is saved in the epc register and the exceptionsourceisidentifiedinthecp0causeregisterintheeventofanaddresserrorexceptionthecp0 badvaddrregisterholdsthefailingaddressforthemipsexceptionsaprogramlocatedattheexception vector identifies the cause of the exception and transfers control to the applicationspecific handler in addition to the mips r3000 exceptions the lx4380 supports up to eight prioritized vectored interrupts to meet hard realtime response requirements coprocessorinstructions thelx4380supportsthemipsicoprocessorinstructionstheseincludemoves toandfromthe32bitcoprocessorgeneralregistersandcontrolregistersmtczmfczctczcfcz32 bitcoprocessorloadsandstoreslwczswczandbranchesbasedoncoprocessorconditionflagsbczt bczf performance and ease of use the lx4380 provides excellent priceperformance and timetomarket there are two strategies used to achieve this deliver simple building blocks outside the processor core to enable system level customizations such as coprocessors application specific instructions memories and busses deliver either fully synthesizable verilog source model or fully implemented hard core called smoothcore for customerselected foundries section13 describes the system level building blocks and section14 describes the licensing models 13 system level building blocks the lx4380 processor is designed to easily fit into different target applications it provides the following building blocks memory management unit mmu options as either r3000style with translation lookaside buffer tlb or lowcost simplified mmu smmu for deeply embedded applications an optional multiply accumulate unit mac flexible local memory interface lmi that supports instruction cache instruction ram data cache and data ram up to two coprocessor interfaces ci an optimized custom engine interface cei simplified cache bus interface cbus for simplified connection to peripheral devices and main memory an optional lexra bus controller lbc and lexra bus lbus protocol for connection4 lexra proprietary confidential release 21section 1 product overview lx4380 to peripheral devices and main memory optional ejtag support for embedded debug the following sections discuss each of these system building block interfaces 131 multiplyaccumulate mac theoptionalmacprovides32bithiandloaccumulatorsfor32bitmultiplyanddivideoperationsand16 bit and 32bit multiplyaccumulate operations the mac is pipelined for optimal performance but also manages resource conflicts to simplify programming and debug 132 memory management unit mmu the optional lx4380 mips r3000style mmu is designed to permit code to run under major operating systemssuchaslinuxthatrequireatranslationlookasidebuffertlbforrobustprotectionofthirdparty programsanddata themmuincludesa3entryinstructiontranslationlookasidebufferitlba3entry data translation lookaside buffer dtlb and 16 32 or 64entry rtlconfigurable joint translation lookaside buffer tlb alternatively for deeply embedded applications using single address space simplified memory management unit smmu is available the primary function of the smmu is to provide memory protection between user space and kernel space the smmu is consistent with the mips address space scheme for userkernel modes mapping and cacheduncached regions 133 local memory interface lmi the lx4380s harvard architecture provides local memory interfaces lmis that support instruction memory and data memory synchronous memory interfaces are employed for all memory blocks the lmi block is designed to easily interface with standard memory blocks provided by asic vendors or by third party library vendors the lmis provide directmapped or twoway set associative instruction cache interface and directmapped or twoway set associative data cache interface the data cache can be selected to be either writethrough or writebackthetagcomparelogicaswellasacachereplacementalgorithmareprovidedaspartofthelmi one of the instruction cache sets may be locked down as unswappable local memory lexras sevenstage executionpipeline provides output registers in both theinstruction and data lmis sothat thememories have the best timing specification possible and are decoupled from critical paths internal to the processor 134 coprocessor interface ci lexra supplies an optional coprocessor interface ci for applications that use custom coprocessor up to twocismaybeemployedinonedesignthecoprocessorinterfaceeavesdropsontheinstructionbusifa coprocessor load lwcz or move to mtcz ctcz instruction is decoded data is passed over the data bus into ci register then supplied to the customerdesigned coprocessor similarly if coprocessor store swcz or move from mfcz cfcz instruction is decoded data is obtained from the coprocessor and loadedintoaciregisterthentransferredontothedatabusinthefollowingcycletheciincludesadatabus fivebitaddressandindependentreadandwriteselectsforcoprocessorgeneralregistersandcontrolregisters the lx4380 pipeline and harvard architecture permit single cycle coprocessor access and transfer an applicationdefined coprocessor condition flag is synchronized by the ci then passed to the lx4380 sequencer for testing in branch instructionsrelease 21 lexra proprietary confidential 5lx4380 section 1 product overview 135 custom engine interface cei the lx4380 includes custom engine interface cei that the application may use to extend the mips i alu opcodes with applicationspecific or proprietary operations similar to the standard alu the cei supplies the custom engine two input 32bit operands src1 and src2 one operand is selected from the register file depending on the most significant 6 bits of the opcode the second operand is either selected from the register file or is 16bit signextended immediate the opcode is locally decoded by the custom engine and following execution by the custom engine the result is returned on the 32bit result bus to the lx4380 to support multicycle operations stall input is included in the interface 136 cache bus cbus interface the cbus interface is simple signalling layer between the lx4380 processors cache controllers and the optional lx4380 system bus interface the lbc lx4380 applications that do not require the full feature set of the lbc or that connect to bus protocol other than lbus may optionally eliminate the lbc and provide their own system bus interfaces or devices that connect directly to the lx4380 using the cbus interfacethelx4380scbusinterfaceincludesabuiltinwritebufferofconfigurabledepthtooptimizethe performanceofwritesthatoccurasaresultwritethroughdatacacheoperationorwritesthatmissthewrite back data cache 137 lexra bus controller lbc the optional lexra bus controller lbc is the interface between the lx4380 and system bus devices which may include dram and various peripherals the lbc implements lexras lbus protocol non multiplexednonpipelinedbustoprovideasimplebusprotocolfordesignintegrationontheprocessorside the lbc connects to the lx4380 cbus on the system side the lbc is designed to easily interface to industry standard bus protocols such as pci usb and firewire the lbc supports synchronous modes with the lbus operating at full cpu speed or half cpu speed and an asynchronous mode that allows the lbus to be clocked at any speed independent of the cpu speed 138 ejtag debug support thelx4380providesoptionalejtagenhancedjtagdebugsupportejtagallowsthirdpartyhardware probes and debug software to access the processor and its attached devices in the same way the processor would access those devices ejtag also supports singlestep instruction execution instruction breakpoints and data breakpoints 139 building block integration the lx4380 configuration script lconfig provides menu of selections for designers to specify building blocks needed number of different memory blocks target speed and target standard cell library next the configuration software automatically generates top level verilog model makefiles and scripts for all steps of the design flow for testability purposes all building blocks contain scan control signals the lexra synthesis scripts support optional scan insertion which allows atpg testing of the entire lx4380 core 14 rtl core smoothcore licensing models lexra delivers lx4380 as either an rtl model or smoothcore rtl model for standard asic designs the rtl model is fully synthesizable and scantestable verilog sourcecodeandmaybetargetedtoanyasicvendorsstandardcelllibrariesinthiscasethedesignermay6 lexra proprietary confidential release 21section 1 product overview lx4380 simplyfollowtheasicvendorsdesignflowtoensurepropersignoffinadditiontotheverilogsourcecode andsystemleveltestbenchlexraprovidessynthesisscriptsaswellasfloorplanguidelinestomaximizethe performance of the lx4380 smoothcore forcotdesignsthataremanufacturedatfoundriessuchastsmcandumcasmoothcore portisthequickestlowestcostandbestperformancechoicelexraprovidesaportingservicethatdeliversa fully implemented and verified hard macro for customerspecific configuration foundry and library all datapathregisterfileandinterfaceoptimizationsareperformedbylexratoensurethesmallestdiesizeand fastest performance possible scan based test pattern is provided for fault coverage during manufacturing tests 15 eda tool support lexra supports mainstream eda software so designers do not have to alter their design methodology the following is snapshot of eda tools currently supported table 1 eda tool support design flow tools supported simulation synopsys vcs cadence verilog xl cadence ncverilog synthesis synopsys design compiler static timing synopsys primetime dft synopsys tetramax pr avant apollo iirelease 21 lexra proprietary confidential 7lx4380 section 2 architecture 2 architecture 21 hardware architecture thelx4380processorincludesthecontrolprocessorcp0andtheregisterfileandaluraluaswell as the optional memory management unit mmu cp0 includes instruction address sequencing and exception processing the ralu performs alu operations and generates data addresses the mmu converts the virtual page numbers vpns in the instruction address and data address into page frame numbers pfns figure 2processor core module partitioninginstruction control and page offset control registersexception processing logicpc and sequencer datadata control and page offsetflags trapscp0 register file 32 x 32bit r00 aluralu data tlbjoint tlbinstruction tlbmmu optional tlb readwriteinstruction vpn data vpninstruction pfn data pfn instructions8 lexra proprietary confidential release 21section 2 architecture lx4380 22 seven stage pipeline the lx4380 has seven stage pipeline the seven stage pipeline provides complete processor cycle for the instruction memory and data memory accesses allowing use of larger memories and 2way setassociative caches without degrading cycle time the seven pipeline stages allow the processor clock speed to scale with current silicon processes two cycle penalty is incurred on branch prediction failure however the lx4380s conditional move instructions can be used to avoid any wasted cycles in the control of realtime critical loops 23 ralu data path the lx4380 ralu incorporates 32x32b fourport register file one write port is dedicated to 32bit register file loads from the data bus loads mfcz cfcz moves from coprocessor the remaining three ports 2r1w are used for the other operations such as alu operations theinstructionsetincludesawideselectionofaluoperationsexecutedbytheraluinthecaseofalu operations one operand is register and the second operand is either register or 16bit immediate value the immediate value is signextended or zeroextended depending on the operation signed adds and subtracts can generate the arithmetic overflow trap ov which is sampled by cp0 theralualsogeneratesthevirtualmemoryaddressesforregisterloadsfromstorestomemorybyadding aregisterbasetoasignextended16bitimmediateoffsetdataaddresserrorsgeneratethe adelades trap flags which are sampled by cp0 the lx4380 employs bigendian memory addressing branches are based on comparisons between registers rather than implicit flags permitting the programmer moreflexibilityfromthesecomparisonstheralugenerates nandzflagsforsamplingincp0branchor jump instructions may optionally store in general purpose register the address of the instruction at the memory location following the branch delay slot of jump or branch which is taken this register called thelink holds the return address following subroutine call coprocessoroperationspermitmovesofthegeneralpurposeregisterstoorfromoptionalapplicationspecific coprocessors one or two these transfers occur over the data bus similar to data memory loads and stores 24system control copr ocessor cp0 the system control coprocessor cp0 is responsible for instruction address sequencing and exception processing fornormalexecutionthenextinstructionaddresshasseveralpotentialsourcestheincrementoftheprevious address branch address computed using pcrelative offset or jump target address for jump addresses the absolute target can be included in the instruction or it can be the contents of generalpurpose register transferred from the ralu branches are assumed or predicted to be taken in the event of prediction failure two stall cycles arestage name actions 1i instruction fetch 2d decode instruction 3s source operand fetch register file read 4e execute alu operations memory address generation 5a access data memory read data cache store and tags 6m memory data select and format 7w write data to register file and memoryrelease 21 lexra proprietary confidential 9lx4380 section 2 architecture incurred and the correct address is selected from special backup register statistics from several large programssuggestthatthesestallswilldegradeaveragelx4380throughputbyseveralpercenthoweverthe net effect of the lx4380s branch prediction on performance is positive because this technique eliminates certain critical paths and therefore permits higher speed system clock if anexception occurs cp0 selects one of several hardwired vectors for the next instruction address the exception vector depends on the mode and specific trap which occurred this is described further in section34 exception processing the following registers which are visible to the programming model are located in cp0 table 2 cp0 registers epc status cause and badvaddr are described in the section34 the index random entrylo context and entryhi registers are described in section5 the dreg depc and desave registers are used by ejtag probe debug software and are described in the ejtag 200 specification the prid register is readonly register that allows software to identify the lexra processor modelthecctlregisterisalexradefinedcp0registerusedtocontroltheinstructionanddatamemories as described in section72 thecontentsoftheregisterslistedintable2aretransferredtoandfromtheralusgeneralpurposeregister file by the mfc0 and mtc0 instructions as described in section316cp0 register number function index 0 tlb location for direct read or write or result of tlb probe random 1 pseudorandom value specifying tlb location to write entrylo 2 low part of tlb entry written to or read from tlb context 4 accelerates page table lookup in service of tlb miss wired 6 indicates number of wired tlb entries badvaddr 8 holds bad virtual address if address exception error occurs entryhi 9 high part of tlb entry written to or read from tlb status 12 interrupt masks mode selects cause 13 exception cause epc 14 holds address for return after exception handler prid 15 processor id readonly 0x0000cd01 for lx4380 dreg 16 ejtag debug control depc 17 ejtag debug exception pc cctl 20 instruction and data memory control desave 31 ejtag debug save register10 lexra proprietary confidential release 21section 2 architecture lx4380 the lx4380 implements extended cp0 registers that provide additional functions summarized in table3 table 3 extended cp0 registers the registers listed in table3 are described in detail in section35 the contents of these registers are transferredtoanfromtheralusgeneralpurposeregisterfilebythemflxc0andmtlxc0instructions as described in section316cp0 register number function estatus 0 interrupt masks for prioritized vectored interrupts ecause 1 interrupt pending ﬂags for prioritized vectored interrupts intvec 2 address of vector table for prioritized vectored interruptsrelease 21 lexra proprietary confidential 11lx4380 section 3 risc programming model 3 risc programming model this section describes the lx4380 programming model section31 summarizes the basic risc operations supported by the lx4380 these opcodes may be extended by the customer using lexras custom engine interface cei this capability is described in section32 section33 describes the simple memory management unit smmu the smmu provides sufficient memorymanagementcapabilitiesformostembeddedapplicationswhilesupportingexecutionofthirdparty mips software development tools section5 describes the optional programmable mmu the lx4380 supports the mips r3000 exception processing model as described in section34 the lx4380 supports mips i coprocessor operations the customer can include one or two application specificcoprocessorsthelx4380includesanoptionalcoprocessorinterfacecithatprovidesasimplified connectionbetweenacoprocessorandtheinternalsignalsofthelx4380theciisdescribedinsection36 31 summary of basic risc instructions the lx4380 executes the mips i r2000r3000 instructions as detailed in the tables below the lx4380 executes full mips i instruction set excluding the unaligned load and store instructions lwl swl lwr swr which are executed as noops the mult multu div and divu are mips i instructions that are supported by the lx4380s optional mac module these instructions are described in section section4 integer multiplyaccumulate the mtlxc0 mflxc0 movz movn and ltw instructions shown in this section are not mips i instructions additional instructions supported by the lx4380 are described in section42 mac instructions section53 tlb instructions and section73 cache instruction the following conventions are employed in the instruction descriptions encloses list of syntax choices from which one must be chosen encloses list of values that are concatented to form larger value n value replicates concatenates value n times value3 bits selected from value rs offset memory address computation and corresponding memory contents 4b0000 sized constant binary value 32h1234_5678 sized constant hexadecimal value expr b select if expr is true otherwise select b12 lexra proprietary confidential release 21section 3 risc programming model lx4380 311 alu instructions table 4 alu instructions instruction name and description add addu addi addiurd rs rt rd rs rt rd rs immediate rd rs immediateadd add unsigned add immediate add immediate unsigned rd rs rt immediate add reg rs to either reg rt or 16bit immediate sign extended to 32 bits result is stored in reg rd add and addi can generate overflow trap addu and addiu do not sub suburd rs rt rd rs rtsubtract subtract unsigned rd rs rt subtract reg rt from reg rs result is stored in register rd sub can generate overflow trap subu does not and andird rs rt rd rs immediateand and immediate rd rs rt immediate logicaland of reg rs with either reg rt or 16bit immedi ate zeroextended to 32 bits result is stored in reg rd or orird rs rt rd rs immediateor or immediate rd rs rt immediate logicalor of reg rs with either reg rt or 16bit immediate zeroextended to 32 bits result is stored in reg rd xor xorird rs rt rd rs immediateexclusive or exclusive or immediate d rs rt immediate logicalxorofregrswitheitherregrtora16bitimmediate zeroextended to 32 bits result is stored in reg rd nor rd rs rt nor rd rs rt logicalnor of reg rs with reg rt result is stored in reg rdrelease 21 lexra proprietary confidential 13lx4380 section 3 risc programming model lui rd immediate load upper immediate rd immediate 16b0 the16bitimmediateisstoredintotheupperhalfofregrd the lower half is loaded with zeroes sll sllvrd rt immediate rd rt rsshift left logical shift left logical variable rd rt rs immediate the 5bit shift amount amt is obtained from the immediate field sll or bits 40 of reg rs sllv the contents of reg rt are shifted left amt bits the result is stored in reg rd srl srlvrd rt immediate rd rt rsshift right logical shift right logical variable rd rt rs immediate the 5bit shift amount amt is obtained from the immediate fieldsrlorbits40ofregrssrlvthecontentsofreg rt are shifted right amt bits the result is stored in reg rd sra sravrd rt immediate rd rt rsshift right arithmetic shift right arithmetic variable rd rt rs immediate the 5bit shift amount amt is obtained from the immediate fieldsraorbits40ofregrssravthecontentsofreg rt are arithmetic shifted right amt bits the result is stored in reg rd slt sltu slti sltiurd rs rt rd rs rt rd rs immediate rd rs immediateset on less than set on less than unsigned set on less than immediate set on less than immediate unsigned rd rs rt immediate 1 0 ifregrsislessthanrtimmediatesetrdto1else0the 16bit immediate is sign extended for slt slti the com parison is signed for slu sltiu the comparison is unsignedinstruction name and description14 lexra proprietary confidential release 21section 3 risc programming model lx4380 312 load and store instructions table 5 load and store instructions instruction description lb rt offsetrs lbu rt offsetrs lh rt offsetrs lhu rt offsetrs lw rt offsetrsload byte load byte unsigned load halfword load halfword unsigned load word rt memoryrs offset reg rt is loaded from data memory the memory address is computed as base offset where the base is reg rs and the offset is the 16bit offset signextended to 32 bits lb lbu addresses are interpreted as byte addresses to data memorylhlhuashalfword16bitaddresseslwasword 32bit addresses thedatafetchedinlblhlbulhuissignextendedzero extended to 32bits for storage to reg rt rt cannot be referenced in the instruction following load instruction ltw rt offsetrs load twinword rt rt1 memoryrs offset theoffset in bytes is signed rt 13bit quantity that must be divisible by 8 since it occupies only 10 bits of the instruction word the offset is sign extended and added to the contents of the register rt to form the address temp the word addressed by temp is fetched and loaded into rt which must be an even register the word addressed by temp4 is loaded into rt1 iftemp is not twinword aligned an address exception is taken iftheinstructionimmediatelyfollowingltwattemptstouse rt or rt1 the results of that instruction are unpredictable sb rt offsetrs sh rt offsetrs sw rt offsetrsstore byte store halfword store word memoryrs offset rt reg rt is stored to data memory the memory address is computed as base offset where the base is reg rs and the offset is the 16bit offset signextended to 32 bits sbaddressesareinterpretedasbyteaddressestodatamem ory the 8 loworder bits of rt are stored sh addresses are interpretedashalfwordaddressestodatamemorythe16low order bits of rt are storedrelease 21 lexra proprietary confidential 15lx4380 section 3 risc programming model 313 conditional move instructions table 6 conditional move instructions instruction description movz rd rs rt move if zero rd rt 0 rs rd if the contents of general register rt are equal to 0 the general register rd is updated with rs otherwise rd is unchanged movn rd rs rt move if not zero rd rt 0 rs rd if the contents of general register rt are not equal to 0 the gen eral register rd is updated with rs otherwise rd is unchanged16 lexra proprietary confidential release 21section 3 risc programming model lx4380 314 branch and jump instructions table 7 branch and jump instructions instruction description beq rs rt offset bne rs rt offsetbranch if equal branch if not equal if cond pc pc 4 14 offset15 offset 2b00 else pc pc 8 where cond rs rt for eq rs ne rt for ne and offset is 16bit value for beq bne the instruction after the branch delay slot is always executed blez rs offset bgtz rs offsetbranch if less than or equal to zero branch if greater than zero if cond pc pc 4 14 offset15 offset 2b00 else pc pc 8 where cond rs 0 for rs 0 for gt and offset is 16bit value forblezbgtztheinstructionafterthebranch delayslotis always executed bltz rs offset bgez rs offsetbranch if less than zero branch if greater than or equal to zero if cond pc pc 4 14 offset15 offset 2b00 else pc pc 8 where cond rs 0 for lt rs 0 for ge and offset is 16bit value forbltzbgeztheinstructionafterthebranch delayslotis always executed bltzal rs offset bgezal rs offsetbranch if less than zero and link branch if greater than or equal to zero and link similar to the bltz and bgez except that the address of the instruction following the delay slot is saved in r31 regardless of whether the branch is takenrelease 21 lexra proprietary confidential 17lx4380 section 3 risc programming model 315 control instructions table 8 control instructionsj target jump pc pc3128 target 2b00 the jump target is 26bit absolute value the instruction fol lowing j delay slot is always executed jal target jump and link same as jump j except that the address of the instruction following the delay slot is saved in r31 jr rs jump register pc rs jump to the address specified in rs the instruction following jr delay slot is always executed jalr rs rd jump and link register same as jump register jr except that the address of the instruction following the delay slot is saved in rd instruction description syscall system call the sys trap occurs when syscall is executed break break the bp trap occurs when break is executed rfe restore from exception causes the kuie stack to be popped used when returning from the exception handler see exception processing belowinstruction description18 lexra proprietary confidential release 21section 3 risc programming model lx4380 316 coprocessor instructions table 9 coprocessor instructions instruction description lwcz rcgen offsetrs load word to coprocessor z rcgen memoryrs offset coprocessor z 13 general reg rcgen is loaded from data memorythememoryaddressiscomputedas baseoffset where the base is reg rs and the offset is the 16bit offset signextended to 32 bits rcgen cannot be referenced in the following instruction one cycle delay swcz rcgen offsetrs store word from coprocessor z memoryrs offset rcgen coprocessor z 13 general reg rcgen is stored to data memorythememoryaddressiscomputedas baseoffset wherethebaseisregrsandtheoffsetisthe16bitoffsetsign extended to 32 bits mtcz rt rcgen ctcz rt rcconmove to coprocessor z move control to coprocessor z inmtczctczthegeneralregisterrtismovedtocoproces sor z 03 general control reg rcgenrccon rcgen and rccon cannot be referenced in the following instruction mfcz rt rcgen cfcz rt rcconmove from coprocessor z move control from coprocessor z inmfczcfczthecoprocessorz03generalcontrolreg rcgen rccon is moved to the general register rt rt cannot be referenced in the following instructionrelease 21 lexra proprietary confidential 19lx4380 section 3 risc programming model mtlxc0 rt lx0reg move to lexra coprocessor 0 register the contents of general register rt are moved to the lexra defined cp0 register indicated by lx0reg mflxc0 rt lx0reg move from lexra coprocessor 0 register the general register rt is loaded from the contents of the lexradefinedcp0registerindicatedbylx0regrtcannotbe referenced in the following instruction bczt offset bczf offsetbranch if coprocessor z is true branch if coprocessor z is false if cond pc pc 4 14 offset15 offset 2b00 else pc pc 8 where cond cpcondz true for bczt cpcondz false for bczf forbcztbczftheinstructionafterthebranch delayslotis always executedinstruction description20 lexra proprietary confidential release 21section 3 risc programming model lx4380 32 opcode extension using the custom engine interface cei customers may add proprietary or applicationspecific opcodes to their lx4380 based products using the custom engine interface cei the new instructions take one of the following forms illustrated below and use reserved opcodes table 10 custom engine interface operations lexra permits customer operations to be added using the four 4 iformat opcodes and six 6 rformat opcodes listed in the table above other opcode extensions in future lexra products will notutilize the opcodes reserved above when the custom engine decodes newopi or newopr it must signal the core that custom operation hasbeenexecutedsothatthereservedinstructionritrapwillnotbetakenmulticyclecustomoperations may be executed by asserting the lx4380s cei halt input note the custom operation may choose to ignore the src1 and src2 operands supplied by the cei and referenceinternalcustomengineregistersinsteadresultscanalsobewrittentoanimplicitcustomregister however unless rd 0 is coded register in the processor will also be written see the table entries under custom engine interface on page109 for listing of the cei signalsnew instruction description available opcodes newopi rd rs immed new operation immediate rd rs newopi immed reg rs is supplied to the src1 port of cei and the 16bit immediate sign extended to 32bits is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 24 27 newop rd rs rt new operation rd rs newopr rt reg rs is supplied to the src1 port of cei and reg rt is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 0 and inst50 5658606263release 21 lexra proprietary confidential 21lx4380 section 3 risc programming model 33 simple memory management unit thelx4380includesasimplememorymanagementunitsmmufortheinstructionmemoryaddressand the data memory address the hardwired virtualtophysical address translation performed by the smmu is sufficient to ensure execution of thirdparty software development tools table 11 smmu address translation thelx4380includesoptionalsupportforafullyprogrammablemipsr3000stylemmuthisisdescribed in section5 memory management unit mmuregion name virtual address physical address cacheability permission kuseg0x0000_0000 0x7fff_ffff0x4000_0000 0xbfff_ffffcached kernel or user kseg00x8000_0000 0x9fff_ffff0x0000_0000 0x1fff_ffffcached kernel kseg10xa000_0000 0xbfff_ffff0x0000_0000 0x1fff_ffffuncached kernel kseg20xc000_0000 0xfeff_ffff0xc000_0000 0xfeff_ffffcached kernel upperkseg20xff00_0000 0xffff_ffff0xff00_0000 0xffff_ffffuncached kernel22 lexra proprietary confidential release 21section 3 risc programming model lx4380 34 exception processing thelx4380implementsthemipsr3000exceptionprocessingmodeltlbrelatedexceptionsareincluded onlyifthelx4380isconfiguredwiththeoptionalmmutheterm exception referstotrapswhicharenon maskable program synchronous events and interrupts which result from unmasked asynchronous events thelistbelowisnumberedfromhighesttolowestpriorityexccodeisstoredincausewhenanexception is taken sys bp ri cpu can share the same priority level because only one can occur in given time slot table 12 list of exceptions exception priority exccode description reset 1 reset trap adel instruction2 4 address exception trap instruction fetch occurs if the instruction address is not wordaligned or if kernel address is referenced in user mode tlbl instruction3 2 tlb instruction fetch trap occurs when virtual instruc tion address does not match tlb entry ov 4 12 arithmetic overflow trap can occur as result of signed add or subtract operations sys 5 8 syscall instruction trap occurs when syscall instruction is executed bp 5 9 breakinstructiontrapoccurswhenbreakinstruction is executed ri 5 10 reserved instruction trap occurs when reserved opcode is fetched cpu 5 11 coprocessor usability trap occurs when an attempt is made to execute coprocessor z operation and copro cessor z is not enabled via the status register adel data6 4 address exception trap data fetch occurs if the data address is not properly aligned or if kernel address is generated in user mode ades 7 5 address exception trap data store occurs if the data address is not properly aligned or if kernel address is generated in user mode tlbl data8 2 tlbdataloadtrapoccurswhenthevirtualdataaddress of load operation does not match tlb entry tlbs 8 3 tlb data store trap occurs when the virtual data addressofastoreoperationdoesnotmatchatlbentry tlbmod 8 1 tlb data modified trap occurs when the virtual data address of store operation matches tlb entry that is marked valid but not dirty int 9 0 unmasked interrupt from one or more of the six r3000 nonprioritized hardware interrupt requests or the eight lexraspecific prioritized hardware interrupt requestsrelease 21 lexra proprietary confidential 23lx4380 section 3 risc programming model 341 exception processing registers theseregistersarereadorwrittenusingmfc0andmtc0operationsthe0fieldsareignoredonwriteand are 0 on read to ensure compatibility with future lx4380 versions they should be written with 0 status coprocessor 0 general register address 12 cause coprocessor 0 general register address 133128 2723 22 2116 158 76 5 4 3 2 1 0 cu30 0 bev 0 im70 0 kuo ieo kup iep kuc iec field description rw reset cu cuz 1 0 indicates that coprocessor z is usable unusable in coprocessor instructions in kernel mode cp0 is always usable regardless of the setting of cu0rw 0 bev bootstrap exception vector selects between two trap vectors see section342rw 1 im interrupt masks for the six nonprioritized hardware interrupts and two software interruptsrw 0 kuie ku01indicateskernelusermodeinthelx4380usermode virtual addresses must have msb 0 in kernel mode the full address space is addressable ie 1 0 indicates that interrupts are enabled disabled the kuo ieo kup iep kuc and iec fields form threelevel stack hardware stack kuie signals the current values are kuc iec theprevious values are kupiep and the old values those before previous are kuoieo see section342rw 0 31 30 2928 2716 158 7 62 10 bd 0 ce10 0 ip70 0 exccode40 0 field description rw reset bd branch delay indicates that the exception was taken in branch or jump delay slotr0 ce coprocessor exception in the case of coprocessor usability exception indicates the number of the responsible coprocessorr0 ip72 interruptpendingbitsaresetwhenthecorresponding hardware interruptinputintreq_n72requestispendinglevelsensitiver0a after reset is deasserted ip contains values sampled from hardware interrupt sourcesip10 interrupt pending software controllable interrupts level sensitive rw exccode theexccodevalueslistedintable12arestoredherewhenan exception occursr024 lexra proprietary confidential release 21section 3 risc programming model lx4380 epc coprocessor 0 general register address 14 epc contains the virtual address of the next instruction to be executed following return from the exception handleriftheexceptionoccursinthedelayslotofabranchepcholdstheaddressofthebranchinstruction and bd is set in cause the branch will typically be reexecuted following the exception handler badvaddr coprocessor 0 general register address 8 342 exception processing entry and exit when an exception occurs the instruction address changes to one of the following locations the kuie stack is pushed kuo ieo kup iep kuc iec before push kup iep kuc iec 0 0 after push whichdisablesinterruptsandputstheprograminkernelmodethecodeexccodefortheexceptionsource isloadedintocausesothattheapplicationspecificexceptionhandlercandeterminetheappropriateaction the exception handler should not reenable interrupts until necessary information has been saved31 0 epc field description rw reset epc exception program counter rw 0 31 0 badvaddr field description rw reset badvaddr bad virtual address contains the virtual address instruction or data which generated an adel or ades exception errorr0 reset 0xbfc0_0000 other exceptions bev 0 0x8000_0080 other exceptions bev 1 0xbfc0_0180release 21 lexra proprietary confidential 25lx4380 section 3 risc programming model to return from the exception the exception handler first moves epc to general register using mfc0 followed by jr operation rfe only pops the kuie stack kup iep kuc iec 0 0 before pop kup iep kup iep kuc iec after pop this example assumes that kuie were not modified by the exception handler therefore typical sequence of operations to return from the exception handler would be 35 lowoverhead prioritized interrupts the lx4380 includes eight lowoverhead hardware interrupt signals that extend the mips r3000 interrupt exceptionmodelthesesignalsarecompatiblewithther3000exceptionprocessingmodelandareusefulfor realtime applications these interrupts are supported with three lexradefined cp0 registers estatus ecause and intvec accessed with the mtlxc0 and mflxc0 variants of the mtc0 and mfc0 instructions the 0 fields in these registers are ignored on write and are 0 on read to ensure compatibility with future lx4380 versions they should be written with 0 as with any cp0 instruction coprocessor unusable exception is taken if these instructions are executed while in user mode and the cu0 bit is 0 in the cp0 status register thethreelexracp0registersareestatus0ecause1andintvec2andaredefinedasfollows estatus lx cp0 reg 0 readwrite ecause lx cp0 reg 1 readonlymfc0 r26 c0_epc r26 is temporary storage register in the ralu jr r26 rfe 31 24 23 16 15 0 0 im158 0 field description rw reset im interrupt masks for the eight prioritized hardware interrupts rw 0 31 24 23 16 15 0 0 ip158 0 field description rw reset ip interrupt pending flags for the eight prioritized hardware interrupts r 0a after reset is deasserted ip contains values sampled from hardware interrupt sources26 lexra proprietary confidential release 21section 3 risc programming model lx4380 intvec lx cp0 reg 2 readwrite estatus contains the interrupt mask bits im158 which are reset to 0 so that none of the vectored interrupts will be activated regardless of the global interrupt enable flag iec in the cp0 status register see section341 exception processing registers the interrupt pending flags ip158 for the vectored interruptsignalsarelocatedinecauseandarereadonlythesefieldsaresimilartotheim70andip70 fields defined in the r3000 exception processing model except that the vectored interrupts are prioritized in hardware and each has dedicated exception vector ip15hasthehighestprioritywhileip8hasthelowestpriorityhoweverallvectoredinterruptsarehigher priority than ip70 the processor concatenates the program defined base address for the exception vectors with the interrupt number to form the interrupt vector as shown in the table below two instructions can be executed in each vector typically these will consist of jump instruction and its delay slot with the target of the jump being either shared interrupt handler or one that is unique to that particular interrupt table 13 prioritized interrupt exception vectors when vectored interrupt causes an exception all of the standard actions for an exception occur these include updating the epc register and certain subfields of the standard status and cause registers in particulartheexceptioncodeofthecauseregisterindicatesinterruptandthecurrentandprevious mode bits of the status register are updated in the usual manner 36 coprocessors applications may include up to two coprocessors to interface with the lx4380 the contents of these coprocessors may include up to thirtytwo 32bit general registers and up to thirtytwo 32bit control registers the general registers may be moved to and from the ralus registers using mtcz mfcz operationsorbeloadedandstoredfromdatamemoryusinglwczswczoperationsthecontrolregisters may only be moved to and from the ralus registers using ctcz cfcz operations the lx4380 includes the optional coprocessor interface ci allowing the customer to easily interface a31 6 5 0 base 0 field description rw reset base base address of interrupt vector table bits 316 rw 0 interrupt number exception vector 15 base 6b111000 14 base 6b110000 13 base 6b101000 12 base 6b100000 11 base 6b011000 10 base 6b010000 9 base 6b001000 8 base 6b000000 release 21 lexra proprietary confidential 27lx4380 section 3 risc programming model coprocessor to the lx4380 the ci supplies set of control address and data busses that may be tied directly to the coprocessor general and control registers the ci is described in more detail in section6 coprocessor interface28 lexra proprietary confidential release 21section 3 risc programming model lx4380release 21 lexra proprietary confidential 29lx4380 section 4 integer multiplyaccumulate 4 integer multiplyaccumulate the multiplyaccumulate mac module is an optional feature of the lx4380 processor this section discusses the operation and features of the mac module 41 mac overview independent 32bit hi and accumulators for 16bit multiplyaccumulate improve performancebyallowingthegenerationofanewresultwhileapreviousresultispending multiplysubtract instructions eliminate the need to negate coefficients twobit per cycle divider writes results to hi and only on the last cycle the hardware manages all resource conflicts to simplify software design and debug figure3 illustrates the mac data paths multiply and multiplyaccumulate operations proceed through twostagepipelinedmultiplieraccumulatorlogicinathirdpipelinestageaddsthemultiplicationresulttothe hiandloaccumulatorsdivideoperationsacton32bitdivisoranddividendoperandstwobitsofquotient andremainderaregeneratedpercycleandpartialquotientsandremaindersarestoredinthedivideruntilthe last cycle figure 3 mac data pathsx divider div divuy 32 32 multiplier 32b x 16b product add with saturation 32 32 hi lo32 32 32 3232 32 32 3230 lexra proprietary confidential release 21section 4 integer multiplyaccumulate lx4380 42 mac instructions table 14 32bit multiply and divide instructions mthi rs move to hi hirs the contents of rs are stored in the hi register mtlo rs move to lors the contents of rs are stored in the register mfhi rd move from hi rdhi the contents of the hi register are stored in rd mflo rd move from rdlo the contents of the register are stored in rd mult rs rt signed 32bit multiply t rs rt lot310 hit6332 the contents of rs is multiplied by rt treating the operands as signed 2scomplementvaluestheupper32bitsofthe64bitresultarestored in the hi register the lower 32bits are stored in the register multu rs rt unsigned 32bit multiply t rs rt lot310 hit6332 thecontentsofrsismultipliedbyrttreatingtheoperandsasunsigned values the upper 32bits of the 64bit result are stored in the hi regis ter the lower 32bits are stored in the register div rs rt signed divide hirs rt lors rt the contents of rs are divided by the contents of rt treating the oper ands as signed 2s complement values the 32bit quotient is stored in the register the 32bit remainder is stored in the hi registerrelease 21 lexra proprietary confidential 31lx4380 section 4 integer multiplyaccumulate table 15 16bit multiply and multiplyaccumulate instructionsdivu rs rt unsigned divide hirs rt lors rt the contents of rs are divided by the contents of rt treating the oper ands as unsigned values the 32bit quotient is stored in the regis ter the 32bit remainder is stored in the hi register mazh rs rt signed 16bit multiply to hi hi 0 rs rt thecontentsofrs150aremultipliedbyrt150treatingtheoperands as signed 2s complement values the 32bit product is added to zero and stored in the hi register mazl rs rt signed 16bit multiply to 0 rs rt thecontentsofrs150aremultipliedbyrt150treatingtheoperands as signed 2s complement values the 32bit product is added to zero and stored in the register madh rs rt signed 16bit multiplyaccumulate to hi hihi rs rt thecontentsofrs150aremultipliedbyrt150treatingtheoperands as signed 2s complement values the 32bit product is added to hi ignoring any overﬂow the result is stored in the hi register madl rs rt signed 16bit multiplyaccumulate to lolo rs rt thecontentsofrs150aremultipliedbyrt150treatingtheoperands as signed 2s complement values the 32bit product is added to ignoring any overﬂow the result is stored in the register mszh rs rt signed 16bit multiplynegate to hi hi0 rs rt thecontentsofrs150aremultipliedbyrt150treatingtheoperands as signed 2s complement values the 32bit product is negated sub tracted from zero and stored in the hi register mszl rs rt signed 16bit multiplynegate to lo0 rs rt thecontentsofrs150aremultipliedbyrt150treatingtheoperands as signed 2s complement values the 32bit product is negated sub tracted from zero and stored in the register32 lexra proprietary confidential release 21section 4 integer multiplyaccumulate lx4380 table 16 32bit multiplyaccumulate instructionsmsbh rs rt signed 16bit multiplysubtract from hi hihi rs rt thecontentsofrs150aremultipliedbyrt150treatingtheoperands assigned2scomplementvaluesthe32bitproductissubtractedfrom hi ignoring any overﬂow the result is stored in the hi register msbl rs rt signed 16bit multiplysubtract from lolo rs rt thecontentsofrs150aremultipliedbyrt150treatingtheoperands assigned2scomplementvaluesthe32bitproductissubtractedfrom ignoring any overﬂow the result is stored in the register mad rs rt signed 32bit multiplyaccumulate thi rs rt lot310 hit6332 the contents of rs are multiplied by rt treating the operands as signed 2scomplementvaluesthe64bitproductisaddedtotheconcatenation hi and to form 64bit result ignoring any overﬂow the upper 32bitsofthe64bitresultarestoredinthehiregisterthelower32bits are stored in the register madu rs rt unsigned 32bit multiplyaccumulate thi rs rt lot310 hit6332 the contents of rs are multiplied by rt treating the operands as unsigned values the 64bit product is added to the concatenation hi andlotoforma64bitresultignoringanyoverﬂowtheupper32bitsof the 64bit result are stored in the hi register the lower 32bits are stored in the register msub rs rt signed 32bit multiplysubtract thi rs rt lot310 hit6332 the contents of rs are multiplied by rt treating the operands as signed 2s complement values the 64bit product is subtracted from the catenation hi and to form 64bit result ignoring any overﬂow the upper 32bits of the 64bit result are stored in the hi register the lower 32bits are stored in the registerrelease 21 lexra proprietary confidential 33lx4380 section 4 integer multiplyaccumulate notes see sectiona3 lexop instructions for instruction encoding the upper 16 bits of both operand registers are ignored by 16bit multiply instructions themxxhandmxxlinstructionscanbefreelyinterleavedthatisaddsandsubtractsfromeitherthehior registers can be combined in sequence with the two registers functioning in parallel the mxzx instructions can be used as standalone 16bit signed multiply instructions 43 mac pipeline the processor may stall if new mac instruction is executed while prior mac operation is pending table58onpage113indicatesthenumberofcyclesthatmustbepresentbetweenmacinstructionstoavoid stalls the mac continues execution of multiplyaccumulate arithmetic during cycles where the hold signal is assertedthemactracksthestateoftheprocessorpipelineanddoesnotcommitdataintoarchitecturalstate the accumulators until the corresponding processor instruction makes an m to w stage transition therefore in the presence of complementary stalls that is stalls which occur in cycles when mac instructionhaspassedavalidecyclethenumberofstallsincurredbythemacwillbe lessthanthenumber stated in table58 the madh madl mazh mazl msbh msbl mszh and mszl instructions which have 16bit operands are pipelined with single cycle throughput and 3 cycle latency the msxx instructions are implemented by negating the multiplier for the 16bit multiplication but are otherwise identical to the corresponding maxx instructions this results in subtracting the product of the original operands from the accumulator the mult mad and msub instructions which have 32bit operands use the same hardware in an iterative fashion to generate the 64bit result with 4 cycle latency for both the low and high order 32 results bits thehiandloregistersareusedastwoindependent32bitaccumulatorsforthe16bitmultiplyinstructions or as paired 64bit result for the 32bit multiply instructions the pipelining for each category of multiplier instruction is shown below the pipeline stages specific to the macarem1m2m3andwaforthe32bitinstructionsandecaccandwaforthe16bitinstructions notethat thewastageiswheretheresultsarevalid eitherin theaccumulator orahold register thealu pipeline is shown for comparisonmsubu rs rt unsigned 32bit multiplysubtract t hi rs rt lot310 hit6332 the contents of rs are multiplied by rt treating the operands as unsigned values the 64bit product is subtracted from the concatena tion hi and to form 64bit result ignoring any overﬂow the upper 32bitsofthe64bitresultarestoredinthehiregisterthelower32bits are stored in the register34 lexra proprietary confidential release 21section 4 integer multiplyaccumulate lx4380 alu i d s m w multmultumadmadumsubmsubu i d s m1 m2 m3 wa madhmadlmazhmazlmsbhmsblmszhmszlmthimtlo i d s c acc wa mfhimflo i d s notes there is indication of overflow for the 32bit add portion of the 16bit multiplyaccumulate instructions the mfhilo instruction will stall the pipeline until the results of the most recent instruction which stores into hilo has completed 44accessing hi and after multiply instructions the mflo and mfhi instructions read the contents of the or hi registers during the cycle of the pipelinethefollowingdescriptionsindicatehowthelatencyofthemultiplyinstructionsaffectstheusageof these instructions the most efficient sequence is shown if the mfhi or mflo instruction is coded earlier the correct result will still be obtained because the hardware will stall the instruction in the ecycle until the result is valid in order to prevent processor deadlock the mac will speculatively complete all of its arithmetic computationevenifprocessorholdisactiveonceithasreceiveditsoperandsandinstructioninavalide cycleinitiallythesimplestpipelinediagramsassumingnostallsareshownthenforclaritysomerelevant stall cases are shown mult or mad followed by mfhi or mflo stalls multx i d s m1 m2 m3 wa any op i d s m w any op i d s m w any op i d s m w mflo i d s m w or mfhi i d s m w madh followed by mfhi stalls mazh0 i d s c acc wa madh1 i d s c acc wa madh2 i d s c acc wa madh3 i d s c acc wa any op i d s m w any op i d s m w mfhi i d s m w hi contains a0 a1 a2 a3 in the presence of stalls the mac completes its normal sequence of operations prior to wa if the pipeline stateofthecorrespondinginstructionshownbelowasmadpipeisnotreadytocompleteanmtowstage transition the data is held in either the astage or mstage registers depending on the pipeline state the hold line is assumed to be stall caused by some purpose other than the mac eg instruction cache missrelease 21 lexra proprietary confidential 35lx4380 section 4 integer multiplyaccumulate mult or mad followed by mfhi or mflo mac stall only mad i d s m1 m2 m3 a_r m_r wa madpipe i d s m w mflo i d s m w machold x x x hold mult or mad followed by mfhi or mflo mac stall concurrent with other stall mad i d s m1 m2 m3 a_r a_r m_r wa madpipe i d s m w mflo i d s m w machold x x x hold x x x x 45divider overview and register usage given dividend dend and divisor dvsr the divider generates quotient quot stored in and remainder rem stored in hi that satisfy the following conditions regardless of the signs of dend and dvsr dend dvsr quot rem 0 absrem absdvsr where rem and dend have the same sign itisworthnotingthattherequirementthatremanddendhavethesamesignisnotuniversallyacceptedif dend and dvsr are not both positive for example the modula3 language expects 5div32 and 5mod31whereasthedividergeneratesquot1rem2inagreementwithfortranandothers these examples show the possible combinations of signs dend dvsr quot rem 19 5 3 4 19 5 3 4 19 5 3 4 19 5 3 4 thedividerisaniterativecircuitthatgenerates2quotientbitspercyclewithanadditional3cyclesrequired due to pipelining considerations thus the pipeline flow of division instruction and the most efficient subsequent read of the quotient using mflo is as shown in the following diagram if the mflo is issued earlier it will stall until the divide completes less than 19 instructions may be issued if some of them take more than one cycle to complete due to cache misses or data dependent stalls for example div i d s d0 d1 d2 d16 d17 d18 18 cycles mflo i s m w36 lexra proprietary confidential release 21section 4 integer multiplyaccumulate lx4380release 21 lexra proprietary confidential 37lx4380 section 5 memory management unit mmu 5 memory management unit mmu this section discusses the lx4380s optional mmu the mmu incorporates the following features 4kb or 64kb memory pages with 32bit virtual and physical addresses and 6bit address space identifier asid the 4gb address space is broken up into 2gb mapped user space kuseg 05gb unmapped cacheable kernel space kseg0 05gb unmapped uncacheable kernel space kseg1 and just less than 1gb of mapped kernel space kseg2 the remaining 16 mb address space above kseg2 16 mb is dedicated to specific debug devices upperkseg2 configurable joint translation lookaside buffer tlb 16 32 or 64 entries hardwaremanaged instruction tlb itlb and data tlb dtlb caches each with three entries entryhi entrylo context and index registers readonly random register readonly wired register the mmu signals the appropriate user tlb utlb exception tlbl or tlbs or the appropriate bev0bev1 exception tlbl tlbs tlbmod implements the tlbp tlbr tlbwi tlbwr instructions 51 memory regions table 17 mmu address translation region namevirtual addressphysical addresscacheability permission writable kuseg 0x0000_0000 0x7fff_ffffmapped via tlb set via tlb user set via tlb kseg0 0x8000_0000 0x9fff_ffff0x0000_0000 0x1fff_ffffcacheable kernel yes kseg1 0xa000_0000 0xbfff_ffff0x0000_0000 0x1fff_ffffuncacheable kernel yes kseg2 0xc000_0000 0xfeff_ffffmapped via tlb set via tlb kernel set via tlb upperkseg2 0xff00_0000 0xffff_ffff0xff00_0000 0xffff_ffffuncacheable kernel yes38 lexra proprietary confidential release 21section 5 memory management unit mmu lx4380 52 registers the registers described in this section are accessed with the mfc0 and mtc0 operations the 0 fields in these registers are ignored on write and are 0 on read for compatibility with future lx4380 versions they should be written with 0 tlb entry tlb entry is 64bit quantity that stores virtual to physical memory mapping the fields of tlb entryareidenticaltothefieldsoftheentryhiandentryloregistersthetlbentriesarewrittenwith the tlb write indexed tlbwi and tlb write random tlbwr instructions they are read with the tlb read tlbr instruction the entries can be examined for match to specific virtual page number vpn address space id asid pair using the tlb probe tlbp instruction the mmu also compares tlb entries to virtual instruction or data memory accesses to determine if match exists entryhi coprocessor 0 general register address 10 entryhiiscomposedoftwofieldsthevpnandasidwhentlbprobetlbpinstructionisexecuted the mmu compares the vpn and asid fields of the entryhi register but also accounting for the global bit of the tlb entry to each entry in the tlb the comparison mechanism is described in section53 when the processor executes tlb read tlbr instruction the tlb entry specified by the index register is loaded into entryhi and entrylo if the tlb is configured with 4kb page size the corresponding lower order bits of the vpn in the entryhi register will always return zeroes the vpn and asid fields of entryhi are written into the tlb when the cpu executes the tlb write index tlbwi or tlb write random tlbwr instruction31 12 11 6 5 0 vpn asid 000000 field description rw reset vpn virtual page number low order 4 bits must be set to zero if mmu is configured for 64kb pagesrwunmappeda vpn is reset to an unmapped address that depends on the page size conﬁguration 0x80000 for 4kb pages 0x8000 for 64kb pagesasid address space id rw 0release 21 lexra proprietary confidential 39lx4380 section 5 memory management unit mmu entrylo coprocessor 0 general register address 2 entrylo is composed of the following fields page frame number pfn noncacheable n dirty d valid v and global g thepfnndvandgfieldsofentryloarewrittentoatlbentrywhenthecpuexecutesthetlbwi or tlbwr instructions during any mapped instruction or data access and during the execution of tlbp instructionthemmuexaminesthegbitofthetlbentrytodetermineifavpnasidcombinationwasa match mapped instruction or data access with tlb match based on vpn asid and g will examine thedandvbitstosignalanexceptionasdescribedinsection56onpage42thenbitisusedtodetermine whether the access is cacheable when the processor executes tlb read tlbr instruction the tlb entry specified by the index register is loaded into entryhi and entrylo if the tlb is configured with 64kb page size the corresponding lower order bits of the pfn in the entrylo register returns zeroes index coprocessor 0 general register address 0 the index register is used by the tlbp tlbr and tlbwi instructions as described in section53 the index register contains 6bit address into the tlb index and onebit probe failure field p31 12 11 10 9 8 7 0 pfn n d v g 00000000 field description rw reset pfn page frame number low order 4 bits must be set to zero if mmu is configured for 64kb pagesrw 0 n noncacheable rw 0 d dirty rw 0 v valid rw 0 g global rw 0 31 30 14 13 8 7 0 p 00000000000000000 index 00000000 field description rw reset p probe failure 1 indicates tlbp instruction did not find tlb matchr0 index result of tlbp instruction tlb entry to write with tlbwi instructionrw 040 lexra proprietary confidential release 21section 5 memory management unit mmu lx4380 random coprocessor 0 general register address 1 the random register contains 6bit address into the tlb that is decremented on every valid mstage instruction completion consistent with r4000 operation the address decrements from the largest tlb index available on the processor 15 31 or 63 down to the value of the wired register the address then wrapsbacktothelargesttlbindexthisensuresthatthelowestwiredentries0towired1entriesare not randomly overwritten when the processor executes tlb write random tlbwr instruction the processor writes the tlb entry that is identified by random however the processor selects different entry for writing if random identifies an entry that was written by either of the last two executions of tlbwr this ensures that thrashing does not occur in the event of backtoback tlb misses wired coprocessor 0 general register address 6 the wired register contains 6bit address of the lowest entry that may be overwritten by the tlb write random tlbwr instruction context coprocessor 0 general register address 4 thecontextregistercontainsapointertothebaseofavirtualpagetableandacopyofbits3012ofthe badvaddr register it may be used by kernel software to accelerate page table lookup operations31 14 13 8 7 0 000000000000000000 random 00000000 field description rw reset random decremented with every valid mstage instruction completionr tlb_max tlb_max is deﬁned by the tlb_entries lconﬁg setting 31 6 5 0 00000000000000000000000000 wired field description rw reset wired number of wired tlb entries this field is readonly constantr4 or 8a reset value depends on the lconﬁg tlb_entries setting 4 if 16 or 32 entries 8 if 64 entries 31 21 20 2 1 0 ptebase badvpn 00 field description rw reset ptebase page table entry base address rw 0 badvpn bad virtual page number r 0release 21 lexra proprietary confidential 41lx4380 section 5 memory management unit mmu 53 tlb instructions theseopcodesfortheseinstructionsareidenticaltothoseusedinthemipsir2000r3000instructionset 54 mapped address translation mapped address translation is performed for instruction fetches data loads data stores and the cache instruction any memory reference to kseg0 kseg1 or upperkseg2 is an unmapped access an unmapped access does notgenerateatlbtranslationinsteadthedirecttranslationtothepfnisusedasshownintable17noteinstruction description tlbp tlb probe index index of tlb entry which matches entryhivpnasid examines each tlb entry to determine if it matches the values contained in entryhi the determination of match for entry i is matchi entryhivpn tlbhiivpn tlbloiglobal entryhiasid tlbhiiasid where tlbhi and tlblo are the appropriate ﬁelds of the tlb entry if tlb match is found the index register p bit is set to 1 and the index ﬁeld is undeﬁned if single tlb match is found the index register p bit is setto0andtheindexﬁeldcontainsthe6bitaddressofthematchingentry if multiple tlb matches are found the index register p bit and index value are both undefined this could only arise because of an error in kernel code tlbr tlb read entryhi entrylo tlbindex updates the entryhi and entrylo registers with the contents of the tlb entryspeciﬁedbytheindexregisterifthevalueofindexregisterisgreater than the number of tlb entries implemented the tlb read instruction returns 32bit zero result to both the entryhi and entrylo registers tlbwi tlb write indexed tlbindex entryhi entrylo updatestheentryofthetlbspeciﬁedbytheindexﬁeldoftheindexregis ter with the values speciﬁed in entryhi and entrylo if the value of index is greater than the number of registers implemented entry is updated tlbwr tlb write random tlbrandom entryhi entrylo updatestheentryofthetlbspeciﬁedbytherandomﬁeldoftherandom register with the values speciﬁed in entryhi and entrylo42 lexra proprietary confidential release 21section 5 memory management unit mmu lx4380 this specifies both the physical location and cacheability of the request all of the unmapped areas are assumed writable ifthereferenceistoakusegorkseg2addressatlbtranslationisperformedbycheckingalltlbentriesfor match similar to the tlbp instruction described in section53 the list below shows the sequence of decisions and actions performed by the mmu note that the vpn comes from the address being tested while the asid is held in entryhi iftheprocessorisinusermodeandthereferenceistokseg2generateanadelorades exception translation is performed ifthereisnotlbmatchandthereferenceistokusegautlbtlblortlbsiemiss exception is taken if there is tlb match and the reference is to kseg2 bev tlbl or tlbs ie miss exception is taken if there is tlb match and the matching entry is not valid bev tlbl or tlbs ie miss exception is taken if the request is for store data operation and the dirty bit is not set bev mod exception is taken if the n field is zero cacheable request is made if the n field is one noncacheable request is made 55 stalls see sectiond8 on page114 for information on stalls that are caused by the mmu 56 mmu exceptions the user tlb utlb exceptions go to unique exception vector that can utilize very low level of functionality for user applications only while the more complete bev boot exception vector versions include handling for privileged tasks invalid entries and access violations modify exceptions table 18 tlb exceptions exception typebev0 exception addressbev1 exception addresscause exccode utlb tlbl 0x8000_0000 0xbfc0_0100 2 utlb tlbs 0x8000_0000 0xbfc0_0100 3 bev tlbl 0x8000_0080 0xbfc0_0180 2 bev tlbs 0x8000_0080 0xbfc0_0180 3 bev tlbmod 0x8000_0080 0xbfc0_0180 1release 21 lexra proprietary confidential 43lx4380 section 5 memory management unit mmu 57 instruction and data tlbs the instruction tlb itlb and data tlb dtlb are hardwaremanaged caches of the most recent tlb translations for instruction fetches itlb and loads or stores dtlb each tlb cache contains three entries which improves processor performance when using the mmu see the stall table appendix for description of the stall cycles associated with the itlb and dtlb 58 comparison of lx4380 mmu features this section summaries the differences between lx4380 mmu and the r3000 mmu the lx4380 supports the random register however it decrements according to the r4000 implementation once for every valid mstage instruction completion therandomregisterdoesnotselectthelasttworandomlywrittentlbentriestoavoid deadlocklivelock conditions that could otherwise occur the lx4380 supports the wired register an r4000 register however it is readonly and its value is based on the number of tlb entries the lx4380 provides configurable number of tlb entries 16 32 or 64 the r3000 provides 64 entries the regions of memory that are mappedunmapped differ from the r3000 the lx4380 does not map the upper 16mb above kseg2 0xff this region is unmapped and uncached and is identified as upperkseg2 59 use restrictions after tlb modiﬁcation when atlbwi ortlbwr instruction isused towrite anentryin thetlbthekernelmust ensurethat the new entry is not used until the write takes effect this can be done by performing the tlb write sufficiently in advance of the return from tlb exception thefollowinglistdocumentsthenumberof instructioncycles thatmustelapsebeforeanupdatedtlbentry isusedfortheindicatedpurposeaninstructioncycleisanycodedinstructionaswellas issuestalls thatare generated by the processor pipeline stalls do not count as instruction cycles see sectiond1 ifetch entry added to tlb 5 cycles ifetch entry removed trom tlb 6 cycles loadstorecache 3 cycles tlbp 3 cycles tlbr 2 cycles44 lexra proprietary confidential release 21section 5 memory management unit mmu lx4380 consider an example involving utlbl exception the exception handler must add the required entry to the tlb according to the above list 5 instruction cycles are required after the tlb write for an instruction fetchtoproperlyfetchfromthenewlyaddedpagethefollowingcodesequenceisshownasanexampleofa valid write of the tlb entry needed by the target of jr k0 the instruction cycles are counted for clarification 510 use restrictions after asid modiﬁcation thecurrentasidthatisusedintheprocessorisheldintheentryhicoprocessor0registeranywriteto this register can change the current asid the asid should only be modified when executing in tlb unmapped space when changing the asid the operating systems kernel must ensure that any operation that depends on the asidisnotexecuteduntilthechangehastakenaffectthefollowinglistdescribesthenumberof instruction cyclesthat must elapse before the updated asid can be used for the intended purpose only mtc0 to the entryhi register or tlbr instruction can change the current asid on tlbl exception it is possible that the asid may be set just before returning to process running in tlb mapped space according to the above list 5 instruction cycles are required after the asid update for anifetchtoacknowledgetheupdatetotheasidthefollowingcodesequenceisshownasanexampleofa valid update to the current asid and return from the exception handler the instruction cycles are counted for clarification 511 determining the number of tlb entries via software to determine the number of tlb entries that are present software can exploit the fact that the tlb read tlbrinstructionreturnszeroifanonexistenttlbentryisreadsoftwaremaywriteanonzeroentrytoa tlb location using the tlb write indexed tlbwi instruction and examine the result of subsequent tlbr instruction to determine if the tlb entry actually exists the nonzero entry should be constructed from an unmapped vpn eg in kseg0 to ensure consistent operation of the processortlbwr tlbw has 1 cycle issue stall tlbwr issue stall 1 jr k0 1 jr has 2 cycle issue stall after delay slot rfe 1 jr issue stall 1 1 jr issue stall 2 1 new ifetched page here ifetch 5 cycles mfc0 2 cycles loadstorecache 3 cycles tlbp 2 cycles tlbw 1 cycle mtc0 k1 c0_entryhi mtc0 has 2 cycle issue stall mtc0 issue stall 1 1 mtc0 issue stall 2 1 jr k0 1 jr has 2 cycle issue stall after delay slot rfe 1 jr issue stall 1 1 jr issue stall 2 1 new ifetched page hererelease 21 lexra proprietary confidential 45lx4380 section 6 coprocessor interface 6 coprocessor interface the lx4380 processor provides coprocessor interfaces cis for the attachment of applicationspecific coprocessors this section provides description of these access points 61 attaching coprocessor using the coprocessor interface ci acoprocessormaycontainupto32generalregistersandupto32controlregisterseachoftheseregistersis up to 32 bits wide typically programs use the general registers for loading and storing data on which the coprocessor operates data is moved to the coprocessors general registers from the processors general registerswiththemtczinstructiondataismovedfromthecoprocessorsgeneralregisterstotheprocessors general registers with the mfcz instruction main memory data is loaded into or stored from the coprocessors general registers with the lwcz and swcz instructions programs may load and store the coprocessors control registers from the processors general registers with the ctcz and cfcz instructions respectively programs may not load or store the control registers directly from main memory the coprocessor may also provide condition flag to the processor the condition flag is tested with the bczt and bczf instructions these instructions indicate that the program should branch if the condition is true bczt or false bczf 62 coprocessor interface ci signals the ci provides the mechanism to attach custom coprocessor to the processor the ci snoops the instruction bus for coprocessor instructions and then gives the coprocessor the signals necessary for reading or writing the general and control registers io is relative to the lx4380 ci table 19 coprocessor interface signals signal io description czcondin input branch ﬂag czrd_addr40 output read address czrhold output coprocessor must stall when asserted one czrd_gen output general register read command czrd_con output control register read command czrd_data310 input read data czwr_addr40 output write address czwr_gen output general register write command czwr_con output control register write command46 lexra proprietary confidential release 21section 6 coprocessor interface lx4380 in the above table z indicates user coprocessor number 1 or 2 the addresses output data and control signals are supplied to the applications coprocessor on the rising edge of the system clock 63 coprocessor write operations during coprocessor write the ci sends czwr_addr and czwr_data and asserts either czwr_gen or czwr_con the coprocessor write operations are subject to pipeline hold that is if either of the write control signals is asserted while czrhold is asserted the coprocessor must defer the write to the appropriate registeronthesubsequentrisingedgeoftheclockthetargetregisterisadecodingofczwr_addrczwr_gen and czwr_con the lwcz mtcz and ctcz instructions cause coprocessor write figure4 illustrates two coprocessor write operations the operation labeled does not encounter pipeline hold the operation labeled b encounters pipeline hold that lasts one cycle figure 4 coprocessor write 64 coprocessor read operations during coprocessor read the ci sends czrd_addr and asserts either czrd_gen or czrd_con the coprocessor must return valid data through czrd_data in the following clock cycle if the processor asserts czrholdindicatingthatitisnotreadytoacceptthecoprocessordatathecoprocessormustholdtheprevious valueofczrd_datathetargetregisterforthereadisadecodingofczrd_addrczrd_genandczrd_conthe instructions causing coprocessor read are swcz mfcz and cfcz figure5 illustrates three coprocessor read operations the signal names beginning with cz_stage_ represent application specific signals in coprocessor design and are shown to illustrate the pipelining within coprocessor coprocessor designs that perform internal operations as result of read must include such stagesintheirreadlogictoallowforthecancellationofacoprocessorreadthatcouldarisefromanexception thatisencounteredduringanearlierinstructionthisispossibleforexampleifthecoprocessorimplements read fifo see figure6 and figure7 for examples of instruction cancellations in the example of figure5 coprocessor read operation encounters pipeline hold while in the stage operations b and c encounter pipeline hold while in the and w stages respectively although notczwr_data310 output write data czinvld_m output one indicates invalid instruction in m stage czxcpn_m output exception ﬂag one indicates exception in m stagesignal io description clk czwr_cntx_w20 czwr_addr_w40 czwr_gen_w czwr_data_w310 czrholda b b b d0117release 21 lexra proprietary confidential 47lx4380 section 6 coprocessor interface shown in the diagram coprocessor operations can also be held while they are in the m stage figure 5 coprocessor read the cpu stalls the pipeline so that the program can access data read by coprocessor instruction in the immediatelyfollowinginstructionforexampleifanmfczinstructionreadsdatafromthecoprocessorand stores it in the processors general register 4 the program can get access to that data in the following instruction whentheprocessorinitiatesacoprocessorreadthecoprocessormustreturnvaliddatainthefollowingclock cycle the coprocessor cannot stall the cpu applications must ensure that the source code does not access invalid coprocessor data if the coprocessor operations take several clock cycles to complete this is done in one of three ways ensure that software does not access data from the coprocessor until n instructions after the coprocessor operation has started this is the least desirable method as it depends on the relative execution of the processor and coprocessor it can also complicate software debug have the coprocessor send an interrupt to the processor and the service routine for that interrupt accesses the appropriate coprocessor registers have the coprocessor set the czcondin flag when its operation is complete the source code can poll the flag as shown in the example below 65 coprocessor interface and pipeline stages coprocessor writes occur in the w stage of the instruction pipeline for coprocessor reads the processor generatesaddressrd_genandrd_consignalsduringtheestageandthecoprocessorreturnsdataduringthemfc2 4 3 move from cop2 to cpu register 4 subu 5 4 2 subtract r2 from r4 and store in 5 mtc2 2 3 store data to cop2 general register 3 ctc2 3 5 set cop2 control register 5 to start nop loop bc2f loop branch back to loop if czcondin bit off nop branch delay slot mfc2 4 7 get results from cop2 general register 7clk czrd_cntx_s20 czrd_addr_s40 czrd_gen_s czrd_data_e310 cz_stage_a cz_stage_m cz_stage_w czrhold czxcpn_m czinvld_ma b c b c b c b c bc bc d011848 lexra proprietary confidential release 21section 6 coprocessor interface lx4380 stage which is passed by the ci to the processor in the m stage the processor introduces two pipeline bubbles after coprocessor instructions to ensure that the result of mtcz instruction can be used by the immediately following instruction mtc2 i d s m w bubble 1 i d s m w bubble 2 i d s m w mfc2 i d s m w wr_gen w x rd_gen x rd_data x 651 pipeline holds the czwr_addr czwr_data czwr_gen and czwr_con signals need not be registered the coprocessor may decode these w stage signals directly to the appropriate register however the coprocessor must ignore the assertion of the write control signals when czrhold is asserted see figure4 thecoprocessormustregisterthereadaddressandthecontrolsignalsczrd_genandczrd_conitmusthold the stage registered values of these signals when czrhold is active high and should make the read data output function of the stage registered read address and control signals if the coprocessor includes additional internal stages that perform actions as result of read operation they must also be held by the czrhold signal see figure5 652 pipeline invalidation under certain circumstances the instruction pipeline can contain an instruction that must be discarded this may be due to mispredicted branches cache misses exceptions inserted pipeline bubbles etc in such cases the ci may decode an instruction that must actually be discarded forthecoprocessorwritetypeinstructionstheciwillonlyissuethewstagecontrolsignalsczwr_genand czwr_con for valid instructions the coprocessor does not need to qualify these controls for the coprocessor readtype instructions the ci may issue the stage control signals czrd_gen and czrd_conforinstructionsthatmustbediscardedifthecoprocessorcantoleratespeculativereadsthenitneed notqualifythosesignalshoweverifthecoprocessorperformsdestructivereadssuchasupdatingafifo pointer upon read then it must use the qualifying signals czxcpn_m and czinvld_m as follows when the czxcpn_m signal is asserted by the processor the coprocessor must discard any s and stage operationsevenifczrholdisalsoassertedthisczxcpn_msignalindicatesthatprecedinginstructioninthe mstageoftheprocessorpipelinehastakenanexceptionandthatsubsequentinstructionsinthepipelinemust bediscardedfigure6illustratestheoccurrenceofanexceptionwhileacoprocessorinstructionisatthese or stagesrelease 21 lexra proprietary confidential 49lx4380 section 6 coprocessor interface figure 6 exception during coprocessor read theprocessorassertsczinvld_msignaltoinvalidatetheinstructioninthemstageifthecoprocessorcannot tolerate speculative reads it must tentatively compute its and m stage results for any read operation if czinvld_m is asserted when the read operation is in the m stage including any period when czrohold is assertedthenthecoprocessormustdiscardthetentativeresultsifthereadoperationpassesadvancestothe w stage without the assertion of czinvld_m then the coprocessor must commit its temporary results an example of an invalidated read operation is shown in figure7 figure 7 invalidation of coprocessor readclk czrd_cntx_s20 czrd_addr_s40 czrd_gen_s czrd_data_e310 cz_stage_a10 cz_stage_m10 cz_stage_w10 czrhold czxcpn_m czinvld_ma b c b c b c c d0119 clk czrd_cntx_s20 czrd_addr_s40 czrd_gen_s czrd_data_e310 cz_stage_a cz_stage_m cz_stage_w czrhold czxcpn_m czinvld_ma d012050 lexra proprietary confidential release 21section 6 coprocessor interface lx4380release 21 lexra proprietary confidential 51lx4380 section 7 local memory 7 local memory 71 local memory overview thissectiondescribeshowmemoriesareconfiguredandconnectedtothelx4380usingthelocalmemory interfaces lmis this section provides brief summary of the conventions and supported memories section72 describes the control register that allows software control over certain aspects of the lmis the subsequent sections cover each of the lmis in detail this section also discusses configuration options and the ports that customers must access to connect application specific rams that are used by the lx4380 lmis all of the signals between the lmis and rams are automatically configured by lconfig the lx4380 configuration tool lconfigalso produces documentationoftheexactramsrequiredforthechosenconfigurationsettingsandgeneratesrammodels used for rtl simulation thelmisconnecttoramsthatservicethelx4380processorslocalinstructionanddatabussesthelmis alsoprovidethepathwaysfromtheprocessortothesystembusthelx4380includesanlmiforeachofthe local memory types the sizes of the rams are customer selectable the lx4380 lmis directly support synchronous rams that register the address write data and control signals at the ram inputs the lmis also supply redundant read enable and chip select lines for each ram which may be required for some ram types lexra supplies an integration layer for the lmis and the memory devices connected to them in this layer memory devices are instanced as generic modules satisfying the depth and width requirements for each specific memory instance the lconfigutility supplies summary of the memory devices required for the chosen configuration in most cases customers simply need to write wrapper that connects the generic module port list to technology specific ram instance inside the ram wrapper thelx4380isconfigurablefora163264or128bytecachelinesizethetagstoreramsizesshownin the tables of this section assume 32byte line size the documentation produced by lconfigindicates the required tag rams for the selected configuration options including the line size as general rule doubling of the line size results in halving the tag store depth thevalidbitswithintagstoresareautomaticallyclearedbythelmisuponresetthedatacacheimplements writethrough or writeback protocols selectable with lconfig caches do not snoop the system bus the lx4380 uses rams with byte write granularity for its data stores byte write granularity results in more efficient operation of store byte and store halfword instructions the lmis use physical addresses for all operations caches are physically indexed and store physical tags table20 summarizes the local memories that can be integrated with the lx438052 lexra proprietary confidential release 21section 7 local memory lx4380 table 20 local memory interface modules 72 cache control register cctl cctl cp0 general register address 20 when reading this register the contents of the reserved bits are undefined when writing this register the contents of the reserved bits should be preserved the imemfill and imemoff bits of the cctl register control the contents and use of any local imem memory configured into the lx4380 when the lx4380 is reset the lmi clears an internal register to indicate that the entire imem lmi contents are invalid when imem is invalid all cacheable fetches from the imem region will be serviced by the instruction cache if an instruction cache is present transition from 0 to 1 on imemfill causes the lmi to initiate series of line read operations to fill the imemcontentstheaddressesusedforthesereadsaredefinedbytheconfiguredbaseandtopaddresses oftheimemdescribedinsection75theprocessorstallswhiletheentireimemcontentsarefilledbythe lmi thereafter the lmi sets its internal imem valid bit and will service any access to the imem range from the local imem memory the time that an imem fill takes to complete is the number of line reads needed to fill the imem range multiplied by the latency of one line read assuming there is other system bus traffic transition from 0 to 1 on imemoff causes the lmi to clear its internal imem valid bit subsequent cacheable fetches from the imem region will be serviced by the instruction cache to use the imem again an application must reinitialize the imem contents through the imemfill bit of the cctl register transition from 0 to 1 on dmemoff causes the dcache lmi to disable the dmem subsequent access in thedmemregionwillbeservicedbythedatacachecacheableaddressesorsystemmemoryuncacheable addresses to use the dmem after it has been disabled an software must cause transition from 0 to 1 on dmemon this will reenable the dmem the state of the dmem will be as it was when it was disabled the ilock field controls set locking in the twoway set associative instruction cache when ilock is 00 the instruction cache operates normally when ilock is 10 lockgather mode all cached instruction referencesareforcedtooccupyway1thehardwarewillinvalidatelinesinway0ifnecessarytoaccomplish thiswhenilockis11lockeddownmodelinesinway1areneverdisplacedietheyarelockedinthe cache way 0 is used to hold other lines as needed ilock 01 is reserved if this setting is used results are undefined toutilizethecachelockingfeaturesoftwareshouldexecuteatleastonepassofcriticalsubroutinesorloops withilocksetto10afterthishasbeendoneilockshouldbesetto11tolockthecriticalcodeintoway1name description icache direct mapped or twoway set associative instruction cache imem instruction ram dcache direct mapped or twoway set associative data cache dmem data ram 3112 11 10 9 8 76 5 4 32 1 0 rsrvd dmemoff dmemon dwbinval dwb rsrvd imemoff imemfill ilock iinval dinvalrelease 21 lexra proprietary confidential 53lx4380 section 7 local memory and use way 0 for other code the iinval bit controls hardware invalidation of the instruction cache transition from 0 to 1 on iinval initiates hardware invalidation sequence of the entire instruction cache thedinvaldwbanddwbinvalbitscontrolhardwareinvalidationofthedatacacheatransitionfrom0to 1ondinvalinitiatesahardwareinvalidationsequenceoftheentiredatacacheanydirtylinesarediscarded ie not written back to main memory transition from 0 to 1 on dwb initiates hardware sequence to writeback all dirty lines in the data cache leaving them in the clean state lines that are already clean or invalidhavenooperationperformedatransitionfrom0to1ondwbinvalinitiatesahardwaresequenceto writebackalldirtylinesinthedatacacheandtoinvalidatealllinesinthedatacacheregardlessoftheirinitial stateasimultaneouswithonemtc0instructiontransitionfrom0to1onmorethanoneofdinvaldwb or dwbinval leads to unpredictable results the dmem if present is unaffected data cache cctl operations the hardware invalidation sequence for the instruction and data caches requires up to four cycles per cache line to complete when dirty data must be written back to main memory the amount of time required is dependent on the state of the data cache and the performance of the system bus the lx4380 observes changes in the contents of the cctl register in the w stage instructions that are in progressinearlierstageswillnotbeaffectedbyaninstructioncacheordatacacheinvalidationorimemfill thismeansforexamplethatafterawritetocctlthatinvalidatestheinstructioncacheseveralinstructions that were fetched before the invalidation may be executed even if those instructions were invalidated from the instruction cache ifasmallnumberoflinesknownmustbeinvalidateditismoreefficientforsoftwaretoexecutethecache instruction to affect the state of specific cache lines this is described in the next section54 lexra proprietary confidential release 21section 7 local memory lx4380 73 cache instruction the cache instruction allows software to affect the state of specific cache lines 74 instruction cache icache lmi the icache lmi supplies the interface for direct mapped or twoway set associative instruction cache attachedtothelx4380localbusthedegreeofassociativityisspecifiedthroughlconfigtheicachelmi participatesincacheableinstructionfetchesbutonlyiftheaddressisnotclaimedbytheimemmodulethe configurations supported by icache and the synchronous rams required for each are summarized in table21 theinstructionstoreforthetwowayicacheconsistsoftwo64bitwidebankswithseparatewriteenable controls the tag store consists of one ram bank with tag and valid bits for way 0 and second ram for way1thatholdsthetagvalidlruleastrecentlyusedandlockbitswhenamissoccursinthetwoway icachethelrubitisexaminedtodeterminewhichwayofthesettoreplacewithway0beingreplacedif lru is 0 and way 1 being replaced if lru is 1 the state of the lru bit is then inverted to optimize the timingofcachereadsthetwowayicacheusesthestateofthelrubittodeterminewhichwayshouldbecache op offsetrs cache operation performs data cache operation at address rs offset an address is computed as base offset wherebase is reg rs and theoffsetisthe16bitoffsetsignextendedto32bitstheaddressis translated using the smmu or the optional mmu as for lb instruc tion to form physical address the op is 5bit data cache opera tionifthelinecontainingthebytewiththespeciﬁedphysicaladdress isnotfoundinthedatacachethennocacheoperationisperformed regardless of the value of op otherwise the following operation is performed 10001 inval the line is invalidated 10101 wbinval the line is written back if dirty and invalidated regardless of state 11001 wb the line is written back if dirty and left in the clean state others reserved the operation is performed even if the address falls within the address range deﬁned for dmema if the mapped or unmapped address translation indicates that the address of the line found in the cache is uncacheable for example by using kseg1 address to access kseg0 line it is undeﬁned whether or not the operation speciﬁed by the instruction is per formed theexecutionofthecacheinstructionissubjectthesameaddress exceptions as the lb instruction and to coprocessor unusable exception under the same conditions as coprocessor instruction that accesses cp0 memory addresses within the dmem range might be held in the data cache if dmem has been disabled with the dmemoff bit in the cctl register this is possible even when dmem access is reenabled with the dmemon bitrelease 21 lexra proprietary confidential 55lx4380 section 7 local memory returned to the cpu in the following cycle theicache determines if the correct way was returnedif not the icache takes an extra cycle to return the correct element to the cpu and inverts the lru bit table 21 icache conﬁgurations table22liststheicachesignalsthatareconnectedtoapplicationspecificramstheic_prefixindicates signals that are driven by the icache lmi module and received by the rams the icr_ prefix indicates signalsthataredrivenbytheicacheramsandreceivedbytheicachelmilexrasuppliestheverilog module that makes all required connections to these wires the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from the table21 table 22 icache ram interfacesconﬁguration icache_inst ram icache_tag ram instruction cache ram required ram required 1k bytes 2way 2 x 64 x 64 bits 16 x 24 and 16 x 26 bits 2k bytes 2way 2 x 128 x 64 bits 32 x 23 and 32 x 25 bits 4k bytes 2way 2 x 256 x 64 bits 64 x 22 and 64 x 24 bits 8k bytes 2way 2 x 512 x 64 bits 128 x 21 and 128 x 23 bits 16k bytes 2way 2 x 1024 x 64 bits 256 x 20 and 256 x 22 bits 32k bytes 2way 2 x 2048 x 64 bits 512 x 19 and 512 x 21 bits 64k bytes 2way 2 x 4096 x 64 bits 1024x18and1024x20bits 1k bytes direct mapped 128 x 64 bits 32 x 23 bits 2k bytes direct mapped 256 x 64 bits 64 x 22 bits 4k bytes direct mapped 512 x 64 bits 128 x 21 bits 8k bytes direct mapped 1024 x 64 bits 256 x 20 bits 16k bytes direct mapped 2048 x 64 bits 512 x 19 bits 32k bytes direct mapped 4096 x 64 bits 1024 x 18 bits 64k bytes direct mapped 8192 x 64 bits 2048 x 17 bits signal description ic_tagindex tag and state ram address line icr_tagrd0 tag and state ram element 0 read path ic_tagwr0 tag and state ram element 0 write path icr_tagrd1 tag and state ram element 1 read path ic_tagwr1 tag and state ram element 1 write path ic_tag0wen tag 0 ram write enable ic_tag0ren tag 0 ram read enable ic_tag0csn tag 0 ram chip select56 lexra proprietary confidential release 21section 7 local memory lx4380 note n designates an available activelow version of signal 75 instruction memory imem lmi theimemlmisuppliestheinterfaceforanoptionallocalinstructionstoretheimemservesafixedrange of the physical address space determined by configuration settings in lconfig the imem contents are filled and invalidated under the control of the cp0 cctl register described in section72 cache control register cctl the imem module services instruction fetches that falls within its configured range the imemisaconvenientlowcostalternativetoacachethatmakesinstructionmemoryavailabletothecorefor highspeed access the configurations supported by imem and the synchronous rams required for each are summarized in table23 table 23 imem conﬁgurationsic_tag1wen tag 1 ram write enable ic_tag1ren tag 1 ram read enable ic_tag1csn tag 1 ram chip select ic_instindex instruction ram address word icr_inst0rd instruction ram element 0 read path icr_inst1rd instruction ram element 1 read path ic_instwr instruction ram write path to both ways ic_inst0wen10 instruction ram 0 write enable ic_inst0ren instruction ram 0 read enable ic_inst0csn instruction ram 0 chip select ic_inst1wen10 instruction ram 1 write enable ic_inst1ren instruction ram 1 read enable ic_inst1csn instruction ram 1 chip select conﬁguration imem_inst ram local instruction ram ram required 1k bytes 128 x 64 bits 2k bytes 256 x 64 bits 4k bytes 512 x 64 bits 8k bytes 1024 x 64 bits 16k bytes 2048 x 64 bits 32k bytes 4096 x 64 bitssignal descriptionrelease 21 lexra proprietary confidential 57lx4380 section 7 local memory table24 lists the imem signals that are connected to application specific rams the iw_prefix indicates signalsthataredrivenbytheimemlmimoduleandreceivedbyramsthe iwr_prefixindicatessignals thataredrivenbyramsandreceivedbytheimemlmithe cfg_prefixidentifiesconfigurationportson the imem lmi that are typically wired to constant values the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table23 thecfg_wires define where the imem is mapped into the physical address space this configuration informationdefinesthelocalbusaddressregionoftheimemitalsodeterminesthemainmemorylocations thatareaccessedbythelx4380whenanimemfilloperationisstartedbyupdatingtheimemfillbitofthe cp0 cctl register the lconfigutility supplied by lexra will verify that the configured address range does notinterferewithotherregionsdefinedforlx4380thesizeofthememoryregionmustbeapoweroftwo and must be naturally aligned table 24 imem ram interfaces note n designates an available activelow version of signal 76 data cache dcache lmi thedcachelmisuppliestheinterfaceforadatacacheattachedtothelx4380localbusthedatacache is rtl configurable for direct mapped or twoway set associativity and writeback or writethrough operation the data cache participates in cacheable data reads and writes but only if the address is not claimed by the dmem lmi the configurations supported by the data cache and the synchronous rams required for each are summarized in table25 see sectiond4 loadstore rules for detailed descriptions of pipeline stalls that the data cache may cause writes that miss the cache or writes that are performed in writethrough mode may require extra time to be serviced by the lbc if its write buffer is full64k bytes 8192 x 64 bits 128k bytes 16384 x 64 bits 256k bytes 32768 x 64 bits signal description iw_instindex imem index iwr_instrd instruction read data iw_instwr instruction write data iw_instwen10 instruction ram write enable iw_instren instruction ram read enable iw_instcsn instruction ram chip select cfg_iwbase3110 conﬁgured base address modulo 1k bytes cfg_iwtop1710 conﬁgured top address bits that may differ from baseconﬁguration imem_inst ram58 lexra proprietary confidential release 21section 7 local memory lx4380 table 25 dcache conﬁgurations table26 lists the dcache signals that are connected to application specific rams the dc_ prefix indicatessignalsthataredrivenbythedcachelmimoduleandreceivedbytheramsthedcr_prefix indicatessignalsthataredrivenbythedcacheramsandreceivedbythedcachelmilexrasupplies the verilog module that makes all required connections to these wires the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table25 table 26 dcache ram interfacesconﬁguration dcache_data ram dcache_tag ram data cache ram required ram required 1k bytes 2way 2 x 64 x 64 bits 16 x 24 and 16 x 26 bits 2k bytes 2way 2 x 128 x 64 bits 32 x 23 and 32 x 25 bits 4k bytes 2way 2 x 256 x 64 bits 64 x 22 and 64 x 24 bits 8k bytes 2way 2 x 512 x 64 bits 128 x 21 and 128 x 23 bits 16k bytes 2way 2 x 1024 x 64 bits 256 x 20 and 256 x 22 bits 32k bytes 2way 2 x 2048 x 64 bits 512 x 19 and 512 x 21 bits 64k bytes 2way 2 x 4096 x 64 bits 1024 x 18 and 1024 x 20 bits 1k bytes direct mapped 128 x 64 bits 32 x 23 bits 2k bytes direct mapped 256 x 64 bits 64 x 22 bits 4k bytes direct mapped 512 x 64 bits 128 x 21 bits 8k bytes direct mapped 1024 x 64 bits 256 x 20 bits 16k bytes direct mapped 2048 x 64 bits 512 x 19 bits 32k bytes direct mapped 4096 x 64 bits 1024 x 18 bits 64k bytes direct mapped 8192 x 64 bits 2048 x 17 bits signal description dc_tagindex tag and state ram address dcr_tagrd tag and state ram read path dc_tagwr tag and state ram write path dc_tagwen tag and state ram write enable dc_tagren tag and state ram read enable dc_tagcsn tag and state ram chip select dc_dataindex data ram address word dcr_datard data ram read path dc_datawr data ram write pathrelease 21 lexra proprietary confidential 59lx4380 section 7 local memory note n designates an available activelow version of signal when configured for writeback operation the data cache tag ram includes bit to indicate that line is dirtyeachcachelineiscoveredbyasingledirtybitwhichwhensetindicatesthattheprocessorhasmodified the line in the cache but has not updated main memory when line is filled from system memory the dirty bit is cleared if write hits in the cache and the dirty bit is not set clean line the data cache ram is updated with the write data and the dirty bit is set to one if the line is already dirty when write hits in the cachethedatacacheramisupdatedwiththewritedataandthedirtybitremainssetanycachedwritethat hits the writeback data cache updates the cache only and does not cause any system bus activity whenconfiguredasawritebackcachethedatacachelmialsoincludesanevictbufferinthecaseofaread miss to dirty line the data cache first issues line read operation to fetch the new line if the line currently stored in the cache is dirty the line is copied from the data cache ram to the evict buffer when the current line has been completely copied into the evict buffer the new line is loaded into the data cache ram as soonastheevictbufferisfullthedatacacheissuesalinewriteoperationtheprocessordoesnotstallwhile the line is being written unless the processor causes the data cache to issue another system bus operation before the line write operation is complete cachelinesareonlyallocatedonreadmissesnotwritesifawritemissesinthecacheitwillbeissuedasa single write on the bus and line will be evicted or filled this is the same for both writeback and write through caches the replacement policy for the 2way setassociative configuration is lru least recently used table27 shows the data cache and system bus activity based on the current operation the state of the line currently stored at the cache location and the outcome of the tag compare the table includes some unusual cases such as uncached operation hitting the data cache such conditions are possible because the same physical address can be accessed in both cacheable or uncacheable modes either through kseg0kseg1 addressaliasorthroughmappingsthatareineffectwiththeoptionalmmuthedatacachecontrollertreats these cases in conservative fashion to ensure coherency between the data cache and main memorydc_datawen10 data ram write enable dc_dataren data ram read enable dc_datacsn data ram chip selectsignal description60 lexra proprietary confidential release 21section 7 local memory lx4380 table 27data cache operations and results operation stateofline currently stored in cachetag compare result actionnew cache state cmdcached uncachedwritethrough writeback read cached x invalid x issue line fill clean x clean hit read from cache clean x clean miss invalidate and issue line fillclean x dirty hit read from cache dirty x dirty miss evictlineandissueline fillclean uncached x invalid x read from system bus invalid x clean hit invalidate and read from system businvalid x clean miss read from system bus clean x dirty hit evictlineandreadfrom system businvalid x dirty miss read from system bus dirty write cached x invalid x write to system bus invalid writeback clean hit write to cache only dirty writethrough clean hit write to cache and system busclean x clean miss write to system bus clean writeback dirty hit write to cache only dirty writethrough dirty hit write to cache and system busdirty x dirty miss write to system bus dirty uncached x invalid x write to system bus invalid x clean hit invalidate and write to system businvalid x clean miss write to system bus clean x dirty hit evict line and write to system businvalid x dirty miss write to system bus dirty x dont carerelease 21 lexra proprietary confidential 61lx4380 section 7 local memory 77 scratch pad data memory dmem lmi the dmem lmi supplies the interface for scratch pad data ram attached to the lx4380 local bus the dmem module services any cacheable or uncacheable data read or write operation that falls within its configured range dmemcanperformreadsorwritesthathitdmemattherateofonepercycleseesectiond4 loadstore rules for detailed descriptions of pipeline stall conditions that may be caused by dmem because write operation to the dmem is never sent to the system bus writes to dmem will not cause processor stalls because of pending system bus activity the dmem configurations and the synchronous rams required for each are summarized in the table28 table 28dmem conﬁgurations table29liststhedmemsignalsthatareconnectedtoapplicationspecificramsthe dw_prefixindicates signals that are driven by the dmem lmi module and received by rams the dwr_prefix indicates signalsthataredrivenbyramsandreceivedbythedmemlmithe cfg_prefixidentifiesconfiguration ports on the dmem lmi that are typically wired to constant values the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table28 thecfg_wires define where dmem is mapped into the physical address space it is not possible for any dmemreferencetoresultinanoperationonthesystembusthe lconfigutilitysuppliedbylexrawillverify that the configured address range does not interfere with other regions defined for lx4380 the size of the memory region must be power of two and must be naturally aligned table 29dmem ram interfacesconﬁguration dmem_data ram 64bit dmem_data ram 128bit local data memory ram required ram required 1k bytes 128 x 64 bits 64 x 128 bits 2k bytes 256 x 64 bits 128 x 128 bits 4k bytes 512 x 64 bits 256 x 128 bits 8k bytes 1024 x 64 bits 512 x 128 bits 16k bytes 2048 x 64 bits 1024 x 128 bits 32k bytes 4096 x 64 bits 2048 x 128 bits 64k bytes 8192 x 64 bits 4096 x 128 bits 128k bytes 16384 x 64 bits 8192 x 128 bits 256k bytes 32768 x 64 bits 16384 x 128 bits signal description dw_dataindex decoded data ram index dwr_datard data ram read data dw_datawr data ram write data62 lexra proprietary confidential release 21section 7 local memory lx4380 note n designates an available activelow version of signaldw_datawen data ram write enable dw_dataren data ram read enable dw_datacsn data ram chip select cfg_dwbase3110 conﬁgured base address modulo 1k bytes cfg_dwtop1710 conﬁgured top address bits that may differ from basesignal descriptionrelease 21 lexra proprietary confidential 63lx4380 section 8 cbus interface 8 cbus interface this section describes the cbus system interface to the lx4380 that is an alternative to the lbus the cbus interface cbi provides simple signalling layer between the lx4380 processors cache controllers and the optional lx4380 system bus interface the lbc see section9 for information on the lbc and lbus lx4380 applications that connect to bus protocol other than lbus may eliminate the lbc and provide their own system bus interfaces or devices that connect directly to the lx4380 using cbus 81 system interface conﬁguration figure8 illustrates the lx4380s organization for the different system interface configurations this section describes the configuration shown is part b of the figure figure 8 lx4380 system interface configurationslbuscbus_ylbcicache dcache ejtag lx4380 configured with lbus interface cbus_ycbus interface cbi b lx4380 configured with cbus interfacelx4380 processor application logic lx4380 processor application logiccbus interface cbi icache dcache ejtag64 lexra proprietary confidential release 21section 8 cbus interface lx4380 82 cbus interface write buffer and outoforder processing the cbus interface contains write buffer with depth that is configurable with lconfig all write requests from the cpu are posted in the write buffer the cpu will not wait for the write to complete write operations complete in the order they are entered into the buffer if the buffer is full and the data cache generates another write operation to the cbus interface then the cpu is stalled until an entry becomes available lx4380 applications that employ lbus instead of cbus still use the cbi write buffer whenthecpuissuesareadoperationthecbiwillattempttoforwardthatrequesttothelexrabusaheadof anypendingwriteoperationsthissignificantlyimprovesperformancesincethecpumustwaitfortheread operation to complete there are few cases when the cbi will not allow the read operation to pass pending writes 1 theaddressofapendingwriteiswithinthesamecachelineasadatacachereadthecbiwill holdthereadoperationuntilthematchingwriteoperationandallwriteoperationsaheadofit completeifthereadisforaninstructionfetchitcanstillpassapendingwritethatisinsidethe same cache line 2 data cache read is to uncacheable address space all writes complete before the read is issued this avoids any problems with io devices and their associated controlstatus registers 3 pending write is to uncachable address space the cbi holds the read operation until all writesuptoandincludingthewritetouncacheableaddressspacecompletethisfurtheravoids io device problems the write buffer bypass feature can be disabled via lconfig so that reads never pass writes 83 cbus line read interleave order thelinereadoperationreadsasequenceofdatabeatsfrommemorycorrespondingtothesizeofacacheline the cache line size affects how many cycles are required to transfer the entire line the lx4380 supports configurable line size specified through lconfig line size of eight words 32 bytes is assumed here the cbus target may transfer the read data starting with word zero first or starting with the desired word first with word zero first operation the target transfers four 64bit beats of data in sequence starting at the nearest 32bytealigned address smaller or equal to the address that the initiator drives in other words the targetstartsthetransferatthebeginningofthelinecontainingtherequestedaddresswithdesiredwordfirst operationthefirstdatabeatreturnedbythetargetisthebeatcorrespondingtotheaddressinsteadoftheword zero of the line the second beat is the next sequential data beat and so on at the end of the line the target wraps around and returns the first beat of line all devices attached to the cbus must consistently return word zero first or the desired word first the lx4380 is configurable to work with either mode the lx4380 supports two ways of incrementing the address of line fill one is by linear wrap where the addressissimplyincrementedbyonetheotherisby interleavedwrap wherethenextaddressisdetermined bythelogicalxorofthecyclecountandthefirstwordaddresstheinterleavesequenceisshownintable30 theloworderaddressbits43forthefirstdatabeataretheobtainedfromtheaddressofthelinereadrequest the loworder address bits for the subsequent data indicate the corresponding interleave order all devices attachedtothecbusmustconsistentlysupportlinearwraporinterleavedwrapthelx4380isconfigurable to work with either moderelease 21 lexra proprietary confidential 65lx4380 section 8 cbus interface table 30 line read interleave order 84 cbus byte alignment cbusdatamustbedriventothebytelanesaccordingtotherulesshownintable31alignmentsnotshown are not generated by the cpu all multibeat operations transfer multiple twin word beats over cbus table 31 cbus byte lane assignmentinterleaved address43 1st data beat 00 01 10 11 2nd data beat 01 00 11 10 3rd data beat 10 11 00 01 4th data beat 11 10 01 00 cbus bus data byte lanes used transfer sizeaddr20 6356 5548 4740 3932 3124 2316 158 70 byte 000 x byte 001 x byte 010 x byte 011 x byte 100 x byte 101 x byte 110 x byte 111 x half word 000 x x half word 010 x x half word 100 x x half word 110 xx word 000 x x x x word 100 x x x x twin word 000 x x x x x x x x66 lexra proprietary confidential release 21section 8 cbus interface lx4380 85 cbus interface signal list table32 summarizes the lx4380s cbus signals table 32 cbus signal list name io function cbus_yreqo 0 request 1 processor is initiating request cbus_yaddro310 address cbus_yreado 1read 0write cbus_yszo30 transfer size 4b1000 1 byte 4b1001 2 bytes 4b1011 1 word 4b1100 2 words 4b0000 4 words this signal is dont care when cbus_ylineo is asserted cbus_ylineo 1 line access 0 single access cbus_ydatao630 write data cbus_yuco 1 uncached access 0 cached access cbus_ysrco30 transaction source within lx4380 4b0001 instruction cache 4b0010 data cache or ejtag dma write 4b0100 ejtag dma read 4b1000 not used cbus_ydbusyo 1 lx4380 is not ready to receive data any return with cbus_yvaltypeiofdata4b0010isignoredbythelx4380 external logic must hold such data until cbus_ydbusyo is deasserted 0 lx4380 is ready to receive data cbus_ybusyi i 1 external logic cannot accept request the current cbus_y request if any is ignored by external logic 0 external logic is ready to accept request cbus_ydatai630 i read data cbus_yvaltypei30 i indicates valid read data of certain type 4b0000 valid read data 4b0001 instruction cache 4b0010 data cache 4b0100 ejtag dma 4b1000 not used cbus_yidlei i indicates external cbus_y device is in an idle state ie has pending read or write transactionsrelease 21 lexra proprietary confidential 67lx4380 section 8 cbus interface 86 cbus transaction types the following transaction types are supported by the cbus interface 1 single read 2 line read 3 single write 4 line writes 87 cbus protocol the transaction request protocol is controlled with cbus_yreqo output and cbus_ybusyi input 1 the cbus_yreqo output is asserted by the lx4380 to initiate an access to external logic additional cbus_y outputs are driven by the lx4380 to provide the transaction details 2 cbus_yreqo remains asserted until the cbus_ybusyi is not asserted by external logic for write transaction the transaction is completed after step 2 for read transaction additional steps control the return of read data by the external logic using the cbus_yvaltypei30 input and the cbus_ydbusyo output 1 if cbus_yvaltypei indicates instruction cache or ejtag dma data is present on cbus_ydatai the data is always accepted by the lx4380 2 if cbus_yvaltypei indicates that data cache data is present on cbus_ydatai and cbus_ydbusyoisassertedtheexternallogicmustcontinuetodrivecbus_yvaltypei and cbus_ydatai until cbus_ydbusyo deasserts 88 cbus transaction timing diagrams noteallofthefollowingtimingdiagramsassumealinesizeof8wordsforreadsthetransactionrequestis shown in different timing diagram than the returning read data as there is protocol link between the two 881 backtoback single writes with busy in cycle 1 the write to address is accepted by the external logic in cycle 2 the external logic asserts cbus_ybusyi which causes the lx4380 to hold its request in cycle 3 the external logic deasserts cbus_ybusyi and accepts the request68 lexra proprietary confidential release 21section 8 cbus interface lx4380 in this example cycle 4 could be used by the processor to initiate another request figure 9 cbus backtoback single writes with busy 882 line writes during line write the address is given in cycle 1 external logic signals that it is able to accept line write request by deasserting cbus_ybusyi external logic does not honor line write request when cbus_ybusyi is asserted figure 10 cbus line writeclk cbus_yreqo cbus_ybusyi cbus_yaddro310 cbus_yreado cbus_yszo30 cbus_ylineo cbus_ydatao630 cbus_yuco cbus_ysrco20a b b b d00771234 clk cbus_yreqo cbus_ybusyi cbus_yaddro310 cbus_yreado cbus_yszo30 cbus_ylineo cbus_ydatao630 cbus_yuco cbus_ysrco20a a1 a2 a3 a4 a1 a2 a3 a4 d007812345release 21 lexra proprietary confidential 69lx4380 section 8 cbus interface 883 backtoback single read requests with busy only the read request is shown here the return data is not shown figure 11 cbus backtoback single read requests with busy 884 line read request line read request takes only one cycle with the data being returned later by the external logic figure 12 cbus line read requestclk cbus_yreqo cbus_ybusyi cbus_yaddro310 cbus_yreado cbus_yszo30 cbus_ylineo cbus_ydatao630 cbus_yuco cbus_ysrco20a b b d00791234 clk cbus_yreqo cbus_ybusyi cbus_yaddro310 cbus_yreado cbus_yszo30 cbus_ylineo cbus_ydatao630 cbus_yuco cbus_ysrco10a d00801270 lexra proprietary confidential release 21section 8 cbus interface lx4380 885 returning read data external logic supplies read data on the cbus_ydatai inputs while asserting bit within cbus_yvaltypei if cbus_yvaltypei indicates data 4b0010 the lx4380 only accepts the read data if it has deasserted cbus_ydbusyo if cbus_ydbusyo is asserted the external logic must maintain cbus_yvaltypei and cbus_ydatai until cbus_ydbusyo is deasserted figure 13cbus read data and dbusy read line data return is illustrated below the external device asserts the appropriate bit of cbus_yvaltypei for each data beat assertion of cbus_ydbusyo is also illustrated figure 14read data for line read request 886 latency of cbus transactions figure15illustrateshowthelatencyofacbusreadtransactionaffects thedurationofcpu stallswhilethe cpu waits for the read data to be returned figure 15 latency of cbus transactions the overall latency encountered for any cbus transaction depends more on system level behavior and less onthebehaviorofthecbusinterfaceitselfinthisexamplethecbusinterfaceissynchronouslyconnected to fullspeed lbus via an lbc and the lbc is assumed to be parked on the lbus thus the read transactionappearsonlbusonecycleafterthecbusrequestisinitiatedsomenumberofcycleswillpass as the addressed lbus target prepares its data response the lbus target then supplies the data beatsclk cbus_ydbusyo cbus_yvaltypei30 cbus_ydatai63000000000 0100 b 0100 c 0010 0000 b c d0074123 456 clk cbus_ydbusyo cbus_yvaltypei30 cbus_ydatai630a 0010 a0 a1 a2 a3 d0075123 456 clk stall cbus_yreqo lbus_frame lbus_trdy cbus_yvaltypei30 4b00004b0000 4b0010 4b0000d0081release 21 lexra proprietary confidential 71lx4380 section 8 cbus interface coincident with the assertion of trdy the lbc requires only one cycle to pass the first data beat from the lbus to the cbus at which time cbus_yvaltype contains the code 5b00010 to indicate the data responsethecbusinterfaceinturnrequiresonlyonecycletopassthedatatothecpuandreleasethestall condition from this example it is seen that only three stall cycles can be attributed to the cbus interface if synchronous fullspeed lbus is employed for the system bus the lbc and lbus protocol will result in minimum of three additional stalls the addressed lbus target may also insert additional stalls72 lexra proprietary confidential release 21section 8 cbus interface lx4380release 21 lexra proprietary confidential 73lx4380 section 9 lexra system bus lbus 9 lexra system bus lbus this section describes the optional lexra system bus lbus and the lexra bus controller lbc that connectsthelx4380tolbusthelbusprovidesaflexiblepcilikeprotocolappropriateforsystemswith multiplemastersandtargetsapplicationswhichdonotrequireasuchasystembusorwhichincludecustom interfacestoothersystembusesmayoptionallyemploythelx4380scbusinterfaceratherthanthelbus see section8 cbus interface 91 connecting the lx4380 to internal devices the lexra bus controller lbc provides the connection between the lx4380 cbus interface cbi and the lexra system bus lbus the lbus supports applicationspecific system bus devices such as main memory usb or ieee1394 firewire the lbc uses protocol similar to that of the peripheral component interface pci bus this is wellknown and proven architecture adding new devices to the lexra bus is straightforward and the performance approaches the highest that can be achieved without adding great deal of complexity to the protocol figure 16 lexra system bus lbus diagram thelexrabussupportsmultiplemastersthisallowsformasteringiocontrollerswithdmaenginestobe connected to the bus the bus has pended architecture in which master holds the bus until all the data is transferred this simplifies the design of usersupplied bus agents and reduces latency for cache miss servicing thelexrabusisasynchronousbussignalsareregisteredandsampledatthepositiveedgeofthebusclock certain logical operations may be made to the sampled signals and then new signals can be driven immediately such as for address decoding this allows samecycle turnaround the lbc supports synchronous modes with the lbus operating at full cpu speed or half cpu speed and an asynchronous mode that allows the lbus to be clocked at any speed independent of the cpu speed thelexrabusdatapathforthelx4380is64bitswidethereforethebuscantransfertwowordsoneword halfword or byte in one bus clock the bus supports line and burst transfers in which several beats 64 bits of data are transferred the lexra bus accomplishes this by transferring data beats in successive clocklexra bus controller lbcbus bridge usb firewirelbusexternal bu s eg pci cbus interface cbibuses to lmis cbusmemoryapplicationspecific modules lx4380 modules74 lexra proprietary confidential release 21section 9 lexra system bus lbus lx4380 cycles the lbc provides enabling signals to control applicationspecific muxes or tristate buffers this allows the lbus to have either bidirectional or pointtopoint topology 92 terminology thelexrabusborrowsterminologyfromthepcibusspecificationonwhichthelexrabusispartiallybased bus transactions take place between two bus agents one bus agent requests the bus and initiates transfer the second responds to the transfer theagentinitiatingatransferiscalledthe businitiator itisalsoreferredtoasthe busmaster bothtermsare used interchangeably in this document therespondingagentisknownasthebus targetitsamplestheaddresswhenitisvalidanddeterminesifthe address is within the domain of the device if so it indicates such to the initiator and becomes the target aread transfer is bus operation whereby the master requests data from the target awrite transfer is bus operation whereby the master requests to send data to the target asingle data bus operation is used to transfer two words one word halfword or byte of data the data can be transferred in one bus cycle not including the address cycle and device latencies aline transfer is read or write operation where an entire cache line of data is transferred in successive cycles as fast as the initiator and target can sendreceive the data aburst transfer is read or write operation where large amount of data needs to be sent the initiator presents starting address and data is transferred starting at that address in successive cycles for each word transferred the address is incremented by the devices internally abeat is the data up to 64 bits that is transferred in one data cycle aword is 32 bits of data deviceasserts signal when it drives it to its logical true electrical state 93 bus operations the purpose of the lexra bus is to connect together the various components of the system including the lx4380 cpu main system memory io devices and external bus bridges different devices have different transfer requirements for example the lx4380 cpu will request the bus to fetch cache line of data from memory io devices will request large blocks of data to be sent to and from memory lbus supports the various types of transfers needed by both io and the processor single data read line read burst read single data write line write burst write note that although burst operations are defined for the lbus protocol the lx4380 does not initiate burst operationsrelease 21 lexra proprietary confidential 75lx4380 section 9 lexra system bus lbus 931 single data read the single data read operation reads twinword single word halfword or byte from the target device this operationisusuallyusedbythecputoreaddatafromuncachableaddressspaceifthereadaddresswasin cacheableaddressspaceeitherahitwouldoccurresultinginnobusactivityoramisswouldoccurresulting in read line transaction 932 line read thelinereadoperationreadsasequenceofdatabeatsfrommemorycorrespondingtothesizeofacacheline the cache line size affects how many cycles are required to transfer the entire line the lx4380 supports configurable line size specified through lconfig line size of eight words 32 bytes is assumed here thetargetmaytransferthereaddatastartingwith wordzerofirst orstartingwiththe desiredwordfirst with word zero first operation the target transfers four 64bit beats of data in sequence starting at the nearest 32 bitalignedaddresssmallerorequaltotheaddressthattheinitiatordrivesinotherwordsthetargetstartsthe transfer at the beginning of the line containing the requested address with desired word first operation the first data beat returned by the target is the beat corresponding to the address instead of the word zero of the linethesecondbeatisthenextsequentialdatabeatandsoonattheendofthelinethetargetwrapsaround and returns the first beat of line all devices on the system bus must operate consistently with respect to whethertheyreturnwordzerofirstorthedesiredwordfirstthelx4380isconfigurabletoworkwitheither mode of operation the lx4380 supports two ways of incrementing the address of line read one is linear wrap where the addressissimplyincrementedbyonetheotheris interleavedwrap wherethenextaddressisdeterminedby the logical xor of the cycle count and the first word address the interleave sequence is shown in the table belowtheloworderaddressbits43forthefirstdatabeataretheobtainedfromtheaddressofthelineread request the low order address bits for the subsequent data indicate the corresponding interleave order the address increment mode used for line read operation is specified in the bus command as described in section95 the lx4380 is configurable via lconfig to generate bus commands for either mode table 33 line read interleave order 933 burst read theburstreadoperationtransfersanarbitraryamountofdatafromthetargettotheinitiatortheinitiatorfirst presents starting address to the target the target responds by providing multiple cycles of data beats in sequence starting at the initial address the initiator indicates to the target when to stop providing data burst read operations are used by io devices for block dma transfers the lx4380 does not issue burst read operations note that there is adifference between an 8cycle burst and aline read aline read mayuse desiredword first increment and wrap burst will always increment and will never wrapinterleaved address43 1st data beat 00 01 10 11 2nd data beat 01 00 11 10 3rd data beat 10 11 00 01 4th data beat 11 10 01 0076 lexra proprietary confidential release 21section 9 lexra system bus lbus lx4380 934 single data write the single data write operation writes twinword single word halfword or byte to the target although twinword writes are supported by the lbus protocol the lx4380 does not issue twinword writes the lx4380 data cache is configurable for writethrough or writeback policies cpu data writes that are performed in writethrough mode generate single data write operation on the system bus cpu data writes thatmissthedatacacheeveninwritebackmodealsogenerateasinglecyclewriteoperationhoweverthe data cache inhibits these bus write operations if the address falls within the cpus local dmem 935 line write thelinewriteoperationwriteasequenceofdatafrommemorycorrespondingtothesizeofacachelinethe cache line size affects how many cycles are required to transfer the full line the lx4380 and the lexra bus support configurable line size specified through lconfig line size of eight words 32 bytes is assumed here line writes always begin with word zero as the first data beat 936 burst write burst write is an operation where the initiator sends an address and then an indefinite sequence of data to thetargettheinitiatorwillinformthetargetwhenithasfinishedsendingdatathisoperationisusedbyio devices for dma transfers it is not used by the lx4380release 21 lexra proprietary confidential 77lx4380 section 9 lexra system bus lbus 94 signal descriptions table 34 lbus signal description signal namesource initiatortargetctrldescription bclock ctrl bus clock bcmd60 initiator encoded command active during ﬁrst cycle that bframe is asserted baddr310 initiator address target indicates valid address by asserting bframe bframe initiator asserted by initiator at beginning of operation with address and command signals deasserted when initiator is ready to accept or send last piece of data otherbusmasterssamplethisandbirdytoindicate that the bus will be available on the next cycle birdy initiator forwritesindicatesthatinitiatorisdrivingvaliddata on reads indicates that initiator is ready to accept data bdata630 initiator on writetarget on readdata if driven by initiator birdy indicates valid data onbusifdrivenbytargetbtrdyindicatesvaliddata on bus btrdy target for writes indicates that target is ready to accept data on reads indicates that target is driving valid data bsel target asserted by selected target after initiator asserts bframeindicatesthattargethasdecodedaddress and will respond to the transaction ie has been selected78 lexra proprietary confidential release 21section 9 lexra system bus lbus lx4380 95 lbus commands the initiator drives bcmd during the cycle that bframe is asserted the encoding for bcmd is shown below bcmd6 0 read 1 write bcmd54 00 burst ﬁxed lengtha for burst transfers the length is determined bcmd3001 burst unlimited number of words 10 line interleaved wrapb b forlinetransfersthelengthisdeterminedbythertllinesizeconﬁgura tion set with lconﬁg not bcmd3011 line linear wrap bcmd30 1000 1 byte 1001 2 bytes 1010 reserved 1011 1 word 1100 2 words 1101 reserved 111x reserved 0000 4 words 0001 8 words 0010 16 words 0011 32 words 01xx reservedrelease 21 lexra proprietary confidential 79lx4380 section 9 lexra system bus lbus 96 lbus byte alignment lbusdatamustbedriventothebytelanesaccordingtotherulesshownintable35alignmentsnotshown are not legal all multibeat operations transfer multiple twin word beats over lbus table 35lbus byte lane assignment the lexra bus does not define unaligned data transfers such as halfword transfer that starts at addr1001 or transfers that would need to wrap to the next data beatlexra bus data byte lanes used bcmd30 addr20 6356 5548 4740 3932 3124 2316 158 70 1000 000 x 1000 001 x 1000 010 x 1000 011 x 1000 100 x 1000 101 x 1000 110 x 1000 111 x 1001 000 x x 1001 010 x x 1001 100 x x 1001 110 xx 1011 000 x x x x 1011 100 x x x x 1100 100 x x x x x x x x80 lexra proprietary confidential release 21section 9 lexra system bus lbus lx4380 97 lexra bus controller thelexrabuscontrollerlbcistheelementofthelx4380thatconnectstothelexrabusitforwardsall transaction requests from the lx4380 cpu to the lexra bus it is an initiator and will never respond to requests from other lexra bus initiators 971 lbc commands the lbc issues only the lbus commands listed in the table below table 36 lbus commands issued by the lbc 972 write buffer the lx4380 includes write buffer in its cbus interface when the lx4380 is configured to include the lbc the cbus interface and its write buffer are always included as an internal lx4380 module see section82 for description of the write buffer 973 lbc read buffer the lbc contains read buffer with depth that is configurable with lconfig all incoming read data from the system bus passes through the read buffer this allows the lbc to accept incoming data as result of cache line fill operation without having to hold the bus when the lbc is configured with an asynchronous interface larger read buffer improves system and processor performance in the event of cache miss when the lbc is configured with synchronous interfacethecachecanacceptdataasfastasthelbccantransferitthereisnoneedforalargereadbuffer throughlconfig the size of the read buffer may be reduced to minimum size of two 64bit data entries insomeapplicationsthereisaneedtominimizethenumberofgatesthereadbuffersizemaybereducedto twoentriesfortheasynchronouscasethiscausesapenaltyintermsoflbusutilizationsincethelbcmay havetodelaythereadbydeassertingirdyifitcannotholdpartofthelineofdatawhenthereadbufferis the size of cache line this will be rare since simultaneous instruction cache and data cache misses are relatively rare for smaller read buffer delays are likelycommand bcmd6 bcmd54 bcmd30 circumstances read line 0 10 or 11 depending on conﬁgu rationundeﬁned cache miss during read by the cpu read single twinwordwordhalf wordbyte0 00 10xx or 1100a read by the cpu from an address in uncachable address space write line 1 10 or 11 depending on conﬁgu rationxxxx whenthedatacacheisconﬁgured for writeback operation read miss requires replacement of dirty line write single wordhalfwordbyte1 00 10xx write by the cpu into cacheable or uncachable address spacerelease 21 lexra proprietary confidential 81lx4380 section 9 lexra system bus lbus 98 transaction descriptions this section describes the various types of lbus read and write transactions in detail these operations adhere to the following protocols 1 agentsthatdrivethebusdosoasearlyaspossibleaftertherisingedgeofthebusclockthere is some time to perform combinational logic after the bus clock goes high but the amount of time is determined by the speed of the bus clock and the number of devices on the bus 2 agents sample signals on the bus at the rising edge of the bus clock 3 all bus signals must be driven at all times if the bus is not owned and external device must drive the bus to legal level 4 change in signal ownership requires one cycle during which the signal is not driven if an initiator gives up the bus another initiator needs to wait for one undriven cycle before it can drive the bus if the same initiator issues read operation and then needs to issue write oper ation it also must wait one extra cycle to ensure that the undriven cycle is present 5 agentsthatownsignalsmustdrivethesignalstoalogicaltrueorlogicalfalseallotheragents must disable tristate their output buffers thelexrabusprotocolisbasedonthepcibusprotocol1thelexrabussignalsbframebtrybirdy and bsel have similar function to the pci signals frame trdy irdy and devsel respectively in general the protocol for the lexra bus is as follows 1 the initiator gains control of the bus through arbitration described section 910 on page 88 2 during the ﬁrst bus cycle of its ownership before the ﬁrst rising clock edge the initiator drivestheaddressforthebustransactionontobaddratthesametimeitassertsbframe to indicate that the bus is in use it will deassert bframe before it send or accepts the last data beat in most cases the initiator will assert birdy to indicate that it is ready to receive data or read operations or is driving valid data for write operations if the operation is write the initiator will drive valid data onto bdata 3 at the rising edge of the ﬁrst clock all agents sample baddr and decode it to determine which agent will be the target 4 the agent that determines that the address is within its address space asserts bsel sometime after the ﬁrst rising edge of the bus clock bsel stays asserted until the transaction is com plete 5 the initiator and the target transfer data either in one cycle or in successive cycles the agent driving data the initiator for write the target for read indicates valid data by asserting its readysignalirdyortrdyforwritesandreadsrespectivelytheagentreceivingdatatar getforawriteinitiatorforareadindicatesitsabilitytoreceivethedatabyassertingitsready signal either agent may deassert its ready signal to indicate that it cannot source or accept data on this particular clock edge 6 when the initiator is ready to send or receive the last data beat that is when it asserts birdy forthelasttimeitalsodeassertsbframeitwilldeassertbirdywhenthelastdatabeatis transferred 1 the lexra bus is not pci compatible it merely borrows concepts from the pci bus speciﬁcation82 lexra proprietary confidential release 21section 9 lexra system bus lbus lx4380 7 the arbiter grants the bus to the next initiator and may do so during bus transfer by differ ent initiator the new initiator must sample bframe and birdy when both birdy and bframe is sampled deasserted and the new initiator has been given grant it can assert bframe the next cycle to start new transaction note in the examples below the signals baddr and bdata are often shown to be in highimpedance state in reality internal bus signals should always be driven even if they are not being sampled the hiz states are shown for conceptual purposes only 981 single data read with waits this operation is used to read twinword word halfword or byte from memory usually in uncachable address space thisisasimplereadoperationwherethetargetrespondsimmediatelywithdatathisisunlikelysincemost deviceswill requireoneormorecycles toreturn datathisexampleillustratesthemostbasicread operation without waits 1 initiator asserts bframe and drives baddr 2 targetassertsbseltoindicatetoinitiatorthatatargetisrespondinginthisexamplethereis animmediatefetchofdatasotargetdrivesdataandassertsbtrdytoindicatetotargetthatit is driving data the initiator deasserts bframe and asserts birdy to indicate that the next piece of data received will be the last 3 initiatordeassertsibirdyandthetargetdeassertsbselandbtrdytoindicatetheendof the transaction the initiator that has been given grant owns the bus this cycle 982 single data read with target wait this is the same as the single data read except that the target needs time to fetch the data from memoryclock bframe bcmd baddr bdata birdy btrdy bsel d0000 clock bframe bcmd baddr bdata birdy btrdy bsel d0001release 21 lexra proprietary confidential 83lx4380 section 9 lexra system bus lbus this is common single data read operation 1 initiator asserts bframe and drives baddr 2 target asserts bsel to indicate that it has decoded the address and is acknowledging that it is the target device however it is not ready to send data so it does not assert btrdy initiator deassertsbframeandassertsbirdytoindicatethatthenextpieceofdatawillbethelastit wants 3 target has not asserted btrdy so data is transferred 4 after second wait cycle target drives data and asserts btrdy to indicate that data is on the bus 5 target deasserts bsel and btrdy initiator deasserts birdy another initiator may drive the bus this cycle 983 line read with waits alinereadtransfersdatabeatsthatcompriseacachelineinthisexamplefourdatabeatsaretransferredin sequence without any waits 1 initiator drives baddr and asserts bframe to indicate beginning of transaction 2 target asserts bsel to indicate that it had decoded the address and will send data when it is ready initiator asserts birdy to indicate that it is ready to receive data 3 target drives data and asserts btrdy 4 target drives second data beat and continues to assert btrdy 5 target drives third data beat and continues to assert btrdy 6 target drives last data beat initiator deasserts bframe to indicate that the next data beat it receives will be the last it needs 7 target deasserts btrdy and bsel initiator deasserts birdy another master may gain ownership of the bus this cycleclock bframe bcmd baddr bdata birdy btrdy bsel d000284 lexra proprietary confidential release 21section 9 lexra system bus lbus lx4380 984 line read with target waits this illustrates what happens when target needs extra time to fetch data it needs to service cache miss 1 initiator asserts bframe and drives baddr 2 targetassertsbseltoindicatethatitisacknowledgingtheoperationinitiatorassertsbirdy to indicate that it is ready to receive data 3 target waits until it has the data 4 target drives ﬁrst data beat and asserts btdry 5 target drives second data beat and asserts btrdy 6 target cannot get third data beat so it deasserts btrdy 7 target drives third data beat and asserts btrdy 8 target cannot get fourth data beat so it deasserts btrdy 9 target drives fourth data beat and asserts btrdy 985 line read with initiator waits this occurs when line of data is requested from the target and the initiator cannot accept all of the data in successive cyclesclock bframe bcmd baddr bdata birdy btrdy bsel d0003 clock bframe bcmd baddr bdata birdy btrdy bsel d0004release 21 lexra proprietary confidential 85lx4380 section 9 lexra system bus lbus 1 initiator drives address and asserts bframe 2 targetassertsbselitdoesnthavedatasoitdoesnotassertbtrdyinitiatorassertsbirdy to indicate that it can accept data 3 target now has data so it drives the data and asserts btrdy 4 target drives second data beat initiator cannot accept it so it deasserts birdy 5 target holds second data beat initiator can accept it and asserts birdy 6 target drives third data beat initiator accepts it 7 target drives fourth data beat initiator cannot accept it and deasserts birdy initiator hold bframe until it can assert birdy 8 initiatorassertsbirdytoacceptfourthdatabeatitdeassertsbframetoindicatethisisthe last data beat 986 burst read the burst read transaction is similar to line read except that bcmd indicates burst read the end of the burst is indicated when the initiator deasserts bframe and birdy 987 single data write with waits asingledatawriteoperationoccurswhenthelx4380processorexecutesastoreinstructionthatmissesthe data cache or executes store operation in writethrough mode writes to uncacheable address space also generate single data write single data write operations are used to write twinwords words halfwords and bytes but note the lx4380 does not generate twinword writes single data write without waits requires two cycles 1 initiator asserts bframe and drives address 2 targetsamplesaddressandassertsbselinitiatordrivesdataandassertsbirdyinthiscase target is also able to accept data so it asserts btrdy initiator also deasserts bframe to indicate that it is ready to send the last and only data beat 3 target accepts data deasserts btrdy and bsel initiator deasserts birdyclock bframe bcmd baddr bdata birdy btrdy bsel d000586 lexra proprietary confidential release 21section 9 lexra system bus lbus lx4380 988 single data write with waits thisisanexampleofasingledatawriteoperationwherethetargetcannotimmediatelyacceptdataandmust insert wait states thisisthesamedescriptionastheaboveexampleexceptthatthetargetinsertstwowaitstatesuntilitasserts birdy to indicate acceptance of data 989 line write with waits line write operationis generally used to transfer amodified cache line from acache to main memory the following illustrates bestcase scenario with wait states 1 initiator drives address and asserts bframe 2 targetassertsbselandbtrdytoindicateitwillacceptdatainitiatordrivedataandasserts birdy 3 initiator drives next data beat target continues to accept data and indicates as such by continu ing to assert btrdy 4 initiator drives third data beat target continues to accept 5 initiator drives fourth data beat and deasserts bframe to indicate that this will be its last beat sent target accepts dataclock bframe bcmd baddr bdata birdy btrdy bsel d0006 clock bframe bcmd baddr bdata birdy btrdy bsel d0007release 21 lexra proprietary confidential 87lx4380 section 9 lexra system bus lbus 6 target deasserts btrdy and bsel initiator gives up control of the bus by deasserting birdy 9810 line write with target waits this example is similar to the above example except that during the third and fourth data beat transfer the target cannot accept the data quickly enough so it deasserts btrdy which indicates to the initiator that it should hold the data for an additional cycle 9811 line write with initiator waits the example illustrates what happens when the initiator cannot supply data fast enough and has to insert waits 9812 burst write burst write is generally used to transfer large amounts of data from an io device to memory via dma transfer this transaction is similar to line write except that bcmd indicates burst write the end of burst write is indicated when the initiator deasserts bframe and birdy 99 lbc signals thetablebelowsummarizesthelx4380lbcportsthelbcportcolumnindicatesthenameoftheport suppliedbythelbcthebussignalcolumnindicatesthecorrespondinglexrabussignalthelbcports are strictly unidirectional while the bus signals at least conceptually include multiple sources and sinks the manner in which lbc ports are connected to bus signals is technology dependent and may employ tri state drivers or logic gating in conjunction with the lbcs lcoe ldoe and ltoe outputsclock bframe bcmd baddr bdata birdy btrdy bsel d0008 clock bframe bcmd baddr bdata birdy btrdy bsel d000988 lexra proprietary confidential release 21section 9 lexra system bus lbus lx4380 table 37 lbc interface signals 910 arbitration 9101 lbus rules the following are the lbus rules for arbitration req request from master gnt grant to the master idle bframe and birdy are both deasserted last birdy and btrdy are both asserted and bframe is deasserted busy birdy or btrdy or bframe are asserted 1 masterassertsreqatthebeginningofacycleandmaystartsamplingforassertedgntinthe same cycle in case gnt is already asserting in the case of park 2 ifbusis idleorifthebusisinthe lastdataphaseoftheprevioustransactionwhenmastersam ples asserted gnt then the master may drive bframe asserted on next cycle 3 if the bus is busy when the master samples gnt the master must also snoop bframe birdyandbtrdyifgntisstillassertedonecycleafterbframeisdeassertedandboth birdy and btrdy are asserted the last data phase the master may drive bframeio lbc port bus signal description output laddro310 baddr310 lbc address output ldatao630 bdata630 lbc data input ldatai630 bdata630 system data output lirdy birdy lbc initiator ready input lirdyi birdy system initiator ready output lframe bframe lbc transaction frame input lframei bframe system transaction frame input lsel bsel system slave select input ltrdy btrdy system target ready output lcmd60 bcmd60 lbc command output lreq lbc bus request input lgnt system bus grant output lcoe90 lbc command output enable terms output ldoe70 lbc data output enable terms output ltoe lbc transaction output enable termsrelease 21 lexra proprietary confidential 89lx4380 section 9 lexra system bus lbus 9102 lbc behavior when the lbc needs access to lbus it asserts lreq and in the same cycle samples lgnt lframei and either lirdyi or lirdyi ltrdy if these are true the lbc takes ownership of the bus on the next cycle the lbc deasserts lreq the cycle after it asserts lframe if the bus is busy the lbc continues to snoop these four signals for this condition all other lbus arbitration rules are based on this behavior of the lbc 911 connecting the lbc to lbus thelbcprovidesarethreesetsofoutputenablesltoevalidforthelengthofthetransactionlcoevalid for only the first cycle of transaction and ldoe valid for data transfers asserted by the master for writes and by the slave for reads ltoe qualifies lframe and lirdy lcoe qualifies lcmd and laddro ldoe qualifies ldatao applicationspecific devices may employ similar signals to qualify their lbus outputs instead of using the lbcs ltoe and similar signals from applicationspecific bus devices it may instead be desirable to logically or the frame outputs from the lbc and all devices this can be done either centrally or with one or gate for each target and master the same holds true for irdy trdy and sel outputs this simplifies the connections when relatively few number of devices are used and there are offchip devices connected directly to the lexra bus masters and slaves not taking part in transaction must always keep their frame irdy trdy and sel outputs driven and deasserted90 lexra proprietary confidential release 21section 9 lexra system bus lbus lx4380release 21 lexra proprietary confidential 91lx4380 section 10 ejtag debug 10 ejtag debug given the increasing complexity of soc designs the nature of embedded processordesign debug hardware and software and the timetomarket requirements of embedded systems debug solution is needed which allows onchip processor visibility in costeffective io constrained manner the ejtag solution uses existing ieee jtag pins providing method of debugging all devices accessible to the processor in the same way the processor would access those devices itself using ejtag debug probe can access all the processor internal registers and caches it can also access devices connected to the lx4380s cbus or lbus bypassing internal caches and memories soc designers need only provide package connections to the lx4380s ejtag signals to obtain the full benefits of embedded system debug using third party hardware probes and debug software ejtagallowssinglesteppingthroughcodeandhaltingonbreakpointshardwareandsoftwareaddressand data with masking for debugging problems that are artifacts of realtime interactions ejtag gives real time program counter pc trace capabilities from which an accurate program execution history is derived 101 overview adebughostcomputercommunicatestotheejtagprobetheprobeinturncommunicatestothelx4380 ejtag hardware via an ieee 11491 jtag interface through the use of the jtag test access port tap controller probe data is shifted into the ejtag data and control registers in the lx4380 to respond to processorrequestsdmaintosystemmemoryconfiguretheejtagcontrollogicenablesinglestepmode or configure the ejtag breakpointregistersthroughtheuseoftheejtagcontrolregisterstheusercanset hardware breakpoints on the instruction address data address or data values physical address range 0xff20_0000 to 0xff3f_ffff is reserved for ejtag use only and should not be mapped to any other device currentlyembeddedperformanceincepiandgreenhillsincprovideejtagdebuggersandprobesfor the lx4380 information on these products is available at the following web sites epi inc httpwwwepitoolscom green hills inc httpwwwghscom lx4380 ejtag implements all required features of version 200 of the ejtag specification including the lx4380 may access debug host resources via addressing of probe memory space debug host can dma directly to or from devices attached to the lx4380s system bus hardware breakpoints may be installed on internal lx4380 instruction and data busses ejtag singlestep execution mode realtime pc trace debug exception and two ejtag debug instructions one for raising debug exception via software and one for returning from debug exception92 lexra proprietary confidential release 21section 10 ejtag debug lx4380 1011 ieee jtagspeciﬁc pinout ieee jtag pins used by ejtag are shown below these are required for all ejtag implementations jtag_trst_n is an optional pin table 38 ejtag pinout table 39 ejtag ac characteristics1 table 40 ejtag synthesis constraints2signal name io description jtag_tdo_nr output serial output of ejtag tap scan chain jtag_tdi input serial input to ejtag tap scan chain jtag_tms input test mode select connected to each ejtag tap controller jtag_clock input jtag clock connected to each ejtag tap controller jtag_trst_n input tap controller reset connected to each ejtag tap controllera this pin is optional in multiprocessor conﬁgurations signal parameter condition min max unit jtag_clock frequency 1 40 mhz duty cycle 4060 6040 jtag_tms setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdi setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdo_nr outputdelaytckfallingedgetotdo 18v 0 7 ns 1 based on epi interface speciﬁcations for majictm and majicplus tmsignal name probe budget core budget slack remaining for other logic jtag_tdo_nr 0 to 7ns 115ns 135 to 205ns jtag_tdi 5ns 135ns 65ns jtag_tms 5ns 135ns 65ns 2 based on 25ns jtag clock periodrelease 21 lexra proprietary confidential 93lx4380 section 10 ejtag debug 102 program counter pc trace the lx4380 ejtag includes support for realtime program counter pc trace when in pc trace mode the lx4380 serially outputs new value of the program counter whenever there is change in the pc ie branch or jump instruction or an exception when the pc trace option is set to export in lconfig the following signals will be output from the lx4380 dclk pcst and tpc these are described in more detail in the following subsections the dclk output is used to synchronize the probe with the lx4380s core clock sysclk the pcst pc trace status signals are used to indicate the status of program execution example status indications are sequential instruction pipeline stall branch or exception the tpc pins output the value of the pc every time there is change of program control 1021 pc trace dclk debug clock the maximum speed allowed for the debug clock dclk output is 100mhz as an epi probe requirement as cores typically run in excess of this speed dclk can be set to divided down value of sysclk this is set by the dclk n parameter in lconfig which indicates the ratio of sysclk frequency to dclk 1 2 3 or 4 1022 pc trace pcst program counter status trace theprogramcounterstatuspcstoutputcomprisesnsetsof3bitpcstvalueswherenisthedclkn parameter described in section1021 pcst value is generated every sysclk cycle when dclk is slower than the lx4380s sysclk up to n pcst values are output simultaneously 1023 pc trace tpc target program counter the bus width of the target program counter tpc output is user configured in lconfigvia the m parametertobeoneof124or8bitswhenchangeinprogramflowoccursthecurrentpcvalueisdrivenon the tpc output as the pc is 32bits wide the number of tpc pins affects how quickly the pc is sent for example if the tpc is 4 bits wide the pc will take 8 dclk cycles to be sent if another change in flow occurswhilethepcofthepreviouschangeisbeingtransmittedthenewpcwillbesentandtheremainderof thepreviouspcwillbelostunlesstheprocessorisinsinglestepmodewhenanexceptionoccurstpcalso indicates the exception type with either 3 or 4 bits depending on whether or not vectored interrupts are present this is described in more detail in section1025 the tdo output is used for the least significant bit of tpc or the only bit if m is set to 1 via lconfig94 lexra proprietary confidential release 21section 10 ejtag debug lx4380 1024 singleprocessor pc trace pinout table 41 singleprocessor pc trace pinout table 42 singleprocessor pc trace ac characteristics1 1025 vectored interrupts and pc trace the ejtag specification states that pc trace provides 3bit code on the tpc output when an exception occursthepcstpinsgivetheexpcodeinordertodistinguishbetweentheeightvectoredinterruptsinthe lx4380 from all other exceptions the lx4380 employs 4bit code for all exceptions other than vectored interrupts the most significant bit of the 4bit code is zero and the remaining 3bits are the standard 3bit code note that this includes the standard software and hardware interrupts numbered 0 through 7 for vectored interrupts the most significant bit is always 1 the 4bit code is simply the number of the vectored interrupt from 8 through 15 being taken since the target of the vectored interrupt is determined by the contents of the intvec register the debug softwarewhichmonitorstheejtagpctracecodesmustbeawareofthecontentsofthisregisterinorderto trace the code after the vectored interrupt is taken for probes that do not support 4bit exception code the lx4380 can be configured via the ejtag_xv_bits lconfig option to use only the 3bit standard codes in that case if vectored interrupt is taken the 3bit code for reset will be presentedsignal name io description jpt_tpc_dr m bitsopthe pc value is output on these pins when pcdiscontinuity occursa tpc0 is multiplexed with tdo in the singleprocessor pc trace solutionjpt_pcst_dr n3 bitsop pc trace status outputs current instruction type every dclk jpt_dclk op pcst and tpc clock frequency determined as fraction of sysclk via the n parameter maximum frequency of dclk is 100mhz signal parameter min max unit jtag_dclk frequency dc 100 mhz dclk high time 4 ns low time 4 ns tpc setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns pcst setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns 1 based on epi interface speciﬁcations for majictm and majicplus tmrelease 21 lexra proprietary confidential 95lx4380 section 10 ejtag debug 1026 demultiplexing of tdo and tdi during pc trace normally ejtag tdi and tdo are multiplexed with the debug interrupt dint and tpc0 when in pc trace mode this reduces the number of pins required by pc trace but prevents any access to ejtag registers during pc trace to allow access to ejtag registers during pc trace and to facilitate pc trace in multiprocessor environments the lconfigoption jtag_trst_is_tpcyes causes tdi and tdo to be demultiplexed such that trst is used as tpc0 and dint is generated via ejtag registers96 lexra proprietary confidential release 21section 10 ejtag debug lx4380release 21 lexra proprietary confidential 97lx4380 section appendix instruction formats this appendix documents the lx4380 instruction encodings that are not included in the standard mipsi r2000r3000 instruction set a1 major opcodes a2 major opcodes table 43 major opcode instruction formats table 44 major opcode bit encodings31 26 25 21 20 16 15 6 assembler mnemonicmajor opcode rs rt immediate cache cache base op offset user deﬁned ce1imm rs rt user deﬁned 655 1 6 inst2826 inst3129 0 1 234567 0 special 1 2 3 ce1imm ce1imm ce1imm ce1imm special2 lexop2 4 5 cache 6 7 lexop98 lexra proprietary confidential release 21section lx4380 a3 lexop instructions table 45 lexop instruction formats table 46 lexop subop bit encodings31 26 25 21 20 16 15 6 5 0 assembler mnemoniclexop 111 100 rs rt immediatelexop subop madh lexop rs rt 0000000000 madh madl lexop rs rt 0000000000 madl mazh lexop rs rt 0000000000 mazh mazl lexop rs rt 0000000000 mazl msbh lexop rs rt 0000000000 msbh msbl lexop rs rt 0000000000 msbl mszh lexop rs rt 0000000000 mszh mszl lexop rs rt 0000000000 mszl 655 1 0 6 inst20 inst53 0 1234567 0 madh madl mazh mazl 1 2 3 4 msbh msbl mszh mszl 5 6 7release 21 lexra proprietary confidential 99lx4380 section a4 lexop2 instructions table 47 lexop2 load instruction formats table 48 lexop2 subop bit encodings31 26 25 21 20 16 15 6 5 0 assembler mnemoniclexop2 011 110 rs rt immediatelexop2 subop ltw lexop2 rs rteven 0 displacement8 ltw 655 1 0 6 base rt selects general register r0 r31 rteven selects general register evenodd pair r0r1 r2r3 r30r31 displacement signed 2scomplement number in bytes inst20 inst53 0 1234567 0 1 2 3 4 5 6 7l tw100 lexra proprietary confidential release 21section lx4380 a5 cop0 instructions table 49 cop0 instruction formats these encodings are variants of the standard mtc0 and mfc0 instructions that allow access to the lexra coprocessor 0 registers listed below as with any cp0 instruction coprocessor unusable exception is taken in user mode if the cu0 bit is 0 in the cp0 status register when these instructions are executed table 50 cop0 subop bit encodings31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniccop0 010 000 rs rt rd 0cop0 subop mflxc0 cop0 mflx 00011rs rd 00000 lxc0 mtlxc0 cop0 mtlx 00111rs rd 00000 lxc0 deret cop0 00000 00000 00000 00000 deret 6555 1 1 rt selects general register r0 r31 rd selects lexra coprocessor 0 register 00000 estatus 00001 ecause 00010 intvec 00011 cvstag for lexra diagnostic purposes only 001xx reserved 01xxx reserved 1xxxx reserved inst20 inst53 0 1234567 0 lxc0 1 2 3 deret 4 5 6 7release 21 lexra proprietary confidential 101lx4380 section a6 special instructions table 51 special instruction formats table 52 special subop bit encodings31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemonicspecial 000 000 copz rs rt rd 0special subop movn special rs rt rd 00000 movn movz special rs rt rd 00000 movz user defined special rs rt rd 00000 ce1reg 65555 6 inst20 inst53 0 1234567 0 1 movz movn 2 3 4 5 6 7ce1reg ce1reg ce1reg ce1reg ce1reg ce1reg102 lexra proprietary confidential release 21section lx4380 a7 special2 instructions table 53 special2 instruction formats table 54 special2 subop bit encodings31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemonicspecial2 000 000 copz rs rt 0 0special2 subop mad special2 rs rt 00000 00000 mad madu special2 rs rt 00000 00000 madu msub special2 rs rt 00000 00000 msub msubu special2 rs rt 00000 00000 msubu sdbbp special2 00000 00000 00000 00000 sdbbp 6 55556 inst20 inst53 0 1234567 0 mad madu msub msubu 1 2 3 4 5 6 7 sdbbprelease 21 lexra proprietary confidential 103lx4380 section appendix b lconﬁg forms b1 conﬁguration options for the lx4380 processor this section provides summary of the configuration options available with lconfig refer to lconfigforms for detailed description of these form options table 55 conﬁguration options lconﬁg option description cbi_wbuf cbus interface write buffer depth ce0 custom engine 0 ce1 custom engine 1 clock_buffers clock buffers at toplevel module cop1 coprocessor interface 1 cop2 coprocessor interface 2 dcache data cache size dcache_policy data cache writebackwritethrough policy selection dmem local scratch pad data ram ejtag ejtag debug support ejtag_data_break number of data breaks to be compiled ejtag_dclk_n ejtag pctrace dclk n parameter ejtag_inst_break number of instruction breaks to be compiled ejtag_tpc_m ejtag pctrace tpc m parameter ejtag_xv_bits ejtag pctrace number of exception vector bits icache instruction cache size imem local instruction ram with line valid bits jtag internal jtag tap controller with ejtag support jtag_trst_is_tpc trst pin is tpc out instead of tdotpc mux lbc_rbuf lexra bus controller read buffer depth lbc_rdbypass lexra bus controller read bypass enable lbc_sync_mode lbc synchronousasynchronous selection line_size cache line size in words104 lexra proprietary confidential release 21section lx4380 lmi_range_source source of lmi address ranges mem_first_word cache line ﬁll ﬁrst word mem_line_order cache line ﬁll beat ordering mmu memory management unit implementation pc_trace ejtag pc trace pins product lexra processor name reset_buffers reset buffers at toplevel module reset_mode ﬂipﬂop reset method scan_insert controls scan insertion and synthesis scan_mix_clocks scan chains can cross clock boundaries scan_num_chains number of scan chains scan_scl scan collar insertion on ram interfaces sen_buffers scan enable buffering sen_dist scan enable distribution method sim_ram_tech simulate with technology speciﬁc ram wrappers sim_tech control use of technology speciﬁc ﬁles in simulation synth_tech control use of technology speciﬁc libraries in synthesis system_interface system bus interface type technology identiﬁes target technology tlb_entries number of entries in translation lookaside buffer unique_name apply unique name to the rtl writethrough_range writethrough range for writeback data cachelconﬁg option descriptionrelease 21 lexra proprietary confidential 105lx4380 section appendix c port descriptions table56 shows the possible port connections for the top level module of the lx4380 processor known as lx2 the actual lx2 ports that are present depends upon lconfig settings port names that include trailing _n or intermediate _n_ indicate active low signals all other signals are active high unless otherwise indicated all input ports must be connected to valid logiclevel sources the information in the tables timing column indicates the point within cycle when the signal is stable in terms of percent the timing column also includes parenthetical references to these notes 1 clocked in the jtag_clock domain 2 clocked in the busclk domain if is asynchronous otherwise clocked in the sysclk domain 3 does not require constraint eg clock 4 aconstantthatistreatedasafalsepathfortiminganalysistheseinputsmustnotchangeafter the processor is taken out of reset 5 timing is speciﬁed with symbol in techvarsscr script eg ram timing 6 atestrelatedinputoroutputthatistreatedasfalsepathfortiminganalysissuchinputsmust not change during normal atspeed operation 7 an asynchronous input if clock domain is specified the signal is clocked in the sysclk domain forsinglebitsignalsthesignalnameandsignaldescriptionindicatetheactionorfunctionwhenthesignalis in the active state table 56 lx4380 processor port summary port name io timing description clocking reset interrupts and control sysclk input 3 processor clock resetn input 10 warm reset or reset button active low cresetn input 10 cold reset or power on active low reset_d1_r_n input 30 sysclkdomainresetcombinationofresetn cresetn ejtag106 lexra proprietary confidential release 21section lx4380 reset_d1_br_n input 30 busclkdomainresetcombinationofresetn cresetn ejtag reset_pwron_c1_n input 30 power on reset copy for jtag reset_pwron_d1_lr_n input 30 sysclk domain power on reset for ejtag reset_d1_r_n_o output 30 sysclkdomainresetcombinationofresetn cresetn ejtag reset_d1_br_n_o output 30 2 busclkdomainresetcombinationofresetn cresetn ejtag reset_pwron_c1_n_o output 30 power on reset copy for jtag reset_pwron_d1_lr_n_o output 30 sysclk domain power on reset for ejtag intreq_n152 input 7 interrupt requests level sensitive active low ext_halt_p input 50 external stall line tie to 0 if not used 1 stall pipeline next cycle 0 advance pipeline if internal stalls conﬁguration cfg_tlb_disable input 4 disable tlb mappings even if the tlb is present cfg_hlenable input 4 strap to one to enable internal hilo registers cfg_macenable input 4 strap to one to enable internal mac if present cfg_memsequential input 4 strap to one if line reads return words in sequential order zero if interleave order cfg_memzerofirst input 4 straptooneiflinereadsreturnwordzeroﬁrst zero if desired word ﬁrst cfg_lbcwbdisable input 4 strap to one to disable read bypass of lbc write buffer zero to allow read bypass cfg_ejtnminus110 input 4 strap with ejtag dclk n minus 1 conﬁgura tion 0314 cfg_ejtmlog210 input 4 strap with ejtag m log2 031248 conﬁg uration cfg_ejt3bitxvtpc input 4 strap with etjag 3bit tpc conﬁguration cfg_ejtbit0m16 input 4 strap with ejtag pc bit0 in tpc conﬁgura tion cfg_dwbase3110 input 30 strapped with dmem base address conﬁgura tion value cfg_dwtop2310 input 30 strapped with dmem top address conﬁgura tion value cfg_iwbase3110 input 30 strapped with imem base address conﬁgura tion value cfg_iwtop2310 input 30 strappedwithimemtopaddressconﬁguration valueport name io timing descriptionrelease 21 lexra proprietary confidential 107lx4380 section cfg_dwdisw input 4 strap to one to disable processor dmem writes must be zero for lx4380 test and debug jtag_reset_o output 20 1 jtag is in testlogicreset state active low jtag_reset input 6 jtag is in testlogicreset state active low tap_reset_n_o output 20 1 tap controller reset tap_reset_n input 6 tap controller reset jtag_tdo_nr output 50 1 test data out active low jtag_tdi input 60 1 test data in jtag_tms input 60 1 test mode select jtag_clock input 3 test clock jtag_trst_n input 6 test reset jtag_capture output 20 1 jtag is in data register capture state jtag_scanin output 50 1 scan input to chain jtag_scanout input 50 1 scan output from chain jtag_ir40 output 20 1 contents of instruction register jtag_shift_ir output 20 1 jtag is in shift instruction register state jtag_shift_dr output 20 1 jtag is in shift data register state jtag_runtest output 20 1 jtag is in runtest state jtag_update output 20 1 jtag is in data register update state ejc_ecrprobeen_r output 30 one indicates ejtag probe is active jpt_pcst_drm10 output 30 ejtag pc trace status m 1 2 4 or 8 jpt_tpc_drn310 output 30 ejtag pc trace value n 1 2 3 or 4 jpt_dclk output 3 ejtag pc trace clock sen input 6 scan enable active high tmode input 6 test mode active high sink0 input 6 scan input k can range from 7 to 0 soutk0 output 6 scan output k can range from 7 to 0 lbc interface to lbus laddro310 output 20 2 address lcmdo80 output 20 2 output command ldatao630 output 20 2 output dataport name io timing description108 lexra proprietary confidential release 21section lx4380 ldatai630 input 50 2 input data lirdyo output 20 2 lbc initiator ready lirdyi input 30 2 system initiator ready lframeo output 20 2 lbc transaction frame lframei input 30 2 system transaction frame lsel input 30 2 system slave select ltrdyi input 30 2 system target ready lid output 20 2 instructiondata luc output 20 2 1 uncacheable transfer 0 cachable transfer lcoe90 output 20 2 command output enable identical copies are provided to relieve the fanout ltoe output 20 2 transaction output enable ldoe70 output 20 2 data output enable identical copies are pro vided to relieve the fanout lreq output 50 2 bus request lgnt input 30 2 bus grant coprocessor interface z12 czcondin input 80 cop branch ﬂag czrd_addr40 output 50 cop read address czrhold output 45 cop hold condition one stalls coprocessor czrd_gen output 50 cop general register read command czrd_con output 50 cop control register read command czrd_data310 input 80 cop read data czwr_addr40 output 20 cop write address czwr_gen output 20 cop general register write command czwr_con output 20 cop control write address command czwr_data310 output 30 cop write data czinvld_m output 60 cop invalid instruction ﬂag one indicates invalid instruction in m stage czxcpn_m output 60 cop exception ﬂag one indicates exception in m stageport name io timing descriptionrelease 21 lexra proprietary confidential 109lx4380 section custom engine interface cei_ce1hold output 45 cpu is halting custom engine cei_ce1invld_m output 40 instruction is not valid m stage cei_ce1invldp_s_r output 30 instruction is not valid s stage cei_xcpn_m_c1 output 40 cpu reports exception cei_ce1op_s_r110 output 30 custom engine op code cei_instm32_s_r_c1_n output 30 one indicates 32bit instruction mode zero indicates 16bit instruction mode cei_ce1aop_e_r310 output 35 operand cei_ce1bop_e_r310 output 35 b operand ce1_res_e310 input 45 result from custom engine ce1_sel_e_r input 30 one indicates custom engine opcode is present in stage ce1_halt_e_r20 input 20 custom engine stalls processor by driving to ones allows processor to run by driving to zeros copies must be supplied from multiple registers to meet timing requirements cbus interface cbus_yreqo output 20 0 request present1 request present cbus_yaddro310 output 20 address cbus_yreado output 20 1read 0write cbus_yszo30 output 20 transfer size 4b1000 byte 4b1001 2 bytes 4b1011 word 4b1101 2 words 4b0000 4 words cbus_ylineo output 20 1line access 0single access cbus_ydatao630 output 20 write data cbus_yuco output 20 1uncached 0cached access cbus_ysrco30 output 20 transaction source within lx4380 4b0001 instruction cache 4b0010 data cache or ejtag dma write 4b0100 ejtag dma read 4b1000 not used cbus_ydbusyo output 20 1 lx4380 is not ready to receive data for data read any return read data with val type of data read will be ignored by the lx4380externallogicmustholdsuchdata cbus_ydbusyo is deasserted 0 lx4380 is ready to receive dataport name io timing description110 lexra proprietary confidential release 21section lx4380 cbus_ybusyi input 80 1externallogiccannotacceptrequestexter nal logic ignores any current request 0 external logic is ready to accept request cbus_ydatai630 input 80 read data cbus_yvaltypei30 input 80 indicates valid read data of certain type 4b0000 valid read data 4b0001 instruction cache 4b0010 data cache 4b0100 ejtag dma 4b1000 not used cbus_yidlei input 80 indicates external cbus_y device has pending read or write transactionsport name io timing descriptionrelease 21 lexra proprietary confidential 111lx4380 section appendix d pipeline stalls this appendix documents the stall conditions that may arise in the lx4380 d1 stall deﬁnitions issue stall an invalid instruction enters each pipe while any other valid instructions in the pipe advance pipeline stall all instructions in the pipe stay in the same stage and do not advance stall if not otherwise qualified means pipeline stall d2 instruction groupings table 57 instruction groupings for stall deﬁnition d3 nonsequential program flow issue stalls jrjalr two issue stalls after the delay slot instruction j jalx and taken branchesgroup name instructions in group miloadstore lb lh lw lbu lhu lwc1 lwc2 lwc3 sb sh sw swc1 swc2 swc3 mimac multu divu mfhi mflo mthi mtlo madh madl mazh mazl msbh msbl mszh mszl micontrol j jalx jr jalr bltzal bgezal linked branches syscall break all copz mfcz cfcz mtcz ctcz bcfz bctz rfe lwcz swcz also in loadstore group mtlxc0 mflxc0 lexraspeciﬁc miunlinkedbranch beq bne blez bgtz bltz bgez migeneral all remaining instructions mivcmove movz movn nvxloadstore ltw ejtagcontrol deret sdbbp112 lexra proprietary confidential release 21section lx4380 stall cycles after the delay slot instruction nottaken branches two issue stalls after the delay slot instruction the branch rules are consequence of the fact that all branches are predicted to be taken d4 loadstore rules loaduse astage single cycle pipeline stall afteraloadinstructiontoatargetregisteraninstructionwhichfollowstheloadinthepipelineby two cycles and uses that target register of the load will pipeline stall for one cycle for twinword loads ltw this rule applies to both of the target registers in the registerpair operand storeload data ram access stall load instruction which follows store instruction by two cycles always causes onecycle stall note this stall only applies if the store instruction hits in the data cache storestore tag ram access stall second store instruction which follows first store instruction by two cycles causes one cycle stall if the first store is to previously clean line of writeback cache note this stall only applies if the first store instruction hits in the data cache storeload data readafterwrite stall aloadinstructionwhichfollowsastoreinstructionbyonecyclecausesatwocyclestallifthe load accesses data at the same word address as the store for twinword load instructions either of the load word addresses may match the store word address storestore tagdirtybit readafterwrite stall hardware detects the case of backtoback stores to the same line and eliminates any replay of the second store to access the tagdirtybit storeload tag invalidate tag ram access stall store or load instruction that follows by two cycles an uncached store or load instruction that causes tag invalidate causes onecycle stall storeload tag invalidate readafterwrite stall astoreorloadinstructionthatfollowsbyonecycleanuncachedstoreorloadinstructionthat causesataginvalidatecausesatwocyclestallifthesecondinstructionaccessesdatainthesamerelease 21 lexra proprietary confidential 113lx4380 section cache line as the first instruction d5 mac ops interlock matrix themaceliminatesallprogramminghazardsbetweenmacinstructionsbystallingthepipelineasnecessary thisisdonebothtoavoidresourceconflictsaswellastowaitforresultsofafirstinstructionthatisneededby second instruction the following table indicates the number of cycles that must be inserted between the first indicated instructionandthesecondazeroordashindicatesthattheinstructionscanissuebacktobacktothemac pipe with stalls nonzero number indicates the number of stall cycles that will occur if the instructions are issued in consecutive cycles these stall cycles are available for any other nonmac instructions but should not be filled with nops since that would only increase the code footprint without improving performance table 58 cycles required between mac instructions d6 mvcz stall the coprocessor move instructions mtcz ctcz lwcz mfcz cfcz are always followed by two cycle issue stalls thevariantsofcoprocessormoveinstructionsmtlxc0mflxc0arealwaysfollowedbytwocycleissue stalls the instructions tlbp and tlbr which update coprocessor 0 registers are always followed by two cycle issue stalls d7 tlbw stall the tlb write instructions tlbwi tlbwr are always followed by one cycle issue stallmult multu mad madu msub msubumthi mtlo madh madl mazh mazl msbh msbl mszh mszl mfhi mflo div divu mult multu mad madu msub msubu madh madl mazh mazl msbh msbl mszh mszl1 cycle 19 cycles div divu 1 cycle 19 cycles mfhi mflo 3 cycles 2 cycles 19 cycles2nd op1st op114 lexra proprietary confidential release 21section lx4380 d8 mmu stalls itlb stall when the program jumps branches or increments from the most recently used page to another page in the itlb single cycle stall is incurred when the program jumps branches or increments to page not in the itlb fourcycle stall is incurred if the target vpn is mapped onecycle if the target vpn is unmapped if the target vpn is not in the joint tlb an exception is recognized when the instruction reaches the mstage tlbwitlbwr instruction invalidates any itlb entry corresponding to the overwritten joint tlb entry itlb issue stall when an itlb stall occurs due to incrementing across page boundary and there is any of the following instructions found anywhere in the last doubleword of the page then there is one issue stall in addition to the itlb stalls branch of any kind j jalx ejtag deret dtlb stall whenaloadorstoreusesabaseregisterthatisinthedtlbandhitsavpnthatisinthedtlb there is stall incurred when aload or storeusesabaseregisterthat isin thedtlb but does nothit avpn that isin the dtlb twocycle stall is incurred if the vpn is mapped onecycle if the vpn is unmapped when load or store uses base register that is not in the dtlb threecycle stall is incurred if the vpn is mapped twocycles if the vpn is unmapped notes on dtlb entry maintenance 1 tlbwitlbwr instruction invalidates any dtlb entry corresponding to the overwritten joint tlb entry 2 any instruction that updates base register invalidates on the transition dtlb entries using that register 3 dtlb entry that is invalidated per item 2 is resurrected on the ea transition with the new base register value if the invalidating instruction is one of the following 4 whenanewdtlbentryiscreatedforavpnthereplacementpolicyisfifobubblesintheaddi addiu slti sltiu andi ori xori lui op3129 001 sll srl sra sllv srlv srav specialop53 000 add addu sub subu and or xor nor specialop53 100release 21 lexra proprietary confidential 115lx4380 section fifo that occurred because of item 2 are collapsed d9 cache miss stalls instruction cache miss stall whenaninstructioncachemissoccurstheprocessorisstalledforthedurationofthecachelinefill operation the number of cycles required to complete the line fill is system dependent instruction cache 2way soft miss stall when 2way icache is in use softmiss is defined as hit in the unpredicted way with way prediction defined as follows when not running in lock mode use the lru bit when running in lockeddown mode if the most recent lockeddown icache access hit locked line then predict way 1 the locked way else use the lru bit whenrunninginlockgathermodepredictway1thelockedwaythispreventsahitwithout softmiss on way 0 thus allowing for the invalidation of way 0 and fill to way 1 in that case also miss is forced in lockgather mode whenever the lock state is clear to allow the lock state to be set for way 1 hit that was not previously locked miss is never allowed to be soft in lockgather mode which forces the fill to way 1 in the case of way 0 hit as noted above soft miss always causes twocycle stall data cache miss stall whenadatacachemissoccursastheresultofaloadinstructiontheprocessorstallswhileitwaits for the data the data cache releases the stall condition after the required word is supplied to the processorevenifadditionalwordsmuststillbefilledintothedatacachehoweveriftheprocessor issues another load or store operation to the data cache while the remainder of the line fill is in progress the cache will again stall the processor until the line fill operation is completed the number of cycles required to complete the line fill is system dependent evict buffer notempty stall whenadataaccessloadorstoreneedstousethesystembusandtheevictbufferisnotemptydue to previous evict operation the processor stalls while it waits for the evict buffer to empty d10 pipeline diagrams for nonsequential program flow issue stalls jr jalr jr i d s m w delayslot i d s m w notvld i notvld i target i d s a116 lexra proprietary confidential release 21section lx4380 j jalx and taken branches j i d s m w delayslot i d s m w target i d s m nottaken branches bntkn i d s m w delayslot i d s m w notvld i notvld i delay4 i d s loaduse astage single cycle pipeline stall 00 lw s00a0 i d s m 04 addi a04 i d s m w 08 add s1s0 i d s m w 0c add t1t2 i d s s m w rhold x dload_m x storeload data ram access stall 00 sw s000a0 i d s m w 04 foo i d s m m w 08 lw s232a0 i d s m w rhold x storestore tag ram access stall 00 sw s000a0 i d s m w 04 foo i d s m m w 08 sw s232a0 i d s m w rhold x storeload data readafterwrite stall 00 sw s000a0 i d s m w 04 lw s200a0 i d s m w rhold x xrelease 21 lexra proprietary confidential 117lx4380 section d11 pipeline diagram for mac ops interlock stall 00 mult s0s1 i d s m 04 lw s00a0 i d s m m m w 08 lw s10a0 i d s m m m w 0c mflo v0 i d s m w 10 sw v00a1 i d s s s m w multcount4s 0 1 2 3 4 rhold x x d12 pipeline diagram for mvcz stall 00 mtc0 i d s m w 04 foo i d d d s m w 08 foo1 i d s m w d13 pipeline diagram for tlbw stall thehandlerforatlbexceptioncanreturntotheoffendinginstructionafterwritinganewjtlbentrywith the following canonical code fragment 00 tlbwr i d s m w 04 jr i d d s m w 08 rfe i d s m w 0c foo i d 10 foo i tgt i i i i i d itlbrequest x jtlbresponse x select new pfn to ram x thetargetofthejrcanuseforitsifetchthenewlycreatedjtlbentrythatiswritteninthewstagethisis duetothesingleissuestallafterthetlbwandthefactthatthejrtargetaddressisresolvedintheestageof the jr it is also true that any data access in the target or subsequent instructions can use the newly created jtlb entry d14 pipeline diagrams for dtlb stalls base assumption all cases dtlb entry exists for lw r1 0r2 where r2 is page aligned case 1 stall 00 lw r14r2 i d s m w dtlb_hit_s x118 lexra proprietary confidential release 21section lx4380 case 2 reghit vpnmiss vpn mapped create new entry 00 lw r14r2 i d s m w 04 lw r38r2 i d s s s m w dtlb_reghit_s x x dtlb_vpnhit_s x case 3 regmiss vpn mapped create new entry 00 lw r14r2 i d s m w 04 lw r38r2 i d s s s s m w dtlb_reghit_s x dtlb_vpnhit_s x case 4 reginvalidate vpn mapped 00 lw r20r2 i d s m w 04 foo i d s m w 04 lw r30r2 i d s m w dtlb_reghit_s dtlb_vpnhit_s case 5 reginvalidate and resurrect stall 00 addiu r2r24 i d s m w 04 foo i d s m w 04 lw r30r2 i d s m w dtlb_reghit_s x dtlb_vpnhit_s x case 6 vector add cab stalls after initialization dtlb entries valid for cbase r1 abase r2 bbase r3 all initially page aligned 00 sw r70r1 i d s m w 04 addiu r1r14 i d s m w 08 lw r50r2 i d s m w 0c addiu r2r24 i d s m w 10 lw r60r3 i d s m w 14 addiu r3r34 i d s m w 18 bne r3r900 i d s m w 1c add r7r5r6 i d s m w dtlb_reghit_s x x x dtlb_vpnhit_s x x xrelease 21 lexra proprietary confidential 119lx4380 section d15 pipeline diagrams for cache misses instruction cache miss stall 08 foo0 i d s m w 0c foo1 i d s m w 10 foo2 i d i d s m w rhold x x x x x instruction cache 2way soft miss stall 08 foo0 i d s m w 0c foo1 i d s m w 10 foo2 i d i d s m w 14 foo3 i d s m w rhold x x data cache miss stall 04 lw i d s m w 08 foo1 i d s m m m m m w 0c foo2 i d s m w rhold x x x x120 lexra proprietary confidential release 21section lx4380release 21 lexra proprietary confidential 121lx4380 index note all instructions are listed under the instructions heading address translation mmu 37 41 smmu 21 alu instructions 12 arbitration lbus 88 b badvaddr register 24 branch instructions 16 byte alignment cbus 65 lbus 79 c cache see local memory cause register 23 cbus byte alignment 65 interleave order 64 protocol 67 signals 66 transaction descriptions 67 write buffer 64 ci see coprocessor interface conditional move instructions 15 control instructions 17 coprocessor 26 coprocessor instructions 18 coprocessor interface attaching coprocessors 45 operations 46 pipeline 47 signals 45 cp0 system control processor 8 d data cache see local memory debug interface see ejtag delay slot branch instructions 16 cause register branch delay ﬂag 23 coprocessor instructions 18 exceptions in branch delay slot 24 jump instructions 17 depc register 9 desave register 9 divide instructions 32bit 30 divide overview 29 divide pipelining 35 dreg register 9 ecause register 25 ejtag cp0 registers 9overview 91 pc trace 93 signals 92 entryhi registers 38 entrylo register 39 epc register 24 estatus register 25 exception processing delay slot 24 entry and exit 24 mmu 42 prioritized interrupt exception vectors 26 priority list 22 registers 23 i index register 39 instruction cache see local memory instructions add 12 addi 12 addiu 12 addu 12 alu 12 and 12 andi 12 bczf 19 bczt 19 beq 16 bgez 16 bgezal 16 bgtz 16 blez 16 bltz 16 bltzal 16 bne 16 branch 16 break 17 cache 54 97 cfcz 18 conditional move 15 control 17 coprocessor 18 ctcz 18 custom engine 97 101 deret 100 div 30 divide 32bit 30 divu 31 j1 7 jal 17 jalr 17 jr 17 jump 16 lb 14 lbu 14 lh 14 lhu 14 liu 13122 lexra proprietary confidential release 21lx4380 load 14 ltw 14 99 lw 14 lwcz 18 mad 32 102 madh 31 98 madl 31 98 madu 32 102 mazh 31 98 mazl 31 98 mfcz 18 mfho 30 mflo 30 mflxc0 100 movn 15 101 movz 15 101 msbh 32 98 msbl 32 98 msub 32 102 msubu 33 102 mszh 31 98 mszl 31 98 mtcz 18 mthi 30 mtlo 30 mtlxc0 19 100 mult 30 multiply 32bit 30 multiplyaccumulate 16bit 31 multiplyaccumulate 32bit 32 multu 30 nor 12 or 12 ori 12 rfe 17 sb 14 sdbbp 102 sh 14 sll 13 sllv 13 slt 13 slti 13 sltiu 13 sltu 13 sra 13 srav 13 srl 13 srlv 13 store 14 sub 12 subu 12 sw 14 swcz 18 syscall 17 xor 12 xori 12 interleave order cbus 64 lbus 75 interrupts nonprioritized 23 prioritized 25 prioritized interrupt exception vectors 26 intvec register 26j jump instructions 16 k kseg0 21 kseg1 21 kseg2 21 kuseg 21 l lbc lexra bus controller commands issued 80 read buffer 80 signals 87 lbus lexra system bus arbitration 88 bus operations 74 byte alignment 79 commands 78 connecting devices to 89 diagram 73 interleave order 75 signals 77 terminology 74 transaction descriptions 81 lconfig conﬁguration forms 103 load instructions 14 local memory cache invalidation control 53 data cache 57 data memory dmem 61 disabling 52 instruction cache 54 instruction cache locking 52 instruction memory imem 56 overview 51 m memory management see mmu and smmu mmu memory management unit dtlb data tlb 43 exception processing 42 itlb instruction tlb 43 mapped address translation 41 registers 38 tlb instructions 41 unmapped address translation 37 multiply instructions 32bit 30 multiply overview 29 multiply pipelining 33 multiplyaccumulate instructions 16bit 31 multiplyaccumulate instructions 32bit 32 multiplyaccumulate overview 29 p pc trace ejtag 93 pipeline coprocessor interface 47 divide 35 multiply 33 processor 8 prid register 9 prioritized interrupts 25 processor modules 7release 21 lexra proprietary confidential 123lx4380 ralu data path 8 system control processor cp0 8 r ralu data path 8 ram see local memory random register 40 read buffer lbc 80 registers badvaddr 24 cause 23 context 40 cp0 registers table 9 depc 9 desave 9 dreg 9 ecause 25 entryhi 38 entrylo 39 epc 24 estatus 25 index 39 invtec 26 prid 9 random 40 status 23 wired 40 s smmu simple memory management unit 21 status register 23 store instructions 14 system bus see cbus and lbus system control processor cp0 8 t tlb 37 tlb instructions 41 u upperkseg2 21 w wired register 40 write buffer cbus 64124 lexra proprietary confidential release 21lx4380