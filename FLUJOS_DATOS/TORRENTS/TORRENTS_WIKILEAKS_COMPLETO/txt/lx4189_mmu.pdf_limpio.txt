november 8 2000 229 pm lx4189 lexra proprietary confidential 64 9 memory management unit the memory management unit mmu is an optional feature of the lx4189 processor this chapter discusses the implementation of the mmu summary of the features is implements the r2000r3000 memory management system with some minor modifications implements fixed 4kbyte memory pages with 32bit virtual and physical addresses and 6bit asid the 4gb address space is broken up into 2gb user spacekuseg 05gb unmappable cacheable kernel space kseg0 05gb unmappable uncacheable kernel space kseg1 and just less than 1gb of mappable kernel space kseg2 the remainder of kseg2 16 mb is dedicated to specific debug devices the tlb is composed of configurable number of entries configuration options are 4 8 16 32 64 entries implementsentryhientryloindexrandomregistersbased on r2000r3000 implementation implements readonly wired register according to r4000 implementation signals the appropriate utlb exception tlbl or tlbs or the appropriate bev0bev1 exception tlbl tlbs mod implements the tlbp tlbr tlbwi tlbwr instructions 91 references please note that this document is an implementation note connected with the lexra processor series for more complete description of mips instruction set implementations of memory management hardware please see mips risc architecture by kane and heinrich for complementary discussion of the role of memory management in operating systems associated with the mips instruction set please see see mips run by sweetman 92 memory regions 93 registers 931 tlb entry tlb entry is 64bit quantity which stores virtual to physical memory mapping the fieldsregion name virtual address physical address cachability permission kuseg 0x0000_00000x7fff_ffff mapped via tlb set via tlb user kseg0 0x8000_00000x9fff_ffff 0x0000_00000x1fff_ffff cacheable kernel kseg1 0xa000_00000xbfff_ffff 0x0000_00000x1fff_ffff uncacheable kernel kseg2 0xc000_00000xfeff_ffff mapped via tlb set via tlb kernel upperkseg2 0xff00_00000xffff_ffff 0xff00_00000xffff_ffff uncacheable kernelnovember 8 2000 229 pm lx4189 lexra proprietary confidential 65 and bit locations of tlb entry are identical to those in the entryhi and entrylo fields the tlb entries are read written via tlb read tlbr tlb write indexed or random tlbwi or tlbwrinstructions thetlbentriescanbeexaminedforamatchtoaspecificvpnasidpair alsoexaminingtheglobalbitusingthetlbpinstruction thetlbentriesarealsomatchedtoa tlb request either from an instruction or data memory request 932 cp0 register 10 entryhi theentryhiregisterisreadwrittenviathemfc0mtc0instructionsmovefromcoprocessor0 move to coprocessor 0 it is accessed as coprocessor 0 register 10 entryhi is composed of two fields the virtual page number vpn and applicationspecific id asid the memory management units compares the vpn and asidfields of entryhi together withtheglobalbitoftheentryloregistertoeach entryinthetlbwhenthecpuexecutesatlb probe tlbp instruction and during any mapped instruction or data probe request the comparison mechanism is described in the tlbp instruction when the processor executes tlb read tlbr instruction the tlb entry specified by the index register is loaded into entryhi and entrylo the vpn and asid fields of entryhi are written into the tlb when the cpu executes the tlb writeindex tlbwi or tlb write random tlbwr instructions the format of the entryhi register is 933 cp0 register 2 entrylo theentryloregisterisreadwrittenviathemfc0mtc0instructionsmovefromcoprocessor0 move to coprocessor 0 it is accessed as coprocessor 0 register 2 entrylo is composed of the following fields pfn noncachable dirty valid and global the pfn n d v and g fields of entrylo are written into the tlb when the cpu executes the tlbwiortlbwrinstructions duringanymappedinstructionordataproberequestandduring the execution of tlbp instruction the mmu utilizes the g bit to determine if vpn asid combinationwasamatch amappedinstructionordataproberequestwithatlbmatchbased on vpn asid and g will examine the dirty and valid bits to signal an exception this process is described in the exception priority codes section of this chapter the noncacheable bit is used to determine if the reference should be made to the cache or directly to the memory when the processor executes tlb read tlbr instruction the tlb entry specified by the index register is loaded into entryhi and entrylo the format of the entryhi register is31 12 11 6 5 0 vpn asid 000000 31 12 11 10 9 8 7 0 pfn n d v g 00000000november 8 2000 229 pm lx4189 lexra proprietary confidential 66 934 cp0 register 0 index the index register is readwritten via the mfc0 mtc0 instructions move from coprocessor 0 move to coprocessor 0 it is accessed as coprocessor 0 register 0 theindexregistercontainsa6bitaddressintothetlbindexandaonebitprobefailurefield p when the processor executes tlb write index tlbwi or tlb read tlbr instruction the tlb entry which is updated read is pointed at by the index field of the index register when the processor executes tlb probe tlbp instruction if tlb match is found the p bit issetto1probefailureandtheresultsoftheindexfieldareundefined ifasingletlbmatchis foundthepbitissetto1andtheindexfieldistheindexofthetlbentrywhichmatched the result of the index register following tlbp instruction with multiple matches is undefined the format of the index register is 935 cp0 register 2 random the random register is readonly register accessed via the mfc0 instruction move from coprocessor 0 it is accessed as coprocessor 0 register 1 therandomregistercontainsa6bitaddressintothetlbrandomwhichisdecrementedon every clock cycle during operation of the processor it decrements from the largest tlb entry availableontheprocessorie32entriestothevalueofthewiredregister thisensuresthatthe lowestwiredentries0towired1aresafetlbentrieswhichcannotberandomlyoverwritten when the processor executes tlb write random tlbwr instruction the tlb entry which is updated is pointed at by the random field of the random register the format of the random register is 936 cp0 register 6 wired the wired register is readonly register accessed via the mfc0 instruction move from coprocessor 0 it is accessed as coprocessor 0 register 6 thewiredregistercontainsa6bitaddressofthefirstnonsafevaluewhichmaybeoverwritten by the tlb write random tlbwr instruction the random register decrements from the largest tlb entry available on the processor ie 32 entries to the value of the wired register thisensuresthatthelowestwiredentries0towired1aresafetlbentrieswhichcannotbe randomly overwritten in the lexra implementation the wired entry is set by the number of tlb entries which have been selected the values are31 30 14 13 8 7 0 p 00000000000000000 index 00000000 31 14 13 8 7 0 000000000000000000 random 00000000november 8 2000 229 pm lx4189 lexra proprietary confidential 67 the format of the wired register is 94 instructions 941 summary of instructions 942 tlb probe tlbp instruction the tlbprobe tlbp instruction examines each tlb entry todetermineif it matchesthe values contained in entryhi and entrylo the determination of match for entry i uses the equation matchi entryhivpn tlbhiivpn tlbloiglobal entryhiasid tlbhiiasid where tlbhi and tlblo are the appropriate fields of the tlb entry if tlb match is found the index register p bit is set to 1 and the index field is undefined if single tlb match is found the index register p bit is set to 0 and the index field takes the value of the matching register if multiple tlb matches are found the index register p bit and index value are both undefined 943 tlb read tlbr instruction the tlb read instruction updates the entryhi and entrylo registers with the contents of the tlb entry specified by the index register if the value of index register is greater than the number of tlb entries implemented the tlbtlb_entries number safe entries wired binary 64 8 6b001000 32 4 6b000100 16 4 6b000100 8 2 6b000010 4 2 6b000010 31 6 5 0 00000000000000000000000000 wired mnemonic operation description tlbp index pointer to tlb entry which matches entryhivpnasid entryloglobaldetermine if there is an entry in the tlb which matches entryhi entrylo set the probe failure bit and index result tlbr entryhi entrylo tlbindexload entryhi and entrylo with the tlb entry pointed at by the index register tlbwi tlbindex entryhi entryloupdate the tlb entry pointed at by the index register with the values in entryhi entrylo tlbwr tlbrandom entryhi entryloupdate the tlb entry pointed at by the random register with the values in entryhi entrylonovember 8 2000 229 pm lx4189 lexra proprietary confidential 68 read instruction returns 32bit zero result to both the entryhi and entrylo registers 944 tlb write index tlbwi instruction the tlb write index instruction updates the entry of the tlb specified by the index field of the index register with the values specified in entryhi and entrylo if the value of index is greater than the number of registers implemented entry is updated tlb write index operation invalidates any previously stored copies of the vpn to pfn mapping stored in the instruction fetch sequencer 945 tlb write random tlbwr instruction thetlbwriterandominstructionupdatestheentryofthetlbspecifiedbytherandomfieldof the random register with the values specified in entryhi and entrylo tlb write random operation does not invalidate any previously stored copies of the vpn to pfn mapping stored in the instruction fetch sequencer therefore it should not be used to overwrite currently valid mapping it should be used only to store new mapping when the existing mappings remain valid 95 translation requests translation requests can be signalled in three ways through an instruction fetch through data load operation and through data store operation the translation handling mechanism is the same regardless of the nature of the exception and is described here any memory reference to kseg0 kseg1 or upper kseg2 see the memory region section of this document it is an unmapped access an unmapped access does not generate request to the tlbinsteadthedirectmaptothepfnisusednotethisspecifiesboththephysicallocationand cacheability of the request all of the areas are assumed dirty writeable if the reference is to kuseg or lowerkseg2 address tlb translation request is generated tlb match is defined as single entry i matching according to the equation shown below matchi vpnaddress tlbhiivpn tlbloiglobal entryhiasid tlbhiiasid the list below shows the sequence of decisions and the results note that the vpn comes from the address being tested while the the asid is stored in entryhi if the processor is in user mode and the reference is to kseg2 an address exception is signaled if there is tlb match and the reference is to kuseg generate utlb tlbl or tlbs aka miss exception ifthereisnotlbmatchandthereferenceistolowerkseg2generate bev tlbl or tlbs aka miss exception if there is tlb match and the matching entry is not valid generate bev tlbl or tlbs aka miss exception if the request is for data store operation and the dirty bit is not setnovember 8 2000 229 pm lx4189 lexra proprietary confidential 69 generate bev mod exception generate cacheable request if the n field is 0 and noncacheable request if the n field is 1 96 pipelining stalls 97 exception codes seethetranslationrequestsectionforadescriptionofthetranslationrequeststlbresultswhich cause the exceptions listed in this table the user tlb utlb exceptions go to unique exception vector which can utilize very low level of functionality for user applications only while the more complete bev boot exception vector versions include handling for privledged tasksinvalidentriesandaccessviolationsmodifyexceptions foramorecompletediscussionof the role of these exceptions please see see mips run by dominic sweetman exception type bev0 exception address bev1 exception address cause exccode utlb tlbl 0x8000_0000 0xbfc0_0100 2 utlb tlbs 0x8000_0000 0xbfc0_0100 3 bev tlbl 0x8000_0080 0xbfc0_0180 2 bev tlbs 0x8000_0080 0xbfc0_0180 3 bev mod 0x8000_0080 0xbfc0_0180 1