lx5280 data sheet lexra inc release 19 april 30 2001 lexra proprietary and conÔ¨Ådentialapril 30 2001 lx5280 lexra proprietary confidential release 19 lx5280 data sheet revision 11 for rtl release 19 this document is proprietary and confidential to lexra inc copyright 2001 lexra inc all rights reserved mips mips16 mips abi mipsii mipsiv mipsv mips32 r3000 r4000 and other mips common law marks are trademarks andor registered trademarks of mips technologies inc lexra inc is not associated with mips technologies inc in any way smoothcore radiax and netvortex are trademarks of lexra incapril 30 2001 lx5280 lexra proprietary confidential i release 19 table of contents 1 lx5280 product overview 1 11 introduction 1 12 lx5280 processor overview 3 13 system level building blocks 4 131 smmu 4 132 local memory interface 4 133 coprocessor interface 5 134 custom engine interface 5 135 lexra bus controller 5 136 building block integration 5 14 rtl core smoothcore 5 15 eda tool support 6 2 lx5280 architecture 7 21 motivation 7 22 hardware architecture 7 221 module partitioning 7 222 six stage pipeline 8 23 dual issue 9 231 instruction fetch 9 232 instruction analysis and select logic 9 233 mips16 9 24 ralu data path 10 241 overview 10 242 assignment of instructions to pipe pipe b 11 25 system control coprocessor cp0 12 26 dual multiliplyaccumulate mac 13 261 dual mac operations 13 262 mac mode mmd register 14 263 architecture 15 27 data addressing 18 271 twinword data movement 18 272 vector addressing 18 273 circular buffers 20 28 radiax alu operations 21 281 extensions to mips alu operations 21 282 new alu instructions 21 283 conditional move operations 21 29 zero overhead loop facility 22 210 lowoverhead prioritized interrupts 24 3 lx5280 risc programming model 27 31 summary of mipsi instructions 27 311 alu instructions 28 312 load and store instructions 29 313 conditional move instructions 29 314 branch and jump instructions 30 315 control instructions 31 316 coprocessor instructions 31april 30 2001 lx5280 lexra proprietary confidential ii release 19 32 opcode extension using the custom engine interface cei 32 321 cei operations 32 322 interface signals 32 33 memory management 33 34 exception processing 33 341 exception processing registers 35 342 exception processing entry and exit 36 35 the coprocessor interface ci 36 36 power savings mode 36 4 mips16 39 41 mips16 instructions 39 42 mode switching 42 43 exceptions 42 44 delay slots 42 5 lx5280 dsp programming model 43 51 radiax instructions 43 511 radiax dualmac instructions 43 512 cyclebycycle usage for dual mac instructions 46 513 vector addressing instructions 48 514 radiax alu operations 50 515 conditional operations 52 52 instruction encoding 53 521 lexra formats 53 53 loadstore formats 54 531 arithmetic format 56 532 mac format 57 533 mac format b 58 534 mac format c 59 535 radiax move format and lexracop0 mtlxc0mflxc0 59 536 cmove format 61 537 lexra subop bit encodings 61 6 integer multiplydivideaccumulate 63 61 summary of instructions 63 62 macdiv instruction overview 64 63 opcodes for standard mode 32bit mac instructions 65 64 opcodes for mips16 16bit mode mac instructions 66 65 nonstandard instruction descriptions 67 66 accessing hi and after multiply instructions 69 67 divider overview and register usage 70 7 lx5280 local memory 71 71 local memory overview 71 72 cache control register cctl 72 73 instruction cache icache lmi 73 74 instruction memory imem lmi 75 75 instruction rom irom lmi 76 76 direct mapped write through data cache dcache lmi 77 77 scratch pad data memory dmem lmi 78 8 lx5280 system bus 81 81 connecting the lx5280 to internal devices 81april 30 2001 lx5280 lexra proprietary confidential iii release 19 82 terminology 81 83 bus operations 82 831 singlecycle read 82 832 read line 82 833 burst read 83 834 singlecycle write 83 835 line write 83 836 burst write 83 84 signal descriptions 84 85 lbus commands 84 86 byte alignment 85 87 lexra bus controller 85 871 lbc commands 85 872 lbc write buffer and outoforder processing 86 873 lbc read buffer 86 874 transfer descriptions 87 875 single cycle read with waits 88 876 single cycle read with target wait 89 877 line read with waits 89 878 line read with target waits 90 879 line read with initiator waits 90 8710 burst read 91 8711 singlecycle write with waits 91 8712 singlecycle write with waits 92 8713 burst write with waits 92 8714 burst write with target waits 93 8715 burst write with initiator waits 93 88 lbc signals 94 89 arbitration 95 891 rules 95 892 lbc behavior 95 810 connecting devices to the bus 95 9 lx5280 coprocessor interface 97 91 attaching coprocessor using the coprocessor interface ci 97 92 coprocessor interface ci signals 97 93 coprocessor write operations 98 94 coprocessor read operations 98 95 coprocessor interface and pipeline stages 99 951 pipeline holds 99 952 pipeline invalidation 99 10 lx5280 ejtag 101 101 introduction 101 102 overview 101 1021 ieee jtagspecific pinout 102 103 single processor pc trace 102 1031 pc trace dclk debug clock 103 1032 pc trace pcst program counter status trace 103 1033 pc trace tpc target program counter 103 1034 dual pipe pc trace 103 1035 singleprocessor pc trace pinout 104april 30 2001 lx5280 lexra proprietary confidential iv release 19 1036 vectored interrupts and pc trace 104 1037 demultiplexing of tdo and tdi during pc trace 105 appendix alx5280 lconfig forms 107 a1 configuration options for the lx5280 processor 107 appendix blx5280 port descriptions 109 appendix c lx5280 pipeline stalls 117 c1 stall definitions 117 c2 instruction groupings 117 c3 dual pipe issue rules 118 c4 m16 32bit instructions 119 c5 nonsequential program flow issue stalls 119 c6 loadstore rules 119 c7 loadstore ops stall matrix 121 c8 mac ops interlock matrix 122 c9 mvcz stall 124 c10 zovloop rules 124 c11 immu stalls 125 c12 cache miss stalls 125 c13 nonsequential program flow issue stall pipeline diagrams 126 c14 loadstore stall pipeline diagrams 127 c15 mac ops interlock pipeline diagram 129 c16 mvcz stall pipeline diagrams 129 c17 zovloop pipeline diagrams 129 c18 cache miss pipeline diagrams 130april 30 2001 lx5280 lexra proprietary confidential v release 19 list of tables table 1 eda tool support6 table 2 assignment of instructions of pipe pipe b11 table 3 cp0 registers13 table 4 mmd fields radiax user register 2415 table 5 prioritized interrupt exception vectors25 table 6 alu instructions28 table 7 load and store instructions29 table 8 conditional move instructions29 table 9 branch and jump instructions30 table 10 control instructions31 table 11 coprocessor instructions31 table 12 custom engine interface operations32 table 13 custom engine interface signals32 table 14 smmu address mapping33 table 15 list of exceptions34 table 16 mips i instructions not supported by mips1640 table 17 mips16 instructions that support mips i40 table 18 new mips16 instructions41 table 19 pcrelative addressing41 table 20 radiax dualmac instructions43 table 21 vector addressing instructions48 table 22 radiax alu operations50 table 23 conditional operations52 table 24 summary of macdiv instructions63 table 25 16bit multiply and multiplyaccumulate instructions67 table 26 32bit multiplyaccumulate instructions68 table 27 local memory interface modules71 table 28 icache configurations73 table 29 icache ram interfaces74 table 30 imem configurations75 table 31 imem ram interfaces75 table 32 irom configurations76 table 33 irom rom interfaces77 table 34 dcache configurations78 table 35 dcache ram interfaces78 table 36 dmem configurations79 table 37 dmem ram interfaces79 table 38 line read interleave order83 table 39 lbus signal description84 table 40 lbus byte lane assignment85 table 41 lbus commands issued by the lbc86 table 42 lbc interface signals94 table 43 coprocessor interface signals97 table 44 ejtag pinout102 table 45 ejtag ac characteristics102 table 46 ejtag synthesis constraints102 table 47 singleprocessor pc trace pinout104 table 48 singleprocessor pc trace ac characteristics104 table 49 lx5280 processor port summary109 table 50 instruction groupings for stall definition117 table 51 loadstore ops stall matrix122 table 52 cycles required between dual mac instructions123april 30 2001 lx5280 lexra proprietary confidential vi release 19 april 30 2001 lx5280 lexra proprietary confidential vii release 19 list of figures figure 1 lx5280 processor overview3 figure 2 superscalar processor core module partitioning8 figure 3 superscalar instruction issue10 figure 4 dual mac data path16 figure 5 postmodified pointers with circular buffer support20 figure 6 lexra system bus diagram81april 30 2001 lx5280 lexra proprietary confidential viii release 19 april 30 2001 lx5280 lexra proprietary confidential 1 release 19 1 lx5280 product overview 11 introduction this data sheet describes the lx5280 highperformance riscdsp developed for intellectual property ip licensing however the lx5280 is not just highly specialized dsp architecture but also carefully engineered extension to the mips isa as result system functions and computationally intensive dsp algorithms can be integrated on single lowcost subsystem key applications include data communication products such as network protocol processors cable and xdsl modems voice over packetized network gateways and settop boxes as well as disk controllers asdspintensiveapplicationshavegainedcommercialimportancetherehasbeenanincreasingrecognition of the benefit of implementing dsp functions on the cpu cpu is usually required for memory managementuserinterfaceandcontrolsoftwarecpusalsohaveexcellentthirdpartysoftwaretoolsupport however software implementations of dsp algorithms such as the fir filter or discrete cosine transform dcttypicallysufferbyanorderofmagnitudeinperformancecomparedtospecializeddspstheproblem iscompoundedbythedifficultyofdeterministicallyallocatingrealtimeinsophisticatedcpusvendorshave addressed these problems by offering dsp coprocessors which have separate instruction sets separate instruction stores and execution units and dsp accelerators which share the same istream with the cpu buthaveseparatedspexecutionunitseachoftheseapproachesimposesasubstantialburdenonthecpuin managing the dsp functions the lx5280 on the other hand tightly integrates its dsp extensions into the mips isa as result wide variety of thirdparty tools are available and the lx5280 programmer can switch seamlessly from risc code to dsp code thelx5280addstothemipsiinstructionsetacollectionofdsporientedinstructionscalledtheradiaxtm instruction set the radiax instruction set adds dual 16bit multiply and multiplyaccumulate operations including dsp modes such as saturation rounding and fractional arithmetic it includes dsp addressing modessuchaspostmodifiedaddresspointerscircularbuffersandzerooverheadloopsitalsoincludesdual 16bit simd alu operations and data alignment operations for applications where 16 bits of data is sufficient the lx5280 pipeline is dualissue sixstage architecture pipe is the loadstore pipe and includes data memory access and all mips instructions except multiply and divide operations while pipe b is the multiplyaccumulatepipe andincludesamacandalueachwithdual16bitoperationsdspalgorithms will typically use pipe to load pair of operands into general register while executing dual mac operationsinpipebonearlierdatadecouplingregisterloadsfromthemacallowsloopunrollingandtakes effective advantage of the 32 general registers for temporary storage as compared to memorybased operandswhicharecommontospecializeddspinstructionsetsdualissueallowsthelx5280toachievethe memory bandwidth required by dsp within risc architecture in addition the lx5280 introduces twinwordloadandstorefunctionsallowing64bitsofdatatobemovedbetweenthelocalcacheandregister file in single cycle this provides sufficient datamovement for datahungry dsp inner loops features introduced in lexras risc product line to support systemonchip soc design including customerdefined coprocessors and customer extensions to the mips isa are standard in the lx5280 configuration options include extendedjtag ejtag support for debug and incircuit emulation ice lexras products include the same memory management stub smmu as the lx4189 because the lx5280 executes the mips instruction set wide variety of thirdparty software tools are available including compilers operating systems debuggers and incircuit emulators the assembler extensions and cycle accurate instruction set simulator iss are developed by lexra programmers can use offtheshelf c compilers for initial coding then replace performancecritical loops with optimized assembler code third parties provide c compiler support for the new dsp instructions and will supply dsp macro librariesapril 30 2001 lx5280 lexra proprietary confidential 2 release 19 and application packages compiler support is provided by the greenhills multi ide package dsp library of functions such as filters and transforms will be available from lexra memorysizesandperipheralscanbetailoredbythelicenseetosystemrequirementsavoidingexcesssilicon cost and power dissipation it is expected that the lx5280 will deliver exceptional priceperformance for numerous consumer products and that multiple lx5280 subsystems on single die can costeffectively implement highperformance next generation telecommunications systems key features complete processor subsystem executes mips i isa except unaligned loads stores extensive thirdparty tool support dual instruction issue highperformance 6stage pipeline local instruction memory andor cache configurable sizes local data memory andor cache configurable sizes memory interface logic included system bus controller optional customerdefined coprocessors optional customerdefined instruction extensions supports ejtag draft 20 for debugging portable rtl model available as synthesizable rtl portable to any 025 ¬µm 018¬µmor 015¬µm logic and sram process foundry partners include ibm tsmc and umc easy asic design single phase clocking fully synchronous design easy to interface system bus protocol supports popular eda tools executes lexras radiaxtm instruction set simd operations zerooverhead loop multiplyaccumulate instructions vector and circular buffer addressing modes easy rtl customization userconfigurable local memory reset method clock distribution userconfigurable ejtag breakpoints over 30 other configuration options interfaces for adding applicationspecific instructionsapril 30 2001 lx5280 lexra proprietary confidential 3 release 19 12 lx5280 processor overview the lx5280 is riscdsp processor that executes the mipsi instruction set1along with lexras radiaxtmdsp extensions however the clocking pipeline structure pinout and memory interfaces have allbeendesignedbylexratoreflectsystemonsilicondesignneedsdeepsubmicronprocesstechnologyas well as design methodology advances the figure below shows the structure of the lx5280 processor figure 1 lx5280 processor overview mipsisaexecution thelx5280supportsthemipsiprogrammingmodeltwosourceoperandscanbe supplied and one destination update performed per cycle the second operand is either register or 16bit immediatetheinstructionsetincludesawideselectionofaluoperationsexecutedbytheralulexras proprietary register based alu the ralu also generates memory addresses for 8bit 16bit and 32bit register loads from stores to memory by adding register base to an immediate offset an extension to the mips isa allows pair of 32bit registers to be loaded from stored to memory branches are based on comparisons between registers rather than flags and are therefore easy to relocate optional links following jump or branch instructions assist with subroutine programming the mips unaligned load and store instructions are not supported because they represent poor priceperformance tradeoff for embedded applications pipeline lx5280 instructions are executed by sixstage pipeline that has been designed so that all transactions internal to the lx5280 as well as at the interfaces occur on the positive edge of the processor clock twophase clocks are not used exception handling the mips r3000 exception handling model is supported exceptions include both instructionsynchronous trapsaswellashardwareandsoftware interruptsthestatusregistercontrolsthe interrupt mask and operating mode exceptions are prioritized when an exception is taken control is transferred to the exception vector the current instruction address is saved in the epc register and the exceptionsourceisidentifiedinthecauseregisterauserprogramlocatedattheexceptionvectoridentifies thecauseoftheexceptionandtransferscontroltotheapplicationspecifichandlerintheeventofanaddress error exception the badvaddr holds the failing address coprocessoroperations thelx5280supports32bitcoprocessoroperationstheseincludemovestoand from the coprocessor general registers and control registers mtcz mfcz ctcz cfcz coprocessor loads and stores lwcz swcz and branches based on coprocessor condition flags bczt bczf the lexrasuppliedcoprocessorinterfacecansupportcoprocessoroperationsinasinglecyclewithoutpipeline 1 the mips unaligned load and store instructions lwl lwr swl swr are not supportedinst ramicache ram inst lmi data lmi data ramdcache ramlx5280 cpu corecustom engine ci 13ceiinstruction bus addr data ctl data bus addr data ctl coprocessorslbcsystem bus denotes customer logicinst romapril 30 2001 lx5280 lexra proprietary confidential 4 release 19 stalls lx5280 provides excellent priceperformance and timetomarket there are two main approaches which lexra has taken to achieve this deliver simple building blocks outside the processor core to enable system level customizations such as coprocessors application specific instructions memories and busses deliver either fully synthesizable verilog source model or fully implemented hardcore called smoothcore for popular pureplay foundries section13 describes the building blocks and section14 describes the deliverable models 13 system level building blocks the lx5280 processor is designed to easily fit into different target applications it provides the following building blocks simple memory management unit smmu an optimized custom engine interface cei up to three coprocessor interfaces ci flexible local memory interface lmi that supports instruction cache instruction ram instruction rom data cache and data ram lexra bus controller lbc to connect peripheral devices and secondary memories to the processors own local buses the following sections discuss each of these system building block interfaces 131 smmu the lx5280 smmu is designed for embedded applications using single address space its primary function is to provide memory protection between user space and kernel space the smmu is consistent with the mips address space scheme for userkernel modes mapping and cacheduncached regions 132 local memory interface the lx5280s harvard architecture provides local memory interfaces lmis that support instruction memory and data memory synchronous memory interfaces are employed for all memory blocks the lmi block is designed to easily interface with standard memory blocks provided by asic vendors or by third party library vendors the lmis provide twoway set associative instruction cache interface and directmapped writethrough datacacheinterfacethetagcomparelogicaswellasacachereplacementalgorithmareprovidedaspartof the lmi one of the instruction cache sets may be locked down as unswappable local memory local instructionanddatamemoriescanalsobemappedtofixedregionsofthephysicaladdressspaceandinclude nonvolatile memory such as rom flash or epromapril 30 2001 lx5280 lexra proprietary confidential 5 release 19 133 coprocessor interface lexrasuppliesanoptionalcoprocessorinterfaceciforapplicationsrequiringthisfunctionalityuptothree cis may be implemented in one design the coprocessor interface eavesdrops on the instruction bus if coprocessor load lwcz or move to mtcz ctcz is decoded data is passed over the data bus into ci register then supplied to the designerdefined coprocessor similarly if coprocessor store swcz or movefrommfczcfczisdecodeddataisobtainedfromthecoprocessorandloadedintoaciregister then transferred onto the data bus in the following cycle the design interface includes data bus fivebit addressandindependentreadandwriteselectsforcoprocessorregistersandcontrolregistersthelx5280 pipeline and harvard architecture permit single cycle coprocessor access and transfer an application defined coprocessor condition flag is synchronized by the ci then passed to the sequencer for testing in branch instructions 134 custom engine interface the lx5280 includes custom engine interface cei that the application may use to extend the mips i alu opcodes with applicationspecific or proprietary operations similar to the standard alu the cei supplies the custom engine two input 32bit operands src1 and src2 one operand is selected from the register file depending on the most significant 6 bits of the opcode the second operand is either selected from the register file or is 16bit signextended immediate the opcode is locally decoded by the custom engine and following execution by the custom engine the result is returned on the 32bit result bus to the lx5280 to support multicycle operations stall input is included in the interface 135 lexra bus controller thelexrabuscontrollerlbcistheinterfacebetweenthelx5280andtheoutsideworldwhichincludes dram and various peripherals it is nonmultiplexed nonpipelined and nonparity checked bus to providetheeasiestbusprotocolfordesignintegrationontheprocessorsidethelbcprovidesawritebuffer of configurable depth to support the writethrough cache as well as the control for byte and halfword transfers on the peripheral side the lbc is designed to easily interface to industry standard bus protocols such as pci usb and firewire thelbccanrunatanyspeedfrom33mhzuptothespeedofthelx5280processorcoreinboththertl core and smoothcore 136 building block integration the lx5280 configuration script lconfig provides menu of selections for designers to specify building blocks needed number of different memory blocks target speed and target standard cell library next the configuration software automatically generates top level verilog model makefiles and scripts for all steps of the design flow for testability purposes all building blocks contain scan control signals the lexra synthesis scripts include scan insertion which allows atpg testing of the entire lx5280 core 14 rtl core smoothcore lexra delivers lx5280 as rtl core and smoothcore rtlcore forfullasicdesignsthertlisfullysynthesizableandscantestableverilogsourcecodeand maybetargetedtoanyasicvendorsstandardcelllibrariesinthiscasethedesignermaysimplyfollowthe asicvendorsdesignflowtoensurepropersignoffinadditiontotheverilogsourcecodeandsystemlevel test bench lexra provides synthesis scripts as well as floor plan guidelines to maximize the performance of the lx5280april 30 2001 lx5280 lexra proprietary confidential 6 release 19 smoothcore forcotdesignsthataremanufacturedatpopularfoundriessuchasibmtsmcandumc smoothcore port is the quickest lowest cost and best performance choice in this case the lx5280 has been fully implemented and verified as hard macro all data path register file and interface optimizations havebeenperformedtoensurethesmallestdiesizeandfastestperformancepossiblefurthermorethereisa scan based test pattern that provides excellent fault coverage during manufacturing tests 15 eda tool support lexra supports mainstream eda software so designers do not have to alter their design methodology the following is snapshot of eda tools currently supported table 1 eda tool support design flow tools supported simulation synopsys vcs cadence verilog xl cadence ncverilog synthesis synopsys design compiler static timing synopsys primetime dft synopsys tetramax pr avant apollo iiapril 30 2001 lx5280 lexra proprietary confidential 7 release 19 2 lx5280 architecture 21 motivation the lx5280 issues dual 32bit instructions to two distinct 6stage execution pipelines superscalar architectureshavebeenwidelydeployedinrisccpuswhereincreasedperformanceisobtainedatthecost of significantly increased area although superscalar issue significantly increases the area of the lx5280 processor core performance analysis at lexra demonstrates benefits on key dsp algorithms well beyond that which is obtained in typical cpu benchmarks sustaining peak computational performance in dsp algorithms typically requires at least one operand from memory per instruction cycle dsps have traditionally implemented specialized instruction sets that support memorybased operands singleissue risc architectures operate on registerbased operands and thus degrade performance by factor of two in order to preload the operand into the register file grafting memorybasedoperandsontoariscarchitectureisinconsistentwithboththeriscpipelineandisadual issue superscalar design on the other hand allows operands to be loaded from memory by one instruction whilethemultipleaccumulatedatapathmacoperatesonregisterbaseddataloadedearlierfrommemory the risc data path is 32bits but few dsp algorithms require more than 16bits of precision thus two values can be fetched simultaneously from memory simultaneous dual 16bit alu and mac operations further improve the lx5280 dsp performance compared to specialized 32bit or even 16bit dsp instructions which allow memory reference the superscalarapproachwillhavelessercodedensitybutonlywithinthedsplooporkernelthesekernelsare typicallysmallsectionsofcodewhichareexecutedmanytimesthustheoveralldegradationofcodedensity is minimal and can be offset by use of mips16 code compression in outer loop code which is not performance critical 22 hardware architecture 221 module partitioning the lx5280 processor core includes two major blocks the ralu register file and alu and the cp0 controlprocessortheraluperformsaluoperationsandgeneratesdataaddresseswhilecp0includes instruction address sequencing exception processing and product specific mode control the ralu and cp0 are looselycoupled and include their own independent instruction decodersapril 30 2001 lx5280 lexra proprietary confidential 8 release 19 figure 2 superscalar processor core module partitioning 222 six stage pipeline the lx5280 has six stage pipeline the lx5280 icache and iram can fetch two 32bit instructions i0_i i1_i simultaneously following the superscalarinstructionbufferandissuelogicdescribedbelowtheinstructionsareissuedtopipebandpipe as appropriate to avoid degrading operating frequency the superscalar issue logic operates during the decode stage dstage of the pipeline support for fully synchronous memories in the lx5280 has the added benefit of isolating the processor logic from the customersupplied memories in the instruction cache thus facilitating integration of the lx5280 into soc designs as result of the dstage two cycle penalty is incurred on branch prediction failure vs the onecycle penalty in the lx4180 five stage pipeline however the lx5280s zerooverhead loop hardware andstage 1 i instruction fetch stage 2 d decode stage 3 s source fetch register file read stage 4 execution and address generation stage 5 m memory data select read data cache store and tags stage 6 w write back to register filen z ov_a dbus1 data addrjump addresslink address pridexception processing logicpc and sequencercp0 and controlraluinstruction address and control instructions register file 32 x 32b r0 0 8p 4r4waddr_ra2addr_wa1 addr_ra1 addr_rb2addr_wb1 addr_rb1addr_wb2addr_wa2 alu cbs0cbs2 cbe0cbe2bypass datara2wa1 wa2 ra1 alu b cei0cei1 opaopb dual mac dmac m0m3wb1 wb2 rb2rb1 res1opaopb custom engine optionalres0april 30 2001 lx5280 lexra proprietary confidential 9 release 19 conditionalmoveinstructionscanbeusedtoavoidanywastedcyclesinthecontrolofrealtimecriticalloops 23 dual issue 231 instruction fetch twoinstructionsarefetchedduringeachinstructioncacheaccessintheeventofacachemisstheprocessor willbestalleduntilthecachelinecontainingtherequestedinstructionsisretrievedintheeventthatonlyone instruction of fetched pair can issue the fetch will be stalled until the second instruction is issued to the pipeline instructionfetchesalwaysoccuronanaligned64bitaddressboundaryintheeventofabranchtoanodd32 bitaddressinthe64bitboundarybothinstructionsinthe64bitwindowwillbefetchedbutonlythesecond odd instruction will issue to the pipeline the first or even instruction will be ignored 232 instruction analysis and select logic the instruction analysis and select logic is located in the dstage of the pipeline during this stage the processor analyzes both instructions in fetched pair and determines which pipeline can execute the instructions for example if the first instruction in the pair i0 is an add and the second instruction i1is mac the processor will determine that i0 can be executed by either pipe or pipe b while i1 can be executedbypipebtheinstructionselectlogicwillthenissuei0topipeaandi1topipebsinceonlypipe b can execute the mac instruction if both instructions of the fetched pair can only be issued to one pipeline for example pair of mac instructionswhichcanonlyissuetopipebthetwoinstructionswillbeissuedseriallytheinstructionfetch will be stalled by one cycle until the second instruction has been issued to the pipeline if the result of the first instruction i0 is used by the second instruction i1 only one of the two instructions will issuethe secondinstructioni1 willissue in thenext cycleandtheinstructionfetchwill bestalled for one cycle until i1 has been issued 233 mips16 themips16_nsignalindicateswhetherornotmips16codecompressionhasbeenenabledifsoeach32 bit fetch is interpreted as pair of 16bit instructions encoded according to the mips16 specification mips16 instructions are not dualissued but always issued to pipe it is expected that mips16 code compression is enabled for outer loop code where code density is more important than performance the criticalregisterfilereadaddressesformips16areresolvedduringthedstagesothatregisterfileaccessfor mips16 instructions as for 32bit mips instructions can begin on the rising edge of the sstage clockapril 30 2001 lx5280 lexra proprietary confidential 10 release 19 figure 3 superscalar instruction issue 24 ralu data path 241 overview thesuperscalarraludatapathisillustratedinthefigureoperationsaredividedbetweenpipeaandpipe binsuchawaythattheraluistheonlymajorsectionoftheprocessorwhichrequiresbothpipeaandb instructionscoprocessor0aswellastheoptionalcustomerdefinedcoprocessors13onlyrequirethepipe instruction to first approximation the superscalar ralu is doubling of the lx4180 ralu it includes an 8port 4r4w general register file with 4ports 2r2w assigned to pipe and 4ports 2r2w assigned to pipe b in each pipe one write port is dedicated to register file updates from the data bus loads mfcz cfcz moves from coprocessor the remaining three ports 2r1w are available for the other operations assigned tothatpipeasaresultloadsincludingtwinwordloadsofregisterpairscandualissuewithanymacor alu instruction without register port access restriction each pipe has an alu and nearlyindependent control section differences occur in the assignment of operationstopipeaandpipebandinthepipelinefeaturestosupportsuperscalar thepipelinedifferences in the ralu to support superscalar issue are datamustbeforwardedfrompipeapipebtopipebpipeawhentheinputtoapipe b pipe execution unit requires result computed earlier in pipe pipeb themux instructions analysis logic instructions select logicmux mux mips16_n1 inst issue statev0v1 i0 i1 mux mux stall1i and iram ord_s_r ib_s_r to pipe b ia_s_r to pipe areg 32 32reg reg 1nop nop32 32 1 i1_i i0_i v_iapril 30 2001 lx5280 lexra proprietary confidential 11 release 19 forwarding paths are illustrated in figure2 ifbothpipeaandpipeboperationswritethesameregistertheralucontrolexamines the instruction order and suppresses the write for the earlier instruction based on program order in addition the ralu interfaces with the dualmac as custom engine this interface can supply two 32 bitoperandspercycleandreturnasingle32bitoperandpercycleinthecaseofthedualmaceachofthe 32bit operands can be interpreted as two independent 16bit operands 242 assignment of instructions to pipe pipe b table2 lists the detailed assignment of instructions to pipe and pipe b pipe b is called the mac pipe becauseituniquelysupportsmultiplyaccumulateaswellasmultiplyanddivideoperationsthedualmac unitwhichisattachedtopipebascustomengine0ce0includestheaccumulatorregistersincludinghi andloandthereforealsosupportsthe movetoandmovefrom operationswhichtransferdatabetweenthese registers and the general register file pipe is called the loadstore pipe because it uniquely supports the load and store operations dsp extensionstomemoryaddressingarethereforealsouniquetopipeatheseextensionsincludepointerpost modification and circular buffer addressing the figure illustrates the circular buffer start registers cbs0 cbs2 and circular buffer end registers cbe0cbe2 located in alu the coprocessor operations and all sequencing control instructions branches jumps are unique to pipe as result pipe b instructions are not routed to coprocessors the opcodes reserved for customer defined custom engine 1 ce1 are routed to pipe b since ce1 is attached to pipe b all alu operations are available in both pipe and pipe b as result performance is improved particularly in computationintensive programs and the design is simplified because major subblocks in alu and alu b are replicated the custom engine interface cei is available for customer proprietary operations in pipe b this allows the customer extensions to maintain high throughput since they can dualissue with load and store instructions which issue to pipe table 2 assignment of instructions of pipe pipe b pipe pipe b the loadstore pipe the mac pipe mips 32bit general instructionsmips32bitgeneralinstructions except ce1 custom engine opcodes multudivumfhimflo mthi mtlomadumsubumultudivumfhimflo mthi mtlomadumsubu ce1 custom engine opcodes mips 32bit alu instructions note load or store instructions mips 32bit control instructionsj jal jr jalr jalx syscall break all branch instructions all mfcz mtcz swcz lwczapril 30 2001 lx5280 lexra proprietary confidential 12 release 19 25system control copr ocessor cp0 the system control coprocessor cp0 is responsible for instruction address sequencing and exception processing fornormalexecutionthenextinstructionaddresshasseveralpotentialsourcestheincrementoftheprevious address branch address computed using pcrelative offset or jump target address for jump addresses the absolute target can be included in the instruction or it can be the contents of generalpurpose register transferred from the ralu branches are assumed or predicted to be taken in the event of prediction failure two stall cycles are incurred and the correct address is selected from special backup register statistics from several large programssuggestthatthesestallswilldegradeaveragelx5280throughputbyseveralpercenthoweverthe net effect of the lx5280s branch prediction on performance is positive because this technique eliminates certain critical paths and therefore permits higher speed system clock if anexception occurs cp0 selects one of several hardwired vectors for the next instruction address the exception vector depends on the mode and specific trap which occurred this is described further in section34 exception processing the following registers which are visible to the programming model are located in cp0mips16 instructions doubleword instructionsall mips16 instructions except multu divu mfhi mflomultu divu mfhi mflo ejtag instructions deret sdbbp including mips16 sdbbp lexra control instructionsmtru mfru mtrk mfrk mtlxc0mflxc0 lexra vector addressinglt st ltp lwp lhpu lbpu stp swp shp sbp lexra mac instructionsmta2 mfa mfa2 multa multa2 mulna2 cmulta madda msuba addma subma diva rnda2 lexra extensions to mips alu instructionssllv2 srlv2 srav2 addraddr2subrsubr2 sltr2sllv2 srlv2 srav2 addraddr2subrsubr2 sltr2 new lexra alu operationsminmin2maxmax2absr abs2 cls mux2 bitrev cmveqz cmvnezminmin2maxmax2absr abs2 cls mux2 bitrev cmveqz cmvnezpipe pipe b the loadstore pipe the mac pipeapril 30 2001 lx5280 lexra proprietary confidential 13 release 19 table 3 cp0 registers epc status cause and badvaddr are described further in the section34 prid is readonly register that allows the customers software to identify the specific version of the lx5280 that has been implemented in their product the cctl register is lexra defined cp0 register used to control the instruction and data memories as described in section72 cache control register cctl the contents of the above registers can be transferred to and from the ralus generalpurpose register file usingcp0operationsunlikeregisterslocatedincoprocessors13theycannotbeloadedorstoreddirectly to data memory 26 dual multiliplyaccumulate mac 261 dual mac operations the dual mac data path is illustrated in figure4 on page16 the major subsystems are two 16bit multiplyaccumulate data paths each with 16bit x 16bit multiplier 32bit product register four 40bit accumulator registers with optional saturate output scalers 40bit addsubtractdual round unit with optional saturate one or two 16bit x 16bit multiply or multiplyaccumulate operations can be initiated every cycle with three cycle latency 32bit x 32bit multiply executes on single multiplyaccumulate data path with five cycle latency by using both data paths 32bit x 32bit multiplyaccumulate can be initiated every other cycle 32bit x 32bit multiplyaccumulate executes using combination of single multiply accumulate data path followed by the addround the total latency is six cycles by using both data paths 32bit x 32bit multiplyaccumulate can be initiated every other cycle complex multiply 16bit real 16bit imaginary perproduct uses both multiply accumulatedatapathswiththreecyclelatencyanewcomplexmultiplycanbeinitiated every two cyclescp0 register number function badvaddr 8 holds bad virtual address if address exception error occurs status 12 interrupt masks mode selects cause 13 exception cause epc 14 holds address for return after exception handler prid 15 processor id readonly 0x0000c601 for lx5280 cctl 20 instruction and data memory controlapril 30 2001 lx5280 lexra proprietary confidential 14 release 19 one divide unit 262 mac mode mmd register several new dsp features are controlled using the mmd mac mode register mmd is new radiax user register 24 which is accessed using radiax user move instructions mtru and mfru if mmd is updated between mac instruction and the mfa instruction that retrieves the result of that instruction the resulting operation is undefined the fields in mmd are as follows note that mmd is reset to all zeroes mf selects arithmetic mode for multiplies in the dual mac 0 use integer arithmetic mode 1 use fractional arithmetic mode ms selects saturation boundary in the dual mac accumulators 0 saturate at 40 bits 1 saturate at 32 bits mt selects truncation of 32x32 multiplies in the dual mac 0 perform full 32x32 multiply sum all four partial products 1 omit partial product rs1500 x rt1500 when performing 32x32 multiply rnd selects the rounding mode used in the rnda2 instruction 00 convergent rounding sometimes called roundtonearesteven round to nearest number when the number to be rounded is midway betweentwonumbersrepresentableinthesmallerformatroundtothe even number the rounded result will always have 0 in the lsb assuming that the lsb left of the roundoff point is random convergent rounding is unbiased 01 roundtonearest round to nearest number when the number to be rounded is midway betweentwonumbersrepresentableinthesmallerformatroundtothe more positive number this rounding mode is common because it is easily implementedbyalwaysadding00100tothenumbertobe rounded digits to the right of are dropped after rounding 1x reservedapril 30 2001 lx5280 lexra proprietary confidential 15 release 19 mmd radiax user register 24 new radiax user register 24 accessed with mtru mfru operations reset to 0 table 4 mmd fields radiax user register 24 263 architecture the multiplyaccumulate data paths can operate on 16bit input data either individually or in parallel the same assembler mnemonic is used for individual or parallel operation the output register specified determines whether mac0 or mac1 or both operate for example eachmultipliercaninitiateanew16bitx16bitproducteverycycle singlecyclethroughput each16bitx 16bit multiplyaccumulate completes in three cycles figure4 illustrates the intermediate pipeline registers temp0 temp1 product 0 product 1 to help the reader remember that the multipliers require two cycles but have single cycle throughput temp0 temp1 product 0 product 1 are not accessible by the programmer thus there are two delay slots for multiplication or multiplyaccumulate for examplefieldwidth bitsdescription rnd 2 rounding mode 00 convergent 01 roundtonearest 10 reserved 11 reserved mf 1 mac fractional mode ms 1 mac 32bit saturate mode mt 1 mac 32x32 truncate mode madda2 m0l r2 r3 mac0 m0l m0l r21500 r31500 mac1 idle madda2 m0h r2 r3 mac0 idle mac1 m0h m0h r23116 r33116 madda2 m0 r2 r3 mac0 m0l m0l r21500 r31500 mac1 m0h m0h r23116 r33116 cycle 1 madda2 m1h r2 r3 cycle 2 delay slot 1 new m1h is not available cycle 3 delay slot 2 new m1h is not available cycle 4 mfa r3 m1h new m1h is available2 2731 534 0 rnd2 mf1 ms 10 mt 11april 30 2001 lx5280 lexra proprietary confidential 16 release 19 figure 4 dual mac data path the accumulator m1h can be referenced by mfa in inst2inst3 however two one stall cycles will be incurred it is expected that the number of stall cycles in dsp algorithms will be minimal because typically many products are accumulated before the accumulator must be stored in 64tap fir for example 64 termsareaccumulatedbeforethefiltersampleisupdatedin memoryalsothefouraccumulatorpairsallow loops to be unrolled so that up to three additional independent mac operations can be initiated before the result of the first is available compared to typical risc multiplyaccumulate unit the lx5280 mac includes number of features criticaltohighfidelitydsparithmeticthesefeaturesareoptionallyselectedbyopcodesandormodebitsin the mmd register and are compatible with conventional integer arithmetic also supported by the lx5280x divider div divuy 32 32 multiplier 0 16b x 16b temp0 32 32 product 0 32 40 accumulator 0 mlp mlsatml pax ml satml paxmultiplier 1 16b x 16b temp1 32 32 product 1 32 40 accumulator 1 mhp mh satmh pax mh satmh pax acc m0l4040 acc m1l40 acc m2l40 acc m3l4040 40 scaler 08 16 32acc m0h40 acc m1h40 acc m2h40 acc m3h40 40 scaler 08 16 32 32add subtract dual round w saturateapril 30 2001 lx5280 lexra proprietary confidential 17 release 19 accumulator guard bits fractional arithmetic saturation rounding output scaling accumulationisperformedat40bitprecisionusingeight guardbits foroverflowprotectionthealternative is to require the programmer to rightshift scale products prior to accumulation which complicates programming and causes loss of precision prior to accumulation the product is signextended to 40bits withguardbitstypicallytheonlylossofprecisionwilloccurattheendofalengthycalculationwhenthe40 bit result must be stored to the general register file or to memory in 32bit or 16bit format fractional arithmetic is implemented by the programs interpretation of the 16 32 or 40bit quantities and iscontrolledbyabitinthemmdregisterwhenfractionalmodeisselectedthedualmacshiftstheresults of any radiax multiply operation left by one bit to maintain the alignment of the implied radix point furthermore since 1 can be represented in fractional format but 1 cannot be represented in fractional mode the dual mac detects when both operands of multiply are equal to 1 if so it generates the approximate product consisting of 0 for the sign bit representing positive result and all ones for the remaining bits this is true for both 16x16 bit and 32x32 bit radiax multiplications the least significant bit of product is always zero in fractional mode due to the left shift the accumulation units can add the product to or subtract it from one of the four accumulator registers this operation can be performed with optional saturation that is if result overflows underflows the accumulator is updated with the largest smallest positive negative number rather than the wraparound result with incorrect sign the lx5280 instructions include multiplyadd and multiplysub each with and without saturation there are also instructions for adding or subtracting any pair of 40bit accumulator registers together with and without saturation bit in the mmd register determines whether the saturation isperformedonthefull40bitsorwhethersaturationisperformedat32bitsthelattercapabilityisusefulfor emulatingtheresultsofotherarchitecturesthatdonothaveguardbitsin32bitsaturationmodeafull40bit compareisusedtodetermineiftheresultisgreaterlessthanthemaximumminimumvaluewhichcanbe stored in 32bit quantity this provides the most robust solution inthecasethattheinstructionrequiresmultiplicationbutnoaccumulationtheproductispassedthroughthe accumulationunitunchangedthusboth16bitmultiplicationandmultiplyaccumulaterequirethreemac cycles round instruction can also be executed on one or pair of the accumulator registers to reduce precision prior to storage the rounding mode is selectable in the mmd register the output scaler is used to right shift scale the accumulator register when it is transferred to the general register file the dual mac is also used to execute the 32bit multu and divu instructions specified in the mips isainthecaseofmultuoneofthe16bitmultiplyaccumulatedatapathsworksiterativelytoproduce the 64bit product in five cycles the least significant 32 bits are available one cycle earlier than the most significant 32 bits note the mmd mode bits have effect on the operation of the standard mips isa instructions by contrast the lx5280 multa instruction is subject to the mmd mode bits for fractional arithmetic and truncated 32x32 multiplication 32bitx32bitmultiplyaccumulateinstructionsmaddamsubaareimplementedusingoneofthe16april 30 2001 lx5280 lexra proprietary confidential 18 release 19 bit multiplyaccumulate data paths and the addround unit it provides 64bit multiply result which is signextended and accumulated at 72bits the result is available in six cycles the least significant 32 bits areavailableonecycleearlierthanthemostsignificant40bitsthemaduandmsubuinstructionsof the mips32 isa are also supported forthelx5280multaanaccumulatorpairm0h390m0l310m1h390m1l310etcisthetarget m0h390 is aliased to hi m0l310 is aliased to the most significant 8bits of the 40bit hi accumulatorareusedastheguardbitswhiletheloaccumulatorissimplyzeroextendedto40bitsunlike the dual 16bit operations singlecycle throughput is not available for 32bit data however since there are twoavailabledatapathstwo32bitx32bitmultiplyoperationscanbeinitiatedeveryfourcyclesthedual mac hardware automatically allocates the second operation to the available data path if third 32bit multiplication is programmed too soon stall cycles are inserted until one of the data paths is free thedualmacalsosupportsacomplexmultiplyinstructioncmultaforthisinstructioneachofthe32 bitgeneralregisteroperandsisconsideredtorepresenta16bitrealpartinbits3116anda16bitimaginary part in bits 1500 one of the multiplyaccumulate engines calculates the real part 33 bits of the complex product namely xryr xiyi and stores it in the h half of the target accumulator pair the other mac engine calculates the imaginary part 32 bits of the complex product namely xryi xiyr and stores it in the l half of the target accumulator pair this instruction can be initiated every two cycles 2cycle throughput and takes four cycles to complete as in the other dual mac operations programming cmulta instructions too close together causes stall cycles but the correct results are always obtained the dual mac includes separate divide unit for executing the 32bit divu operations specified by the mips isa the divide requires 19 cycles to complete the quotient is loaded into m0l310 m1l310 m2l310 or m3l310 and the remainder is loaded into the lower 32bits of the other accumulator in the target pair there is special support for fractional arithmetic for the divide operations 27 data addressing 271 twinword data movement sincethedualmaciscapableofconsumingfour16bitoperandseverycycleinpipebbyperformingtwo 16x16multiplyaccumulatesitisdesirabletobeabletofetchfour16bitoperandsfrommemoryeverycycle in pipe therefore the lx5280 extends the mips load and store instructions to include twinword accessesandimplementsa64bitdatapathfrommemoryatwinwordmemoryoperationaccessesaneven odd pair of 32bit general registers with single instruction and executes in single pipeline cycle the nomenclature twinword is used to distinguish these operations from doubleword operations which in other extensions to the mips isa access single 64bit general register likethestandardbytehalfwordandwordloadstoreinstructionsthetwinwordloadstoreinstructionsusea register and an immediate field to specify the memory address however in order to obtain the maximum range from the lexop instruction format the available signed 11bit immediate field called the displacement is considered twinword quantity so is leftshifted by 3 bits before being added to the base registerthisisequivalenttoa14bitbyteoffsetincomparisontothefull16bitimmediatebyteoffsetused inthebytehalfwordandwordinstructionsalsothetargetregisterpairforthetwinwordloadstoremustbe an evenodd pair so that only 4 bits are used to specify it 272 vector addressing dsp algorithms usually operate on vectors or matrices of data for example discrete cosine transforms operateon8x8pixelblocksasaresultdatamemorypointersareincrementedfromoneoperandtothenext the extra instruction cycle required to increment risc memory pointers is eliminated in dsps with auto increment this capability is provided in the lx5280 memory pointers are used unmodified to create theapril 30 2001 lx5280 lexra proprietary confidential 19 release 19 address then updated in the general register file before the next use in the lx5280 the 8bit immediate field containing the stride is signextended to 32bits before being added tothepointerforthelattersupdatethenomenclaturepointerisusedtodistinguishtheupdateperformed aftermemory addressing from the offset in which the base register in the mips isa which is augmented by the offset beforeaddressing memory in the standard instructions the nomenclature stride which is dependent on the granularity of the access is used to distinguish it from the invariant byte offset usedinthestandardloadandstoreinstructionsfortwinwordwordhalfwordaddressingthe8bitfieldisfirst leftshiftedbythreetwooneplacesandzerofilledbeforesignextensionto32bitsthisuseofleftshiftsfor the twinword word and halfword word and halfword strides is similar to mips16 and is used to extend the effective address range thus increments of between 128 and 127 twinwords1 words halfwords or bytes are available for each data type in the case of loads but not stores pointer update requires second general register file write port the lx5280includesan8p4r4wregisterfilewithtwoofthefourwriteportsdedicatedtoregisterloadsasa result twinword loads can execute in parallel with any pipe b operation forsomedspalgorithmsnotablyfiltersdspdataisorganizedintocircularbuffersinthiscaseatthe end of the buffer the next reference is to the beginning of the buffer implementing this structure in risc requires note that the above example is written so that branch prediction failure will only be incurred at the end of the buffer nevertheless the combination of postmodified pointers together with hardware support for circularbuffersinthelx5280allowsthistypicaldspaddressingoperationtobereducedfromfourcyclesto oneaddress pointer pointer pointer stride 1 twinwords are supported only on the lx5280 and not the lx5180inst 1 lw reg addressreg inst 2 bnel addressreg bufferend continue inst 3 addiu addressreg addressreg 4 inst 4 move addressreg bufferstart continueapril 30 2001 lx5280 lexra proprietary confidential 20 release 19 figure 5 postmodified pointers with circular buffer support 273 circular buffers thelx5280supportsthreecircularbufferstoinitializethecircularbuffersthemtruinstructionsareused to set the twinword start addresses cbs0cbs2313 and twinword end addresses cbe0cbe2313 circularbuffersareonlyusedwhenmemorypointersarepostmodifiedandconsistofanintegralnumberof twinwords when circular buffer pointer is used in postmodified address calculation the pointer is compared to the associatedcbeaddressiftheymatchandthestrideisnonnegativethecbsaddressratherthanthepost modified address is restored to the register file similarly to allow for traversing the circular buffer in the reverse direction the pointer is compared to the cbs address if they match and the stride is negative the cbe address rather than the postmodified address is restored to the register file it is worth noting that circular buffers can also be accessed with byte halfword or word loadstore with pointer increment instructions in those cases the several least significant bits of the pointer register are examinedtodetermineifthestartorendofthebufferhasbeenreachedtakingintoaccountthegranularityof the access before replacing the pointer with the cbs or cbe as appropriate anygeneralregistermemorypointercanbeusedwith circularbuffers usingthecnoptiontousegeneral register rp as circular buffer pointer for example the instruction lwpc2 r3 r4stridealu regfor pointer update reg bi reg br reg temp dbus_malu reg bi comparedaddr_em u x select enable cb203 enable cb203cbe1 cbe2cbe0 cbs1 cbs2cbs0april 30 2001 lx5280 lexra proprietary confidential 21 release 19 associatesther4memorypointerwithcircularbufferc2whichisdefinedbythestartaddresscbs2andend address cbe2 28 radiax alu operations the lx5280 introduces extensions to the mips instructions to support dual 16bit operations the lx5280 also introduces number of new alu instructions which improve performance on dsp algorithms these instructions will also be described in this section 281 extensions to mips alu operations tosupporthighperformancedual16bitoperationsintheriscdspitisnecessarytosupportnotonlydual mac instructions but also dual 16bit versions of other arithmetic operations that the programmer may require to maintain simple orthogonal instruction set the following criteria were used to determine the mips alu extensions dual 16bit versions of all mips alu operations without immediate data optional saturation for every alu instruction without immediate data that can produce signed overflow or underflow it is expected that the above organizing principles will simplify the lx5280 isa for both programmers and tool developers obviously dual 16bit versions of logical operations such as and are not required howeverdual16bitversionshavebeenprovidedforall3registeroperandshiftsandaddsubtractsincluded in the mips rformat the character 2 in the assembler mnemonic indicates an operation on dual 16bit data dsp algorithms are often somewhat tolerant of data errors for example bad audio sample may cause brief distortion but lasting effect as new audio samples arrive and the bad sample is cleared out of the buffer accordinglythesaturatedresultofsignedarithmeticisaclosermoredesirableapproximationthan the wraparound result therefore all lx5280 arithmetic operations which may potentially produce arithmetic overflow or underflow and do not have immediate operands support optional saturation for examplenotonlythedual16bitaddaddr2butalsothe32bitaddaddrhaveoptionalsaturateinthe lx5280 saturation options are not provided for mips iformat 32bit instructions for example addiu howeverinthiscasetheprogrammerselectstheimmediateoperandandasaresultsaturationislesslikely or at least more predictable neither the dual 16bit instructions nor the new 32bit saturating adds and subtracts cause exceptions 282 new alu instructions the lx5280 adds several new alu instructions which have proven useful in dsp performance analysis consistent with the approach described above each new instruction has both 32bit and dual 16bit version if signed overflowunderflow is possible saturation option is provided 283 conditional move operations the lx5280 includes new instructions movz and movn to support conditional operations these instructions are described in this section number of dsps and risc processors have deployed extensive conditional execution in these processorsthebranchpredictionpenaltyisthreecyclesormoreconditionalexecutioncanmitigatetheeffect of the branch prediction penalty by allowing the branch to be avoided in some cases however conditional executionisacostlyalternativeitusesinstructionopcodebitsandconsequentlylimitsthesizeofimmediateapril 30 2001 lx5280 lexra proprietary confidential 22 release 19 data andor limits the number of general purpose registers visible to the program the lx5280 branch prediction penalty is only two cycles therefore the need for conditional execution is minimized and only restricted set of conditional move instructions is needed it is notable however that the effect of any conditional execution can be emulated in the lx5280 with sequence of two instructions by using the conditional move for example processor with conditional execution lx5280 if rb satisfies the cond rd is updated with ra ie the 2nd alu operation is executed to completion note that this sequence is interruptible another use of the conditional move instructions is to code ifthenelse constructs as follows can be coded if the previous example is prefaced with one reason lexra has provided conditional move is to facilitate initial porting of assembler code from processors with conditional execution to the lx5280 29 zero overhead loop facility because dsp algorithms spend much of their time in short realtime critical code loops dsps often include hardwaresupportforzerooverheadloopingthegoalofzerooverheadloopingisthatbranchingfromthe endtobeginning of the loop can be accomplished without explicit program overhead if the loop is to be executed fixed number of times known at compile time the lx5280 supplies such facility but allows the loop count to be determined at run time as well the facilityconsistsofthreenewradiaxregisterswhichareaccessiblebyaprogramrunninginusermodeusing the radiax instructions mfru and mtru the operating system should consider these registers as part of the context of the executing process and must save and restore them in the case of an interrupt lpe0312 virtual address of the ending instruction of the loop lps0282 low order bits of the virtual address of the starting instruction of the loop lpc0150 the loop count although the facility is intended for use in loops the algorithm executed by the hardware can be described moresimplyinparticularitshouldbenotedthatthereisnoknowledgeofbeinginsidetheloopallthat mattersisthecontentsofthethreeregisterswhenanattemptismadetoexecutetheinstructionattheaddressinst 1 alu operation sets condition flags inst 2 cond alu operation inst 1 alu operation updates register rb condition setting operation inst 2 alu operation with result directed to temp register ra inst 3 movcond rd ra rb if rb cond rd ra else rd rc move rd rc move rc to rdapril 30 2001 lx5280 lexra proprietary confidential 23 release 19 specified by lpe0 if m32mode and currentinstructaddr312 lpe0 and lpc0 0 then execute current instruction at lpe0312 00 decrement lpc0150 by one execute instruction at lpe03129 lps0282 00 continue lps0 could be jumpbranch else execute current instruction continue current instruction could be jumpbranch the following restrictions apply to the usage of the zero overhead loop facility it is only active in 32bit isa mode it is disabled in mips16 mode lpsmaynotbeexactlyequaltolpeiflpcisnonzerothereforetheloopmustcontain at least two instructions otherwise operation is undefined lpe may not be in the delay slot of branch nor may it be branch or jump instruction itself if lpc is nonzero otherwise operation is undefined forcorrectoperationtheorderofloadingtheregistersmustbefirstlpsthenlpethen lpc with nonzero value for correct operation there must be at least two 2 instructions between the instruction which loads lpc with nonzero value and the instruction at the lpe address to guarantee that stall cycles are incurred there must be at least three 3 cycles between the instruction which loads lpc with nonzero value and the instruction at the lpe address1 if the instruction at lpe is load type instruction then the immediately executed instruction at lps is considered to be in the load delay slot and cannot rely on seeing the result of the load the following items are notrestrictions that apply to the usage of the zero overhead loop facility but are features to be aware of the loop count lpc may be reloaded multiple times after lps and lpe are loaded typically this would be done in an outer loop theinstructionatlpemaybethetargetofajumporbranchincludingachangeinmode from 16bit to 32bit isa any of the instructions before or at lpe may be subject to exceptions or interrupts and processingwillconformtothenormalexceptionhandlingrulesnotethatthebdbitwill 1 the following discussion is only relevant if lpc will be updated in an instruction that is close to lpe that case can have per formance impact although correct operation will still be obtained the programming guideline is keep the lpc update in an outer loop as far as possible from the end of the inner loop the updates of lps lpe and lpc use the mtru instruction therefore the new lps lpe and lpc values are only known after the estage of the pipeline but in order to perform the pseudobranch they must be used in the istage of the pipeline because of therestrictionontheorderofsettingtheseregistersthehardwareintroducesaminimumnumberofstallsaftersettinglpsandlpe to test for an lpe match against the current instruction address however if the lpc update is still in the pipeline when the lpe match is detected the hardware stalls to check and update the new value of lpc to avoid these stalls lpc should not be updated within 3 cycles which could be as many as 6 instruction issue slots of an expected lpematching instruction as noted above for correct operation there must be at least 2 instructions between the lpc update and any expected lpematching instructionapril 30 2001 lx5280 lexra proprietary confidential 24 release 19 always be off since lpe must not be in the delay slot of branch the return from the exception handler to lpe will also be handled normally since it is just special case of lpe being the target of jump if the instruction at lpe causes reserved instruction trap it is necessary for the exception handler to decrement lpc prior to return after emulating the instruction at lpe and before returning to the instruction at lps similar restrictions apply if the instruction at lpe is not to be reexecuted for any other reason such as break or syscall execution 210 lowoverhead prioritized interrupts thelx5280includeseightnewlowoverheadhardwareinterruptsignalsthesesignalsarecompatiblewith the r3000 exception processing model and are useful for realtime applications these interrupts are supported with three new lexra cp0 registers estatus ecause and intvec accessed with the new mtlxc0 and mflxc0 variants of the mtc0 and mfc0 instructions as with any cop0instructionacoprocessorunusableexceptionistakeniftheseinstructionsareexecutedwhileinuser mode and the cu0 bit is 0 in the cp0 status register the three new lexra cp0 registers are estatus 0 ecause 1 and intvec 2 and are defined as follows estatus lx cop0 reg 0 readwrite ecause lx cop0 reg 1 readonly intvec lx cop0 reg 2 readwrite estatus contains the new interrupt mask bits im158 which are reset to 0 so that none of the new interruptswillbeactivatedregardlessoftheglobalinterruptsignaliecip158forthenewinterruptsignals islocatedinecauseandisreadonlythesefieldsaresimilartotheimandipfieldsdefinedinther3000 exception processing model except that the new interrupts are prioritized in hardware and each have dedicated exception vector ip15 has the highest priority while ip8 has the lowest priority however all new interrupts are higher priority than ip70 the processor concatenates the program defined base address for the exception vectorswiththeinterruptnumberforformtheinterruptvectorasshowninthetablebelowtwoinstructions can be executed in each vector typically these will consist of jump instruction and its delay slot with the target of the jump being either shared interrupt handler or one that is unique to that particular interrupt31 24 23 16 15 0 0 im158 0 31 24 23 16 15 0 0 ip158 0 31 6 5 0 base 0april 30 2001 lx5280 lexra proprietary confidential 25 release 19 table 5 prioritized interrupt exception vectors when vectored interrupt causes an exception all of the standard actions for an exception occur these include updating the epc register and certain subfields of the standard status and cause registers in particulartheexceptioncodeofthecauseregisterindicatesinterruptandthecurrentandprevious mode bits of the status register are updated in the usual mannerinterrupt number exception vector 15 base 6b111000 14 base 6b110000 13 base 6b101000 12 base 6b100000 11 base 6b011000 10 base 6b010000 9 base 6b001000 8 base 6b000000 april 30 2001 lx5280 lexra proprietary confidential 26 release 19 april 30 2001 lx5280 lexra proprietary confidential 27 release 19 3 lx5280 risc programming model this section describes the lx5280 programming model section31 summary of mipsi instructions containsalistsummarizingallmipsioperationssupportedbythelx5280theseopcodesmaybeextended by the customer using lexras custom engine interface cei this capability is described in section32 opcode extension using the custom engine interface cei section33 memory management describes the simplified memory management unit smmu which is physically incorporated in the lx5280 lmi the smmu provides sufficient memory management capabilities for most embedded applications while ensuring execution of thirdparty mips software development tools thelx5280supportsthemipsr3000exceptionprocessingmodelasdescribedinsection34 exception processing thelx5280supportsallmipsicoprocessoroperationsthecustomercanincludeonetothreeapplication specific coprocessors lexra provides functional block called the coprocessor interface ci which allows thecustomerasimplifiedconnectionbetweentheircoprocessorandtheinternalsignalsofthelx5280the ci is described in section35 the coprocessor interface ci 31 summary of mipsi instructions the lx5280 executes mipsi instructions as detailed in the tables below to summarize the lx5280 executes mipsi instructions with the following exclusions the unaligned loads and stores lwl swl lwrswrarenotsupportedbecausetheyaddsignificantsiliconareaforlittlebenefitinmostapplications the following conventions are employed in the instruction descriptions encloses list of syntax choices from which one must be chosen encloses list of values that are concatented to form larger value n value replicates concatenates value n times value3 bits selected from value ra offset memory address computation and corresponding memory contents 4b0000 sized constant binary value 32h1234_5678 sized constant hexadecimal value expr b select if expr is true otherwise select bapril 30 2001 lx5280 lexra proprietary confidential 28 release 19 311 alu instructions table 6 alu instructions instruction description add rd ra rb addu rd ra rb addi rd ra immediate addiu rd ra immediaterd ra rb immediate add reg ra to either reg rb or 16bit immediate sign extendedto32bitsresultisstoredinregrdaddandaddi can generate overflow trap addu and addiu do not sub rd ra rb subu rd ra rbrd ra rb subtract reg rb from reg ra result is stored in register rd sub can generate overflow trap subu does not and rd ra rb andi rd ra immediaterd ra rb immediate logicaland of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rd or rd ra rb ori rd ra immediaterd ra rb immediate logicalor of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rd xor rd ra rb xori rd ra immediaterd ra rb immediate logicalxor of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rd nor rd ra rb rd ra rb logicalnor of reg ra with either reg rb or zeroextended 16 bit immediate result is stored in reg rd lui rd immediate rd immediate 16b0 the 16bit immediate is stored into the upper half of reg rd the lower half is loaded with zeroes sll rd rb immediate sllv rd rb rard rb ra immediate regrbisleftshiftedby031theshiftamountiseitherthe5b immediate of the 5 lsb of ra result is store in reg rd srl rd rb immediate srlv rd rb rard rb ra immediate reg rb is rightshifted by 031 the unsigned shift amount is either the 5b immediate or the 5 lsb of ra result is stored in reg rd sra rd rb immediate srav rd rb rard rb ra immediate reg rb is arithmetic rightshifted by 031 the unsigned shift amount is either the 5b immediate or the 5 lsb of ra result is stored in reg rd slt rd ra rb sltu rd ra rb slti rd ra immediate sltiu rd ra immediaterd ra rb immediate 1 0 if reg ra is less than rb immediate set rd to 1 else 0 the 16bitimmediateissignextendedforsltsltithecompari is signed for slu sltiu the comparison is unsignedapril 30 2001 lx5280 lexra proprietary confidential 29 release 19 312 load and store instructions table 7 load and store instructions 313 conditional move instructions table 8 conditional move instructionsinstruction description lb rd offsetra lbu rd offsetra lh rd offsetra lhu rd offsetra lw rd offsetrard memoryra offset reg rd is loaded from data memory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits lb lbu addresses are interpreted as byte addresses to data memorylhlhuashalfword16bitaddresseslwasword 32bit addresses thedatafetchedinlblhlbulhuissignextendedzero extended to 32bits for storage to reg rd rd cannot be referenced in the instruction following load instruction sb rb offsetra sh rb offsetra sw rb offsetrarb memoryra offset reg rb is stored to data memory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits sbaddressesareinterpretedasbyteaddressestodatamem ory the 8 lsb of rb are stored sh addresses are interpreted as halfword addresses to data memory the 16 lsb of rb are stored instruction description movz rd rs rt rd rt 0 rs rd if the contents of general register rt are equal to 0 the general register rd is updated with rs otherwise rd is unchanged movn rd rs rt rd rt 0 rs rd if the contents of general register rt are not equal to 0 the gen eral register rd is updated with rs otherwise rd is unchangedapril 30 2001 lx5280 lexra proprietary confidential 30 release 19 314 branch and jump instructions table 9 branch and jump instructions instruction description beq ra rb destination bne ra rb destinationif cond pc pc 4 14 destination15 destination 2b00 else pc pc 8 where cond ra rb for eq ra ne rb for ne and desti nation is 16bit value for beq bne the instruction after the branch delay slot is always executed blez ra destination bgtz ra destinationif cond pc pc 4 14 destination15 destination 2b00 else pc pc 8 where cond ra 0 for ra 0 for gt and destina tion is 16bit value forblezbgtztheinstructionafterthebranch delayslotis always executed bltz ra destination bgez ra destinationif cond pc pc 4 14 destination15 destination 2b00 else pc pc 8 where cond ra 0 for lt ra 0 for ge and destina tion is 16bit value forbltzbgeztheinstructionafterthebranch delayslotis always executed bltzal ra destination bgezal ra destinationsimilar to the bltz and bgez except that the address of the instruction following the delay slot is saved in r31 regardless of whether the branch is taken j target pc pc3128 target 2b00 target is 26bit absolute the instruction following j delay slot is always executed jal target same as above except that the address of the instruction fol lowing the delay slot is saved in r31 jr ra pc ra the instruction following jr delay slot is always executed jalr ra rd same as above except that the address of the instruction fol lowing the delay slot is saved in rdapril 30 2001 lx5280 lexra proprietary confidential 31 release 19 315 control instructions table 10 control instructions 316 coprocessor instructions table 11 coprocessor instructionsinstruction description syscall the sys trap occurs when syscall is executed break the bp trap occurs when break is executed rfe causes the kuie stack to be popped used when returning from the exception handler see exception processing below sleep initiates lowpower standby mode this is lexra specific operation lexop see section36 power savings mode instruction description lwcz rcgen offsetra rcgen memoryra offset coprocessor z general reg rcgen is loaded from data mem ory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits rcgen cannot be referenced in the following instruction one cycle delay swcz rcgen offsetra rcgen memoryra offset coprocessor z general reg rcgen is stored to data memory the memory address is computed as base offset where the base is reg ra and the offset is the16bit offset sign extended to 32 bits mtcz rb rcgen ctcz rb rcconin mtczctcz the general register rb is moved to copro cessor z general control reg rcgenrccon rcgen and rccon cannot be referenced in the following instruction mfcz rb rcgen cfcz rb rcconin mfczcfcz the coprocessor z general control reg rcgenrccon is moved to the general register rb rb cannot be referenced in the following instruction bczt destination bczf destinationif cond pc pc 4 14 destination15 destination 2b00 else pc pc 8 where cond cpcondz true for bczt cpcondz false for bczf forbcztbczftheinstructionafterthebranch delayslotis always executedapril 30 2001 lx5280 lexra proprietary confidential 32 release 19 32 opcode extension using the custom engine interface cei 321 cei operations customers may add proprietary or applicationspecific opcodes to their lx5280 based products using the custom engine interface cei the new instructions take one of the following forms illustrated below and use reserved opcodes table 12 custom engine interface operations lexra permits customer operations to be added using the four 4 iformat opcodes and six 6 rformat opcodes listed in the table above other opcode extensions in future lexra products will notutilize the opcodes reserved above when the cei decodes newopi or newopr it must signal the core that custom operation has been executed so that the reserved instruction trap will not be taken multicycle custom operations may be executed by asserting cesel note the custom operation may choose to ignore the src1 and src2 operands supplied by the cei and reference customer registers instead results can also be written to an implicit customer register however unless d 0 is coded register in the core will also be written 322 interface signals table 13 custom engine interface signalsnew instruction description available opcodes newopi rd ra immed rd ra newopi immed reg ra is supplied to the src1 port of cei and the 16bit immediate sign extended to 32bits is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 24 27 newopr rd ra rb rd ra newopr rb reg ra is supplied to the src1 port of cei and reg rb is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 0 and inst50 5658 606263 signal io description src1310 output operand supplied to customer logic src2310 output operand supplied to customer logic res310 input result of customer logic supplied to core ceiop110 output instruction op and subop fields to be decoded by customer logicapril 30 2001 lx5280 lexra proprietary confidential 33 release 19 33 memory management thelx5280includesasimplifiedmemorymanagementunitsmmufortheinstructionmemoryaddress and the data memory address these units are physically located in the local memory interface lmi modulesthehardwiredvirtualtophysicaladdressmappingperformedbythesmmuissufficienttoensure execution of thirdparty software development tools table 14 smmu address mapping 34 exception processing thelx5280implementsthemipsr3000exceptionprocessingmodelasdescribedbelowfeaturesspecific to onchip tlb support are not included in the discussion below the term exception refers to both traps which are nonmaskable program synchronous events and interrupts which result from unmasked asynchronous events thelistbelowisnumberedfromhighesttolowestpriorityexccodeisstoredincausewhenanexception is taken note that sys bp ri cpu can share the same priority level because only one can occur in particular time slotcehalt input indicates that multicycle custom operation is in progress cesel input indicates that cei operation has been decoded virtual address space description mapped to physical address 0xff00_0000 to 0xffff_ffffejtag address space 16 mbyte uncached this address range is reserved for ejtag use only0xff00_0000 to 0xffff_ffff 0xc000_0000 to 0xfeff_ffffkseg2 1gbyte minus 16 mbyte addressable only in kernel mode cached0xc000_0000 to 0xfeff_ffff 0xa000_0000 to 0xbfff_ffffkseg1 05 gbyte addressable only in ker nel mode uncached used for io devices0x0000_0000 to 0x1fff_ffff 0x8000_0000 to 0x9fff_ffffkseg0 05 gbyte addressable only in ker nel mode cached0x0000_0000 to 0x1fff_ffff differentiated from kseg1 addresses with an internal signal 0x0000_0000 to 0x7fff_ffffkuseg 2gbyte addressableinkernelor user mode cached0x4000_0000 to 0xbfff_ffffsignal io descriptionapril 30 2001 lx5280 lexra proprietary confidential 34 release 19 table 15 list of exceptions exception priority exccode description reset 1 reset trap adel instruction2 4 address exception trap instruction fetch occurs if the instruction address is not wordaligned or if kernel address is referenced in user mode ov 3 12 arithmeticoverflowtrapcanoccurasa result of signed add or subtract opera tions sys 4 8 syscall instruction trap occurs whensyscallinstructionisexecuted bp 4 9 break instruction trap occurs when break instruction is executed ri 4 10 reservedinstructiontrapoccurswhen areservedopcodeisfetchedreserved opcodes are listed below cpu 4 11 coprocessor usability trap occurs when an attempt is made to execute coprocessor n operation and copro cessor n is not enabled adel data 5 4 address exception trap data fetch occurs if the data address is not prop erly aligned or if kernel address is generated in user mode ades 6 5 address exception trap data store occurs if the data address is not prop erly aligned or if kernel address is generated in user mode int 7 0 unmasked interrupt there are six 6 levelsensitive hardware interrupt request signals into the lx5280 core eachissynchronizedbythecoretothe lx5280 system clock in addition pro gram writes to cause98 are soft wareinitiated interrupt requests each of the eight 8 requests has an associ ated mask bit in status int is gener ated by any unmasked request when interrupts are globally enabledapril 30 2001 lx5280 lexra proprietary confidential 35 release 19 341 exception processing registers status coprocessor 0 general register address 12 cu cun 10 indicates that coprocessor n is usableunusable in coprocessor instructions bev bootstrap exception vector selects between two trap vectors see below im interrupt masks for the six hardware interrupts and two software interrupts kuie ku01indicateskernelusermodeinthelx5280usermodevirtualaddressesmusthave msb 0 in kernel mode the full address space is addressable ie 10 indicates that interrupts are enabled disabled the kuo ieo kup iep kuc and iec fields form threelevel stack hardware stack kuie signals the currentvalues are kuciec the previousvalues are kupiep and the oldvalues those before previous are kuoieo see section342 statusisreadorwrittenusingmtc0andmtf0operationsonresetbev1kuciec0theother bitsinstatusareundefinedthe0fieldsareignoredonwriteandare0onreaditisrecommendedthatthe user explicitly write them to 0 to insure compatibility with future versions of the lx5280 cause coprocessor 0 general register address 13 bd branch delay indicates that the exception was taken in branch or jump delay slot ce coprocessorexceptioninthecaseofacoprocessorusabilityexceptionindicatesthenumber of the responsible coprocessor ip interrupt pending each bit in ip70 indicated an associated unmasked interrupt request exccode the exccode listed above for the different exceptions are stored here when as exception occurs causeisreadorwrittenusingmtc0andmtf0operationstheonlyprogramwritablebitsincauseare ip10 which are called softwareinterrupts cause isundefinedatreset the 0 fieldsare ignored on write and are 0 on read epc coprocessor 0 general register address 14 epc is 32bit readonly register which contains the virtual address of the next instruction to be executed following return from the exception handler if the exception occurs in the delay slot of branch epc will hold the address of the branch instruction and bd will be set in cause the branch will typically be re executed following the exception handler badvaddr coprocessor 0 general register address 8 badvaddr is 32bit readonly register containing the virtual address instruction or data which3128 2723 22 2116 158 76 5 4 3 2 1 0 cu30 0 bev 0 im70 0 kuo ieo kup iep kuc iec 31 30 2928 2716 158 7 62 10 bd 0 ce10 0 ip70 0 exccode40 0april 30 2001 lx5280 lexra proprietary confidential 36 release 19 generated an adel or ades exception error 342 exception processing entry and exit when an exception occurs the instruction address changes to one of the following locations the kuie stack is pushed kuo ieo kup iep kuc iec before push kup iep kuc iec 0 0 after push whichdisablesinterruptsandputstheprograminkernelmodethecodeexccodefortheexceptionsource isloadedintocausesothattheapplicationspecificexceptionhandlercandeterminetheappropriateaction the exception handler should not reenable interrupts until necessary context has been saved to return from the exception the exception handler first moves epc to general register using mfc0 followed by jr operation rfe only pops the kuie stack kup iep kuc iec 0 0 before pop kup iep kup iep kuc iec after pop this example assumes that kuie were not modified by the exception handler therefore typical sequence of operations to return from the exception handler would be 35 the coprocessor interface ci designers may implement up to three coprocessors to interface with the lx5280 the contents of these coprocessors may include up to thirtytwo 32 32bit general registers and up to thirtytwo 32 32bit controlregisters thegeneralregistersmaybemovedtoandfromtheralusregistersusingmtczmfcz operationsorbeloadedandstoredfromdatamemoryusinglwczswczoperationsthecontrolregisters may only be moved to and from the ralus registers using ctcz cfcz operations lexra supplies simple coprocessor interface ci model allowing the customer to easily interface coprocessor to the lx5280 the ci supplies set of control address and data busses that may be tied directly to the coprocessor general and special registers the ci is described in more detail in section9 lx5280 coprocessor interface 36 power savings mode the operating system kernel can initiate power savings standby mode using the lexra specific sleepreset 0xbfc0_0000 other exceptions bev 0 0x8000_0080 other exceptions bev 1 0xbfc0_0180 mfc0 epc r26 r26 is temporary storage register in the ralu jr r26 rfeapril 30 2001 lx5280 lexra proprietary confidential 37 release 19 instruction this holds the lx5280s internal clocks in the high state until an external hardware interrupt is received before executing the sleep instruction the kernel must ensure that the interrupt condition that will ultimately terminate standby mode has been enabled via the im field of the coprocessor 0 status register whenthesleepinstructionentersthewstagethestandbylogicstallstheprocessorandwaitsforthelbc to complete any outstanding processor initiated system bus operations after these are completed the standby logic holds the system and bus clocks high these are held high until an enabled interrupt is received when standby mode is terminated by an interrupt the standby logic allows the clocks to toggle the processor honors the interrupt by branching to the exception handler as is normally done for interrupt servicing because several instructions are held in the pipeline while the clocks are frozen prior to the interrupt the exception pc will not point to the sleep instruction but rather some later instruction typicallyakernelwouldenteranidleloopjustafterexecutingthesleepinstructionsotheinterruptwillbe serviced from the kernels normal idle interrupt service level the lx5280 takes minimum of 6 cycles after the sleep instruction enters the w stage to safely synchronize the initiation of standby mode ie hold the clocks in the high state two cycles are required terminate standby mode the processor is stalled during these periods thestandbylogicreceivesthefreerunningsystemandbusclocksandgeneratesgatedclocksfordistribution to the lx5280 the standby logic must use flipflops tied to free running clocks which results in about dozen loads on the free running clocks twopinssl_sleeping_randsl_sleeping_brareavailablefromthestandbylogicandareasserted highwhentheprocessorisinstandbymodethe_rpinisforuseinthesystemclockdomainandthe_br pin is for use in the bus clock domainapril 30 2001 lx5280 lexra proprietary confidential 38 release 19 april 30 2001 lx5280 lexra proprietary confidential 39 release 19 4 mips16 mips16 is an extension to the mips instruction set architecture isa that was developed to improve code densityespeciallyforsystemonchipsocdesignsinthesedesignsonchipinstructionstorageisoftena significant even dominant portion of the silicon component cost this is especially true for realtime applications because in order to meet realtime requirements instruction cache miss penalties cannot be tolerated and thus large portion of the instruction storage must be resident onchip mips16 provides set of 16bit instruction formats to encode the most common operations the key compromisesrequiredtoachieve16bitencodingincludeisomemipsiinstructionsarenotavailableii immediate widths are reduced iii only 8 of the 32 general registers may be directly addressed as result some operations cannot be executed in mips16 or require multiple mips16 instructions thus realistic programs need to include both mips16 and mips i instructions using mips16 where possible to save storageatsomecosttoperformance1modeswitchingbetweenmips16andmipsiisdiscussedbelowto permit occasional access to all 32 general registers without the overhead of mode switching mips16 providesmoveinstructions to move data between the mips16visible registers and the full general register set also to permit occasional use of 16bit immediates without mode switching mips16 provides the extend instructiontoallowafullwidthimmediateintwomips16instructioncyclesprogramsrequiring large register set or frequent fullwidth immediates should be compiled in mips i mips16 is difficult to program effectively at the assembler level this is because of the limited register set and the restricted size immediates in fact according to sweetman2 mips16 is not suitable language for assembly coding rather mips16 is viewed as compiler option which can be effectively applied to achieve significant code size reduction where performance is not critical 41 mips16 instructions this section describes the mips16 instructions with emphasis on the differences between mips16 and the 32bit mips isa the first table lists mips i instructions that are notsupported in mips16 the second table lists mips i instructions which are supported in mips16 in most cases these are specialized versions of the mips i instruction mips16 is compatible with mips i ii and iii iv or v the lx5280implements allmips16for32bitdataoperations3thetablelistsallmips16instructionstogether withthecorrespondingmipsiinstructionandthespecializationrequiredtoproducethemips16instruction other than smaller register set and smaller immediates the third table lists the several new instructions introduced by mips16 itisnotablethatmultudivuaresupportedinmips16mfhiandmfloarealsosupportedandare necessarytoaccesstheresultofmultuordivuhowevermthiandmtloarenotsupportedthese are used primarily to restore the state after exception handling and are used within the kernel typically in mips i 1 the mips16 performance penalty results from occasionally using two instructions where one mips i instruction would sufÔ¨Åce some of this penalty is recovered in applications where larger number of instructions per cache line reduces cache miss rate 2 see mips run dominic sweetman appendix d p 425 3 mips16 includes 16bit formats for number of mips iii 64bit doubleword operations which are not supported in the mips i isathey are also not supported in radiaxapril 30 2001 lx5280 lexra proprietary confidential 40 release 19 table 16 mips i instructions not supported by mips16 table 17 mips16 instructions that support mips imips i not supported by mips16 assembler mnemonics coprocessor operations ctcz cfcz mtcz mfcz lwcz swcz bczt bczf copz unaligned loads stores lwl lwr swl swr arithmetic operations add addi sub conditional branches blez bgtz bltz bgez bltzal bgezal logical operations with immediates andi ori xori lui jump j miscellaneous syscall rfe mthi mtlo mips16 instruction mips i equivalent instructiona lbu ry offsetrx lhu ry offsetrx lw ry offsetrx lw rx offsetsp r29 base sb ry offsetrx sh ry offsetrx sw ry offsetrx sw rx offsetsp r29 baselw rx offsetbase base r29 sw rx offsetbase base r29 addiu ry rx immediate addiu rx immediate addiu sp immediate 1operand addiu rx sp immediate 2operand addu rz rx ry subu rz rx ry neg rx ry 2operandaddiu rt rs immediate rtrs addiu rt rs immediate rtrsr29 addiu rt rs immediate rsr29 subu rd rs rt rsr0 sltu rx ry r24 dest implied sltiu rx immediate 2op r24 destsltu rd rs rt rdr24 sltiu rt rs immediate rtrs cmpi rx immediate r24 dest implied cmp rx ry r24 dest impliedxori rt rs immediate rtr24 xor rd rs rt rdr24 and rx ry 2operand or rx ry 2operand xor rx ry 2operand not rx ry 2operand move ry r32 2operand move r32 ry 2operand li rx immediateand rd rs rt rdrs or rd rs rt rdrs xor rd rs rt rdrs nor rt rs rt rsr0 or rd rs rt rsr0 or rd rs rt rsr0 ori rd rs immediate rsr0 sll rx ry immediate srl rx ry immediate sra rx ry immediate sllv ry rx 2operand srlv ry rx 2operand srav ry rx 2operandsllv rd rt rs rdrs srlv rd rt rs rdrs srav rd rt rs rdrs multu rx ry divu rx ry mfhi rx mflo rxapril 30 2001 lx5280 lexra proprietary confidential 41 release 19 as noted earlier mips16 restricts the mips i directly addressable register set and immediate field another commonmips16restrictionisthattworatherthanthreeregisteroperandsarepermittedmips16provides number of instructions that are not found mips i as shown in table18 table 18 new mips16 instructions the pcrelative load lw is important to overcoming the drawback of smaller immediates in mips16 it allowsfull32bitimmediatestobeembeddedintheprogramandloadedintoregistersinasingleinstruction the addiu with pc operand is useful to support immediates embedded in the program the pc value referenced in lw or addiu depends on the context of the pcrelative instruction as shown in table19 table 19 pcrelative addressing extend is used to supply an extra 11bits of immediate it is used together with the restricted size immediatefieldofthenextinstructiontosupplyafullwidthimmediateextendcannotoccurinthedelay slot of jump it is not necessary for the assembly programmer to code extend instructions it will automatically be assembled by mips16 assemblers wherever the immediate is too large to be encoded in single mips16 instructionjal target jr rx jr ra jalr ra rx 2operand link r31jr rs rsr31 jalr rs rd rsr31 beqz rx offset 1operand bnez rx offset 1operand bteq offset implied operands btne offset implied operands b offset implied operandsbeq rs rt offset rtr0 bne rs rt offset rtr0 beq rs rt offset rsr24 rtr0 bne rs rt offset rsr24 rtr0 beq rs rt offset rsr0 rtr0 break if 32bit mips instruction is listed specialization beyond limited size register set and limited size immediates is required new mips16 instruction comment lw rx offsetpc load word with pcrelative address addiu rx pc immediate addiu with pc operand extend immediate supplies 11bit immediate for use in the following mips16 instruction jalx target jump to target store return in r31 and toggle the isa mode between mips16 and mips i context for pcrelative instruction pc value normal case nonextended pcrelative instruction not in jump delay slotpc of the pcrelative instruction pcrelative instruction with extended immediate pc of the extend instruction nonextended pcrelative in the delay slot of jumpjrjalrjalxextendedinstructions are not permitted in the delay slot of the jumppc of the jump instructionmips16 instruction mips i equivalent instructionaapril 30 2001 lx5280 lexra proprietary confidential 42 release 19 another new instruction jalx is available in both mips16 and also in mips i on machines implementing mips16andisdiscussedbelowinmipsimachinesnotimplementingmips16thejalxopcode000111 causes an ri trap 42 mode switching mode is switched between mips16 and mips i in one of two ways 1 the instruction jalx target toggles the mode 2 the lsb of the general register rx in jr rx jalr rs rx in mips16 rsra causes the mode to be set to mips16 if rx0 1 to mips i if rx0 0 however the lsb of the instruction memory address from jrjalr is forced to 0 as consequence machines that implement mips16 never take adel exceptions on the lsb of the instruction address this is true regardless of whether the machine is operating in mips16 or mips i mode the mode bit is saved in the lsb of the link register in jal jalx jalr 43 exceptions upon exception the mode is automatically switched to mips i the mode is saved in the lsb of the exception pc epc epc0 0 indicates that the exception occurred while executing code in mips i modeepc01indicatesthattheexceptionoccurredinmips16modethetypicalprogramwillsavethe epc to general register and later return to the main program with jr instruction causing the proper isa mode to be restored 44 delay slots consistent with the mip16 emphasis on code density there are load delay or branch delay slots in other wordstheinstructionfollowingthebranchisexecutedonlyifthebranchisnottakenmips16 jumpsjal jalx jr jalr have single delay slot the same as in mips i for jumps the target address is always taken thus there is risk that the delay slot cannot be used to do useful work the instruction from the target can be moved to the delay slot if necessary for mips16 loads the instruction following the load can reference the loaded register as in mips ii this feature is present because the mips i compiler is not always successful in scheduling useful instruction in the delay slot and must occasionally resort to nop reducing code density this possibility is eliminated in mips16april 30 2001 lx5280 lexra proprietary confidential 43 release 19 5 lx5280 dsp programming model the lx5280 supports lexras radiax dsp extensions to the mips1 instruction set this chapter describes the radiax extensions in detail section51 describes each of the radiax instructions section52 describes the instruction encoding the following conventions are employed in the instruction descriptions 51 radiax instructions the radiax instruction extensions include mac operations vectoraddressing and enhanced extensions to the mips1 alu instructions 511 radiax dualmac instructions table 20 radiax dualmac instructions encloses list of syntax choices from which one must be chosen value3 bits selected from value mnemopt indicates an optional form of instruction an mnemonic instruction syntax and description dual move to accumulatormta2g rs md mdh mdl ifmta2andmdhmdlisselectedsignextendthecontentsofgeneralregisterrsto 40bits and move to accumulator register mdhmdl if mta2 and md is selected update both mdh and mdl with the 40bit signextended contents of the same rs if mta2gisselectedtheaccumulatorregisterbits3932areupdatedwithrs3124 bits 3100 of the accumulator are unchanged the g option is used to restore the upperbits of the accumulator from the general register file typically following an exception move from accumulatormfa rd mth mtl n move the contents of accumulator register mth or accumulator register mtl to register rd with optional right shift bits 31n n from the accumulator register are transferredtord3100therangen 08isper mittedfortheoutputalignmentshift amount in the case of n 0 the field may be omitted dual move from accumulatormfa2 rd mt n movethecontentsoftheupperhalvesofaccumulatorregisterpairmttoregisterrd with optional right shift the rd3116 are taken from mth and rd1500 from the corresponding mtl mth31n 16n mtl31n 16n from the accumulator register pair are transferred to rd3100 the range n 0 8 is permitted for the output alignment shift amount in the case of n 0 the field may be omitted divide diva md rs rt the contents of register rs is divided by rt treating the operands as signed 2s complement values the remainder is signextended to 40bits and stored in mdh and the quotient is signextended to 40bits and stored in mdl m0h3100 is also called hi m0l3100 is also called divide unsigned divau md rs rt thecontentsofregisterrsisdividedbyrttreatingtheoperandsasunsignedvalues the remainder is zeroextended to 40bits and stored in mdh and the quotient is zeroextended to 40bits and stored in mdl m0h3100 is also called hi m0l3100 is also called loapril 30 2001 lx5280 lexra proprietary confidential 44 release 19 multiply 32bitmulta md rs rt the contents of register rs is multiplied by rt treating the operands as signed 2s complement values the upper 32bits of the 64bit product is signextended to 40 bitsandstoredinmdhandthelower32bitsiszeroextendedto40bitsandstoredin the corresponding mdl m0h3100 is also called hi m0l3100 is also called if mmdmt is 1 then the partial product rs1500 x rt1500 is not included in the total product if mmdmf is 1 then the product is left shifted by one bit and furthermore if both operands are 1 then the product is set to positive signed all ones fraction prior to the shift if both mmdmt and mmdmf are 1 the result is undefined multiply unsigned 32bitmultau md rs rt the contents of register rs is multiplied by rt treating the operands as unsigned valuestheupper32bitsofthe64bitproductiszeroextendedto40bitsandstored in mdh and the lower 32bits is zeroextended to 40bits and stored in the corresponding mdl m0h3100 is also called hi m0l3100 is also called if mmdmt is 1 then the partial product rs1500 x rt1500 is not included in the total product if mmdmf is 1 then the result is undefined dual multiply 16bitmulta2 md mdh mdl rs rt the contents of register rs is multiplied by rt treating the operands as signed 2s complement values if the destination register is mdh rs3116 is multiplied by rt3116 and the product is signextended to 40bits and stored in mdh if the destination register is mdl rs1500 is multiplied by rt1500 and the product is signextended to 40bits and stored in mdl if the destination is md both operations areperformedandthetwoproductsarestoredintheaccumulatorregisterpairmdif mmdmfis1theneachproductisleftshiftedbyonebitandfurthermoreforeach multiply if both operands are 1 then the product is set to positive signed all ones fraction dual multiply and negate 16bitmulna2 md mdh mdl rs rt the contents of register rs is multiplied by rt treating the operands as signed 2s complement values if the destination register is mdh rs3116 is multiplied by rt3116 and the product is signextended to 40bits negated ie subtracted from zero and stored in mdh if the destination register is mdl rs1500 is multiplied by rt1500 and the product is signextended to 40bits negated ie subtracted from zero and stored in mdl if the destination is md both operations are performed and the two products are stored in the accumulator register pair md if mmdmf is 1 then each product is left shifted by one bit prior to signextension and negation and furthermore for each multiply if both operands are 1 then the product is set to positive signed all ones fraction prior to signextension and negation complex multiplycmulta md rs rt rs3116isinterpretedastherealpartofacomplexnumberrs1500isinterpreted as the imaginary part of the same complex number similarly for the contents of generalregisterrtastheresultofcmultamdhisupdatedwiththerealpartofthe product signextended to 40bits and mdl is updated with the imaginary part of the product signextended to 40bits if mmdmf is 1 then each product is left shifted by one bit and furthermore for each multiply if both operands are 1 then the product is set to positive signed all ones fraction prior to the addition of terms 32bit multiplyadd with 72bit accumulatemadda md rs rt the contents of register rs is multiplied by rt treating the operands as signed 2s complementvaluesifmmdmtis1thenthepartialproductrs1500xrt1500is not included in the total product if mmdmf is 1 then the product is left shifted by one bit and furthermore if both operands are 1 then the product is set to positive signedallonesfractionifbothmmdmtandmmdmfare1thentheresultofthe multiply is undefined the 64bit product is signextended to 72bits and added to the concatenation mdh390 mdl310 ignoring mdl3932 the lower 32 bits of the result are zero extended to 40bits and stored into mdl the upper 40bits of the result are stored into mdhinstruction syntax and descriptionapril 30 2001 lx5280 lexra proprietary confidential 45 release 19 32bit unsigned multiply add with 72bit accumulatemaddau md rs rt the contents of register rs is multiplied by rt treating the operands as unsigned valuesifmmdmtis1thenthepartialproductrs1500xrt1500isnotincluded in the total product if mmdmf is 1 then the result of the multiply is undefined the 64bit product is zeroextended to 72bits and added to the concatenation mdh390 mdl310 ignoring mdl3932 the lower 32 bits of the result are zero extended to 40bits and stored into mdl the upper 40bits of the result are stored into mdh dual multiplyadd optional saturationmadda2smd mdh mdl rs rt the contents of register rs is multiplied by rt and added to an accumulator register treating the operands as signed 2s complement values if the destination register is mdh rs3116 is multiplied by rt3116 then signextended and added to mdh3900ifthedestinationregisterismdlrs1500ismultipliedbyrt1500then signextended and added to mdl3900 if the destination is md both operations are performed and the two results are stored in the accumulator register pair md if madda2stheresultofeachadditionissaturatedbeforestorageintheaccumulator register the multiplies are subject to mmdmf as in multa2 the saturation point is selected as either 40 or 32 bits by mmdms 32bit multiplysubtract with 72bit accumulatemsuba md rs rt the contents of register rs is multiplied by rt treating the operands as signed 2s complementvaluesifmmdmtis1thenthepartialproductrs1500xrt1500is not included in the total product if mmdmf is 1 then the product is left shifted by one bit and furthermore if both operands are 1 then the product is set to positive signedallonesfractionifbothmmdmtandmmdmfare1thentheresultofthe multiply is undefined the64bitproductissignextendedto72bitsandsubtractedfromtheconcatenation mdh390 mdl310 ignoring mdl3932 the lower 32 bits of the result are zero extended to 40bits and stored into mdl the upper 40bits of the result are stored into mdh 32bit unsigned multiply subtract with 72bit accumulatemsubau md rs rt the contents of register rs is multiplied by rt treating the operands as unsigned valuesifmmdmtis1thenthepartialproductrs1500xrt1500isnotincluded in the total product if mmdmf is 1 then the result of the multiply is undefined the64bitproductiszeroextendedto72bitsandsubtractedfromtheconcatenation mdh390 mdl310 ignoring mdl3932 the lower 32 bits of the result are zero extended to 40bits and stored into mdl the upper 40bits of the result are stored into mdh dual multiplysub optional saturationmsuba2s md mdh mdl rs rt the contents of register rs is multiplied by rt and subtracted from an accumulator register treating the operands as signed 2s complement values if the destination register is mdh rs3116 is multiplied by rt3116 then signextended and subtracted from mdh3900 if the destination register is mdl rs1500 is multiplied by rt1500 then signextended and subtracted from mdl3900 if the destination ismdbothoperationsareperformedandbothresultsarestoredintheaccumulator register pair md if msuba2s the result of each subtraction is saturated before storage in the accumulator register add accumulatorsaddmasmdhl mshl mthl the contents of accumulator mth or mtl is added to the contents of accumulator msh or msl treating both registers as signed 40bit values mdh or mdl is updated with the result if addmas the result is saturated before storage the saturation point is selected as either 40 or 32 bits by mmdms subtract accumulatorssubmas md hl mshl mthl the contents of accumulator mth or mtl is subtracted from the contents of accumulatormshormsltreatingbothregistersassigned40bitvaluesmdhormdl is updated with the result if submas the result is saturated before storagethe saturation point is selected as either 40 or 32 bits by mmdmsinstruction syntax and descriptionapril 30 2001 lx5280 lexra proprietary confidential 46 release 19 nomenclature 512 cyclebycycle usage for dual mac instructions the dual mac eliminates all programming hazards for its instructions by stalling the pipeline when necessary it does this both to avoid resource conflicts and to wait for results of first instruction to be ready before attempting to use those results in second instruction this means that there are programming restrictions in order to obtain correct results from sequence of dual mac instructions howeverthemostefficientuseofthedualmachardwareisobtainedwhentheprogramavoidsthesestalls this can be done by scheduling the instructions properly table52 on page123 indicates the number of cycles that must be present between mac instructions to avoid stalls in addition several instruction sequences are presented that represent the most efficient use of the dual mac for the inner loop of some common dsp algorithms typically these make use of the multiple accumulators in the dual mac the following code sequences indicate the most efficient use of the dual mac for coding the inner loop of somecommondspalgorithmsthealgorithmsarepresentedfor16bitoperandswith16bitresultsaswell as32bitoperandswith32bitresultsthealgorithmsassumethatfractionalarithmeticisusedthereforefor the 32bit results of 32x32 multiply only the hi half of the target accumulator pair is retrieved or used in these examples only the dual mac instructions are shown the other pipe is used to fetch and store operands and take care of loop housekeeping functions the loops may need to be unrolled to take full advantage of the multiple dual mac accumulators case 1 16bit inner product sum sum aibi assuming packed operands two multiplyadds per cycle madda2 m0r1r2 madda2 m0r3r4 madda2 m0r5r6 madda2 m0r7r8 case 2 16bit vector product loop ci aibi assuming packed fractional operands two multiplies per two cycles using two accumulator pairsdual round rnda2 mt mth mtl n the accumulator register mth or mtl is rounded then updated if mt the accumulator register pair mthmtl are each rounded then updated the rounding mode is selected in mmd field rnd the least significant bit of precision in the accumulatorregisterafterroundingis16nbits15n00arezeroedtherangen 0 8 is permitted for the output alignment shift amount in the case of n 0 the field may be omitted rs rt r0 r31 md mdh mdl also for mt mdh m0h m3h also for msh mth mdl m0l m3l also for msh mth hi m0h3100 m0l3100instruction syntax and descriptionapril 30 2001 lx5280 lexra proprietary confidential 47 release 19 multa2 m0r1r2 mfa2 m1r8 multa2 m1r3r4 mfa2 m0r7 case 3 16bit complex vector product ci ai complex bi assuming fractional operands packed as 16bit real 16bit imaginary one complex multiply every two cycles using two accumulator pairs cmulta m0r1r2 mfa2 m1r8 cmulta m1r3r4 mfa2 m0r7 case 4 32bit inner product loop sum sum aibi achieves multiplyaccumulate every other cycle using one accumulator madda m0 r1 r2 nondualmac op madda m0 r3 r4 nondualmac op case 5 32bit vector product loop ci aibi assuming fractional 32bit operands so that the mfa waits for the hi result of the multa achieves one multiply per two cycles using all the accumulators multa m0 r1 r2 mfa r9 m1h multa m1 r3 r4 mfa r10m2h multa m2 r5 r6 mfa r11m3h multa m3 r7 r8 mfa r12m0h case 6 32bit complex vector product ci ai complex bi assuming fractional 32bit operands so that the addmasubma waits for the hi result of the second multa achieves one complex multiply per ten cycles using all the accumulators with two inserted instructions this is good example of the cycles needed from multa to submaaddma 5 cycles for hi and from submaaddma to mfa 2 cycles multa m0 r1 r4 a2i b2i1 mfa rimag m1h multa m1 r2 r3 a2i1 b2i subma m3hm2hm3h c2i2 a2i2b2i2 a2i1b2i1 nondualmac op multa m2 r1 r3 a2i b2i mfa rreal m3hapril 30 2001 lx5280 lexra proprietary confidential 48 release 19 multa m3 r2 r4 a2i1 b2i1 addma m1hm0hm1h c2i1 a2i1b2i a2ib2i1 nondualmac op 513 vector addressing instructions table 21 vector addressing instructions instruction syntax and description load twinword lt rt displacementbase the displacement in bytes is signed 14bit quantity that must be divisible by 8 sinceitoccupiesonly11bitsoftheinstructionwordsignextendthedisplacement to 32bits and add to the contents of register base to form the address temp load contents of word addressed by temp into register rt which must be an even register load contents of word addressed by temp4 into register rt1 store twinword st rt displacementbase the displacement in bytes is signed 14bit quantity that must be divisible by 8 sinceitoccupiesonly11bitsoftheinstructionwordsignextendthedisplacement to 32bits and add to the contents of register base to form the address temp store contents of register rt which must be an even register into word addressed by temp store contents of register rt1 into word addressed by temp4 load twinword pointer increment optional circular bufferltpcn rt pointerstride lettemp contents of register pointer load contents of word addressed by temp into register rt which must be an even register load contents of word addressed bytemp4intoregisterrt1thestrideinbytesisasigned11bitquantitythatmust bedivisibleby8sinceitoccupiesonly8bitsoftheinstructionwordsignextendthe strideto32bitsandaddtocontentsofregister pointertoformnextaddressupdate pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 load word pointer increment optional circular bufferlwpcn rt pointerstride load contents of word addressed by register pointer into register rt the stride in bytes is signed 10bit quantity that must be divisible by 4 since it occupies only 8 bits of the instruction word signextend the stride to 32bits and add to contents of registerpointertoformnextaddressupdate pointerwiththecalculatednextaddress cn selects circular buffer n 0 2 see note 2 load halfword pointer increment optional circular bufferlhpcn rt pointerstride load contents of signextended halfword addressed by register pointer into register rt the stride in bytes is signed 9bit quantity that must be divisible by 2 since it occupiesonly8bitsoftheinstructionwordsignextendthestrideto32bitsandadd to contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 load halfword unsigned pointer increment optional circular bufferlhpucn rt pointerstride load contents of zeroextended halfword addressed by register pointer into register rt the stride in bytes is signed 9bit quantity that must be divisible by 2 since it occupiesonly8bitsoftheinstructionwordsignextendthestrideto32bitsandadd to contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 load byte pointer increment optional circular bufferlbpcn rt pointerstride load contents of signextended byte addressed by register pointer into register rt the stride in bytes is signed 8bit quantity signextend the stride to 32bits and add to contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2april 30 2001 lx5280 lexra proprietary confidential 49 release 19 nomenclature notes 1 for ltpcn lwpcn lhpucn lbpucn rt pointer is unsupported 2 when circular buffer is selected the update of the pointer register is performed according to the following algorithm which depends on the sign of the stride and the granularity of the access stride exactly equal to 0 is not supportedload byte unsigned pointer increment optional circular bufferlbpucn rt pointerstride load contents of zeroextended byte addressed by register pointer into register rt the stride in bytes is signed 8bit quantity signextend the stride to 32bits and add to contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 store twinword pointer increment optional circular bufferstpcn rt pointerstride lettemp contents of register pointer store contents of register rt which must be an even register into word addressed by temp store contents of register rt1 into wordaddressedby temp4thestrideinbytesisasigned11bitquantitythatmust bedivisibleby8sinceitoccupiesonly8bitsoftheinstructionwordsignextendthe stride to 32bits and add to contents of register pointer to form next addressupdate pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 store word pointer increment optional circular bufferswpcn rt pointerstride store contents of register rt into word addressed by register pointer the stride in bytes is signed 10bit quantity that must be divisible by 4 since it occupies only 8 bits of the instruction word signextend the stride to 32bits and add to contents of registerpointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 store halfword pointer increment optional circular buffershpcn rt pointerstride storecontentsofregisterrt1500into16bithalfwordaddressedbyregister pointer the stride in bytes is signed 9bit quantity that must be divisible by 2 since it occupiesonly8bitsoftheinstructionwordsignextendthestrideto32bitsandadd to contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 store byte pointer increment optional circular buffersbpcn rt pointerstride store contents of register rt0700 into byte addressed by register pointer the strideinbytesisasigned8bitquantitysignextendthestrideto32bitsandaddto contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 move to radiax user mtru rt radreg move the contents of register rt to one of the user radiax registers cbs0 cbs2 cbe0cbe2mmdlpc0lpe0lps0thisinstructionhasasingledelayslotbeforethe mmd register takes effect all other registers have delay slot move from radiax user mfru rt radreg movethecontentsofthedesignateduserradiaxregistercbs0cbs2cbe0cbe2 mmd lpc0 lps0 lpe0 to register rt rt r0 r31 and must be even for lt st ltpcn stpcn base pointer r0 r31 stride 891011bit signed value in bytes for bytehalfword wordtwinword ops displacement 14bit signed value in bytes radreg cbs0 cbs2 cbe0 cbe2 mmd lpc0 lps0 lpe0instruction syntax and descriptionapril 30 2001 lx5280 lexra proprietary confidential 50 release 19 lbpucn and sbpcn if stride 0 pointer20 111 pointer313 cben tpointer cbsn313 3b000 else if stride 0 pointer20 000 pointer313 cbsn pointer cben313 3b111 else pointer pointer stride lhpucn and shpcn if stride 0 pointer20 11x pointer313 cben pointer cbsn313 3b000 else if stride 0 pointer20 00x pointer313 cbsn pointer cben313 3b110 else pointer pointer stride lwpcn and swpcn if stride 0 pointer20 1xx pointer313 cben pointer cbsn313 3b 000 else if stride 0 pointer20 0xx pointer313 cbsn pointer cben313 3b100 else pointer pointer stride ltpcn and stpcn if stride 0 pointer313 cben pointer cbsn313 3b000 else if stride 0 pointer313 cbsn pointer cben313 3b000 else pointer pointer stride 514 radiax alu operations theradiaxaluoperationsincludebothdual16bitandsaturatingversionsofthemips1aluoperations and several new alu operations which are useful for common dsp algorithms table 22 radiax alu operations instruction syntax and description dual shift left logical variablesllv2 rd rt rs thecontentsofrt3116andthecontentsofrt1500areindependentlyshiftedleft by the number of bits specified by the low order four bits of the contents of general register rs inserting zeros into the low order bits of rt3116 and rt1500 for sllv2 the high and low results are concatenated and placed in register rd note that s option is not provided because this is logical rather than arithmetic shift and thus the concept of arithmetic overflow is not relevantapril 30 2001 lx5280 lexra proprietary confidential 51 release 19 dual shift right logical variablesrlv2 rd rt rs the contents of rt3116 and the contents of rt1500 are independently shifted right by the number of bits specified by the low order four bits of the contents of generalregisterrsinsertingzerosintothehighorderbitsofrt3116andrt1500 thehighandlowresultsareconcatenatedandplacedinregisterrdnotethatas option is not provided because this is logical rather than arithmetic shift and thus the concept of arithmetic overflow is not relevant dual shift right arithmetic variablesrav2 rd rt rs the contents of rt3116 and the contents of rt1500 are independently shifted right by the number of bits specified by the low order four bits of the contents of generalregisterrssignextendingthehighorderbitsofrt3116andrt1500the high and low results are concatenated and placed in register rd note that s option is not provided because arithmetic overflowunderflow is not possible add optional saturationaddrs rd rs rt 32bit addition considering both quantities as signed 32bit integers add the contents of register rs to rt for addr the result is placed in register rd ignoring anyoverfloworunderflowforaddrstheresultissaturatedto0131ifoverflow or1031ifunderflowthenplacedinrdaddrswillnotcauseanoverflowtrap dual add optional saturationaddr2srd rs rt dual 16bit addition considering all quantities as signed 16bit integers add the contents of register rs1500 to rt1500 and independently add the contents of register rs3116 to rt3116 for addr2 the high and low results are concatenated and placed in register rd ignoring any overflow or underflow for addr2s the two results are independently saturated to 0 115 if overflow or 1 015 if underflow then placed in rd addr2s will not cause an overflow trap subtract optional saturationsubrs rd rs rt 32bitsubtractionconsideringbothquantitiesassigned32bitintegerssubtractthe contentsofregisterrtfromthecontentsofregisterrsforsubrtheresultisplaced inregisterrdignoringanyoverfloworunderflowforsubrstheresultissaturated to 0 131 if overflow or 1 031 if underflow then placed in rd subrs will not cause an overflow trap dual subtract optional saturationsubr2srd rs rt dual 16bit subtraction considering all quantities as signed 16bit integers subtract the contents of register rt1500 from rs1500 and independently subtract the contents of register rt3116 from rs3116 for subr2 the high and low results are concatenated and placed in register rd ignoring any overflow or underflow for subr2s the two results are independently saturated to 0 115 if overflow or 1 015 if underflow then placed in rd subr2s will not cause an overflow trap dual set on less than sltr2 rd rs rt dual 16bit comparison considering both quantities as signed 16bit integers if rs1500 is less than rt1500 then set rd1500 to 015 1 else to zero independently considering both quantities as signed 16bit integers if rs3116 is less than rt3116 then set rd3116 to 015 1 else to zero minimum min rd rs rt the contents of the general register rt are compared with rs considering both quantities as signed 32bit integers if rs rt or rs rt rs is placed into rd if rs rt rt is placed into rd dual minimum min2 rd rs rt thecontentsofrt3116arecomparedwithrs3116consideringbothquantitiesas signed 16bit integers if rs3116 rt3116 or rs3116 rt3116 rs3116 is placed into rd3116 if rs3116 rt3116 rt3116 is placed into rd3116 similar independent operation is performed on rt1500 and rs1500 to determine rd1500instruction syntax and descriptionapril 30 2001 lx5280 lexra proprietary confidential 52 release 19 515 conditional operations the lx5280 provides conditional move instructions that reduce the need for program branches resulting in greater program efficiency table 23 conditional operationsmaximum max rd rs rt the contents of the general register rt are compared with rs considering both quantities as signed 32bit integers if rs rt or rs rt rs is placed into rd if rs rt rt is placed into rd dual maximum max2 rd rs rt thecontentsofrt3116arecomparedwithrs3116consideringbothquantitiesas signed 16bit integers if rs3116 rt3116 or rs3116 rt3116 rs3116 is placed into rd3116 if rs3116 rt3116 rt3116 is placed into rd3116 similar independent operation is performed on rt1500 and rs1500 to determine rd1500 absolute optional saturationabsrs rd rt consideringrtasasigned32bitintegerifrt0rtisplacedintordifrt0rtis placed into rd if absrs and rt 1 031 the smallest negative number then 0 131 the largest positive number is placed into rd otherwise if absr and rt 1 031 rt is placed into rd dual absolute optional saturationabsr2s rd rt abss operations are performed independently on rt3116 and rt1500 considering each to be 16bit signed integers rd is updated with the absolute value of rt3116 concatenated with the absolute value of rt1500 dual mux mux2hh hl lh ll rd rs rt rd3116 is updated with rs3116 for mux2hh or mux2hl rd3116 is updated with rs1500 for mux2lh or mux2ll rd1500 is updated with rt3116 for mux2hh or mux2lh rd1500 is updated with rt1500 for mux2hl or mux2ll count leading sign bits cls rd rt the binaryencoded number of redundant sign bits of general register rt is placed into rd if rt3130 10 or 01 rd is updated with 0 if rt 0 or if rt 132 rd is updated with 027 15 decimal 31 bit reverse bitrev rd rt rs bitreversal of the contents of general register rt is performed the result is then shifted right logically by the amount specified in the lower 5bits of the contents of general register rs then stored in rd instruction syntax and description conditional move on equal zerocmveqzh lrd rs rt if the general register rt is equal to 0 the general register rd is updated with rs otherwise rd is unchanged for h if rt3116 is equal to 0 the full 32bit general register rd3100 is updated with rs otherwise rd is unchanged for l if rt1500 isequalto0the full32bitgeneralregisterrd3100isupdatedwithrsotherwiserd is unchangedinstruction syntax and descriptionapril 30 2001 lx5280 lexra proprietary confidential 53 release 19 usage note when combined with the slt or sltr2 instructions the conditional move instructions can be used to construct complete set of conditional move macrooperations for example 52 instruction encoding 521 lexra formats the lexra formats are introduced into the mips instruction set by designating single iformat as lexopthenusingtheinst50subopfieldtopermitupto64newlexraopcodesthusthenewdsp opcodesmodelthemipsspecialopcodesencodedinrformatthediagramsbelowillustratethelexop codes using iformat 011_111 which is unused in the mips iiv isa thefollowingprinciplesareusedtoresolvepotentialambiguityofencodingbetweenthenewlx5280dsp extensions and mips instructions lx5280instructionswithsimilaroperationstoexistingmipsinstructionsbutwithadditionaloperands permitted are programmed with new assembler mnemonics and encoded as lexop for instance b if mips instruction is extended with new functionality it is programmed with new assembler mnemonics and encoded as lexop lexra mnemonics which end in r indicate general register file targets mnemonics which end in indicate accumulator register targets this convention removesconditional move on not equal zerocmvnezh lrd rs rt if the general register rt is not equal to 0 the general register rd is updated with rs otherwise rd is unchanged for h if rt3116 is not equal to 0 the full 32bit general register rd3100 is updated with rs otherwise rd is unchanged for l if rt1500isnotequalto0the full32bitgeneralregisterrd3100isupdatedwithrs otherwise rd is unchanged if r3 r4 r1 r2 cmvlt r1r2r3r4 slt atr3r4 cmvnez r1r2at if r3 r4 r1 r2 cmvge r1r2r3r4 slt atr3r4 cmveqz r1r2at if r3 r4 r1 r2 cmvle r1r2r3r4 slt atr4r3 cmveqz r1r2at if r3 r4 r1 r2 cmvgt r1r2r3r4 slt atr4r3 cmvnez r1r2at multa m1 r1 r2 is encoded as lexop instruction mult r1 r2 is encoded as mips instruction multa m0 r1 r2 isencodedasalexopinstruction m0isanaliasforhiloinstruction syntax and descriptionapril 30 2001 lx5280 lexra proprietary confidential 54 release 19 ambiguity between the lexra op and similar mips op for example the mips addand the lexop addrare both signed 32bit additions however on overflow the mips instruction triggers the overflow exception while the lexop does not alternatively the result of the lexop will saturate if the s option is selected addrs 53 loadstore formatsaddr r3 r1 r2 is encoded as lexop instruction add r3 r1 r2 is encoded as mips instruction 31 26 25 21 20 16 15 6 5 0 assembler mnemoniclexop 011 111 base rt immediatelexra subop lt lexop base rteven displacement8 lt st lexop base rteven displacement8 st 65 5 1 0 6 31 26 25 21 20 16 15 8 7 6 5 0 assembler mnemoniclexop 011 111 base rt immediate cclexra subop lbpcn lexop pointer rt stride cc lbp lbpucn lexop pointer rt stride cc lbpu lhpcn lexop pointer rt stride2 cc lhp lhpucn lexop pointer rt stride2 cc lhpu lwpcn lexop pointer rt stride4 cc lwp ltpcn lexop pointer rt stride8 cc ltp sbpcn lexop pointer rt stride cc sbp shpcn lexop pointer rt stride2 cc shp swpcn lexop pointer rt stride4 cc swp stpcn lexop pointer rt stride8 cc stp 65 5 8 2 6april 30 2001 lx5280 lexra proprietary confidential 55 release 19 base pointer rt selects general register r0 r31 rteven selects general register evenodd pair r0r1 r2r3 r30r31 stride signed 2scomplement number in bytes must be an integral number of halfwordswordstwinwords for the corresponding instructions displacement signed 2scomplement number in bytes must be an integral number of twinwords cc 00 select circular buffer 0 cbs0 cbe0 01 select circular buffer 1 cbs1 cbe1 10 select circular buffer 2 cbs2 cbe2 11 circular buffer selectedapril 30 2001 lx5280 lexra proprietary confidential 56 release 19 531 arithmetic format 31 26 25 21 20 16 15 11 10 9 8 7 6 5 0 assembler mnemoniclexop 011 111 rs rt rd hl 0 s dlexra subop addrsaddr2s lexop rs rt rd 0 0 s d addr subrs subr2s lexop rs rt rd 0 0 s d subr sltr2 lexop rs rt rd 0 0 0 1 sltr sllv2 lexop rs rt rd 0 0 0 1 sllv srlv2 lexop rs rt rd 0 0 0 1 srlv srav2 lexop rs rt rd 0 0 0 1 srav min min2 lexop rs rt rd 0 0 0 d min max max2 lexop rs rt rd 0 0 0 d max absrs absr2s lexop 0 rt rd 0 0 s d absr mux2lllhhlhh lexop rs rt rd hl 0 0 1 mux cls lexop 0 rt rd 0 0 0 0 cls bitrev lexop rs rt rd 0 0 0 0 bitrev 65 5 5 2 111 6 rs rt rd selects general register r0 r31 s selects saturation of result s1 indicates that saturation is performed d d1 indicates that dual operations on 16bit data are performed hl for mux2 00 ll rd rs1500 rt1500 01 lh rd rs1500 rt3116 10 hl rd rs3116 rt1500 11 hh rd rs3116 rt3116april 30 2001 lx5280 lexra proprietary confidential 57 release 19 532 mac format 31 26 25 21 20 16 15 11 10 9 8 5 6 5 0 assembler mnemoniclexop 011 111 rs rt md 0 u gz s dlexra subop cmulta lexop rs rt md 0 0 0 0 0 cmulta divau lexop rs rt md 0 u 0 0 0 diva multau lexop rs rt md 0 u 1 0 0 madda multa2 lexop rs rt md 0 0 1 0 1 madda maddau lexop rs rt md 0 u 0 0 0 madda madda2s lexop rs rt md 0 0 0 s 1 madda msubau lexop rs rt md 0 u 0 0 0 msuba msuba2s lexop rs rt md 0 0 0 s 1 msuba mulna2 lexop rs rt md 0 0 1 0 1 msuba mta2g lexop rs rt md 0 0 g 0 1 mta 65 5 5 11111 6 base pointer rtselects general register r0 r31 rs rt selects general register r0 r31 md selects accumulator 0nnhl where nn m0 m3 hl 00 reserved 01 mnl 10 mnh 11 mn s selects saturation of result s1 indicates that saturation is performed d d1 indicates that dual operations on 16bit data are performed gz for mta2 used as guard bit if g1 bits 3932 of the accumulator pair are loaded and bits 3100 are unchanged if g0 all 40 bits 3900 of the accumulator or pair are updated for madda msuba used as zero bit if z 1 the result is added to subtracted from zero rather than the previous accumulator value this performs multa multa2 or mulna2 if z 0 performs madda msuba madda2 or msuba2 u treat operands as unsigned values 0 signed 1 unsignedapril 30 2001 lx5280 lexra proprietary confidential 58 release 19 533 mac format b 31 26 25 21 20 16 15 11 10 7 6 5 0 assembler mnemoniclexop 011 111 00000 mt rd so dlexra subop mfa mfa2 lexop 000000 mt rd so d mfa rnda2 lexop 000000 mt 0 so 1 rnda 65 5 5 4 1 6 rd selects general register r0 r31 mt selects accumulator 0nnhl where nn m0 m3 hl 00 reserved 01 mnl 10 mnh 11 mn d d1 indicates that dual operations on 16bit data are performed so encoded output shift amount n 0 8 for rnda2 mfa mfa2 instructionsapril 30 2001 lx5280 lexra proprietary confidential 59 release 19 534 mac format c 535 radiax move format and lexracop0 mtlxc0mflxc031 26 25 21 20 16 15 11 10 8 7 6 5 0 assembler mnemoniclexop 011 111 ms mt md 000 s 0lexra subop addmas lexop ms mt md 000 s 0 addma submas lexop ms mt md 000 s 0 subma 65 5 5 3 11 6 mt ms md selects accumulator 0nnhl where nn m0 m3 hl 00 reserved 01 mnl 10 mnh 11 reserved s selects saturation of result s1 indicates that saturation is performed 31 26 25 21 20 16 15 11 10 8 7 6 5 0 assembler mnemoniclexop 011 111 00000 rt rurk 000 k 0lexra subop mfru lexop 00000 rt ru 000 0 0 mfrad mtru lexop 00000 rt ru 000 0 0 mtrad mfrk lexop 00000 rt rk 000 1 0 mfrad mtrk lexop 00000 rt rk 000 1 0 mtrad 65 5 5 3 11 6 rt selects general register r0 r31 rk selectsradiaxkernelregisterinmfrkmtrkinstructions currently all reserved however coprocessor unusable exception is taken in user mode if the cu0 bit is 0 in the cp0 status register when mfrk or mtrk is executed ru selects radiax user register in mfru mtru instructions 00000 cbs0 00001 cbs1 00010 cbs2 00011 reserved 00100 cbe0 00101 cbe1 00110 cbe2 00111 reserved 01xxx reserved 10000 lps0 10001 lpe0 10010 lpc0april 30 2001 lx5280 lexra proprietary confidential 60 release 19 these are notlexop instructions they are variants of the standard mtc0 and mfc0 instructions that allow access to the lexra coprocessor0 registers listed below as with any cop0 instruction coprocessor unusable exception is taken in user mode if the cu0 bit is 0 in the cp0 status register when these instructions are executed 1001 reserved 101xx reserved 11000 mmd 11001 reserved 111xx reserved 31 26 25 21 20 16 15 11 10 0 assembler mnemoniccop0 010 000 copz rs rt rd 000 0000 0000 mflx cop0 00011 rt rd 000 0000 0000 mtlx cop0 00111 rt rd 000 0000 0000 65 5 5 1 1 rt selects general register r0 r31 rd selects lexra coprocessor0 register 00000 estatus 00001 ecause 00010 intvec 00011 reserved 001xx reserved 01xxx reserved 1xxxx reservedapril 30 2001 lx5280 lexra proprietary confidential 61 release 19 536 cmove format 537 lexra subop bit encodings indicates instructions which are implemented only in the lx5280 and not the lx5180 product31 26 25 21 20 16 15 11 10 9 8 6 5 0 assembler mnemoniclexop 011 111 rs rt rd 00 condlexra subop cmveqzhl lexop rs rt rd 00 cond cmove cmvnezhl lexop rs rt rd 00 cond cmove 6555 2 3 6 rs rt rd selects general register r0 r31 cond condition code for rt operand referenced by the conditional move 000 eqz 001 nez 010 eqzh 011 nezh 100 eqzl 101 nezl 11x reserved inst20 inst53 01234567 0 cmove sllv srlv srav 1 bitrev mux cls absr 2 madda msuba rnda 3 diva cmulta mfa mta addma subma 4 addr subr mfrad mtrad 5 min max sltr 6 lbp lhp ltp lwp lbpu lhpu lt 7 sbp shp stp swp stapril 30 2001 lx5280 lexra proprietary confidential 62 release 19 april 30 2001 lx5280 lexra proprietary confidential 63 release 19 6 integer multiplydivideaccumulate the integer multiplydivideaccumulate instructions which are optional on other lexra processors are standard feature of the lx5280 processor 61summary of instructions table24 provides summary of the integer multiplydivideaccumulate instructions table 24 summary of macdiv instructions mnemonic operation description mthi hi rs preload accumulator or restore saved hi mtlo rs preload accumulator or restore saved mfhi rd hi read accumulator or part of 64 bit result mflo rd read accumulator or part of 64 bit result mult hilo rs rt 32x32 signed multiply 64bit result multu hilo rs rt 32x32 unsigned multiply 64bit result mad hilo hilo rs rt 32x32signedmultiplywith64bitsignedadd to accum madu hilo hilo rs rt 32x32 unsigned multiply with 64bit unsigned add to accum msub hilo hilo rs rt 32x32signedmultiplywith64bitsignedadd to accum msubu hilo hilo rs rt 32x32 unsigned multiply with 64bit unsigned add to accum madh hi hi rs150 rt150 16x16 signed multiply with 32 bit signed add to accum madl lolors150rt150 16x16 signed multiply with 32 bit signed add to accum mazh hi 0 rs150 rt150 16x16 signed multiply add to prezeroed 32bit accum mazl 0 rs150 rt150 16x16 signed multiply add to prezeroed 32bit accum msbh hi hi rs150 rt150 16x16 signed multiply with 32 bit signed sub from accum msbl rs150 rt150 16x16 signed multiply with 32 bit signed sub from accum mszh hi 0 rs150 rt150 16x16 signed multiply sub from prezeroed 32bit accum mszl 0 rs150 rt150 16x16 signed multiply sub from prezeroed 32bit accum div hi rsrt rsrt 32 by 32 signed divide with remainder divu hi rsrt rsrt 32 by 32 unsigned divide with remainderapril 30 2001 lx5280 lexra proprietary confidential 64 release 19 the processor may stall if new mac instruction is executed while prior mac operation is pending table52onpage123indicatesthenumberofcyclesthatmustbepresentbetweenmacinstructionstoavoid stalls 62 macdiv instruction overview all ops except movetoaccumulator and 32bit multiplyaccumulate functions are supported in m16 mode as well as m32 for best code compression independent 32bit hi and accumulators for 16bit multiplyaccumulate allow optimal performance in the fir filter or other applications which allow generation of new result while the previous result is pending multiplysubtract instructions eliminate the need to negate coefficients in case of resource conflicts hardware manages all hazards simplifying software debug there are coding restrictionsapril 30 2001 lx5280 lexra proprietary confidential 65 release 19 63opcodes for standard mode 32bit mac instructions 31 26 25 21 20 16 15 6 5 0 mnemonic major op base rt immediate subop mfhi 000000 rs rt 0000000000 010000 mthi 000000 rs rt 0000000000 010001 mflo 000000 rs rt 0000000000 010010 mtlo 000000 rs rt 0000000000 010011 mult 000000 rs rt 0000000000 011000 multu 000000 rs rt 0000000000 011001 mad 011100 rs rt 0000000000 00000 madu 011100 rs rt 0000000000 000001 msub 011100 rs rt 0000000000 000100 msubu 011100 rs rt 0000000000 000101 div 000000 rs rt 0000000000 011010 divu 000000 rs rt 0000000000 011011 madh 111100 rs rt 0000000000 000000 madl 111100 rs rt 0000000000 000010 mazh 111100 rs rt 0000000000 000100 mazl 111100 rs rt 0000000000 000110 msbh 111100 rs rt 0000000000 010000 msbl 111100 rs rt 0000000000 010010 mszh 111100 rs rt 0000000000 010100 mszl 111100 rs rt 0000000000 010110 655 1 0 6april 30 2001 lx5280 lexra proprietary confidential 66 release 19 64opcodes for mips16 16bit mode mac instructions 15 11 10 8 7 5 4 0 mnemonic major op base rt subop mfhi 11101 rx ry 10000 mthi not supported by mips16 architecture mflo 11101 rx ry 10010 mtlo not supported by mips16 architecture mult 11101 rx ry 11000 multu 11101 rx ry 11001 mad not supported by mips16 architecture madu not supported by mips16 architecture msub not supported by mips16 architecture msubu not supported by mips16 architecture div 11101 rx ry 11010 divu 11101 rx ry 11011 madh 11111 rx ry 00000 madl 11111 rx ry 00010 mazh 11111 rx ry 00100 mazl 11111 rx ry 00110 msbh 11111 rx ry 10000 msbl 11111 rx ry 10010 mszh 11111 rx ry 10100 mszl 11111 rx ry 10110 533 5april 30 2001 lx5280 lexra proprietary confidential 67 release 19 65 nonstandard instruction descriptions table 25 16bit multiply and multiplyaccumulate instructions signed16bitmultiply to hilomazh rs rt mazl rs rt thecontentsofrs150ismultipliedbyrt150treatingtheoperandsassigned 2s complement values the 32bit product is stored in the hilo register hilo 0 rs rt signed 16bit multiply accumulate to hilomadh rs rt madl rs rt thecontentsofrs150ismultipliedbyrt150treatingtheoperandsassigned 2s complement values the 32bit product is added to hilo ignoring any overflow the result is stored in the hilo register hilo hilo rs rt signed 16bit multiply negate to hilomszh rs rt mszl rs rt thecontentsofrs150ismultipliedbyrt150treatingtheoperandsassigned 2scomplementvaluesthe32bitproductisnegatedsubtractedfromzeroand stored in the hilo register hilo 0 rs rt signed 16bit multiply subtract from hilomsbh rs rt msbl rs rt thecontentsofrs150ismultipliedbyrt150treatingtheoperandsassigned 2s complement values the 32bit product is subtracted from hilo ignoring any overflow the result is stored in the hilo register hilo hilo rs rtapril 30 2001 lx5280 lexra proprietary confidential 68 release 19 table 26 32bit multiplyaccumulate instructions notes the 32bit opcodes are unchanged from the mipsi standard for the existing mult div mf and mt instructions the mad madu msub and msubu are new special2 opcodes also standard to several processors in m32 mode the new instructions are all rformat with bits 3126 6b111100 bits 50 determine the specific operation as shown in m16 mode the new instructions are all rrformat with bits 1511 5b11111 bits 40 determine the specific operation as shown in section64 the upper 16 bits of both operand registers are ignored by 16bit instructions the mxxh and mxxl instructions can be freely interleaved that is adds and subtracts from either accumulator can be combined in sequence with the two accumulators functioning in parallel the mxzx instructions can be used as standalone 16bit signed multiply this removes the need for mthi zero instruction at the beginning of multiplyaccumulate sequence for examplesigned 32bit multiply accumulatemad rs rt the contents of rs is multiplied by rt treating the operands as signed 2s complementvaluesthe64bitproductisaddedtotheconcatenationhiandlo toforma64bitresultignoringanyoverflowtheupper32bitsofthe64bitresult are stored in the hi register the lower 32bits are stored in the register t hilo rs rt t310 hi t6332 32bit multiply accumulatemadu rs rt the contents of rs is multiplied by rt treating the operands as unsigned values the64bitproductisaddedtotheconcatenationhiandlotoforma64bitresult ignoring any overflow the upper 32bits of the 64bit result are stored in the hi register the lower 32bits are stored in the register t hilo rs rt t310 hi t6332 signed 32bit multiply subtractmsub rs rt the contents of rs is multiplied by rt treating the operands as signed 2s complement values the 64bit product is subtracted from the concatenation hi and to form 64bit result ignoring any overflow the upper 32bits of the 64 bit result are stored in the hi register the lower 32bits are stored in the register t hilo rs rt t310 hi t6332 32bit multiplysubtract msubu rs rt the contents of rs is multiplied by rt treating the operands as unsigned values the 64bit product is subtracted from the concatenation hi and to form 64 bitresultignoringanyoverflowtheupper32bitsofthe64bitresultarestoredin the hi register the lower 32bits are stored in the register t hilo rs rt t310 hi t6332april 30 2001 lx5280 lexra proprietary confidential 69 release 19 mazh r1r2 madh r3r4 madh r5r6 madh r7r8 any op that doesnt write hi any op that doesnt write hi mfhi r9 intheabovesequencethetwononhiopsarenotnecessaryforcorrectoperationbutthepipelinewillstallif they are not used so it is more efficient to perform useful work in those slots for the multx madx or msubx instructions the most efficient use is multx r1r2 madx r3r4 msubx r5r6 any op that doesnt write hi or any op that doesnt write hi or any op that doesnt write hi or mflo r7 or hi is available this cycle mfhi r8 66accessing hi and after multiply instructions the mflo mfhi instruction reads the contents of the hi register during the cycle of the pipeline the following descriptions indicate how the latency of the multiply instructions affects the usage of the mf instructions the most efficient sequence is shown if the mf instruction is coded earlier the correct result will still be obtained because the hardware will stall the mf instruction in the ecycle until the result is valid during the cycle of any multiply operation the initial operands are recoded and loaded into the mandhw and mierhw mbooth registers for the multx operations the multiply cycles can be labeled m1 through m3 then the following timing diagram is valid multx i s m1 m2 m3 lohi valid x any op i s m w any op i s m w mflo i s m w or mfhi i s m w for the madx operations the pipeline cycles after can be labeled as c carry save and accumulate then the following timing diagram is valid mazh0 i s c madh1 i s c madh2 i s c madh3 i s c any op i s m w any op i s m w mfhi i s m w hi contains a0 a1 a2 a3april 30 2001 lx5280 lexra proprietary confidential 70 release 19 67divider overview and register usage given dividend dend and divisor dvsr the divider generates quotient quot and remainder rem that satisfy the following conditions regardless of the signs of dend and dvsr dend dvsr quot rem 0 absrem absdvsr where rem and dend have the same sign itisworthnotingthattherequirementthatremanddendhavethesamesignisnotuniversallyacceptedif dend and dvsr are not both positive for example the modula3 language expects 5div32 5mod31 whereas the divider generates quot1 rem2 in agreement with fortran and others these examples show the possible combinations of signs dend dvsr quot rem 19 5 3 4 19 5 3 4 19 5 3 4 19 5 3 4 the divider is an iterative circuit that generates 2 quotient bit per cycle with an additional 3 cycles required due to pipelining considerations thus the pipeline flow of division instruction and the most efficient subsequent read of the quotient using mflo is as shown in the following diagram assuming that all the intervening instructions complete in one cycle if the mflo is issued earlier it will stall until the divide completes less than 19 instructions may be issuedifsomeofthemtakemorethanonecycletocompleteduetocachemissesordatadependentstallsfor example div i s d0 d1 d2 d17 d18 18 cycles mflo i s m wapril 30 2001 lx5280 lexra proprietary confidential 71 release 19 7 lx5280 local memory 71 local memory overview thischapterdescribeshowmemoriesareconfiguredandconnectedtothelx5280usingthelocalmemory interfaces lmis this section provides brief summary of the conventions and supported memories section72 describes the control register that allows software control over certain aspects of the lmis the subsequent sections cover each of the lmis in detail this chapter also discusses configuration options and the ports that customers must access to connect application specific ram and rom devices that are used by the lx5280 lmis all of the signals between the processor core the lmis rams and the system bus controller are automatically configured by lconfig the lx5280 configuration tool lconfigalso produces documentation of the exact rams required for the chosen configuration settings and writes ram models used for rtl simulation thelmisconnecttoramsthatservicethelx5280processorslocalinstructionanddatabussesthelmis alsoprovidethepathwaysfromtheprocessortothesystembusthelx5280includesanlmiforeachofthe localmemorytypesthesizesoftheramsandromsarecustomerselectablethelx5280lmisdirectly support synchronous rams that register the address write data and control signals at the ram inputs the lmisalsosupplyredundantreadenableandchipselectlinesforeachramwhichmayberequiredforsome ram types roms may also be connected but may require customer supplied address register at the address inputs lexra supplies an integration layer for the lmis and the memory devices connected to them in this layer memory devices are instanced as generic modules satisfying the depth and width requirements for each specific memory instance the lconfigutility supplies summary of the memory devices required for the chosen configuration in most cases customers simply need to write wrapper that connects the generic module port list to technology specific ram instance inside the ram wrapper thelx5280isconfigurablefora163264or128bytecachelinesizethetagstoreramsizesshownin the tables of this chapter assume 16byte line size the documentation produced by lconfigindicates the required tag rams for the selected configuration options including the line size as general rule doubling of the line size results in halving the tag store depth thevalidbitswithintagstoresareautomaticallyclearedbythelmisuponresetthedatacacheimplements writethrough protocol caches do not snoop the system bus the lx5280 is configurable to work with rams with write granularity of 8 bits byte or 32 bits word byte write granularity results in more efficient operation of store byte and store halfword instructions table27 summarizes the lmis that can be integrated on the local busses table 27 local memory interface modules name description icache direct mapped or twoway set associative instruction cache imem instruction ram irom instruction rom dcache direct mapped data cache dmem data ram or romapril 30 2001 lx5280 lexra proprietary confidential 72 release 19 72 cache control register cctl cctl cp0 general register address 20 when reading this register the contents of the reserved bits are undefined when writing this register the contents of the reserved bits should be preserved changes in the contents of the cctl register are observed in the w stage however these changes affect instruction fetches currently in progress in the i stage and data load or store operations in progress in the m stage the iromon and iromoff bits of the cctl register control the and use of the optional local irom memory configured into the lx5280 when irom is present and the lx5280 is reset the lmi enables accesstotheiromatransitionfrom0to1oniromoffdisablestheiromallowinginstructionreferences to be serviced imem icache or the system bus transition from 0 to 1 on iromon enables the irom the imemfill and imemoff bits of the cctl register control the contents and use of any local imem memory configured into the lx5280 when the lx5280 is reset the lmi clears an internal register to indicate that the entire imem lmi contents are invalid when imem is invalid all cacheable fetches from the imem region will be serviced by the instruction cache if an instruction cache is present transition from 0 to 1 on imemfill causes the lmi to initiate series of line read operations to fill the imemcontentstheaddressesusedforthesereadsaredefinedbytheconfiguredbaseandtopaddresses oftheimemdescribedinsection74theprocessorstallswhiletheentireimemcontentsarefilledbythe lmi thereafter the lmi sets its internal imem valid bit and will service any access to the imem range from the local imem memory the time that an imem fill takes to complete is the number of line reads needed to fill the imem range multiplied by the latency of one line read assuming there is other system bus traffic transition from 0 to 1 on imemoff causes the lmi to clear its internal imem valid bit subsequent cacheable fetches from the imem region will be serviced by the instruction cache to use the imem again an application must reinitialize the imem contents through the imemfill bit of the cctl register theilockfieldcontrolssetlockinginthetwosetassociativeinstructioncachewhenilockis00or01the instructioncacheoperatesnormallywhenilockis10allcachedinstructionreferencesareforcedtooccupy set1thehardwarewillinvalidatelinesinset0ifnecessarytoaccomplishthiswhenilockis11linesinset 1 are never displaced ie they are locked in the cache set 0 is used to hold other lines as needed toutilizethecachelockingfeaturesoftwareshouldexecuteatleastonepassofcriticalsubroutinesorloops with ilock set to 10 after this has been done ilock should be set to 11 to lock the critical code into set 1 and use set 0 for other code the iinval and dinval fields control hardware invalidation of the instruction cache and data cache transition from 0 to 1 on iinval will initiate hardware invalidation sequence of the entire instruction cache likewisea0to1transitionondinvalwillinitiateahardwareinvalidationsequenceoftheentiredatacache the dmem if present is unaffected by this operation the hardware invalidation sequence for the instruction and data caches requires one cycle per cache line to complete depending on the circumstances software may be able to employ an alternative to full invalidation of the datacacheifasmallnumberoflinesmustbeinvalidatedsoftwaremayperformcachedreadsfromaliasesof318 7 6 5 4 32 1 0 reserved iromoff iromon imemoff imemfill ilock iinval dinvalapril 30 2001 lx5280 lexra proprietary confidential 73 release 19 thememorylocationsofconcernthisdisplacesdataintheaddressedlocationsofthedatacacheevenifthey do not encache the affected memory location anotheralternativeiftheaffectedmemorylocationhasanaliasinuncacheablekseg1spaceistosimply performanuncachedreadoftheaffectedmemorylocationsifthelocationisresidentinthedatacacheitwill be invalidated this method has the advantage of not displacing data in the cache unless it is absolutely necessary to maintain coherency note that write to kseg1 address has affect on the contents of the data cache with either of these two alternatives it is only necessary to reference one word of each affected cache line 73 instruction cache icache lmi the icache lmi supplies the interface for direct mapped or twoway set associative instruction cache attachedtothelx5280localbusthedegreeofassociativityisspecifiedthroughlconfigtheicachelmi participatesincacheableinstructionfetchesbutonlyiftheaddressisnotclaimedbytheimemmodulethe configurations supported by icache and the synchronous rams required for each are summarized in table28 theinstructionstoreforthetwowayicacheconsistsoftwo64bitwidebankswithseparatewriteenable controlsthetagstoreconsistsofonerambankwithtagandvalidbitsforset0andasecondramforset 1 that holds the tag valid lru least recently used and lock bits when miss occurs in the twoway icache the lru bit is examined to determine which element of the set to replace with element 0 being replacediflruis0andelement1beingreplacediflruis1thestateofthelrubitistheninvertedto optimize the timing of cache reads the twoway icache uses the state of the lru bit to determine which elementshouldbereturnedtothecpuinthefollowingcycletheicachedeterminesifthecorrectelement wasreturnedifnottheicachetakesanextracycletoreturnthecorrectelementtothecpuandinvertsthe lru bit table 28 icache conÔ¨Ågurations conÔ¨Åguration icache_inst ram icache_tag ram instruction cache ram required ram required 1k bytes 2way 2 x 64 x 64 bits 32 x 24 and 32 x 26 bits 2k bytes 2way 2 x 128 x 64 bits 64 x 23 and 64 x 25 bits 4k bytes 2way 2 x 256 x 64 bits 128 x 22 and 128 x 24 bits 8k bytes 2way 2 x 512 x 64 bits 256 x 21 and 256 x 23 bits 16k bytes 2way 2 x 1024 x 64 bits 512 x 20 and 512 x 22 bits 32k bytes 2way 2 x 2048 x 64 bits 1024x19and1024x21bits 64k bytes 2way 2 x 4096 x 64 bits 2048x18and2048x20bits 1k bytes direct mapped 128 x 64 bits 64 x 23 bits 2k bytes direct mapped 256 x 64 bits 128 x22 bits 4k bytes direct mapped 512 x 64 bits 256 x 21 bits 8k bytes direct mapped 1024 x 64 bits 512 x 20 bitsapril 30 2001 lx5280 lexra proprietary confidential 74 release 19 table29 lists the icache signals that are connected to application specific modules the ic_ prefix indicates signals that are driven by the icache lmi module and received by the rams the icr_ prefix indicates signals that are driven by the icache rams and received by the icache lmi lexra supplies the verilog module that makes all required connections to these wires the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from the table28 table 29 icache ram interfaces note n designates an available activelow version of signal16k bytes direct mapped 2048 x 64 bits 1024 x 19 bits 32k bytes direct mapped 4096 x 64 bits 2048 x 18 bits 64k bytes direct mapped 8192 x 64 bits 4096 x 17 bits signal description ic_tagindex tag and state ram address line icr_tagrd0 tag and state ram element 0 read path ic_tagwr0 tag and state ram element 0 write path icr_tagrd1 tag and state ram element 1 read path ic_tagwr1 tag and state ram element 1 write path ic_tag0wen tag 0 ram write enable ic_tag0ren tag 0 ram read enable ic_tag0csn tag 0 ram chip select ic_tag1wen tag 1 ram write enable ic_tag1ren tag 1 ram read enable ic_tag1csn tag 1 ram chip select ic_instindex instruction ram address word icr_inst0rd instruction ram element 0 read path icr_inst1rd instruction ram element 1 read path ic_instwr instruction ram write path to both elements ic_inst0wen10 instruction ram 0 write enable ic_inst0ren instruction ram 0 read enable ic_inst0csn instruction ram 0 chip select ic_inst1wen10 instruction ram 1 write enable ic_inst1ren instruction ram 1 read enable ic_inst1csn instruction ram 1 chip selectconÔ¨Åguration icache_inst ram icache_tag ramapril 30 2001 lx5280 lexra proprietary confidential 75 release 19 74 instruction memory imem lmi theimemlmisuppliestheinterfaceforanoptionallocalinstructionstoretheimemservesafixedrange of the physical address space determined by configuration settings in lconfig the imem contents are filled and invalidated under the control of the cp0 cctl register described in section72 cache control register cctl the imem module services instruction fetches that falls within its configured range the imemisaconvenientlowcostalternativetoacachethatmakesinstructionmemoryavailabletothecorefor highspeed access the configurations supported by imem and the synchronous rams required for each are summarized in table30 table 30 imem conÔ¨Ågurations table31liststheimemsignalsthatareconnectedtoapplicationspecificmodulesthe iw_prefixindicates signalsthataredrivenbytheimemlmimoduleandreceivedbyramsthe iwr_prefixindicatessignals thataredrivenbyramsandreceivedbytheimemlmithe cfg_prefixidentifiesconfigurationportson the imem lmi that are typically wired to constant values the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table30 thecfg_wires define where the imem is mapped into the physical address space this configuration information defines the local bus address region of the imem it also determines the address of the external resources which are accessed when an imem miss occurs the lconfigutility supplied by lexra will verify that the configured address range does not interfere with other regions defined for lx5280 the size of the memory region must be power of two and must be naturally aligned table 31 imem ram interfacesconÔ¨Åguration imem_inst ram local instruction ram ram required 1k bytes 128 x 64 bits 2k bytes 256 x 64 bits 4k bytes 512 x 64 bits 8k bytes 1024 x 64 bits 16k bytes 2048 x 64 bits 32k bytes 4096 x 64 bits 64k bytes 8192 x 64 bits 128k bytes 16384 x 64 bits 256k bytes 32768 x 64 bits signal description iw_instindex imem index iwr_instrd instruction read data iw_instwr instruction write data iw_instwen10 instruction ram write enableapril 30 2001 lx5280 lexra proprietary confidential 76 release 19 note n designates an available activelow version of signal 75 instruction rom irom lmi the irom lmi supplies the interface for an optional readonly local instruction store the irom serves fixed range of the physical address space determined by configuration settings in lconfig irom may be disabled via hardware configuration pin cfg_iroff irom may also be enabled and disabled under software control as described in section72 cache control register cctl the irom is convenient lowcost alternative to cache that makes readonly instruction memory available to the core for highspeed access the configurations supported by irom and the synchronous roms required for each are summarized in table32 table 32 irom conÔ¨Ågurations table33 lists the irom signals that are connected to application specific modules the ir_ prefix indicates signals that are driven by the irom lmi module and received by the rom the irr_ prefix indicates signals that are driven by rom and received by the irom lmi the cfg_ prefix identifies configuration ports on the irom lmi that are typically wired to constant values lexra supplies the verilog module that makesallrequiredconnectionstothesewiresthewidthoftheindexanddatalinesdependsupontherom connected to the lmi and can be inferred from table31 the cfg_ wires define where irom is mapped into the physical address space this configuration information defines the local bus address region of the irom it also determines the address of the external resources which are accessed when an irom miss occurs the lconfig utility supplied by lexra will verify that the configured address range does not interfere with other regions defined by the lx5280 note that theiw_instren instruction ram read enable iw_instcsn instruction ram chip select cfg_iwbase3110 conÔ¨Ågured base address modulo 1k bytes cfg_iwtop1710 conÔ¨Ågured top address bits that may differ from base conÔ¨Åguration irom_data local instruction ram rom required 1k bytes direct mapped 128 x 64 bits 2k bytes direct mapped 256 x 64 bits 4k bytes direct mapped 512 x 64 bits 8k bytes direct mapped 1024 x 64 bits 16k bytes direct mapped 2048 x 64 bits 32k bytes direct mapped 4096 x 64 bits 64k bytes direct mapped 8192 x 64 bits 128k bytes direct mapped 16384 x 64 bits 256k bytes direct mapped 32768 x 64 bitssignal descriptionapril 30 2001 lx5280 lexra proprietary confidential 77 release 19 size of the memory region must be power of two and must be naturally aligned table 33 irom rom interfaces note n designates an available activelow version of signal 76 direct mapped write through data cache dcache lmi the dcache lmi supplies the interface for direct mapped write through data cache attached to the lx5280localbusthedcachelmiparticipatesincacheabledatareadsandwritesbutonlyiftheaddress isnotclaimedbythedmemlmi theconfigurationssupportedbydcacheandthesynchronousrams required for each are summarized in table34 the direct mapped dcache module services word or twinword read requests from the core in one cycle when the request hits the cache byte or halfword reads that hit the data cache require an extra cycle for alignmentthedatacachecanstreamwordandtwinwordreadsorwritesthathitthecacheattherateofone per cycle if the lx5280 is configured to work with rams that have word write granularity byte or half wordwritesthatfollowanywritebyonecycleandhitthecacherequireanextracycletomergethedatawith the current cache contents alternatively the lx5280 can be configured to work with rams support byte write granularity which eliminates the extra cycle see appendixc lx5280 pipeline stalls for detailed descriptions of these and other pipeline stall conditions writesthatareservicedbythedatacachemayrequireextratimetobeservicedbythelbcifitswritebuffer isfullalsowhenacachewriteoperationisimmediatelyfollowedbyacachereadthecachemustdelaythe read for one cycle while the write completes when miss occurs the cache obtains cache line 4 8 16 or 32 words of data from the lexra bus controller lbc write operations that hit the data cache are simultaneously written into the cache and forwarded to the write buffer of the lbc thus if the core subsequently reads the data it will likely be available from the cache for main memory systems that support byte writes all data writes that miss the cache are forwarded to the write buffer of the lbc without disturbing any data currently in the cache for main memory systems that can only write with word granularity byte or halfword write that misses the cachecausesthecachetoperformalinefillfrommainmemorythecachethenmergesthepartialwritedata with the full word data obtained from memory and writes the word to the system bussignal description ir_instindex irom index irr_instrd instruction read data ir_instren instruction rom read enable ir_instcsn instruction rom chip select cfg_irbase3110 conÔ¨Ågured base address modulo 1k bytes cfg_irtop1710 conÔ¨Ågured top address bits that may differ from baseapril 30 2001 lx5280 lexra proprietary confidential 78 release 19 table 34 dcache conÔ¨Ågurations table35 lists the dcache signals that are connected to application specific modules the dc_ prefix indicatessignalsthataredrivenbythedcachelmimoduleandreceivedbytheramsthedcr_prefix indicatessignalsthataredrivenbythedcacheramsandreceivedbythedcachelmilexrasupplies the verilog module that makes all required connections to these wires the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table34 table 35 dcache ram interfaces note n designates an available activelow version of signal 77 scratch pad data memory dmem lmi the dmem lmi supplies the interface for scratch pad data ram attached to the lx5280 local bus the dmem module services in any cacheable or uncacheable data read or write operation that falls within its configured rangeconÔ¨Åguration dcache_data ram dcache_tag ram data cache ram required ram required 1k bytes direct mapped 128 x 64 bits 64 x 23 bits 2k bytes direct mapped 256 x 64 bits 128 x 22 bits 4k bytes direct mapped 512 x 64 bits 256 x 21 bits 8k bytes direct mapped 1024 x 64 bits 512 x 20 bits 16k bytes direct mapped 2048 x 64 bits 1024 x 19 bits 32k bytes direct mapped 4096 x 64 bits 2048 x 18 bits 64k bytes direct mapped 8192 x 64 bits 4096 x 17 bits signal description dc_tagindex tag and state ram address dcr_tagrd tag and state ram read path dc_tagwr tag and state ram write path dc_tagwen tag and state ram write enable dc_tagren tag and state ram read enable dc_tagcsn tag and state ram chip select dc_dataindex data ram address word dcr_datard data ram read path dc_datawr data ram write path dc_datawen10 data ram write enable dc_dataren data ram read enable dc_datacsn data ram chip selectapril 30 2001 lx5280 lexra proprietary confidential 79 release 19 byte or halfword reads that hit the dmem require an extra cycle for alignment dmem can stream word and twinword reads or writes that hit dmem at the rate of one per cycle if the lx5280 is configured to work with rams that have word write granularity byte or halfword writes that follow any write by one cycleandhitdmemrequireanextracycletomergethedatawiththecurrentdmemcontentsalternatively thelx5280canbeconfiguredtoworkwithramssupportbytewritegranularitywhicheliminatestheextra cycle see appendixc lx5280 pipeline stalls for detailed descriptions of these and other pipeline stall conditionsalsobecauseawriteoperationtothedmemisneversenttothelbcwritestodmemwillnot cause the lbc to stall the processor due to full write buffer condition the dmem configurations and the synchronous rams required for each are summarized in the table36 table 36dmem conÔ¨Ågurations table37 lists the dmem signals that are connected to application specific modules the dw_prefix indicates signals that are driven by the dmem lmi module and received by rams the dwr_prefix indicates signals that are driven by rams and received by the dmem lmi the cfg_prefix identifies configurationportsonthedmemlmithataretypicallywiredtoconstantvaluesthewidthoftheindexand data lines depends upon the ram connected to the lmi and can be inferred from table36 thecfg_wires define where dmem is mapped into the physical address space it is not possible for any dmemreferencetoresultinanoperationonthesystembusthe lconfigutilitysuppliedbylexrawillverify that the configured address range does not interfere with other regions defined for lx5280 the size of the memory region must be power of two and must be naturally aligned the dmem lmi can also be used as rom controller simply by tying off the write enable and data input lines in the ram wrapper and instancing rom in the ram wrapper table 37dmem ram interfacesconÔ¨Åguration dmem_data ram 64bit dmem_data ram 128bit local data ram ram required ram required 1k bytes 128 x 64 bits 64 x 128 bits 2k bytes 256 x 64 bits 128 x 128 bits 4k bytes 512 x 64 bits 256 x 128 bits 8k bytes 1024 x 64 bits 512 x 128 bits 16k bytes 2048 x 64 bits 1024 x 128 bits 32k bytes 4096 x 64 bits 2048 x 128 bits 64k bytes 8192 x 64 bits 4096 x 128 bits 128k bytes 16384 x 64 bits 8192 x 128 bits 256k bytes 32768 x 64 bits 16384 x 128 bits signal description dw_dataindex decoded data ram index dwr_datard data ram read data dw_datawr data ram write dataapril 30 2001 lx5280 lexra proprietary confidential 80 release 19 note n designates an available activelow version of signaldw_datawen data ram write enable dw_dataren data ram read enable dw_datacsn data ram chip select cfg_dwbase3110 conÔ¨Ågured base address modulo 1k bytes cfg_dwtop1710 conÔ¨Ågured top address bits that may differ from basesignal descriptionapril 30 2001 lx5280 lexra proprietary confidential 81 release 19 8 lx5280 system bus 81 connecting the lx5280 to internal devices the lexra system bus lbus is the connection between the lx5280 and other internal devices such as systemmemoryusbieee1394firewireandanexternalbusinterfacethelbcusesaprotocolsimilar to that of the peripheral component interface pci bus this is wellknown and proven architecture addingnewdevicestothelexrabusisstraightforwardandtheperformanceapproachesthehighestthatcan be achieved without adding great deal of complexity to the protocol figure 6 lexra system bus diagram thelexrabussupportsmultiplemastersthisallowsformasteringiocontrollerswithdmaenginestobe connected to the bus the bus has pended architecture in which master holds the bus until all the data is transferred this simplifies the design of usersupplied bus agents and reduces latency for cache miss servicing thelexrabusisasynchronousbussignalsareregisteredandsampledatthepositiveedgeofthebusclock certain logical operations may be made to the sampled signals and then new signals can be driven immediately such as for address decoding this allows for samecycle turnaround the lbc provides an optionalasynchronousinterfacebetweenthecpuandthelexrabusallowingthelexrabusspeedcanbeset to be any speed equal to or less than the cpu clock frequency thelexrabusdatapathforthelx5280is32bitswidethereforethebuscantransferonewordhalfword or byte in one bus clock the bus supports line and burst transfers in which several words of data are transferred the lexra bus accomplishes this by transferring words of data from incremental addresses on successive clock cycles thelbccontainsawritebufferwhenthecpuissuesawriterequesttoalexrabusdevicetheaddressand data are saved in the buffer and sent to the device sometime later the cpu can continue processing having safely assumed that the write will eventually happen this is described more thoroughly in section872 thelbcdrivesenablingsignalstocontrolmuxesortristatebuffersthisallowsthelexrabustohaveeither bidirectional or pointtopoint topology 82 terminology thelexrabusborrowsterminologyfromthepcibusspecificationonwhichthelexrabusispartiallybased bus transactions take place between two bus agents one bus agent requests the bus and initiates transfer the second responds to the transferlexra bus controller lbcbus bridge usb firewirebus to cpu and local memory interfaceslexra system bus external bus eg pciapril 30 2001 lx5280 lexra proprietary confidential 82 release 19 theagentinitiatingatransferiscalledthe businitiator itisalsoreferredtoasthe busmaster bothtermsare used interchangeably in this document therespondingagentisknownasthebus targetitsamplestheaddresswhenitisvalidanddeterminesifthe address is within the domain of the device if so indicates as such to the initiator and becomes the target aread transfer is bus operation whereby the master requests data from the target awrite transfer is bus operation whereby the master requests to send data to the target asinglecycle busoperationisusedtotransferonewordhalfwordorbyteofdatathisamountofdatacan be transferred in one bus cycle not including the address cycle and device latencies aline transfer is read or write operation where an entire cache line of data is transferred in successive cycles as fast as the initiator and target can sendreceive the data aburst transfer is read or write operation where large amount of data needs to be sent the initiator presents starting address and data is transferred starting at that address in successive cycles for each word transferred the address is incremented by the devices internally some signals on the lexra bus are active low that is they are considered logically true when they are electrically low and logically false when electrically high device assertsa signal when it drives it to its logical true electrical state 83 bus operations the purpose of the lexra bus is to connect together the various components of the system including the lx5280 cpu main system memory io devices and external bus bridges different devices have different transfer requirements for example the lx5280 cpu will request the bus to fetch cache line of data from memoryiodeviceswillrequestlargeblocksofdatatobesenttoandfrommemorythelexrabussupports the various types of transfers needed by both io and the processor the six types of bus operations are singlecycle read line read burst read singlecycle write line write though this wont be used by the lx5280 core and burst write 831 singlecycle read thesinglecyclereadoperationreadsasinglewordhalfwordorbytefromthetargetdevicethisoperation isusuallyusedbythecputoreaddatafromuncachableaddressspaceifthereadaddresswasincacheable address space either hit would occur resulting in bus activity or miss would occur resulting in read line transaction 832 read line thereadlineoperationreadsasequenceofdatafrommemorycorrespondingtothesizeofacachelinethe cache line size affects how many cycles are required to transfer the full line the lx5280 and the lexra bus support configurable line size specified through lconfig the default line size of four words 16 bytes is assumed here there are two ways that the target could transfer the data back to the initiator the conventional way is to transferfourwordsofdatainsequencestartingatthenearest16bytealignedaddresssmallerorequaltothe address that the initiator drives in other words the target starts the transfer at the beginning of the line containing the requested address somememorydevicesmayimplementaperformanceoptimizationcalled desiredwordfirst iftheaddressisapril 30 2001 lx5280 lexra proprietary confidential 83 release 19 notaligned to 16byte boundary then the first data returned by the target is the word corresponding to the addressinsteadofthefirstwordofthelinethesecondwordisthenextsequentialwordofdataandsoonat the end of the line the target wraps around and returns the first word of line thelx5280supportstwowaysofincrementingtheaddressofalinerefilloneisby linearwrap wherethe addressissimplyincrementedbyonetheotherisby interleavedwrap wherethenextaddressisdetermined bythelogicalxorofthecyclecountandthefirstwordaddresstheinterleavesequenceisshowninthetable belowtheloworderaddressbits32forthefirstdatabeataretheobtainedfromtheaddressofthelineread request the low order address bits for the subsequent data indicate the corresponding interleave order table 38 line read interleave order 833 burst read theburstreadoperationtransfersanarbitraryamountofdatafromthetargettotheinitiatortheinitiatorfirst presents starting address to the target the target responds by providing multiple cycles of data words in sequence starting at the initial address the initiator indicates to the target when to stop providing data burstreadoperationsareusedbyiodevicesforblockdmatransfersthelx5280willneverissueaburst read operation note that there is difference between 4cycles burst and line read line read may use desiredword first increment and wrap burst will always increment and will never wrap 834 singlecycle write the singlecycle write operation writes single word halfword or byte to the target thelx5280usesacachewithawritethroughpolicyallcpuinstructionsthatwritetomemorygeneratea singlecycle write operation unless the address is in the local scratchpad memory in which case the write operation will not make it out to the lexra bus 835 line write the line write operation is not used by the lx5280 this operation could be used by processor that has data cache that implements writeback policy 836 burst write burst write is an operation where the initiator sends an address and then an indefinite sequence of data to thetargettheinitiatorwillinformthetargetwhenithasfinishedsendingdatathisoperationisusedbyio devices for dma transfers it is not used by the processorinterleaved address32 1st data beat 00 01 10 11 2nd data beat 01 00 11 10 3rd data beat 10 11 00 01 4th data beat 11 10 01 00april 30 2001 lx5280 lexra proprietary confidential 84 release 19 84 signal descriptions table 39 lbus signal description 85 lbus commands the initiator drives bcmd during the cycle that bframe is asserted bcmd6 0read 1write bcmd54 54 00 burst fixed length1 01 burst unlimited number of words 10 line interleaved wrap2 11 line linear wrapsignal namesource initiatortargetctrldescription bclock ctrl bus clock bcmd60 initiator encoded command active during Ô¨Årst cycle that bframe is asserted baddr310 initiator address target indicates valid address by asserting bframe bframe initiator asserted by initiator beginning of operation with address and command signals deasserted when initiator is ready to accept or send last piece of data otherbusmasterssamplethisandbirdytoindicate that the bus will be available on the next cycle birdy initiator forwritesindicatesthatinitiatorisdrivingvaliddata on reads indicates that initiator is ready to accept data bdata310 initiator on writetarget on readdata if driven by initiator birdy indicates valid data onbusifdrivenbytargetbtrdyindicatesvaliddata on bus btrdy target for writes indicates that target is ready to accept data on reads indicates that target is driving valid data bsel target asserted by selected target after initiator asserts bframeindicatesthattargethasdecodedaddress and will respond to the transaction ie has been selected 1 the number of words comes from bcmd20 2 length is determined by the line size not bcmd30april 30 2001 lx5280 lexra proprietary confidential 85 release 19 bcmd30 3210 1000 1 byte 1001 2 bytes 1010 3 bytes 1011 1 word 1100 2 words 1101 reserved 111x reserved 0000 4 words 0001 8 words 0010 16 words 0011 32 words 01xx reserved 86 byte alignment the lexrabus isa big endian bus transactionsmust havetheir data driven to theappropriate busrails the bus mapping is as shown in table40 table 40 lbus byte lane assignment the lexra bus does not define unaligned data transfers such as halfword transfer that starts at addr1001 or transfers that would need to wrap to the next word 87 lexra bus controller thelexrabuscontrollerlbcistheelementofthelx5280thatconnectstothelexrabusitforwardsall transaction requests from the lx5280 cpu to the lexra bus it is an initiator and will never respond to requests from other lexra bus initiators 871 lbc commands the lbc issues the only the lbus commands listed in the table belowlexra bus data byte lanes used bcmd10 addr10 3124 2316 158 70 00 00 x 00 01 x 00 10 x 00 11 x 01 00 x x 01 10 x x 10 00 x x x 10 01 x x x 11 00 x x x xapril 30 2001 lx5280 lexra proprietary confidential 86 release 19 table 41 lbus commands issued by the lbc 872 lbc write buffer and outoforder processing the lbc contains write buffer with depth that is configurable with lconfig all write requests from the cpu are posted in the write buffer the cpu will not wait for the write to complete write operations completeintheordertheyareenteredintothequeueifthequeuefillsthenthecpumustwaituntilanentry becomes available whenthecpu issuesareadoperationthelbcwillattempttoforwardthatrequesttothelexrabus ahead ofanypendingwriteoperationsthissignificantlyimprovesperformancesincethecpuneedstowaitforthe readoperationtocompleteandwouldwastetimeifithadtoalsowaitforunnecessaryorirrelevantwritesto complete there are few cases when the lbc will not allow the read operation to pass pending writes 1 theaddressofapendingwriteiswithinthesamecachelineasthereadthelbcwillholdthe read operation until the matching write operation and all write operations ahead of it com plete if the read is for an instruction fetch it can still pass pending write that is inside the same cache line 2 the read is to uncacheable address space all writes will complete before the read is issued this avoids any problems with io devices and their associated controlstatus registers 3 apendingwriteistouncachableaddressspacethelbcwillholdthereadoperationuntilall writesuptoandincludingthewritetouncacheableaddressspacecompletethisfurtheravoids io device problems the write buffer bypass feature can be disabled so that reads will never pass writes 873 lbc read buffer the lbc contains read buffer with depth that is configurable with lconfig all incoming read data from the system bus passes through the read buffer this allows the lbc to accept incoming data as result of cache line fill operation without having to hold the bus when the lbc is configured with an asynchronous interface larger read buffer improves system and processorperformanceintheeventofcachemisswhenthelbcisconfiguredwithasynchronousinterface thecachecanacceptthedataasfastasthelbccanreaditthereforethereisnoneedforalargereadbuffer customers may reduce the size of the read buffer to minimum size of two 32bit entriescommand bcmd54 bcmd30 circumstances read line 10 or 11 dependingon conÔ¨Åguration0000 cache miss during read by the cpu read single wordhalfwordbyte00 10xx read by the cpu from an address in uncachable address space write single wordhalfwordbyte00 10xx write by the cpu into cacheable or uncachable address spaceapril 30 2001 lx5280 lexra proprietary confidential 87 release 19 insomecasesthereisaneedtominimizethenumberofgatesthereadbuffersizemaybereducedtotwoor fourentriesfortheasynchronouscasethiscausesapenaltyintermsoflbusutilizationsincenowthelbc may have to deassert irdy if it cannot hold part of the line of data when the read buffer is the size of cache line this will be relatively rare since simultaneous instruction cache and data cache misses are relatively rare for smaller read buffer irdy deassertion is almost certainty 874 transfer descriptions this section describes the various types of read and write transfers in detail these operations follow certain patterns and rules the rules for driving and sampling the bus are as follows 1 agentsthatdrivethebusdosoasearlyaspossibleaftertherisingedgeofthebusclockthere is some time to perform some combinational logic after the bus clock goes high but the amount of time is determined by the speed of the bus clock and the number of devices on the bus 2 agents sample signals on the bus at the rising edge of the bus clock 3 all bus signals must be driven at all times if the bus is not owned and external device must drive the bus to legal level 4 change in signal ownership requires one dead cycle if an initiator gives up the bus another initiatorneedstowaitforonedeadcyclebeforeitcandrivethebusifthesameinitiatorissues areadoperationandthenneedstoissueawriteoperationitalsomustwaitoneextracyclefor the data bus to turn around 5 agentsthatownsignalsmustdrivethesignalstoalogicaltrueorlogicalfalseallotheragents must disable tristate their output buffers thelexrabusprotocolisbasedonthepcibusprotocol1thelexrabussignalsbframebtrybirdy and bsel have similar function to the pci signals frame trdy irdy and devsel respectively in general the protocol for the lexra bus is as follows 1 the initiator gains control of the bus through arbitration described later in this chapter 2 during the Ô¨Årst bus cycle of its ownership before the Ô¨Årst rising clock edge the initiator drivestheaddressforthebustransactionontobaddratthesametimeitassertsbframe to indicate that the bus is in use it will deassert bframe before it send or accepts the last word of data in most cases the initiator will asserts birdy to indicate that it is ready to receivedataorreadoperationsorisdrivingvaliddataforwriteoperationsiftheoperation is write the initiator will drive valid data onto bdata 3 at the rising edge of the Ô¨Årst clock all agents sample baddr and decode it to determine which agent will be the target 4 the agent that determines that the address is within its address space asserts bsel sometime after the Ô¨Årst rising edge of the bus clock bsel stays asserted until the transaction is com plete 5 the initiator and the target transfer data either in one cycle or in successive cycles the agent driving data the initiator for write the target for read indicates valid data by asserting its readysignalirdyortrdyforwritesandreadsrespectivelytheagentreceivingdatatar getforawriteinitiatorforareadindicatesitsabilitytoreceivethedatabyassertingitsready 1 the lexra bus is not pci compatible it merely borrows concepts from the pci bus speciÔ¨Åcationapril 30 2001 lx5280 lexra proprietary confidential 88 release 19 signal either agent may deassert its ready signal to indicate that it cannot source or accept data on this particular clock edge 6 when the initiator is ready to send or receive the last word of data that is when it asserts birdy for the last time it also deasserts bframe it will deassert birdy when the last word of data is transferred 7 the arbiter grants the bus to the next initiator and may do so during bus transfer by differ ent initiator the new initiator must sample bframe and birdy when both birdy and bframe is sampled deasserted and the new initiator has been given grant it can assert bframe the next cycle to start new transaction note in the examples below the signals baddr and bdata are often shown to be in highimpedance state in reality internal bus signals should always be driven even if they are not being sampled the hiz states are shown for conceptual purposes only 875 single cycle read with waits this operation is used to read word halfword or byte from memory usually in uncachable address space thisisasimplereadoperationwherethetargetrespondsimmediatelywithdatathisisunlikelysincemost bus memory will require one or more cycles to fetch data this example illustrates the most basic read operation without waits 1 initiator asserts bframe and drives baddr 2 targetassertsbseltoindicatetoinitiatorthatatargetisrespondinginthisexamplethereis animmediatefetchofdatasotargetdrivesdataandassertsbtrdytoindicatetotargetthatit is driving data the initiator deasserts bframe and asserts birdy to indicate that the next piece of data received will be the last 3 initiatordeassertsibirdyandthetargetdeassertsbselandbtrdytoindicatetheendof the transaction the initiator that has been given grant owns the bus this cycleclock bframe baddr bdata birdy btrdy bsel d0000april 30 2001 lx5280 lexra proprietary confidential 89 release 19 876 single cycle read with target wait this is the same as the singlecycle read except that the target needs time to fetch the data from memory this is common singlecycle read operation 1 initiator asserts bframe and drives baddr 2 target asserts bsel to indicate that it has decoded the address and is acknowledging that it is the target device however it is not ready to send data so it does not assert btrdy initiator deassertsbframeandassertsbirdytoindicatethatthenextpieceofdatawillbethelastit wants 3 target has not asserted btrdy so data is transferred 4 after second wait cycle target drives data and asserts btrdy to indicate that data is on the bus 5 target deasserts bsel and btrdy initiator deasserts birdy another initiator may drive the bus this cycle 877 line read with waits this operation is used to service cache miss four words of data are transferred in sequence in this example the target is supplying four words of data without any waits 1 initiator drives baddr and asserts bframe to indicate beginning of transactionclock bframe baddr bdata birdy btrdy bsel d0001 clock bframe baddr bdata birdy btrdy bsel d0002april 30 2001 lx5280 lexra proprietary confidential 90 release 19 2 target asserts bsel to indicate that it had decoded the address and will send data when it is ready initiator asserts birdy to indicate that it is ready to receive data 3 target drives data and asserts btrdy 4 target drives second word of data and continues to assert btrdy 5 target drives third word of data and continues to assert btrdy 6 target drives last word of data initiator deasserts bframe to indicate that the next word of data it receives will be the last it needs 7 target deasserts btrdy and bsel initiator deasserts birdy another master may gain ownership of the bus this cycle 878 line read with target waits this illustrates what happens when target needs extra time to fetch data it needs to service cache miss 1 initiator asserts bframe and drives baddr 2 targetassertsbseltoindicatethatitisacknowledgingtheoperationinitiatorassertsbirdy to indicate that it is ready to receive data 3 target waits until it has the data 4 target drives Ô¨Årst word of data and asserts btdry 5 target drives second word of data and asserts btrdy 6 target cannot get third word of data so it deasserts btrdy 7 target drives third word of data and asserts btrdy 8 target cannot get fourth word of data so it deasserts btrdy 9 target drives fourth word of data and asserts btrdy 879 line read with initiator waits this occurs when line of data is requested from the target and the initiator cannot accept all of the data inclock bframe baddr bdata birdy btrdy bsel d0003april 30 2001 lx5280 lexra proprietary confidential 91 release 19 successive cycles 1 initiator drives address and asserts bframe 2 targetassertsbselitdoesnthavedatasoitdoesnotassertbtrdyinitiatorassertsbirdy to indicate that it can accept data 3 target now has data so it drives the data and asserts btrdy 4 target drives second word of data initiator cannot accept it so it deasserts birdy 5 target holds second word of data initiator can accept it and asserts birdy 6 target drives third word of data initiator accepts it 7 targetdrivesfourthwordofdatainitiatorcannotacceptitanddeassertsbirdyinitiatorhold bframe until it can assert birdy 8 initiatorassertsbirdytoacceptfourthwordofdataitdeassertsbframetoindicatethisis the last word of data 8710 burst read this is identical to the read line 8711 singlecycle write with waits singlecycle write operation occurs almost every time the lx5280 processor executes store instruction thisisbecausethecacheusedintheprocessorusesawritethroughpolicyofcoursewritestouncacheable address space and to an io device will also generate singleword write singleword write operations are used to write words halfwords and bytesclock bframe baddr bdata birdy btrdy bsel d0004april 30 2001 lx5280 lexra proprietary confidential 92 release 19 singleword write without waits requires two cycles 1 initiator asserts bframe and drives address 2 targetsamplesaddressandassertsbselinitiatordrivesdataandassertsbirdyinthiscase target is also able to accept data so it asserts btrdy initiator also deasserts bframe to indicate that it is ready to send the last and only word of data 3 target accepts data deasserts btrdy and bsel initiator deasserts birdy 8712 singlecycle write with waits this is an example of singlecycle write operation where the target cannot immediately accept data and must insert wait states thisisthesamedescriptionastheaboveexampleexceptthatthetargetinsertstwowaitstatesuntilitasserts birdy to indicate acceptance of data 8713 burst write with waits aburstwriteoperationisgenerallyusedtotransferlargeamountsofdatafromaniodevicetomemoryviaclock bframe baddr bdata birdy btrdy bsel d0005 clock bframe baddr bdata birdy btrdy bsel d0006april 30 2001 lx5280 lexra proprietary confidential 93 release 19 dma transfer the following illustrates bestcase scenario with wait states 1 initiator drives address and asserts bframe 2 targetassertsbselandbtrdytoindicateitwillacceptdatainitiatordrivedataandasserts birdy 3 initiator drives next word of data target continues to accept data and indicates as such by tinuing to assert btrdy 4 initiator drives third word of data target continues to accept 5 initiatordrivesfourthwordofdataanddeassertsbframetoindicatethatthiswillbeitslast word sent target accepts data 6 target deasserts btrdy and bsel initiator gives up control of the bus by deasserting birdy 8714 burst write with target waits this example is similar to the above example except that during the third and fourth data word transfer the target cannot accept the data quickly enough so it deasserts btrdy which indicates to the initiator that it should hold the data for an additional cycle 8715 burst write with initiator waits the example illustrates what happens when the initiator cannot supply data fast enough and has to insertclock bframe baddr bdata birdy btrdy bsel d0007 clock bframe baddr bdata birdy btrdy bsel d0008april 30 2001 lx5280 lexra proprietary confidential 94 release 19 waits 88 lbc signals thetablebelowsummarizesthelx5280lbcportsthelbcportcolumnindicatesthenameoftheport suppliedbythelbcthebussignalcolumnindicatesthecorrespondinglexrabussignalthelbcports are strictly unidirectional while the bus signals at least conceptually include multiple sources and sinks the manner in which lbc ports are connected to bus signals is technology dependent and may employ tri state drivers or logic gating in conjunction with the lbcs lcoe ldoe and ltoe outputs table 42 lbc interface signals io lbc port bus signal description output laddro310 baddr310 lbc address output ldatao310 bdata310 lbc data input ldatai310 bdata310 system data output lirdy birdy lbc initiator ready input lirdyi birdy system initiator ready output lframe brame lbc transaction frame input lframei bframe system transaction frame input lsel bsel system slave select input ltrdy btrdy system target ready output lcmd60 bcmd60 lbc command output lreq lbc bus request input lgnt system bus grant output lcoe90 lbc command output enable terms output ldoe70 lbc data output enable terms output ltoe lbc transaction output enable termsclock bframe baddr bdata birdy btrdy bsel d0009april 30 2001 lx5280 lexra proprietary confidential 95 release 19 89 arbitration 891 rules the following are the rules for arbitration gntgrant reqrequest 1 masterassertsreqatthebeginningofacycleandmaystartsamplingforassertedgntinthe same cycle in case gnt is already asserting in the case of park 2 if bus is idle or it is the last data phase of the previous transaction when master samples asserted gnt master may assert frame on next cycle 3 ifthebusisbusywhenthemastersamplesgntismustalsosnoopframeirdyandtrdy onecycleafterframeisnotassertedandbothirdyandtrdyareassertedindicatingthe last data phase if gnt is still asserted master may now drive frame ie gnt frame_r irdy_r trdy_r 892 lbc behavior the lbc when it need access to the bus asserts req and in the same cycle samples gnt frame and either irdy or irdy trdy if these are true then the lbc will on the next cycle take ownership of the bus req is deasserted on the cycle after lbc asserts frame if the bus is busy lbc continues to snoop these four signals for this condition all other lbus arbitration rules can be based on this behavior of the lbc 810 connecting devices to the bus there are three sets of output enables toevalid for the length of the transaction coe valid for only the first cycle of transaction and doe valid for data transfers asserted by the master for writes and by the slave for reads toe is intended to qualify frame irdy coe is intended to qualify cmd addr doe is intended to qualify data there is output enable to qualify trdy and sel these are defined by customer logic for slave devices insteadofusingtoeitmaybedesirabletoinsteadoralloftheframesignalseithercentrallyoroneor gate for each target and master the same holds true for irdy trdy and sel this simplifies the connections when relatively few number of devices are used and there are offchip devices connected directly to the lexra bus therefore it is defined that masters and slaves not taking part in transaction always keep frame irdy trdy and sel driven and deassertedapril 30 2001 lx5280 lexra proprietary confidential 96 release 19 april 30 2001 lx5280 lexra proprietary confidential 97 release 19 9 lx5280 coprocessor interface thelx5280processorprovidescustomeraccesspointsforthecoprocessorinterfacesthissectionprovides description of these access points attachment of memory devices to the lmis the system bus and the ejtag interface are described in separate chapters 91 attaching coprocessor using the coprocessor interface ci acoprocessormaycontainupto32generalregistersandupto32controlregisterseachoftheseregistersis up to 32 bits wide typically programs use the general registers for loading and storing data on which the coprocessor operates data is moved to the coprocessors general registers from the cores general registers with the mtcz instruction data is moved from the coprocessors general registers to the cores general registers with the mfcz instruction main memory data is loaded into or stored from the coprocessors general registers with the lwcz and swcz instructions programs may load and store the coprocessors control registers from the cores general registers with the ctczandcfczinstructionsrespectivelyprogramsmaynotloadorstorethecontrolregistersdirectlyfrom main memory the coprocessor may also provide condition flag to the core the condition flag can be bit of control registeroralogicalfunctionofseveralcontrolregistervaluestheconditionflagistestedwiththebcztand bczfinstructionstheseinstructionsindicatethattheprogramshouldbranchiftheconditionistruebczt or false bczf 92 coprocessor interface ci signals the ci provides the mechanism to attach the custom coprocessor to the core the ci snoops the instruction bus for coprocessor instructions and then gives the coprocessor the signals necessary for reading or writing the general and control registers table 43 coprocessor interface signals signal io description czcondin input cop branch Ô¨Çag czrd_addr40 output cop read address czrhold output cop hold condition one stalls coprocessor czrd_gen output cop general register read command czrd_con output cop control register read command czrd_data310 input cop read data czwr_addr40 output cop write address czwr_gen output cop general register write command czwr_con output cop control write address command czwr_data310 output cop write data czinvld_m output cop invalid instruction Ô¨Çag one indicates invalid instruction in m stageapril 30 2001 lx5280 lexra proprietary confidential 98 release 19 theaddressesoutputdataandcontrolsignalsaresuppliedtotheuserscoprocessorontherisingedgeofthe system clock in the case of read cycle the coprocessor must supply the data from either the control or generalregisteronczrd_databytheendofthesamecyclesimilarlythewriteofdatafromczwr_data to the addressed control or general register must be complete by the end of the cycle the ci incorporates forwarding path so that data which is written in instruction n can be read in instruction n 2 the coprocessor registers should be implemented as positiveedge flipflops using the lx5280 system clock 93 coprocessor write operations duringacoprocessorwritethecisendsczwr_addrandczwr_dataandassertseitherczwr_genor czwr_con the coprocessor must ensure that the coprocessor completes the write to the appropriate register on the subsequent rising edge of the clock the target register is decoding of czwr_addr czwr_gen and czwr_con use these instructions to cause coprocessor write lwcz mtcz and ctcz 94 coprocessor read operations during coprocessor read the ci sends czrd_addr and asserts either czrd_gen or czrd_con the coprocessor must return valid data through czrd_data in the following clock cycle if the core asserts czrhold indicating that it is not ready to accept the coprocessor data the coprocessor must hold the previous value of czrd_data the target register for the read is decoding of czrd_addr czrd_gen and czrd_con the instructions causing coprocessor read are swcz mfcz and cfcz the cpu stalls the pipeline so that the program can access data read by coprocessor instruction in the immediatelyfollowinginstructionforexampleifanmfczinstructionreadsdatafromthecoprocessorand stores it in the cores general register 4 the program can get access to that data in the following instruction when the core initiates coprocessor read the coprocessor must return valid data in the following clock cycle the coprocessor cannot stall the cpu applications must ensure that the source code does not access invalid coprocessor data if the coprocessor operations take several clock cycles to complete this is done in one of three ways ensure that code does not access data from the coprocessor until n instructions after the coprocessor operation has stared this is the least desirable method as it depends on the relative execution of the core and coprocessor it can also complicate software debug have the coprocessor send an interrupt to the core and the service routine for that interrupt accesses the appropriate coprocessor registers havethecoprocessorsettheczcondinflagwhenitsoperationiscompletethesourceczxcpn_m output copexceptionÔ¨Çagoneindicatesexception in m stage mfc2 4 3 move from cop2 to cpu register 4 subu 5 4 2 subtract r2 from r4 and store in 5signal io descriptionapril 30 2001 lx5280 lexra proprietary confidential 99 release 19 code can poll the flag as shown in the example below 95 coprocessor interface and pipeline stages coprocessorwritesoccurinthewstageoftheinstructionpipelineforcoprocessorreadsthecoregenerates address rd_gen and rd_con signals during the s stage and the coprocessor returns data during the stage whichispassedbythecitothecoreinthemstagethecoreintroducesapipelinebubbleaftercoprocessor instructions to ensure that the result of mtcz instruction can be used by the immediately following instruction in particular if there are backtoback mtcz and mfcz instructions that access the same coprocessor register the pipeline bubble still does not allow cycle between the w stage write and stage read as required in this case special forwarding path within the ci is used that is the true data from the coprocessor is ignored instead the exact data from the mtcz is used mtc2 i d s m w bubble i d mfc2 i d s m w data forwarded by ci from mtc2 wr_gen w x rd_gen s x rd_datae x theforwardingpathcancausesideeffectsifthecoprocessordoesnotimplementallofthebitsofaregister contains readonly bits or updates the register value upon reading the register in such cases the mfc2 instructionreturnsdifferentdatafromwhatitwouldifthecoredidnotactivatetheforwardingpathtoavoid the forwarding path another instruction must be inserted between the mtc2 and mfc2 mtc2 i d s m w bubble i d foo i d s m w mfc2 i d s m w read data from coprocessor wr_gen w x rd_datae x 951 pipeline holds thecoprocessormustregisterthereadaddressandthecontrolsignalsrd_genandrd_conitmustholdthee stage registered values of these signals when cz_rhold is active high and should make the read data output function of the stage registered read address and control signals thewr_addrwr_datawr_genandwr_consignalsneednotberegisteredthecoprocessormaydecodethese w stage signals directly to the appropriate register 952 pipeline invalidation under certain circumstances the instruction pipeline can contain an instruction that must be discarded this can be due to mispredicted branches cache misses exceptions inserted pipeline bubbles etc in such casesmtc2 2 3 store data to cop2 general register 3 ctc2 3 5 set cop2 control register 5 to start nop loop bc2f loop branch back to loop if czcondin bit off nop branch delay slot mfc2 4 7 get results from cop2 general register 7april 30 2001 lx5280 lexra proprietary confidential 100 release 19 the ci may decode an instruction that must actually be discarded for the coprocessor writetype instructions the ci will only issue the w stage control signals wr_gen and wr_con for valid instructions the coprocessor does not need to qualify these controls forthecoprocessorreadtypeinstructionsthecimayissuethesstagecontrolsignalsrd_genandrd_confor instructions that must be discarded if the coprocessor can tolerate speculative reads then it need not qualify those signals however if the coprocessor performs destructive reads such as updating fifo pointer upon read then it must use the qualifying signals cz_xcpn_m and cz_invld_m as follows thesignalcz_xcpn_msignalisusedtodiscardanysstagefromcird_genorrd_consignalandanye stage registered in the coprocessor rd_gen or rd_con signal it indicates that preceding instruction in the pipe has taken an exception and that subsequent instructions in the pipe must be discarded the signal cz_invld_m signal is used to invalidate the operation of the current instruction in the m stage this can be for various reasons not limited to an exception on preceding instruction if the coprocessor cannot tolerate speculative reads it must register an m stage version of rd_gen and rd_con the coprocessor must use the cz_rhold signal to hold this m stage version as well as the stage version if cz_invld_m is asserted then any such m stage signals must be discarded to summarize rd_gen or rd_con instruction can retire only if it reaches the m stage and neither cz_rhold nor cz_invld_m is assertedapril 30 2001 lx5280 lexra proprietary confidential 101 release 19 10 lx5280 ejtag 101 introduction given the increasing complexity of soc designs the nature of embedded processordesign debug hardware and software and the timetomarket requirements of embedded systems debug solution is needed which allows onchip processor visibility in costeffect io constrained manner lexrasejtagsolutionmeetsallsuchrequirementsitusesexistingieeejtagpinsaswellasfastbringup on new designs it provides way of debugging all devices accessible to the processor in the same way the processor would access those devices itself using ejtag debug probe can access all the processor internalregistersandcachesitcanalsoaccessdevicesconnectedtothelexrabusbypassinginternalcaches and memories software debug is enhanced by ejtag features that allow singlestepping through code and halting on breakpoints hardware and software address and data with masking for debugging problems that are artifacts of realtime interactions ejtag gives realtime program counter trace capabilities from which an accurate program execution history is derived for the codesystem perspective pc profiling provides statistical analysis of code usage to aim code optimization 102 overview adebughostcomputercommunicatestotheejtagprobethrougheitheraserialorparallelportorethernet connectiontheprobeinturncommunicatestothelx5280ejtaghardwareviatheincludedieee11491 jtaginterfacethroughtheuseofthejtagtapcontrollerprobedataisshiftedintototheejtagdataand control registers in the lx5280 to respond to processor requests dma into system memory configure the ejtag control logic enable singlestep mode or configure the ejtag breakpointregistersthroughtheuse of the ejtag control registers the user can set hardware breakpoints on the instruction cache address data cache address or data cache data values physical address range 0xff20_0000 to 0xff3f_ffff is reserved for ejtag use only and should not be mapped to any other device currentlyembeddedperformanceincepiandgreenhillsincprovideejtagdebuggersandprobesfor the lx5280 information on these products is available at the following web sites epi inc httpwwwepitoolscom green hills inc httpwwwghscom lx5280 ejtag implements all required features of version 200 of the ejtag specification and includes support for the following features processor access of host via addressing of probe memory space host probe can dma directly into system memory or io devices hardware breakpoints on internal instruction and data busses singlestep execution mode realtime program counter trace debug exception and two new debug instructions one for raising debug exception via software and one for returning from debug exceptionapril 30 2001 lx5280 lexra proprietary confidential 102 release 19 1021 ieee jtagspeciÔ¨Åc pinout ieee jtag pins used by ejtag are shown below these are required for all ejtag implementations jtag_trst_n is an optional pin table 44 ejtag pinout table 45 ejtag ac characteristics1 table 46 ejtag synthesis constraints2 103 single processor pc trace the lx5280 ejtag includes support for realtime program counter trace pc trace when in pc tracesignal name io description jtag_tdo_nr output serial output of ejtag tap scan chain jtag_tdi input serial input to ejtag tap scan chain jtag_tms input test mode select connected to each ejtag tap controller jtag_clock input jtag clock connected to each ejtag tap controller jtag_trst_n input tap controller reset connected to each ejtag tap controllera this pin is optional in multiprocessor conÔ¨Ågurations signal parameter condition min max unit jtag_clock frequency 1 40 mhz duty cycle 4060 6040 jtag_tms setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdi setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdo_nr outputdelaytckfallingedgetotdo 18v 0 7 ns 1 based on epi interface speciÔ¨Åcations for majictm and majicplus tmsignal name probe budget core budget slack remaining for other logic jtag_tdo_nr 0 to 7ns 115ns 135 to 205ns jtag_tdi 5ns 135ns 65ns jtag_tms 5ns 135ns 65ns 2 based on 25ns jtag clock periodapril 30 2001 lx5280 lexra proprietary confidential 103 release 19 mode the lx5280 will serially output new value of the program counter whenever change in program control occurs ie branch or jump instruction or an exception when the pc trace option is set to export in lconfig the following signals will be output from the lx5280 dclk pcst and tpc these are described in more detail in the following subsections the dclk output is used to synchronize the probe with the lx5280s sysclk the pcst pc trace status signals are used to indicate the status of program execution example status indications are sequential instruction pipeline stall branch or exception the tpc pins output the value of the pc every time there is change of program control 1031 pc trace dclk debug clock the maximum speed allowed for the debug clock dclk output is 100mhz as an epi probe requirement as cores typically run in excess of this speed dclk can be set to divided down value of sysclk this is set by the dclk n parameter in lconfig which indicates the ratio of sysclk frequency to dclk 1 2 3 or 4 1032 pc trace pcst program counter status trace theprogramcounterstatuspcstoutputcomprisesnsetsof3bitpcstvalueswherenisconfigurable as123or4via lconfigapcstvalueisgeneratedeverysysclkcyclewhendclkisslowerthanthe lx5280s sysclk up to n pcst values are output simultaneously 1033 pc trace tpc target program counter the bus width of the target program counter tpc output is user configured in lconfig via the m parametertobeoneof124or8bitswhenchangeinprogramflowoccursthecurrentpcvalueissentout oftpcasthepcis32bitswidethenumberoftpcpinsaffectshowquicklythepcissentforexample if the tpc is 4 bits wide the pc will take 8 dclk cycles to be sent if another change in flow occurs while thepcofthepreviouschangeisbeingtransmittedthenewpcwillbesentandtheremainderoftheprevious pc will be lost the tpc bus also outputs the exception type when an exception occurs the exception type fieldwidth is either3or4bitsdependingonwhetherornotvectoredinterruptsarepresentthisiscoveredinmoredetail below toreducepinoutthetdooutputisusedfortheleastsignificantbitoftpcortheonlybitifmissetto1 1034 dual pipe pc trace theejtagpctracefacilityspecifiesthatapcstpctracestatuscodeisissuediftheinstructionpipeline has stalled sequentially completed an instruction or taken an branch or jump in order to accommodate the two pipelines in the lx5280 the capability of emitting more than one pcst code per cycle is employed specifically to the external ejtag probe the lx5280 appears to be single pipe machine running at twice the speed that it actually does since there must be an even number of pcst codes made available at every dclk rising edge in the ejtag nomenclature the dclk parameter n must be set to 2 or 4 setting the dclk n parameter to 2 results in dclk running at the same frequency of sysclk setting the parameter to 4 results in dclk running at onehalf the frequency of sysclk the maximum value of the n parameter is 4 and the maximum dclk frequency is 100mhz thereforeapril 30 2001 lx5280 lexra proprietary confidential 104 release 19 until the ejtag specification is extended beyond n4 or maximum dclk of 100mhz the maximum sysclk frequency for which dualpipe pc trace can be used is 200 mhz 1035 singleprocessor pc trace pinout table 47 singleprocessor pc trace pinout table 48 singleprocessor pc trace ac characteristics1 1036 vectored interrupts and pc trace the ejtag pc trace facility specifies 3bit code be output on the tpc output when an exception occurs thepcstpinsgivetheexpcodeinordertodistinguishtheeightvectoredinterruptsinthelx5280from all other exceptions 4bit code is used instead for all exceptions otherthan vectored interrupts the most significant bit of the 4bit code is zero and the remaining 3bits are the standard 3bit code note that this includes the standard software and hardware interrupts numbered 0 through 7 for vectored interrupts the most significant bit is always 1 the 4bit code is simply the number of the vectored interrupt from 8 through 15 being taken since the target of the vectored interrupt is determined by the contents of the intvec register the debug softwarewhichmonitorstheejtagpctracecodesmustbeawareofthecontentsofthisregisterinorderto trace the code after the vectored interrupt is takensignal name io description jpt_tpc_dr m bitsopthe pc value is output on these pins when pcdiscontinuity occursa tpc0 is multiplexed with tdo in the singleprocessor pc trace solutionjpt_pcst_dr n3 bitsop pc trace status outputs current instruction type every dclk jpt_dclk op pcst and tpc clock frequency determined as fraction of sysclk via the n parameter maximum frequency of dclk is 100mhz signal parameter min max unit jtag_dclk frequency dc 100 mhz dclk high time 4 ns low time 4 ns tpc setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns pcst setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns 1 based on epi interface speciÔ¨Åcations for majictm and majicplus tmapril 30 2001 lx5280 lexra proprietary confidential 105 release 19 for probes that do not support 4bit exception code the lx5280 can be configured via the ejtag_xv_bits lconfig option to use only the 3bit standard codes in that case if vectored interrupt is taken the 3bit code for reset will be presented 1037 demultiplexing of tdo and tdi during pc trace in normal ejtag pc trace tdi and tdo are multiplexed with the debug interrupt dint and the lsb of the tpc tpc0 when in pc trace mode this reduces the number of pins required by pc trace but has the unfortunate sideaffect of preventing any access to ejtag registers during pc trace in order to allow access to ejtag registers during pc trace and to facilitate pc trace in multiprocessor environments the lconfig option jtag_trst_is_tpcyes causes tdi and tdo to be demultiplexed suchthattrstisusedastpc0anddintisgeneratedviaejtagregistersnotesettingthisoptionmay require changes in ejtag probe hardware check with probe manufacturer for detailsapril 30 2001 lx5280 lexra proprietary confidential 106 release 19 april 30 2001 lx5280 lexra proprietary confidential 107 release 19 appendix lx5280 lconÔ¨Åg forms a1 conÔ¨Åguration options for the lx5280 processor this section provides summary of the configuration options available with lconfig refer to lconfigforms for detailed description of these form options product lexra processor name product_type indicates product type technology identifies target technology testbed_env identifies simulation testbed environment type reset_type flipflop reset method reset_dist reset distribution method sleep include clock sleep support reset_buffers reset buffers at toplevel module clock_buffers clock buffers at toplevel module ram_clock_buffers lmi ram clock distribution method cop1 coprocessor interface 1 cop2 coprocessor interface 2 cop3 coprocessor interface 3 ce0 custom engine 0 ce1 custom engine 1 m16_support 16bit opcode support mem_line_order cache line fill beat ordering mem_first_word cache line fill first word mem_granularity main memory system partial word write support system_interface system bus interface type lbc_wbuf lexra bus controller write buffer depth lbc_rbuf lexra bus controller read buffer depth lbc_rdbypass lexra bus controller read bypass enable lbc_sync_mode lbc synchronousasynchronous selection line_size cache line size in words icache instruction cache size dcache data cache size imem local instruction ram with line valid bits irom local instruction rom dmem local scratch pad data ram lmi_data_granularity dcache and dmem write granularity lmi_range_source source of lmi address ranges lmi_ram_arb allow external agents to arbitrate for lmi rams jtag internal jtag tap controller with ejtag support ejtag ejtag debug support ejtag_inst_break number of instruction breaks to be compiled ejtag_data_break number of data breaks to be compiled jtag_trst_is_tpc trst pin is tpc out instead of tdotpc mux pc_trace ejtag pc trace pins ejtag_dclk_n ejtag pctrace dclk n parameter ejtag_tpc_m ejtag pctrace tpc m parameter ejtag_xv_bits ejtag pctrace number of exception vector bits ejtag_pc_isabit ejtag pctrace include isa as pc bit0 scan_insert controls scan insertion and synthesis scan_mix_clocks scan chains can cross clock boundaries with lockup latches scan_num_chains number of scan chainsapril 30 2001 lx5280 lexra proprietary confidential 108 release 19 scan_scl scan collar insertion on ram interfaces sen_dist scan enable distribution method sen_buffers scan enable buffering ram_bist_mux include test ram mux and portsapril 30 2001 lx5280 lexra proprietary confidential 109 release 19 appendix b lx5280 port descriptions all ports must be connected to valid logiclevel sources the timing information indicates the point within cycle when the signal is stable in terms of percent the timing information also includes parenthetical references to these notes 1 clocked in the jtag_clock domain 2 clocked in the busclk domain if crossbar or lbc are asynchronous otherwise clocked in the sysclk domain 3 does not require constraint eg clock 4 constant that is treated as false path for timing analysis these inputs must not change after the processor is taken out of reset 5 timing is speciÔ¨Åed with symbol in techvarsscr script eg ram timing 6 atestrelatedinputoroutputthatistreatedasfalsepathfortiminganalysissuchinputsmust not change during normal atspeed operation 7 an asynchronous input if clock domain is specified the signal is clocked in the sysclk domain the table below shows the possible port connections for the top level module of the lx5280 processor known as lx2 the actual ports that are present depends upon lconfigsettings the timing information and notes have the same meaning as for the previous table names that include _n indicate active low signals all other signals are active high unless otherwise indicated forsinglebitsignalsthesignalnameandsignaldescriptionindicatetheactionorfunctionwhenthesignalis in the active state table 49 lx5280 processor port summary port name io timing description clocking reset interrupts and control sysclk input 3 processor clock sysclkf input 3 freerunningprocessorclockifproces sor is conÔ¨Ågured with sleep support sl_sleepsys_r output 30 clock gating term for sysclk if pro cessorisconÔ¨Åguredwithsleepsupport busclk input 3 bus clock if processor is conÔ¨Ågured with async lbc busclkf input 3 free running bus clock if processor is conÔ¨Ågured with async lbc sleep sup portapril 30 2001 lx5280 lexra proprietary confidential 110 release 19 sl_sleepbus_br output 30 clock gating term for busclk if pro cessor is conÔ¨Ågured with async lbc and sleep support resetn input 10 warm reset or reset button active low cresetn input 10 cold reset or power on active low reset_d1_r_n input 30 sysclk domain reset combination of resetn cresetn ejtag reset_d1_br_n input 30 busclk domain reset combination of resetn cresetn ejtag reset_pwron_c1_n input 30 power on reset copy for jtag reset_pwron_d1_lr_n input 30 sysclk domain power on reset for ejtag reset_d1_r_n_o output 30 sysclk domain reset combination of resetn cresetn ejtag reset_d1_br_n_o output 30 2 busclk domain reset combination of resetn cresetn ejtag reset_pwron_c1_n_o output 30 power on reset copy for jtag reset_pwron_d1_lr_n_o output 30 sysclk domain power on reset for ejtag intreq_n152 input 7 interrupt requests ext_halt_p input 50 external stall line ext_sleepreq_r input 30 external sleep request conÔ¨Åguration cfg_tlb_disable input 4 disable tlb mappings even if tlb is present cfg_sleepenable input 4 sleep enable conÔ¨Åguration cfg_rad_lexop50 input 4 lexop encoding must be 011111 for lx5280 cfg_rad_disable input 4 lexop disable conÔ¨Åguration must be one for lx5280 cfg_singleissue input 4 forces single instruction issue cfg_hlenable input 4 strap to one to enable internal hilo registers cfg_macenable input 4 strap to one to enable internal mac if present cfg_memsequential input 4 strap to one if line reads return words in sequential order zero if interleave order cfg_memzerofirst input 4 strap to one if line reads return word zero Ô¨Årst zero if desired word Ô¨Årstport name io timing descriptionapril 30 2001 lx5280 lexra proprietary confidential 111 release 19 cfg_memfullword input 4 strap to one if main memory must be written with 32bit words zero if byte and halfword writes are allowed cfg_lbcwbdisable input 4 strap to one to disable read bypass of lbc write buffer zero to allow read bypass cfg_ejtnminus110 input 4 strap with ejtag dclk n minus 1 conÔ¨Åguration 0314 cfg_ejtmlog210 input 4 strap with ejtag m log2 031248 conÔ¨Åguration cfg_ejt3bitxvtpc input 4 strap with etjag 3bit tpc conÔ¨Ågura tion cfg_ejtbit0m16 input 4 strap with ejtag pc bit0 in tpc Ô¨Åguration cfg_dwbase3110 input 30 strapped with dmem base address conÔ¨Åguration value cfg_dwtop2310 input 30 strapped with dmem top address Ô¨Åguration value cfg_iwbase3110 input 30 strappedwithimembaseaddresscon Ô¨Åguration value cfg_iwtop2310 input 30 strapped with imem top address Ô¨Åguration value cfg_iwrom input 4 straptoonetotreatimemlikearom note new applications should use irom instead of romlike imem cfg_iroff input 4 strap to one to disable irom cfg_dwdisw input 4 strap to one to disable processor dmem writes must be zero for lx5280 cfg_ejdis input 4 must be strapped to zero test and debug jtag_reset_o output 20 1 jtag is in testlogicreset state active low jtag_reset input 6 jtag is in testlogicreset state active low tap_reset_n_o output 20 1 tap controller reset tap_reset_n input 6 tap controller reset jtag_tdo_nr output 50 1 test data out active low jtag_tdi input 60 1 test data in jtag_tms input 60 1 test mode select jtag_clock input 3 test clockport name io timing descriptionapril 30 2001 lx5280 lexra proprietary confidential 112 release 19 jtag_trst_n input 6 test reset jtag_capture output 20 1 jtag is in data register cap ture state jtag_scanin output 50 1 scan input to chain jtag_scanout input 50 1 scan output from chain jtag_ir40 output 20 1 contents of instruction regis ter jtag_shift_ir output 20 1 jtagisinshiftinstructionreg ister state jtag_shift_dr output 20 1 jtag is in shift data register state jtag_runtest output 20 1 jtag is in runtest state jtag_update output 20 1 jtag is in data register update state ejc_ecrprobeen_r output 30 one indicates ejtag probe is active jpt_pcst_drm10 output 30 ejtagpctracestatusm124or8 jpt_tpc_drn310 output 30 ejtag pc trace value n 1 2 3 or 4 jpt_dclk output 3 ejtag pc trace clock sen input 6 scan enable active high tmode input 6 test mode active high sink0 input 6 scan input k can range from 7 to 0 soutk0 output 6 scan output k can range from 7 to 0 rbc_sel70 input 6 ram bist ram select code 10000000 instruction mem 01000000 data mem 00100000 dcache data store 00010000 dcache tag store 00001000 icache tag store set 1 00000100 icache inst store set 1 00000010 icache tag store set 0 00000001 icache inst store set 0 rbc_wek0 input 6 rambistwriteenablewherekis1 for word write granularity 7 for byte write granularity rbc_re input 6 ram bist read enable rbc_cs input 6 ram bist select rbc_addr150 input 6 ram bist address rbc_datawr630 input 6 ram bist write data rbm_datard630 output 6 ram bist read dataport name io timing descriptionapril 30 2001 lx5280 lexra proprietary confidential 113 release 19 lbc interface to lbus laddro310 output 2 20 address lcmdo60 output 2 20 lbc command ldatao310 output 2 20 lbc data ldatai310 input 2 50 system data lirdyo output 2 20 lbc initiator ready lirdyi input 2 30 system initiator ready lframeo output 2 20 lbc transaction frame lframei input 2 30 system transaction frame lsel input 2 30 system slave select ltrdyi input 2 30 system target ready xbrdvld input 2 30 crossbar read data valid xbrdsize input 2 30 split read data size spltrdfull output 2 30 read data queue full lid output 2 20 instructiondata luc output 2 20 bus request lcoe90 output 2 20 command output enable ltoe output 2 20 transaction output enable ldoe70 output 2 20 data output enable lreq output 2 50 bus request lgnt input 2 30 bus grant shared ram requestgrant interface ext_iwreqram_r input 30 external hardware drives to one to request access to imem iw_gntram_r output 30 cpu drives to one to grant external imem access request ext_dwreqram_r input 30 external hardware drives to one to request access to dmem dw_gntram_r output 30 cpu drives to one to grant external dmem access request ext_icreqram_r input 30 external hardware drives to one to request access to icache ic_gntram_r output 30 cpu drives to one to grant external icache access request ext_dcreqram_r input 30 external hardware drive to one to request access to dcacheport name io timing descriptionapril 30 2001 lx5280 lexra proprietary confidential 114 release 19 dc_gntram_r output 30 cpu drives to one to grant external dcache access request coprocessor interface czcondin input 80 cop branch Ô¨Çag czrd_addr40 output 50 cop read address czrhold output 45 cop hold condition one stalls copro cessor czrd_gen output 50 cop general register read command czrd_con output 50 cop control register read command czrd_data310 input 80 cop read data czwr_addr40 output 20 cop write address czwr_gen output 20 cop general register write command czwr_con output 20 cop control write address command czwr_data310 output 30 cop write data czinvld_m output 60 cop invalid instruction Ô¨Çag one indi cates invalid instruction in m stage czxcpn_m output 60 cop exception Ô¨Çag one indicates exception in m stage c3cnt_iparet output 20 count instructions retired pipe c3cnt_ipbret output 20 count instructions retired pipe b c3cnt_ifetch output 20 count instruction fetches c3cnt_imiss output 20 count icache misses c3cnt_istall output 20 count icache stalls c3cnt_dmiss output 20 count dcache misses c3cnt_dstall output 20 count dcache stalls c3cnt_dload output 20 count data load operations c3cnt_dstore output 20 count data store operations custom engine interface cei_ce1hold output 45 cpu is halting custom engine cei_ce1invld_m output 40 instruction is not valid m stage cei_ce1invldp_s_r output 30 instruction is not valid s stage cei_xcpn_m_c1 output 40 cpu reports exception cei_ce1op_s_r110 output 30 custom engine op code cei_instm32_s_r_c1_n output 30 one indicates 32bit instruction mode zero indicates 16bit instruction modeport name io timing descriptionapril 30 2001 lx5280 lexra proprietary confidential 115 release 19 cei_ce1aop_e_r310 output 35 operand cei_ce1bop_e_r310 output 35 b operand ce1_res_e310 input 45 result from custom engine ce1_sel_e_r input 30 one indicates custom engine opcode is present in stage ce1_halt_e_r20 input 20 custom engine stalls processor by drivingtoonesallowsprocessortorun by driving to zeros copies must be suppliedfrommultipleregisterstomeet timing requirementsport name io timing descriptionapril 30 2001 lx5280 lexra proprietary confidential 116 release 19 april 30 2001 lx5280 lexra proprietary confidential 117 release 19 appendix c lx5280 pipeline stalls this section documents stall conditions that may arise in the lx5280 c1 stall deÔ¨Ånitions issue stall an invalid instruction enters the pipe while any other valid instructions in the pipe advance pipeline stall all instructions in either pipe stay in the same stage and do not advance dualissue interlock only one of the potential pair of instructions enters pipe the other instruction of the pair waits for the next cycle to enter stall if not otherwise qualified means pipeline stall c2 instruction groupings these instruction groupings are used to describe stall conditions that are based on the type of instructions in the pipeline table 50 instruction groupings for stall deÔ¨Ånition group name instructions in group miloadstore lb lh lw lbu lhu lwc1 lwc2 lwc3 sb sh sw swc1 swc2 swc3 mimac multudivumfhimflomthimtlo micontrol j jalx jr jalr bltzal bgezal linked branches syscall break all copz mfcz cfcz mtcz ctcz bcfz bctz rfe lwcz swcz also in loadstore group miunlinkedbranch beq bne blez bgtz bltz bgez migeneral all remaining instructions mivcmove movz movn m16loadstore lb lh lwsp lw lbu lhu lwpc sb sh swsp sw swrasp m16mac multu divu mfhi mflo m16control jalx jr jalr break m16unlinkedbranch b beqz bnez bteqz btnez m16general all remaining m16 instructions radmac mta2 mfa mfa2 multau multa2 mulna2 cmulta maddau msubau addma subma divau madda2 msuba2 rnda2 radloadstore lt ltp lwp lhp lbp lhpu lbpu st stp swp shp sbp radcontrol mtru mfru mtrk mfrk mtlxc0 mflxc0april 30 2001 lx5280 lexra proprietary confidential 118 release 19 c3 dual pipe issue rules these instruction groups must issue to pipe miloadstore micontrol miunlinkedbranch m16loadstore m16control m16unlinkedbranch radloadstore radcontrol ejtagcontrol these instruction groups must issue to pipe b mimac m16mac radmac these instruction groups must single issue micontrol radcontrol ejtagcontrol all m16 instructions instruction doubleword issue rule inorderforapairofinstructionstodualissuetheymustbefoundinthesamealigneddoubleword unlinkedbranchdelay slot rules anunlinkedbranchcandualissuewiththeprecedinginstructionifnootherrulesareviolatedthe delay slot instruction of an miunlinkedbranch single issues in the cycle following the unlinkedbranch producerconsumer readafterwrite raw hazard pair of instructions will not dual issue if the second instruction uses register updated by the first instruction this does not apply to register 0 which never causes an interlock producerproducer writeafterwrite waw hazard apairofinstructionswillnotdualissueifthesecondinstructionupdatesaregisterupdatedbythe firstinstructionunlessthecommontargetregisterisalsoasourceregisterofthesecondinstruction in which case the raw interlock applies useful program is expected to include such pair of instructions since the results of the first update are lost this does not apply to register 0 which never causes an interlock examples both raw and waw apply causing single issue 00 add s0s1s2 04 add s0s0s3 2xsingle issue s0 raw first instruction does useful work visible only in case of exception 00 add s0s1s2 04 add s0s4s3 2xsingle issue s0 wawradgeneral all remaining rad instructions ejtagcontrol deret sdbbp m16sdbbpgroup name instructions in groupapril 30 2001 lx5280 lexra proprietary confidential 119 release 19 c4 m16 32bit instructions m16jalx issues in two consecutive cycles m16 extended instructions issue in two consecutive cycles c5 nonsequential program flow issue stalls jr jalr and m16 jr jalr alx two issue stalls after the delay slot instruction the delay slot instruction always single issues j jalx and taken branches stall cycles after the delay slot instruction the delay slot instruction always single issues m16 taken branches one issue stall after the branch nottaken branches two issue stalls after the delay slot instruction the delay slot instruction always single issues m16 nottaken branches three issue stalls after the branch the branch rules are consequence of the fact that all branches are assumed to be taken c6 loadstore rules store twinword dualissue interlock thestoretwinwordinstructionsststpalwayssingleissuebecausetheyuse3ofthe4register file read ports leaving only one for the other instruction which usually needs two read ports m16 load slot issue stall there is one unconditional issue stall after any m16 load instruction there is m16 target register analysis loaduse single cycle issue stall after load instruction to target register an instruction which follows the load by one cycle and uses the target register of the load will stall issue for one cycle note the architectural loaddelay slot has been eliminated this issue stall applies even to theapril 30 2001 lx5280 lexra proprietary confidential 120 release 19 instruction immediately following the load this does not apply to m16 loads since they are always followed by single cycle issue stall examples this executes in 3 cycles 00 lw s00a0 04 addi a04 dual issue 08 add s1s0 0c add t1t2 stalls0 loaduse dual issue this executes in 3 cycles 00 lw s00a0 04 addi a04 dual issue 08 add t1t2 0c add s1s0 2xsingle issue s0 loaduse this executes in 3 cycles 00 add t1t2 04 lw s00a0 dual issue 08 addi a04 0c add s1s0 2xsingle issue s0 loaduse this executes in 3 cycles 00 lw s00a0 04 lw s24a0 2xpipea single issue 08 add s1s0 0c addi a08 dual issue this executes in 3 cycles note elimination of architectural delay slot 00 add t1t2 04 lw s00a0 dual issue 08 add s1s0 0c addi a04 stalls0 loaduse dual issue this executes in 2 cycles 00 add t1t2 04 lw s00a0 dual issue 08 add s2s1 0c addi a04 dual issue s0 not used for twinword loads lt ltp this rule applies to both of the target registers in the registerpair operand for radiax pointerupdate load instructions lbplhpltplwplbpu this rule does not apply to the updated pointer register which is covered by the raw and waw hazard dualissue interlocks load subword stall load instructions which have byte or halfword operands always cause onecycle stall storeload stall load instruction which follows store instruction by one cycle always causes onecycle stall note this stall only applies if the store instruction hits in the dcache or has byte or halfword operand examples this executes in 3 cycles 00 sw s04a0 04 addi a08 dual issue 08 add s0s1 0c lw s20a0 dual issue and swlw stallapril 30 2001 lx5280 lexra proprietary confidential 121 release 19 this executes in 3 cycles 00 sw s04a0 04 addi a08 dual issue 08 lw s20a0 0c add s0s1 dual issue and swlw stall this executes in 4 cycles 00 sw s04a0 04 lw s28a0 2xpipea sing issue and swlw stall 08 addi a08 0c add s0s1 dual issue this executes in 2 cycles 00 lw s20a0 04 add s0s1 dual issue 08 sw s04a0 0c addi a08 dual issue lwsw okay storetwin storeany stall anystoreinstructionwhichfollowsastoretwinwordinstructionststpbyonecyclealways causes single cycle stall examples this executes in 4 cycles 00 nop 04 st s08a0 2xsingle issue st single issue 08 add s0s1 0c sw s20a0 dual issue and stsw stall this executes in 3 cycles 00 st s20a0 04 st s08a0 2xsingle issue and stst stall storeany storesubword stall astoreinstructionwhichhasabyteorhalfwordoperandandwhichfollowsanystoreinstruction by one cycle always causes onecycle stall this cycle includes any potential storetwin storeany stall examples this executes in 3 cycles 00 sw s04a0 04 addi a08 dual issue 08 add s0s1 0c sb s20a0 dual issue and swsb stall this executes in 4 cycles 00 sh s04a0 04 addi a08 dual issue and subword stall 08 sb s20a0 0c add s0s1 dual issue and shsb stall this executes in 3 cycles 00 st s20a0 04 sb s03a0 2xsingle issue and stsb stall this executes in 4 cycles 00 nop 04 st s08a0 2xsingle issue st single issue 08 add s0s1 0c sb s20a0 dual issue and stsb stall c7 loadstore ops stall matrix the following table summarizes the stall rules related to load and store instructions described above thisapril 30 2001 lx5280 lexra proprietary confidential 122 release 19 table does not include the raw and waw dualissue interlocks in this table the 2nd op refers to an instruction which issues in the cycle after the 1st op table 51 loadstore ops stall matrix notes means stalls xu indicates unconditional stall for the indicated number of cycles xs indicates stall only if 2ndop source 1stop loadtarget xw indicates stall if data rams have wordwrite granularity c8 mac ops interlock matrix the mac in the 5280 eliminates all programming hazards between mac instructions by stalling the pipeline as necessary this is done both to avoid resource conflicts as well as to wait for results of first instruction that is needed by second instruction the following table indicates the number of cycles that must be inserted between the first indicated instructionandthesecondazeroordashindicatesthattheinstructionscanissuebacktobacktothemac pipe with stalls nonzero number indicates the number of stall cycles that will occur if the instructions are issued in consecutive cycles these stall cycles are available for any other nonmac instructions but should not be filled with nops since that would only increase the code footprint without improving performancem16 lwm16 lbu lhumirad lbu lhumirad lbpu lhpusb sbp sh shpsw swpst stp non loadstore1u 2u 1s1u 2s lt ltp lw lwp lbu lhu lbpu lhpu1u 2u 1s 2s 1u 1u 1u sbsbpsh shp1u 2u 1s1u 2s1u 1u 1u sw swp st stp1u 2u 1s 2s 1u1st op 2nd opapril 30 2001 lx5280 lexra proprietary confidential 123 release 19 table 52 cycles required between dual mac instructions nomenclaturemultau multumaddau msubau madu msubu cmultadivau divumadda2s msuba2s addmas submas multa2 mulna2 rnda2 mta2 mthi mtlomfa mfa2 mfhi mflo multau maddau msubau madu msubu1u 1u 1u 19t divau divu3t 4t 1t 19u cmulta madda2s msuba2s multa2 mulna2 mta2 mthi mtlo3u 4u 1u 19t addmas submas rnda2lo 2s 2thi 3s 3t4u1s 1t19s 19t mfa mfa2 mfhi mflolo 4shi 5slo 5shi 6s 3s 19s 2s the two ops can be issued backtoback xu unconditional delay of the indicated number of cycles xs delayonlyifany2ndopsourceisthesameasany1stoptar get producerconsumer dependency xt delay only if any 2nd op target is the same as any 1s op tar get preserve write after write order items in parenthesis are unlikely to occur in any useful program which would probably have an intervening mfa lohi for the 72bit result of 32x32 mult or madda the 32bits m0l m1l etc are available one cycle earlier delay of x cycles means that if the 1st op issues in cycle n then the 2nd op may issue in cycle nx12nd op1st opapril 30 2001 lx5280 lexra proprietary confidential 124 release 19 examples this executes in 7 cycles 00 mult s0s1 04 addi a08 dual issue 08 lw s00a0 0c lw s10a0 2xpipea sing issue 10 addi a14 14 mflo v0 dual issue and stall2 18 sw v00a1 1c nop dual issue c9 mvcz stall the coprocessor move instructions lwcz mtcz mfcz and radiax mtlxc0 mflxc0 mtru mfru mtrk mfrk always single issue and are always followed by single cycle issue stall c10 zovloop rules there are special zovloop rules but the execution of zovloop must follow all of the other rules as it wraps from the loop end back to the loop start unless one of these other rules require it there are stall cycles between loop end and loop start examples lps 00 lpe 0c unless otherwise noted executes in 2 cycles per loop but gets the wrong answer 00 add s1s0 04 addi a08 dual issue 08 add t1t2 0c lw s00a0 dual issue 00 add s1s0 04 addi a08 dual issue bad s1 result 08 add t1t2 0c lw s00a0 dual issue executes in 3 cycles per loop 00 addi a08 04 add s1s0 dual issue 08 add t1t2 0c lw s00a0 dual issue 00 addi a08 04 add s1s0 2x single issue s0 loaduse 08 add t1t2 0c lw s00a0 dual issue executes in 2 cycles per loop 00 addi a08 04 add t1t2 dual issue 08 add s1s0 0c lw s00a0 dual issue 00 addi a08 04 add t1t2 dual issue 08 add s1s0 0c lw s00a0 dual issue executes in 4 cycles per loop block copy one word per loop 00 addi a04 04 lw s00a1 dual issue 08 addi a14 0c sw s00a0 2x single issue s0 loaduse addi a04 04 lw s00a1 2x single issue swlw stall 08 addi a14 0c sw s00a0 2x single issue s0 loaduse executes in 5 cycles per loop block copy two words per loop lps 00 lpe 14 00 lw s00a1 04 lw s14a1 2x pipea single issue 08 sw s00a0 0c sw s14a0 2x pipea single issue 10 addi a08 14 addi a18 dual issue 00 lw s00a1 04 lw s14a1 2x pipea single issue 08 sw s00a0 0c sw s14a0 2x pipea single issue 10 addi a08 14 addi a18 dual issueapril 30 2001 lx5280 lexra proprietary confidential 125 release 19 use pointerupdate instructions executes in 3 cycles per loop poor 00 lwp s0a08 04 add s1s2 dual issue 08 lw s24a0 0c add s1s0 2x single issue s0 loaduse 00 lwp s0a08 04 add s1s2 dual issue s2 already delayed 08 lw s24a0 0c add s1s0 2x single issue s0 loaduse executes in 2 cycles per loop optimum 00 add s1s0 04 lwp s0a08 dual issue 08 add s1s2 0c lw s24a0 dual issue 00 add s1s0 04 lwp s0a08 dual issue 08 add s1s2 0c lw s24a0 dual issue lps 04 lpe 10 poor alignment executes in 3 cycles per loop 00 04 add s1s0 single issue 08 add t1t2 0c lw s00a0 dual issue 10 addi a08 14 single issue 00 04 add s1s0 single issue 08 add t1t2 0c lw s00a0 dual issue 10 addi a08 14 single issue c11 immu stalls immu stall when the program jumps branches or increments between the two most recently used pages single cycle stall is incurred when the program jumps branches or increments to third page twocycle stall is incurred immu issue stall when an immu stall occurs due to incrementing across page boundary and there is any of the following instructions found anywhere in the last doubleword of the page then there is one issue stall in addition to the immu stalls or m16 branch of any kind j jalx ejtag deret m16 extend m16 jalx first half c12 cache miss stalls instruction cache miss stall whenaninstructioncachemissoccurstheprocessorisstalledforthedurationofthecachelinefill operation the number of cycles required to complete the line fill is system dependent instruction cache 2way soft miss stallapril 30 2001 lx5280 lexra proprietary confidential 126 release 19 when 2way set associative instruction cache is in use softmiss is defined as hit in the unpredicted set with set prediction defined as follows ifnotrunninginlockmodeorifthecurrentcacheindexhasnolockedlinesetpredictionisbased onthe lru bit predict the nonleast recently used set at the current cache index if running in lock mode and the current cache index has locked line set prediction is based on the previous icache access predict the locked set if the previous icache access hit locked line and vice versa soft miss always causes twocycle stall data cache miss stall whenadatacachemissoccursastheresultofaloadinstructiontheprocessorstallswhileitwaits for the data the data cache releases the stall condition after the required word is supplied to the processorevenifadditionalwordsmuststillbefilledintothedatacachehoweveriftheprocessor issues another load or store operation to the data cache while the remainder of the line fill is in progress the cache will again stall the processor until the line fill operation is completed when data cache miss occurs as result of load byte or load halfword the processor stalls for the duration of the cache line fill operation the number of cycles required to complete the line fill is system dependent c13 nonsequential program flow issue stall pipeline diagrams jrjalr and m16 jrjalrjalx jr i d s m w delayslot i d s m w notvld i notvld i target i d s i d s j jalx and taken branches j i d s m w delayslot i d s m w target i d s m i d s m m16 taken branches b i d s m w notvld i target i d s m nottaken branches bntkn i d s m w delayslot i d s m w notvld i notvld i delay4 i d s i d sapril 30 2001 lx5280 lexra proprietary confidential 127 release 19 m16 nottaken branches bntkn i d s m w notvld i notvld i notvld i delay4 i d s c14 loadstore stall pipeline diagrams m16 load slot issue stall load i d s m w notvld i load2 i d s m loaduse single cycle issue stall 00 lw s00a0 i d s m w 04 addi a04 i d s m w 08 add s1s0 i d d s m w 0c add t1t2 i d d s m w 00 lw s00a0 i d s m w 04 addi a04 i d s m w 08 add t1t2 i d s m w 0c add s1s0 i d d s m w 00 add t1t2 i d s m w 04 lw s00a0 i d s m w 08 addi a04 i d s m w 0c add s1s0 i d d s m w 00 lw s00a0 i d s m w 04 lw s24a0 i d d s m w 08 add s1s0 i d s m w 0c addi a08 i d s m w load subword stall 00 lb i d s m m w 04 foo1 i d s m m w 08 foo2 i d s m w 0c foo3 i d s m w 10 foo4 i d s s m w 14 foo5 i d s s m w rhold x storeload stall 00 sw s04a0 i d s m w 04 addi a08 i d s m w 08 add s0s1 i d s m m w 0c lw s20a0 i d s m m w 10 foo2 i d s m w 14 foo3 i d s m w rhold xapril 30 2001 lx5280 lexra proprietary confidential 128 release 19 00 sw s04a0 i d s m w 04 lw s28a0 i d d s m m w 08 addi a08 i d s m w 0c add s0s2 i d s m w 10 foo2 i d s s m w 14 foo3 i d s s m w rhold x storetwin storeany stall 00 nop i d s m w 04 st s08a0 i d d s m w1 w2 08 add s0s1 i d s m m w 0c sw s20a0 i d s m m w 10 foo2 i d s m w 14 foo3 i d s m w rhold x 00 st s20a0 i d s m w1 w2 04 st s08a0 i d d s m m w1 w2 08 foo2 i d s m w 0c foo3 i d s m w 10 foo4 i d s s m w 14 foo5 i d s s m w rhold x storeany storesubword stall 00 sw s04a0 i d s m w 04 addi a08 i d s m w 08 add s0s1 i d s m m w 0c sb s20a0 i d s m m w 10 foo2 i d s m w 14 foo3 i d s m w rhold x 00 sh s04a0 i d s m m w 04 addi a08 i d s m m w 08 sb s20a0 i d s m m w 0c add s0s1 i d s m m w 10 foo2 i d s s m w 14 foo3 i d s s m w rhold x x 00 st s20a0 i d s m w1 w2 04 sb s03a0 i d d s m m w 08 foo2 i d s m w 0c foo3 i d s m w 10 foo4 i d s s m w 14 foo5 i d s s m w rhold xapril 30 2001 lx5280 lexra proprietary confidential 129 release 19 00 nop i d s m w 04 st s08a0 i d d s m w1 w2 08 add s0s1 i d s m m w 0c sb s20a0 i d s m m w 10 foo2 i d s m w 14 foo3 i d s m w rhold x c15 mac ops interlock pipeline diagram 00 mult s0s1 i d s m 04 addi a08 i d s m w 08 lw s00a0 i d s m w 0c lw s10a0 i d s m m m w 10 addi a14 i d s m w 14 mflo v0 i d s m w 18 sw v00a1 i d s s s m w 1c nop i d s s s m w multcount4s 0 1 2 3 4 rhold x x c16 mvcz stall pipeline diagrams 00 mtc0 i d s m w notvld i 04 foo i d d d s m w 08 foo1 i d s m w 0c foo2 i d s m w 00 nop i d s m w 04 mtc0 i d d s m w notvld i 08 foo1 i d d s m w 0c foo2 i d d s m w 10 foo3 i d s m w 14 foo4 i d s m w c17 zovloop pipeline diagrams 00 addi a04 i d s m w 04 lw s00a1 i d s m w 08 addi a14 i d s m w 0c sw s00a0 i d d s m w 00 addi a04 i d s m w 04 lw s00a1 i d s m m w 08 addi a14 i d s m w 0c sw s00a0 i d d s s m w rhold xapril 30 2001 lx5280 lexra proprietary confidential 130 release 19 00 lw s00a1 i d s m w 04 lw s14a1 i d d s m w 08 sw s00a0 i d s m w 0c sw s14a0 i d d s m w 10 addi a08 i d s m w 14 addi a18 i d s m w 00 lwp s0a08 i d s m w 04 add s1s2 i d s m w 08 lw s24a0 i d s m w 0c add s1s0 i d d s m w 00 lwp s0a08 i d s m w 04 add s1s2 i d s m w 08 lw s24a0 i d s m w 0c add s1s0 i d d s m w c18 cache miss pipeline diagrams icache miss pipeline diagram 00 foo0 i d s m m m m m m w 04 foo1 i d s m m m m m m w 08 foo2 i d s m w 0c foo3 i d s m w 10 foo4 i d i d s m w 14 foo5 i d i d s m w rhold x x x x x icache 2way soft miss pipeline diagram 00 foo0 i d s m m m w 04 foo1 i d s m m m w 08 foo2 i d s m w 0c foo3 i d s m w 10 foo4 i d i d s m w 14 foo5 i d i d s m w 18 foo6 i d s m w 1c foo7 i d s m w rhold x x dcache miss pipeline diagram 00 foo i d s m w 04 lw i d s m w 08 foo1 i d s m m m m m w 0c foo2 i d s m m m m m w 08 foo3 i d s m w 0c foo4 i d s m w rhold x x x x