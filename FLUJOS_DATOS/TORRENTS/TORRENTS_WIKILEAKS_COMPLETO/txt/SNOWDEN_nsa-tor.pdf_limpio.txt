top secretcomint20291123 ufouo tor 2006 ces summer program abstract u tor is an opensource anonymization program created by roger dingledine nick mathewson and paul syverson originally sponsored by the us naval research laboratory and now backed by the electronic frontier foundation it routes users trac through several servers in way that hides the users location tssi we have seen several targets using tor our goal was to analyze tor source code and determine any vulnerabilities in the system we set up an internal tor network to analyze tor trac in the hopes of discovering ways to passively identify it we also worked to create custom tor client which allows the user ner control contents 1 u tor overview 3 2 ufouo objectives 4 3 ufouo objectives 1 and 2 4 4 ufouo mjolnir 4 41 ufouo building circuits 5 42 ufouo sending and receiving data 6 43 ufouo mjolnir gui for windows 7 5 ssi tors x509 certi cates 8 51 ssi mjolnirs x509 certi cates 8 6 u tors hidden services 10 7 ufouo possible attacks 10 71 tssi denialofservicestyle attacks with mjolnir 11 711 tssi coil attack 11 712 tssi flower attack 12 72 ufouo trac analysis 12 721 u basic tor circuit 12 722 ssi locating known hidden services 15 73 ssi discovering unknown hidden services 16 74 ufouo maninthemiddle attack 17 1 top secretcomint20291123 top secretcomint20291123 8 u future areas of study 17 81 ufouo expanding mjolnirs functionality 18 82 u privoxy 18 83 u tor remote control 18 84 tssi directory server exploitation 19 9 u acknowledgments 19 10 u references 19 ufouo tor glossary 21 b u programming details 21 b1 u building circuits 21 b11 u choosing server 23 b2 u connecting the circuit 24 b3 u encryption 26 b31 utls encryption 26 b32 u onion skins 27 c u hidden services 29 c1 u ering hidden service 29 c2 u accessing hidden service 29 d u information at the nodes 30 d1 u first node 31 d2 u second node 32 d3 u third node 32 d4 u hidden service nodes 33 d41 u introduction points 33 d42 u rendezvous points 34 ufouo mjolnir api 35 e1 u initialization 35 e2 ssi circuit building 37 e3 ufouo sending and receiving data 39 e4 ssi smartlists and certi cate masking 42 e5 tssi dosstyle attacks 44 f ufouo mjolnir for windows 46 f1 u interface 46 f2 ssi creating new circuits 46 f3 tssi dosstyle attacks 47 f4 tssi sending arbitrary packets 47 2 top secretcomint20291123top secretcomint20291123 f5 u future features 49 f51 u minor changesbug xes 49 1 u tor overview u tor is an implementation of an onion routing system its creators use special jargon to describe its workings please consult appendix tor glossary for nitions tors anonymization works by having tor client send its trac through circuit of three servers each running tor under several layers of encryption this accomplishes several things most basically the tor servers many of which are listed on publicly advertised directory servers are chosen to act as series of proxies this may seem to be excessively complex as single proxy server can be used to hide ones location but singlehop proxy is vulnerable in two ways first by analyzing the pattern of the trac going to and from the proxy server it is possible to deduce which clients are making which requests second if an attacker owns the proxy server then it certainly knows who is asking for what and anonymization is ruined by using multiple hops tor is much more resistant to both of these attacks trac analysis becomes extraordinarily dicult as it must be coordinated across several machines and an attacker must own all the hops along the circuit in order to trace requests back to the originating client u if tors only feature was the use multiple proxies it would not necessarily mean that it could not be attacked some way such as knowing which circuit client will choose to route trac through or simply reading requests sent in the clear and looking for identifying information however tor leverages the openssl cryptographic libraries to encrypt the data it sends and to choose random circuits in order to prevent an attacker from gaining useful information u the series of tor servers used to relay clients tcp trac is referred to as circuit circuits are set up one server at time in way that keeps any single server from knowing the entire layout of the circuit the client connects to the rst server it then asks the rst server to connect to the second server finally it sends request through the rst server that asks the second server connect to the third server each server only knows who connected to it and to whom it connected which is just one server each way in the circuit more detailed explanation can be found in appendix b1 u the phrase onion routing refers to the way that encryption is layered to hide information sent down the circuit when setting up the circuit the client negotiates keys with each of the servers it will be routing through most circuits in tor contain three servers so the client negotiates three secret keys one with each server when the client wants to send some data for example an http get request it rst encrypts the data once using each key it sends the packet to the rst server which removes one layer of encryption and passes along the packet to the second server the second server removes another layer of encryption and sends the packet to the third server when the third server removes layer of encryption then the packet is now in the clear and the server will send the http get to the appropriate destination in this way only the third server can see 3 top secretcomint20291123top secretcomint20291123 what the client is sending and to anyone outside of the tor cloud it appears that the third node originated the request u in short tor uses combination of encryption and multiple proxies to hide who is sending what through the tor cloud 2 ufouo objectives 1 ufouo become familiar with tor by setting up an internal tor network 2 ufouo read the documentation and code of as well as examine the packets sent and received by the client 3 ssi develop detailed client speci cations and requirements and document them for the community 4 ssi create tor client libraries to be leveraged by networkenabled application 5 ssi create tor client using the above tor libraries that allows for onthe tweaking of the clients behavior in the tor cloud ufouo we feel that we accomplished all of these objectives as well as few other unspeci ed goals this paper discusses our progress on all of these objectives 3 ufouo objectives 1 and 2 ssi we set up our own internal tor network on eight machines in the protocol ex ploitation lab the network consisted of two directory servers ve servers and 1 machine that was gured to act only as client they were connected to each other through the same hub and we used ethereal to sni packets that they sent back and forth ufouo tor is large opensource project and we were able to download its source code and documentation from tore org most of our analysis was performed using source code from tor versions 01117 and 01121 there were major di erences between the two versions and the core functionality of building circuits and maintaining interserver connections remained unchanged ufouo our analysis was threefold we read the protocol speci cation exam ined the source code and observed the actual behavior of our own tor cloud this gave us an excellent idea of how tor works allowing us to formulate hypotheses regarding tors behavior which we could then immediately test 4 ufouo mjolnir tssi another major objective was the speci cation and development of custom tor client library we developed library that allows the programmer control over all aspects 4 top secretcomint20291123top secretcomint20291123 of building circuit and sending data our library is as portable as tor itself and we have successfully compiled and tested it on both windows and linux we named the library mjolnir which is the name of thors hammer from norse mythology tssi mjolnir is modi cation of tor and it is ideally indistinguishable from an original tor client as such it should appear identical to tor in trac to ease this process we used original tor functions whenever possible however its main purpose is to provide the programmer with greater control over all aspects of tor in the normal tor client almost all servers in all circuits chosen randomly using mjolnir the programmer can build circuits one server at time with limit to the number of servers in the circuit then the programmer can send an arbitrary tcp payload across the circuit that he built and process the response however he wishes tssi all of mjolnirs most important calls in setting up circuit as well as sending data are blocking this is because the tor code is inextricably linked with libevent an opensource library that allows the user to set up signals that can be handled whenever they are needed whereas tor uses events and function called once per second to perform all its necessary checks and corrections mjolnir uses libevent internally so that each function does what it should do before returning control to the calling program it would be unfair to any programmer to require that any program using mjolnir should also be forced to use libevent at the same level that tor does we felt that having blocking calls was the lesser of two evils in this situation as only programs that follow tors structure could possibly nd libevent viable way of controlling program ow mjolnirs solution of using libevent internally does make the program slower but allows the programmer to know whether all of his requests succeed or fail immediately upon return to his program 41 ufouo building circuits tssi the most fundamental portion of mjolnir is its capability to build arbitrary circuits of any length using our library programmer can build circuit use it for some trac then extend it and continue using it like tor mjolnir allows multiple circuits to be active at one time and the user can send trac along any of them tssi in order to build circuit the client must have information about some of the servers in the tor cloud this information is kept on the directory servers and their mirrors and to get this information the client must request it speci cally from the directory mjolnir provides function updaterouterdescriptors which automates this process once mjolnir has the directory it can build circuits to any of the servers that it knows about servers that have middlemanonly exit policies are still allowed to be at the end of the circuit as it is being built however should the calling program want data to travel across the circuit it must be using an exit node that will allow trac to exit to where the program wants it to go or mjolnir will refuse to send the trac in the rst place tssi in order to build circuit the programmer must begin with call to mjolnirs function newarbitrary circuit bynickname which returns new cir cuittstructure with the given server as its rst node mjolnir also provides set 5 top secretcomint20291123top secretcomint20291123 of functions that will append another server to given circuit there is also function that will return random circuit of given length which is provided both in order to retain some of tors original functionality and to ease the process of constructing circuit mjolnir is designed to provide as much exibility as possible providing the programmer with wide array of options for building and extending circuits tssi in an ort to provide robust suite of functions mjolnir provides errorchecking at many di erent levels of circuit construction tor servers will fail when asked to connect to themselves but that error will not become apparent until data is sent across the circuit to avoid this problem mjolnir will watch what servers are added to the circuit and it will refuse to add server if it is currently at the end of the circuit in this case the circuit is not destroyed but there is at least one situation in which attempting to add circuit will result in the destruction of the entire circuit if the program attempts to connect to server that has gone down since being added then the circuit will be destroyed this is initiated by the end of the circuit rather than the client so we have control over it the calling program should always check return values to ensure that circuit constructions and extensions were successful 42 ufouo sending and receiving data tssi mjolnir would not be useful if it could not communicate with other computers fortunately tor makes it easy for mjolnir to send and receive data without relying on an outside program to send data mjolnir must have three things message destination and circuit across which to send the message presumably the rst two are application dependent while the circuit is easy enough to build using mjolnirs functions once circuit is built and message is ready to be sent the programmer needs to callsendpayload downcircwith the correct arguments and the message should get to the destination each new payload creates new application proxy ap connection which is only used internally normally outside applications eg web browser send their messages across tor using ap connections instead of creating ap connections when it gets request from another program mjolnir creates an ap connection when it has something to send across circuit tssi before the message is sent mjolnir sets up libevent events so that it can successfully read and write across that connection it uses the write event immediately when it sends payload it must still listen for response before returning control to the calling program in order to provide reasonable amount of time to receive response mjolnir uses timeout scheme modeled on tcp timeouts if mjolnir does not receive response before the timeout runs down then it will shut down the connections it is waiting on and return to the calling program tssi theoretically there should be way to shut down connections more ele gantly than using timeouts for example consider if mjolnir shut down connection when it received cell that was less than the maximum length initially this seems like good idea because tor servers should minimize the number of packets they send by send ing maximallength payloads whenever possible however upon inspection of the packets 6 top secretcomint20291123top secretcomint20291123 figure 1 tssi the basic gui window showing clockwise from top left circuits available servers and circuit contents servers do not always send maximallength cells so this method does not work also as far as tor is concerned there is di erence between cell at the beginning of message and cell at the end so there is easy way to know that message is complete without parsing the payload tssi once mjolnir receives cell it calls userset function payload readhandler this is pointer to function that takes string the pay load and its length unfortunately due to the problems described above there is way to handle an entire response if it comes in more than one cell each cell is handled individ ually however by setting this variable see the api in the appendix the calling program can do any operation on the incoming cells thereby parsing out any necessary data the exibility orded by this arrangement is largely what makes mjolnirs communication capabilities so useful 43 ufouo mjolnir gui for windows tssi in addition to porting the mjolnir library to windows in dynamic link library dll we created graphical user interface gui to implement custom tor client for windows tssi in its current state the windows version of mjolnir has the following capabilities creating new circuits appending node to an already existing circuit creating random circuits of arbitrary length 7 top secretcomint20291123top secretcomint20291123 performing coil and ower attacks on servers appending coils and owers to existing circuits sending arbitrary packets through circuit ufouo see appendix f for detailed information on the windows version of mjolnir 5 ssi tors x509 certi cates ssi the only part of normal tor interaction that does not take place under tls encryption is the tls handshake which has to be done in the clear we chose to focus on this trac to see if there was any way to identify tor trac since all trac under tls encryption looks the same u tor creates two x509 certi cates shortly after starting up in the function tortlscontext new the rst certi cate contains shortterm connection key and is signed by the machines public rsa key its identity key the second is selfsigned certi cate containing the identity key u typical tor x509 certi cate is shown in table 1 ssi the string tor appears in the organizationname of both the subject and issuer portions of the x509 certi cates this means that we see this string in the clear during the tls handshake by also taking advantage of the asn1 encoding that surrounds the string in the certi cate we were able to nd byte sequence that appears in every tor tls handshake this makes collection easy as we simply look for the byte sequence in trac see table 2 for the sequences 51 ssi mjolnirs x509 certi cates tssi when tor server receives certi cate it will verify that its peer sent it certi cate with all of the required elds for x509 certi cates and that its subjects com monname eld exists and is alphanumeric tor servers will not reject certi cate with period in them but they will generate log message to the ect that someone who is not using tor is trying to connect to the machine it does not check that the organizationname for either subject or issuer is tor and it does not check to see that the identity string is ever present because of this mjolnir can easily send certi cate with false or random information and still connect to the tor cloud tssi to send falsi ed certi cate mjolnir just needs an array of eldvalue pairs where the eld is the eld name of the x509 certi cate eg commonname or ganizationname countrycode and the value is the corresponding value of the eld eg mjolnir pantheonse as long as the eldvalue pair is valid mjolnir will put it into the certi cate so that anyone watching trac will not immediately realize that the trac from machine using mjolnir is tor trac 8 top secretcomint20291123top secretcomint20291123 table 1 u tors x509 certi cate version 3 0x2 this is hardcoded into tor serial number some number currently we dont know if this is random number or if there is some signi cance we do know that it is created with an openssl function signaturealgorithm sha1withrsaencryption issuer otor cnstring identity tor will always be present as the organizationname the commonname eld is more variable string will be the nick name of the server as listed in the public directories for clients without nicknames it will be the string client note that it will always be followed by identity validity not before time this is the time that the tls certi cate was created by tor not after time by default this is 2 hours later subject otor cnstring again tor is the organizationname this is hardcoded and will always be present string will be just the nickname of the server in the rst certi cate and will contain identity in the second selfsigned certi cate subject public key info public key algorithm rsaencryption rsa public key modulus 1024bit some number varies exponent 655370x10001 this is hard coded into tor signature algorithm sha1withrsaencryption this is followed by 1024 bits of signature 9 top secretcomint20291123top secretcomint20291123 byte sequence found in all tor x509 certi cates 30 xx 31 0c 30 0a 06 03 55 04 0a 13 03 54 4f 52 31 xx 30 xx 06 03 55 04 03 byte sequence found in x509 certi cates of clients with default settings 30 2a 31 0c 30 0a 06 03 55 04 0a 13 03 54 4f 52 31 1a 30 18 06 03 55 04 03 14 11 63 6c 69 65 6e 74 20 3c 69 64 65 6e 74 69 74 79 3e this corresponds roughly to the part of the certi cate that says organization nametor and commonnameclient identity table 2 ssi tor byte sequences tssi if the programmer does not provide mjolnir with the subjects common name then it will randomly generate using openssls random byte generator legal commonname between 10 and 21 bytes long this ensures that even if the programmer forgets to give certi cate to the program there will be identifying information in the tls handshake 6 u tors hidden services u tor allows machines to er tcp service without revealing their ip address using the same anonymization techniques as clients connected to the network such services can only be connected to through the tor network and are accessed by special onion addresses resolved by tor directory servers this ers several bene ts to the operator of the service such service can be hosted from behind rewall or nat and any attackers attempting to perform distributeddenialofservice attack will be stymied because they do not know the machines ip address for details on the hidden service protocols see appendix c ssi currently there are roughly 50 publicly advertised hidden services this number seems low given tors rising popularity it seems likely that more than 50 hidden services exist the ability to locate hidden services is important as only then will we be able to police andor exploit them unfortunately we were not able to nd any good way to discover new hidden service or to nd where known hidden service is hosted for more discussion see sections 722 locating known hidden services and 73 discovering unknown hidden services 7 ufouo possible attacks tssi this portion of the paper will be devoted to several possible attacks related to tor their application is mostly speculative as we have not implemented any of them except for the mjolnirrelated attacks and we have not attempted any of them outside 10 top secretcomint20291123top secretcomint20291123 of the lab these descriptions are intended to be used as possible avenues for future research and development 71 tssi denialofservicestyle attacks with mjolnir tssi an unmodi ed tor client will never include given server in circuit more than once this ensures that server will have to do more work than any other however only the client can check for repeated servers with mjolnir we can build an arbitrary circuit of arbitrary length violating nearly all restrictions on circuit construction with impunity this capability allows for many interesting dosstyle attacks as we can force other server to do many times the work we have to since tor normally sends packets of length 586 large circuits can heavily tax the tor cloud in general and targeted server in particular tssi the biggest problem with these attacks is that they take us large amount of work to set up for an nserver circuit we must send at least ncells to set up that circuit building circuit can take large amount of time especially if the servers are on di erent continents as is the case in the tor cloud the number of packets generated is on the order of n2 and the time to set up circuit grows similarly once the circuit is set up the amount of trac grows linearly with the number of servers on the circuit tssi the point of building these circuits is to get target servers to handle much more trac than our client machine while not disturbing the rest of the tor cloud once the circuit is set up this is not problem for example if we set up circuit in which one server appears 50 times it will always do at least 50 times more work than our machine once the circuit is established we can use this for two distinct types of attack tssi first there is the possibility that if we had enough circuits running through target machine we could cause socket denial of service each connection between two tor servers uses distinct sockets once two machines are connected to each other they will always use the same sockets but with enough machines connecting to server it is theoretically possible to cause machine to use all of its available sockets tssi also tor gives servers the option of sending only limited amount of trac through the tor network in given period day week or month by targeting machine with these attacks we could cause server to hibernate essentially taking it out of the tor cloud until the next accounting period begins this could also make bandwidth costs prohibitively high for targets 711 tssi coil attack tssi our rst implemented technique for achieving either type of attack is what we call the coil attack for this attack we choose two target servers and set up circuit that bounces back and forth between the two coiling them around each other when we set up circuit of nccoils the circuit will actually be composed of 2n cservers this is because for each coil both targets are included once this attack is concentrated but requires two targets in order to work this may be detected by an observant sysadmin but by default 11 top secretcomint20291123top secretcomint20291123 tors logs do not store ip addresses so the information would have to come from elsewhere even given the necessary ip information the system administrator will see only the other target sending and receiving large quantities of information without further investigation and some creative thinking it is highly likely that the system administrator will assume our other target is actually launching the dos attack we can leverage the anonymity provided by tor to protect ourselves from easy detection by simply appending this coil onto the end of circuit 712 tssi flower attack tssi our second implemented technique for achieving dos attack is what we call the ower attack and it targets only one server in this attack mjolnir builds circuit to random server then to the target then another random one then the target and so on for speci ed number of petals when we set up ower with nppetals the circuit will actually be composed of 2n pservers the ower attack distributes most of the load amongst the machines of the tor cloud so at most the target server will suspect that it is being attacked but even if the target knows about an attack it will have to assume that someone is trying distributed denialofservice attack while the system administrator will likely recognize that his attackers are leveraging tor tors strong anonymity will leave him with few options he will be forced to accept it or reduceeliminate tor usage of his machine tssi perhaps the most serious aw with the ower attack is that administrators on the petals might notice that their tor trac is coming from and going to the same server violation of tors protocol which clearly requires custom client however the petals still would not have enough information to know where the request originated and any attempt to discover this would necessarily break the anonymity of tor in order to get around this we could build petal with two servers between the instances of the target server in this way server realizes that it is taking part in an attack 72 ufouo trac analysis ssi is there way to undo the anonymity that tor provides it does not appear that tor leaks any signi cant information about the client to anyone other than the client however it is still possible to analyze the pattern of trac in and out of the tor cloud to try to determine which clients are responsible for which requests tor does not make such an attack here referred to as correlation attack easy 721 u basic tor circuit u the most common activity in tor is carried out across circuits 3 nodes long client connects to rst server which connects to second server which connects to third server which connects to the desired web page or other service 12 top secretcomint20291123top secretcomint20291123 tssi for this scenario we are most interested in tracing request back to the client assuming that we see an exit node connect to something we deem interesting the worst and most likely case is that we will not own any of the servers along the way there are two types of potential correlation attacks although both are complex ssi first method circuit tracing this method requires data on all of the connections for each server in the attacked circuit while currently unrealistic in general this is potentially powerful attack small private tor network for example could possibly be completely compromised by this technique ufouo we also need to have good idea of how long it takes to send data across the network to another machine this comes with the usual caveats that network congestion distance between links and packet size ect transmission time although in theory tor packets are all the same size owing to the xed cell size in practice we see di erent packet sizes as two or more cells sometimes get sent in the same packet despite this we should have good idea of the network latency actual processing time devoted to the cells is minimal and can be ignored ssi we begin by focusing on an exit node making connection to material of interest at this point we must keep track of all of the connections that node has up when the exit node receives data it will send it back down the circuit that requested it thus data comes in to the exit node and then the node will send out data over the appropriate connection ssi unfortunately the exit node will almost certainly be sending data out over several connections we must keep track of all of them let the network latency be x seconds when we see data get sent to the exit node we only need to pay attention to the outgoing connections that send out data roughly xseconds later we must take into account some error in our timing to allow for di erences in latency owing to di erences in network conditions we then make list of all of the nodes in the tor cloud that the exit server sends data to these are all potential second nodes ssi the above process must be recursively performed on the list of potential second nodes hopefully this number of nodes will not be prohibitive but we have hard data about how many nodes given machine in the tor cloud is simultaneously connected and actively sending data to again we will use the timing to determine which connections are of interest this is made slightly easier by the fact that node will appear twice in circuit meaning that we can ignore any outgoing connections from our possible second nodes to our exit server we can also ignore any connections made to machines outside of the tor cloud ie clients because the second server should only be talking to other tor servers now we have an even larger list of nodes to look at and these are our possible entry servers ssi finally we look at the outgoing connections from the entry servers that are sending out information roughly xseconds after the possible second nodes this is made easier by the fact that we are really only interested in connections into the tor cloud from outside of the tor cloud so we can ignore any connections made to other tor servers so 13 top secretcomint20291123top secretcomint20291123 now we have large list of potential circuits ssi from here we watch for more interesting material to be sent to the exit server and repeat the process we should get di erent set of potential circuits as not every connection should be active again at roughly the same time except the connections along the circuit for which we are looking there should be some overlap between the two lists this intersection is our new smaller list of potential circuits after repeating this process enough times we should only have one circuit or at most handful tssi this analysis becomes easier for each box that we own along the circuit since we then know for sure which incoming connection matches which outgoing connection on that box this means that our tree of potential circuits branches one less time owning the exit server is probably most useful for this type of analysis since it is the only machine known to be part of the circuit from the beginning tssi there are some diculties how many potential circuits will result from each iteration without some data on the real tor cloud regarding how many connections each server is sending data over for given span of time it is impossible to say it would not be surprising if this number turns out to be very very large even with the pruning at each step assuming the number of potential circuits is not too large to work with how many iterations of this algorithm will it be necessary to run before we can track down the one true circuit again without some real data about the tor cloud it is impossible to say clearly the more potential circuits we nd at each iteration the more iterations it will take to narrow the list down to one ufouo the biggest problem with this idea is that tor will only use circuit for short period of time before tearing down and building new one currently the default period of time for this is 10 minutes and tor checks every 30 seconds to see if any circuits need torn down so at best there are 10 minutes during which one can perform this analysis tssi second method blackbox the tor cloud in order for this attack to work we only need to see connections entering and exiting the tor cloud when we see an exit server make request of service that we are interested in we keep track of when information is sent back into the tor cloud we then keep track of each client connected to the tor cloud that receives data afterward for an arbitrary amount of time probably tcp timeout this will likely be an enormous number of clients each client will have certain probability of being the one that made the request for example client that receives information 2 seconds after the service sends back some data is more likely to be the one that requested it than client that receives information 10 seconds after the service sends the data each time we see the service send information back to that same exit server we track which clients receive data during the right time frame each iteration will give us large number of clients but we are only interested in the clients that receive information each time that is clients in the intersection of all the sets the client making the requests must be in that intersection the client with the highest total probability over all the iterations is the most likely to be the target 14 top secretcomint20291123top secretcomint20291123 tssi this technique is essentially widescale version of the circuittracing tech nique and is less precise however it should be easier to collect this information as there are currently only around 450 publicly known exit servers and it is easier to watch connec tions from 450 machines to the outside of the tor cloud than it is to watch all connections of all machines as the circuittracing method requires the hope is that the large amount of data we could collect for this method would compensate for its less precise nature 722 ssi locating known hidden services ssi in the case of hidden service the most likely scenario is that we know about hidden service and to want to know where ie on what machine it is located we would use tor client and connect to the hidden service in order to set up circuit see appendix c for description of hidden service circuits for normal hidden service circuit circuit tracing would have to stretch across circuit containing ve servers making it too complex and we can not use the tor black box approach things must be done somewhat di erently tssi if we know the rendezvous point rp the analysis becomes more man ageable we can set preferred rp using the guration of even basic tor client this will work for our purposes but if we do that then we will be using normal tor server as rp meaning that it will have several connections through it at given time if we program custom client to choose an arbitrary rp perhaps even making the client box the rp see section 81 then we can choose rp outside of the tor cloud meaning that the only connections through it will be ones related to the hidden service for this attack assume that we know the rp as well as the server that it is connected to for this circuit ssi when the client makes request it will go to the rp which will send it down another circuit to the hidden service this gives us chance to to see what node the rp is connected to call it the rst node then we check the timing in the same manner as in the basic tor circuit to see to which servers it is connected we can ignore any connections that go outside of the tor cloud we now have list of potential second nodes in similar fashion we check the timing of all of these to see to which servers they are connected one of these is the hidden service ssi the hidden service will respond so we will see data come back up the circuit to the rp this gives us another chance to work with the timing to try and gure out the circuit it would be easiest to gure out the second node during this step one would have to see which machines are talking to the rst node just before it talks to our rp and correlate that list with our possible second nodes from when the request was sent down the circuit the actual second node should be in the intersection of these two lists ssi as with the normal tor circuit this will likely give us many potential circuits and need to be iterated several times before the hidden service is located there are two main advantages over the same analysis for normal tor circuit the rst is that there are fewer servers between the rp and the hidden service meaning that we only need to keep track of two possible branches in the circuit instead of three the second is that we 15 top secretcomint20291123top secretcomint20291123 can ask the hidden service to connect to the rp as many times as we want whenever we want this allows us to perform the correlation over and over again albeit with di erent circuits each time the more data we have the more likely we are to locate the hidden service ssi we know that the hidden service will never build circuit to the rp that contains the hidden service machine although it can be its own rp thus whatever machine the hidden service is on will never be the machine that connects to the rp every time we ask the hidden service to build circuit to the rp we keep track of which machines are connecting to the rp eventually there will be sizable list of machines that cannot be the hidden service it is doubtful that we will narrow it all the way down to the machine on which the hidden service is located but it will help us prune the possible branches from possible second nodes ssi the hidden service may have list of nodes that it will never use in circuit under excludenodes in the guration these will never show up as the machine that connects to the rp it will however use server listed under excludenodes as an rp also the hidden service may have set up one or more entry guards for its circuits meaning that the rst node from the hidden service the second node in the above example will always be one of those routers if it has only set up one entry guard that machine will also never be the one that connects to the rendezvous point this is unlikely because most of the time one sets up multiple entry guards xed rst node ectively shortens your circuit by one hop so this analysis may turn up the hidden services excluded nodes and entry guards even if it does not locate the hidden service 73 ssi discovering unknown hidden services ssi we did not discover any method to detect previously unknown hidden services if hidden service is being ered on machine that is also tor server there may be some noticeable di erence between its trac and that of typical tor server however hidden service may be ered on machine outside of the tor cloud ssi in our time in the lab we found that running an nmap on node that is ering hidden service will turn up the port that the hidden service is using to deal with incoming connections it can then be directly connected to outside of tor tssi there are several issues with this we must already suspect the machine of housing hidden service to decide to do the nmap or alternately nmap several servers in the hopes of turning up hidden service then the machine running the hidden service will likely have several ports open and there is way to tell which port is ering hidden service just by looking at the list of open ports hidden service may even be ered on wellknown port such as port 80 we would have to try to connect to each of the ports we see open on machine to determine if there is hidden service being run we would not even know which protocol the hidden service is running it may be an http server an ftp server an smtp server etc the only thing we know is that the protocol must run over tcp it is not enough to attempt to connect once to each port using an http get request several protocols must be tried 16 top secretcomint20291123top secretcomint20291123 ssi also keep in mind that the people running these hidden services are gener ally very careful and all of these requests and nmaps are detectable by canny system administrator we can hide ourselves by using tor to route our requests even if we dont try to access the hidden service the tor way but the attempt may well be detected this combined with the shotinthedark nature of the whole enterprise limits its usefulness 74 ufouo maninthemiddle attack tssi because tors x509 certi cates are selfsigned it may be possible to perform maninthemiddle attack using mjolnir to forge certi cates assume that we wish to intercept trac between two tor servers with the nicknames alice and bob they will send x509 certi cates that are structured in very speci c way see section 5 we can use mjolnir to create our own torstyle x509 certi cate with alice or bob in the correct location and appear to be the other machine from here we carry out maninthemiddle attack in the normal fashion tssi however this only allows us to get under the layer of tls encryption as covered in section b32 the client sets up layer of encryption with the server for example bob by passing it an onion skin most of the time this is done using create cell which contains half of diehellman handshake the contents of this create cell are encrypted to bobs publicly advertised rsa key this means that we wont be able to read the create cell and we still wont be able to read the contents of the cells that go through the maninthemiddle all we will be able to see is 3 bytes of header on the cells that we would relay through tssi if the maninthemiddle intercepts create fast cell it will be able to read the xvalue that it contains and create shared secret with the client in ect becoming the rst server in the circuit the intended rst server can be completely removed from the circuit and the maninthemiddle will see which server is second in the clients circuit tssi we did not test this in our work so there may be issues with this attack that we did not foresee at the very least there is still the obstacle of the authoritative directory servers they act in fashion similar to trusted third party the directory listing weakly associates speci c rsa public keys with speci c server nicknames if server operator registers their tor server with the authoritative directory server this must be done outofband then this becomes strong association and certi cates with alices name will not be accepted unless they have alices listed public key thus it may not always be possible to perform this attack however the authoritative directory servers appear vulnerable see section 84 for further discussion 8 u future areas of study tssi there are still many interesting and important areas of tor functionality to ex plore as with any software project there are always bugs to x and features to add there 17 top secretcomint20291123top secretcomint20291123 are also two major avenues of exploration in the architecture of tor itself that warrant further study because they may provide ways to discover important target information 81 ufouo expanding mjolnirs functionality tssi the tor code provided solid basis for our work on mjolnir but every modi cation opens up the opportunity for bugs to arise all of our work was done in small lab with eight machines so the mjolnir code must be tested on larger network to see if it still behaves correctly or if its response time is simply too long to be useful there remain large portions of code that are only useful to servers that can safely be cut from the mjolnir main code unfortunately we did not have enough time to completely divorce the client and server sides of tors code tssi mjolnir still has one major ciency it cannot connect to hidden services in order to successfully connect to one the client must set up circuit to rendezvous point then to an introduction point then must request that the hidden service meet it at the rendezvous point doing this much is very important and with the right modi cations it becomes possible to have client be its ownrendezvous point as such there will be only two servers between our client and the hidden service making trac analysis attack easier which may open the way for locating the identity and location of hidden services 82 u privoxy ufouo tor is useful only for rerouting trac so that ones location andor browsing habits are kept secret tor does not examine the packets it sends for identifying information such as ip addresses because of this tor is packaged with privoxy free software ltering proxy privoxys purpose is to scrub all identifying information from http requests etc any tor user who is not using ltering proxy like privoxy is probably leaking identifying information especially in dns requests there may be situations in which privoxy does not hide all of the information that needs to be hidden for perfect anonymity however we did not have time to study the interaction between tor and privoxy and it warrants some attention 83 u tor remote control tssi one area of interest that we looked at brie before turning to other more useful ideas was the possibility of using tors control port to control client or server tor ers the option to set up control port control port would allow one to remotely control any standard guration option of his tor server as if he were directly editing tors guration however this did not er the exibility or power that we needed to set up custom client so we abandoned the idea early on this does not mean that there is useful application of using the control port for example one may be able to set up carefully selected set of entry guards or exit servers or both so that suspected target 18 top secretcomint20291123top secretcomint20291123 trac will always route through friendly servers there may be other ways of exploiting the control port including going so far as to modify the targets list of trusted directory servers this might send the target client to directory server in which all of the servers are friendly 84 tssi directory server exploitation tssi it may also be useful to study tor directory servers in more detail our work focused solely on the client but many attacks would be much easier with access to more tor servers the directory servers ultimately control which tor servers are used by clients we have found that server can put itself on directory server multiple times all it takes is the server running several tor processes each having di erent nickname open port ngerprint and log this only requires di erent guration for the di erent processes which are easy to set up that machine will handle disproportionate amount of trac since it is listed several times this increases the density of friendly servers in the cloud without increasing the number of servers we have set up unfortunately each listing has the same ip address which would be very noticeable to anyone who inspecting the directories tssi more useful attack would be to fool tor clients into believing that friendly box is actually someone else this could potentially be accomplished by getting the directory servers to list the friendly box as the other machine that may allow us to see more information than the target wants us to see for example if we know that certain target has list of preferred entry guards and exit servers and if we can list our machines as those servers then the target or second node respectively will be very likely to send trac through our machines making it easier to correlate the trac and determine what the target is requesting andor where the target is tssi there may be many other applications of this type of attack and for this reason directory server exploitation should be looked into 9 u acknowledgments ufouo we would like to thank the ces summer program for giving us the oppor tunity to work on this problem we would also like to the our mentor for his guidance and help with this problem also thanks to the ces summer program direc tors and the other students in the program their questions and ideas provided us with several ideas for areas of study 10 u references 1 dingledine roger tc tor control protocol httptore orgcvstordoc controlspectxt accessed 20060310 19 top secretcomint20291123 top secretcomint20291123 2 dingledine roger tor directory protocol for 011x series httptore org cvstordocdirspectxt accessed 20060310 3 dingledine roger tor rendezvous speci cation httptore orgcvstor docrendspectxt accessed 20060310 4 r dingledine and n mathewson tor manpage httptore orgtormanual cvshtmlen accessed 20060310 5 r dingledine n mathewson and p syverson tor the secondgeneration onion router httptore orgcvstordocdesignpapertordesignhtml accessed 20060310 6 theonionroutertorfaq httpwikinoreplyorgnoreplytheonionrouter torfaq last edited 20060310 7 tor linuxbsdunix install instructions httptore orgdoc tordocunixhtml accessed 20060310 8 tor protocol speci cation httptore orgcvstordoctorspectxt ac cessed 20060310 9 tor server guration instructions httptore orgdoc tordocserverhtml accessed 20060310 20 top secretcomint20291123top secretcomint20291123 ufouo tor glossary cell tors basic building block of communication any message either sent to or from client or server will communicate in cells each of which is xed length currently 512 bytes any message longer than this is broken up into multiple cells circuit series of tor servers that transfer data for client to destination each server in the circuit has its own level of encryption so that server can read the message except the last one directory the collection of information about servers that are available for use as tor nodes directory server server that keeps the directory information these can be either trusted hardcoded into the client or speci ed in the guration or mirrored on normal tor servers entry guard client or server can specify servers that it wants as its rst node in its circuits these are entry guards exit server the last server in circuit clients can specify preferred exit servers hidden service service hosted anonymously using tor the ip of said service need not be revealed to anyone accessing it for more details see appendix c serverrouterhopnode computer running tor that is connected to the tor cloud servers have nicknames and should be known from the directory tor cloud the set of servers running tor when client or server builds circuit it is connecting to the tor cloud b u programming details b1 u building circuits u the most important structure in tor is the circuit that is the list of machines that client will send its trac through information regarding this circuit is maintained in thecircuit tstructure this structure stores information regarding the connections and encryption used by the machine when sending information along the circuit for the client it also contains list of the servers along the path and the encryption information to use with each server u when user wants to build circuit most of the work happens in the func tioncircuit establish circuit it is passed ve parameters purpose needcapacity needuptime internal and pointer to info these parameters contain information used to determine several aspects of the circuit that is ultimately built in particular infocontains 21 top secretcomint20291123top secretcomint20291123 information for connecting to speci c exit server if one has already been chosen this only happens when attempting to access one of tors hidden services see appendix c belowcircuit establish circuit is small function consisting of only 20 lines all of the real work happens in 4 function calls that it makes u first circuit establish circuit callscircuit init to which it passes pur poseneeduptime needcapacity and internal right away this function calls another function circuit new this function allocates memory for the circuit tstructure ini tializes several elds of the structure calls circuit addto add the new circuit to the global circuit list and returns back in circuit init the parameters are used to ini tialize more elds in the circuit tstructure next it sets the state of the circuit to circuit stateorwait indicating that it is waiting to establish connection to the next server in the path before it sends along any packets finally circuit init returns pointer to the newlycreated circuit tstructure u back in circuit establish circuit the function onionpickcpathexitis called and passed the pointer to the new circuit tfromcircuit initand the parameter infooriginally passed to circuit establish circuit onionpickcpathexit starts by getting the list of available routers using the function routergetrouterlist this router list is created using information obtained from the directory servers the process is not covered in this paper see section 84 u next the function newroutelenis called to determine the number of servers that should be in the circuit this number is based on the purpose of the circuit and whether or not infois null but for most tor circuits it will be three after number has been decided on the function countacceptable routers checks how many servers it thinks can route trac if the number of acceptable routers is less than two the function returns failure and circuit is built if the number of available routers is two or more but less then what was decided on this becomes the length of the circuit u one of two things can happen next if infois not null then the server with that information will be used as an exit and the program moves on otherwise the program picks good exit server this is done in the function choosegoodexitserver which takes parameters purpose dira router list needuptime needcapacity and isinternal three of these are parameters originally sent to circuit establish circuit there are two cases based on the circuits purpose for general purpose circuits if isinternal is set meaning the circuit is intended to be used to connect to server within the tor cloud most likely as rendezvous point for hidden service then the exit server is chosen usingrouterchooserandomnode seechoosing hop section b11 otherwise choosegoodexitservergeneral chooses the exit server this function takes list of all available exit servers discards any that are currently unsuitable for example those servers that are listed as down and selects from those remaining one that can handle the most pending connections it then returns the router information necessary to connect to the selected server u after initializing the circuit and picking out an exit the other hops in the circuit must be chosen to do this the program calls onionpopulate cpath this function repeatedly calls another function onionextendcpath until the whole circuit is built in 22 top secretcomint20291123top secretcomint20291123 onionextendcpathchoosegoodentryserver is called to select the rst node in the circuit this takes the entire list of available servers gets rid of those unsuitable already chosen as the exit listening on wrong port etc and from the remainder chooses random node using routerchooserandomnode u for the middle hop choosegoodmiddleserver is called essentially this is the same routine as choosegoodentryserver except that it also excludes from the list of possible routers those that have already been chosen as other hops in the circuit u for each hop along the circuit once good router is chosen the choice is re turned to the calling function the router is then appended onto the circuit by call ingonionappendhop this function rst calls onionappendtocpath which adds this router to the list of routers in the circuit how does the program keep track of this list one of the elements of the circuit tstructure is cpath which is actually pointer to crypt pathtstructure all of the information necessary to connect to each router in cluding the ip address and cryptovariables between the two machines can be found in this structure as well as few simple bandwidth accounting elds cpath points to the rst router in the circuit but it also maintains nextandprevmembers in the crypt patht structure which unsurprisingly point to the next and previous routers in the circuit respectively it is important to note that not only is this doubly linked list but it is also circular u after all three routers in the circuit have been chosen and appended to the circuit the program returns all the way back to circuit establish circuit and moves on to the next important step establishing connections to all of the routers b11 u choosing server u most of the time routerchooserandomnodeis called to choose which server will be used despite its name the choice is not exactly random and the function is passed several parameters to help with its decision the most important arguments would be the list of preferred servers and the lists of excluded servers for some reason two lists of excluded servers are passed character string containing server nicknames and smartlist t structure see below containing server information the lists do not necessarily overlap several ags indicating user preferences regarding server capacity uptime and the like are also passed one of the arguments strict is set if the user will only accept choice from their list of preferred servers u the function begins by creating smartlist of the preferred servers from which it removes any excluded servers it will then call smartlist choose to select random element of that list tssi smartlist choose is very simple function in tor the smartlist t structure is essentially resizable array and several functions are provided to manage them see appendix mjolnir api for more on smartlists smartlist choose generates random index and returns the element of the smartlist with that index the random index is generated using the openssl randbytes function care is taken to avoid bias in the random numbers by making sure that the maximum value returned by 23 top secretcomint20291123top secretcomint20291123 randbytes is multiple of the size of the smartlist for example suppose the size of the array is 10 and randbytes could return any value up to 25 then when computing random index for the smartlist the function would generate value less than 25 and take it mod 10 because 25 is not multiple of 10 the numbers 0 1 2 3 and 4 would occur more often than 5 6 7 8 and 9 u if for some reason preferred server is chosen for instance preferred servers were speci ed two things can happen if strict is set the function returns null indicat ing failure otherwise the program continues by attempting to nd servers that meet the preferences indicated by the ags this is done by creating smartlist containing all run ning routers that meet the preferences which is passed to smartlist choose the only ex ception is if the parameter needcapacity is set in which case routerlist slchoosebybandwidth is called which makes its random choice slightly di erently urouterlist slchoosebybandwidth works di erently than smartlist choose for the given list of servers it adds up all of the bandwidths at the same time it creates separate smartlist of each servers bandwidth for example if the rst three servers can handle 200 bytess 450 bytess and 1000 bytess respectively then the smartlist will have entries 200 450 and 1000 then random number between 0 and the total bandwidth is selected using the same openssl function as in smartlist choose it steps through the smartlist of bandwidths summing the bandwidths and chooses the rst server where the bandwidth sum is greater than the random number again returning to the example if the random number was 412 the second server would be chosen because 200 450 650 and 650 412 if the number was 70 the rst server would be chosen we see that higher bandwidth servers are more likely to be chosen than lower bandwidth servers as one would expect u if the function is still unsuccessful in nding an acceptable server the program tries one more time to nd next hop this time without setting any preferences this is the last resort if server can be found then the function returns null and the circuit fails b2 u connecting the circuit u recall that client records all of the servers in its circuit using the crypt patht structure once it has decided upon complete circuit the client must now connect the servers in the circuit so they can send information back and forth in tor the connec tiontstructure holds the information needed to set up such connection such as the ip address of the node it connects to the port it should connect on and lot of other information connection is speci ed by an id number connections and circuits are related in complex ways single connection may be part of several di erent circuits and eachcircuit tstructure holds information on previous and next connection p connand nconn respectively u after all the servers that will make up the circuit have been determined circuit establish circuit callscircuit handlefirsthop first this function re 24 top secretcomint20291123top secretcomint20291123 trieves information regarding the rst server from the circuits cpath variable this infor mation is used to see if there is already connection to that server if so that connection will be used for the circuits nconn the appropriate elds of the circuit tstructure are set to hold information about that connection and circuit sendnextonionskin is called to set up the cryptovariables between the two routers see b3 encryption for more about the information sent in an onion skin u if there is preexisting connection to the rst server the function connection orconnect is called it takes as arguments the address port and iden tity digest of the server being connected to the identity digest is sha1 hash of the servers public rsa key and is often used to uniquely identify particular router lot of things happen in this function with the ultimate goal of returning fully initialized connection first it calls connection new which allocates memory for new connection and initializes various members of the connection tstructure u next connection orconnect callsconnection orinitconnfromaddress which is passed the newly created connection tstructure and the address port and identity digest of the server being connected to it tries to retrieve the servers information based on its identity digest which if found is used to ll in more variables in nconn if it could not nd the server information then the function will ll in the necessary information itself occasionally using more generic information than would have been retrieved based on the identity digest with all of these things initialized the function will return to connection orconnect u the next important step is that connection connect is called this attempts to create nonblocking socket connected to the ip addressport combination it was passed most of what goes on in here is basic c socket calls if successful the connection is added to the global connection array and read and write events for the connection are set up using libevent the events on the connection are initially set to be nonreading and non writing but as the program continues the events will be changed to handle reads and writes u finally connection orconnect will callconnection orfinished connecting which will start the tls handshake between the two servers after the tls hand shake completes the client will send create cell to set up encryption between it self and the rst server all of this will be discussed in the next section encryption so onceconnection orfinished connecting returns everything up to and including circuit establish circuit returns u at this point the circuit is still not fully connected the client has set up its connection to the rst server and is waiting for created cell in response to the create cell it just sent once created cell is received the client and the rst server have nished agreeing on their cryptovariables and can communicate freely under layer of encryption at this point the client will make an extend cell which contains all of the information necessary to connect to the second server in the circuit as well as cryptovariable information for the layer of encryption between the client and the second server and send it encrypted to the rst server u the rst server will decrypt the cell and read the information for connect 25 top secretcomint20291123top secretcomint20291123 ing to the second server if there is already an existing connection between the two servers that connection will be used for communication along this circuit if not then connection orconnect is called to open connection between the two see above once connection is open the rst server packages the cryptovariable information for the second hop in create cell and sends it to the second server upon receiving created cell from the second hop the rst server packages the necessary information into an ex tended cell which it sends back to the client u this whole process is repeated one more time as the client sends an encrypted extend cell through the rst server to the second server which will send corresponding create cell to the third server again an extended cell gets sent back to the client after the third server sends back created cell once the client has nished setting up the cryptovariables between itself and the third server all of the connections in the circuit have been made and it is considered open any applications waiting to send packets through tor are noti ed that there is new circuit available to use b3 u encryption u tor packets are sent under several layers of encryption each connection between two machines is under tls encryption additionally each tor payload is encrypted by the client once for each hop in the circuit using symmetric cipher u in tor all information to set up the symmetric cipher between the client and the servers in the circuit is sent in what is known as an onion skin in basic tor circuit three onion skins are sent from the client one for each server in the circuit each server reads its onion skin sets up its cryptovariables and sends back information to the client to allow the two machines to share cryptovariables in this way the client gets the necessary information to put its data under one layer of encryption for each server in the circuit all cells across typical tor circuit will be under three layers of encryption when it is sent and each server will strip one layer see gure b3 for visual representation of this process it is these layers of encryption that give tor its designation as an onion routing network the last server in the circuit will have the cell in the clear and be able to pass along the request found inside b31 utls encryption u tors tls handshake is carried out in 3 main phases the function connection orfinished connecting see above connecting the circuit calls connection tlsstarthandshake which allocates memory for new tor tls context and initializes several of its elds including the socket that will be written to and the sslctx that will be used for communication the ssl ctx is initialized at tor startup and is changed every 2 hours it is this structure that contains the certi cates that are used during the tls handshake as well as the list of cipher suites to be used tors cer cates are discussed in more detail in section 5 tors x509 certi cates by default tor supports 2 cipher suites 26 top secretcomint20291123top secretcomint20291123 figure 2 ufouo layers of encryption on normal get tlsedh rsawith des192cbc3 sha tlsdhe rsawith aes128cbc sha this is preferred u once the tls context is properly initialized the tls handshake continues in connection tlscontinue handshake which calls tortlshandshake this calls sslconnect orsslaccept depending on which side of the handshake this is on as suming there are errors the program moves on to connection tlsfinishhandshake which validates the handshake and extracts the identity key from the certi cate if every thing checks out then the server is considered authenticated and future communications will take place under tls encryption b32 u onion skins u after the client picks out its circuit and sets up connection to the rst server in the circuit it will send an onion skin to the rst server this is held in the payload of either create or create fast cell whats the di erence when the client connects to the rst server it does so using tls this means that it has already authenticated the rst servers identity and negotiated key this allows it to send create fast cell which does not require an rsa operation nor diehellman operation since most of the necessary information has already been established note that create fast cell can only be sent between client and the rst server in the path because all other servers need to be authenticated and the client has tls connection directly to them for this reason create cells are sent for all other servers in circuit u create fast cells are simple the cell contains only random xvalue created using tors cryptorandfunction which calls the openssl function randbytes the client sends this to the rst server in its circuit when server receives cre atefast cell it extracts the xvalue and calculates random yvalue using cryptorand 27 top secretcomint20291123top secretcomint20291123 it sends the yvalue back in created fast cell along with sha1 hash based on xjy where jdenotes concatenation xjyis the shared secret and will be used to generate the keys between the two machines when the client receives the created fast cell it will perform the same hash based on xjythat the rst server should have and compare it to the value in the cell if the two values agree then the keys for communication between the two machines are set up see keys below u an onion skin in create cell is more complex the rst 42 bytes are oaep padding the next 16 bytes are symmetric key this is done using openssl calls the last 128 bytes of payload are the gxvalue for diehellman handshake the rst 128 bytes of this cell which goes up to about halfway through the gxvalue are encrypted using the second servers public rsa key the rest of the cell is encrypted with aes in counter mode using the symmetric key from the rst half of the cell u when server receives create cell it extracts gx generates random gy computes the shared secret gxy and sends back created cell containing gyas well as sha1 hash based on gxy if machine other than the client gets created cell eg the rst hop receives created cell from the second hop it puts the information in an extended cell and sends it to the client when the client gets created cell or an extended cell it calculates gxyand checks that the accompanying hash is correct the client uses gxyto set up the keys that will be used when it communicates with that node note that this key exchange required expensive rsa and diehellman operations in contrast to the simple random number generation of the create fast exchange u keys u when created or created fast cell is received the function circuit finishhandshake is called it will extract the shared secret and use it to create keys for communication recall that for created cell the shared secret is gxy and for created fast cell the shared secret is xjy denote the shared secret as k0 u regardless of which type of cell is received the function cryptoexpandkeymaterial is passed the shared secret it does series of hashes to get khk0j00jh k0j01jh k0j02j where jdenotes concatenation this should not include more than 5 hashes each hash is 20 bytes long any extra bytes are ignored u the rst 20 bytes of k form kh the handshake digest this is used to make sure the other nodes handshake checks out the next 20 bytes become df the forward digest and the next 20 bytes become db the backward digest these digests are used for integritychecking purposes they seed hash that is used by machines to to determine whether or not cell has been decrypted all the way or not dfis used for client to server streams and dbis used for server to client streams the next 16 bytes of k become kf and the next 16 bytes of k become kbkfandkbare the keys used to encrypt and decrypt the streams of data between the two machines kfis used for client to server streams and kbis used for server to client streams all other bytes are discarded 28 top secretcomint20291123top secretcomint20291123 c u hidden services c1 u ering hidden service u in order to er hidden service the operator of the service whom we will call bob must rst add lines to their tor guration indicating the directory containing information regarding the hidden service and the port on which the hidden service will be advertised after tor starts up with this new guration it will automatically generate an rsa publicprivate key pair and create onion address for the service the address is of the form xonion where xis based on the services public key speci cally xis the base32 encoding of the rst 80 bits of the sha1 hash of the public key u at this point tor picks out at least 3 servers in the cloud to act as introduction points bob may use the guration to specify particular servers that he wants to act as intro points but if he does not tor will simply choose servers randomly once the intro points have been decided upon bob does two things he will generate service descriptor which contains information about his public key and how to connect to his introduction points this service descriptor can be uploaded to the public directory servers but it need not be if bob does not wish to have his service publicly known bob will also create circuits to his introduction points once the circuit is connected he will send along cells which contain his public key hash based on khseekeys in b3 encryption and signature based on that data these are called relay establish intro cells u when an intended introduction point receives the relay establish intro cell it checks that the information is wellformed and correctly signed if so it sends cell back to bob acknowledging that it will act as an introduction point for his hidden service it also makes note that the circuit on which it received the relay establish intro cell will be used when dealing with requests for bobs hidden service and associates it with bobs public key u when bob receives acknowledgment from his introduction points he considers the introduction circuits open he will advertise his service descriptors to the tor directory servers if he so desires and he is now ready to receive requests to access the hidden service c2 u accessing hidden service u there are several ways that client whom we will call alice can become aware of bobs hidden service at the very least she must receive bobs public key somehow most likely through some outofband communication such as phone conversation or encrypted email using this she can request bobs service descriptor from the tor directory servers if bob has chosen to advertise his service publicly otherwise alice must know bobs entire service descriptor through some other means u once alice has the descriptor and decides to talk to bobs hidden service she must rst set up circuit to some server in the tor cloud known as rendezvous point rp this point is chosen randomly although alice can add line to her tor guration that will indicate preferred rps once the circuit is established alice sends re 29 top secretcomint20291123top secretcomint20291123 layestablish rendezvous cell to the rp which contains randomly generated number referred to as rendezvous cookie rc u when the rp receives the relay establish rendezvous cell it will send an acknowledgment back to alice and make note that the circuit the cell came in on is to be used for rendezvous and is associated with that rc u after alice receives acknowledgment from the rp she builds circuit to one of the introduction points listed in bobs service descriptor once connected she will send relay introduce1 cell to the intro point which contains hash of bobs public key as well as information intended for bob that is encrypted to his public key when the introduction point sees the relay introduce1 cell it checks the hash against the hashes of the hidden service public keys that it knows and nds the circuit associated with that public key it then sends the cell now encapsulated as relay introduce2 cell with the same payload down that circuit to bob afterward it sends alice acknowl edgment that her cell was sent and alice will shut down her circuit to the introduction point u when bob receives relay introduce2 cell he decrypts it and pulls out the data alice sent this includes information for connecting to the rp the rc and alices half of diehellman handshake gx if bob decides to talk to alice he will create circuit to the speci ed rp bob sends the rp relay rendezvous1 cell which contains the rc bobs half of the diehellman handshake gy and the khfor his interaction with alice u when the rp receives relay rendezvous1 cell it nds the circuit as sociated with the given rc it then sends gyandkhin relay rendezvous2 cell down that circuit to alice it makes note of the fact that the circuit from alice and the circuit from bob are linked and zeroes out the rc so one else can attempt to connect to alices circuit u finally alice receives the relay rendezvous2 cell and uses it to complete the diehellman handshake and initialize the cryptovariables between her and bob now alice and bob can talk across this newlyformed rendezvous circuit in almost the exact same way as normal circuit neither knows what is on the other side of the rp so they dont know where the other persons machine is located the content of their messages is under the normal circuit encryption as well as one more layer based on their shared secret d u information at the nodes ssi it is possible for us to have friendly computer in the tor cloud for example we can set up server and advertise it to the tor directory servers like all other users we might compromise another server in the tor cloud through other means so how much do we know about the trac that we are sending and receiving across circuits tor does good job of hiding information about the circuit from all of the nodes in the circuit in most cases allowing nodes to know only about the machines to which they are directly connected however some information is still leaked simply by being part of the circuit 30 top secretcomint20291123top secretcomint20291123 and there are some instances where tor gives the machines slightly more information than is needed the following section attempts to provide list of information known by each server here referred to as node along the circuit d1 u first node u the rst node in the circuit is the only node that knows the location of the machine originating the request it sets up circuit tvariable with particular pcircidand arranges shared secret with the originating node see section b32 when the client extends the circuit to the second node the rst node receives an extend cell with the address port and identity ngerprint of the second node it sets up connection to the second node and sets ncircidin itscircuit tvariable with new circuit id the second node will send back cell containing its half of diehellman handshake that is gy andkhseekeys in section b32 for an explanation of kh after this the rst node should not receive any cells that it will be able to recognize because the cells will be encrypted in short the rst node knows the location of the client that connected to it cryptovariables used for communication with the client which allow it to perform one layer of encryptiondecryption on cells tofrom the client the id of the circuit from which the client is sending information this is pcircid in the rst nodes circuit tstructure the location of the second node in the circuit the id of the circuit on which it sends information to the second node this is ncircidin the rst nodes circuit tstructure and will be di erent from pcircid gyin the diehellman handshake between the client and the second node and kh ssi however machine may not know that it is the entry node if the common name on the x509 certi cate passed during the tls handshake is client identity then it is nitely an entry node because it is talking directly to the client this is sucient but not necessary if the machine receives create fast cell then it is the entry node as clients will never send create fast cell farther down the circuit there is an option in the guration that can be set so that tor client will never use create fast cell and tor servers will never use them but this still appears to be the most common way that the entry node is set up otherwise create cell is used if the node receives create cell followed by an extend cell it may be the entry node the only guarantee for such pattern is that it is not the exit server which will never see an extend cell tssi this knowledge would be useless unless we can induce the client to pick one of our machines as its entry node in the guration there is an option called 31 top secretcomint20291123top secretcomint20291123 entrynodes which is commaseparated list of server nicknames any servers on that list will be preferred when choosing an entry node if the option strictentrynodes is true then only servers from that list can be chosen as entry nodes if the guration can be changed to have client always use friendly machine for an entry node then we can discover who is using tor if not what they are requesting d2 u second node u the second node has the least information of any node in the circuit it does not know who or where the client is nor does it know what or where the client is connecting to it does know the location of the machine connected to it cryptovariables used for communication with the client which allow it to perform one layer of encryptiondecryption on cells tofrom the client the id of the circuit from which the rst node is sending information this is pcircidin the second nodes circuit tstructure and should be equal to ncircid in the rst nodes circuit tstructure the location of the third node in the circuit the id of the circuit on which it sends information to the third node this is ncircid in the second nodes circuit tstructure and will be di erent from pcircid gyin the diehellman handshake between the client and the third node and kh ssi machine cannot nitely know that it is the second node in circuit if it receives create cell followed by an extend cell on the same circuit then there is good chance it is the second node however this same pattern is possible for the rst node because rst nodes often see create fast cells instead of create cells it is more likely that if machine sees such pattern it is the second node tssi it is not possible to induce client to pick our machine as second node the second node is chosen using routerchooserandomnode with list of preferred nodes passed to it the only possible way is to edit the clients guration so that their list of excluded servers excludes all boxes except friendly ones but that seems unrealistic since that would probably entail listing hundreds of server nicknames in their guration d3 u third node u the third node is the exit node for basic tor circuit this means that it sees request that the client makes in the clear which is useful information the downside is that the third node has idea who or where the client is the exit node knows 32 top secretcomint20291123top secretcomint20291123 the location of the machine connected to it the id of the circuit from which the second node is sending information this is pcircidin the third nodes circuit tstructure and should be equal to ncircidin the second nodes circuit tstructure cryptovariables shared with the client which allows it to perform one layer of cryptiondecryption on cells tofrom the client the exit node can see the data the client is sending such as an http request or post data for form ssi machine can know it is the exit node very easily there are several functions only called by exit nodes such as connection exitbeginconn there is even macro connisedgethat will return true if it is passed an exit connection or an ap connection which only appears at the client side of the circuit tssi similar to entry nodes client can set up preferred exit nodes in their torrc there is an option called exitnodes that is commaseparated list of server nicknames and any servers on that list will be preferred when choosing an exit node if the option strictexitnodes is true then only nodes from that list can be chosen as exit nodes so the guration can be changed to have client always come to friendly machine for an exit server tssi there is one other way to in uence client to choose speci c machine for the exit servers have exit policies which are lists of types of requests that server will handle for example by default all servers reject trac sent to port 25 smtp in order to discourage spammers from using tors network to hide their activities one can even set up server that will reject all exit trac and only act as rst or second node so if we set up server with more permissive exit policy than most other machines we will be chosen more often to handle the sort of trac that other machines will not allow for example if we were to allow connections to port 25 our server would be chosen to send email with higher probability than it would for sending other types of trac we have speci c statistics regarding common exit policies and even if we er certain exit policy that doesnt mean that people will think to try to send such trac through tor still this option is more attractive than altering client guration because it only requires change on machine that we own d4 u hidden service nodes u as covered in appendix c tor uses special nodes when accessing hidden services d41 u introduction points u the introduction point is the third node in circuit that starts at the hidden service so it knows the information listed under third node above it is also brie the third 33 top secretcomint20291123top secretcomint20291123 node in circuit coming from the client but this circuit is shut down as soon as the intro point passes along the hidden service request in addition it knows the rsa public key modulus for the hidden service this is more information than it needs because when it receives request to access the hidden service all that is passed along is sha1 hash of the public key so all the introduction point really needs is that hash by giving the introduction point the entire public key tor is leaking more information than it needs to of course the only thing that the public key really gets us is the ability to connect to the hidden service but that is not insigni cant consider the small probability that hidden service that we do not know about will select friendly machine as one of its introduction points and the usefulness is clear ssi machine knows that it is an introduction point as soon as it receives an establish intro cell which contains the public key info tssi the hidden service can select its introduction points in its guration through eld called hiddenservicenodes by changing that eld we can in uence the hidden service to choose our box as its introduction point but if we are on their box already there are far more useful things we can do like obtaining the hidden services private key if hiddenservicenodes is empty then introduction points are picked using routerchooserandomnode d42 u rendezvous points tssi rendezvous points are the most knowledgeable nodes in hidden service circuit when accessing hidden service client must rst set up circuit to rendezvous point rp the rp is the third node in this circuit so it knows all the information third node knows see above in addition to this basic third node information the rendezvous point is also given rendezvous cookie random 20byte number which the rp will use later after this circuit is set up the client requests access to the hidden service through the introduction point the rp sees none of this and if the hidden service decides to allow contact it will set up circuit to the rp the rp is the third node in this circuit as well the hidden service sends cell down this circuit that contains the rendezvous cookie gy for diehellman handshake between the hidden service and the client and kh right now the rp only looks at the rendezvous cookie but it would require only trivial change to have it store the other values tssi at the rp after it decrypts its layer of encryption the cell is only under one layer of encryption based on the shared secret between the hidden service and the client we can also see gy this is far cry from knowing the shared secret but this is as close to being able to see trac between the client and hidden service as we can get right now it is certainly the weakest point of the entire hidden service system ssi node knows that it is rendezvous point as soon as it receives re layestablish rendezvous cell which contains the rendezvous cookie and it knows that the hidden service and client are connected across it as soon as it receives re layrendezvous1 cell from the hidden service and sends relay rendezvous2 cell to the client 34 top secretcomint20291123top secretcomint20291123 ssi clients can be induced to choose particular machine as rendezvous point by changing the eld rendnodes in their guration if this eld is empty the rp will be chosen using routerchooserandomnode hidden services will connect to whatever rendezvous point the client tells them to even if that node is normally on their list of excluded nodes assuming that it decides to communicate with the client ufouo mjolnir api ufouo mjolnir attempts to make accessing tor functionality simple below is an api describing the most useful functions of mjolnir arranged by topic e1 u initialization uint tor init void description this is the main entry point for the tor client it must be called before any tor services are used arguments none return value return 0 on success return negative value on failure notes thismust be called before any other tor functions are used it can be called multiple times without issue tssi int init keys const smartlist t subject const smartlist t issuer description in addition to important crypto initialization initkeysgen erates x509 certi cates through internal functions which the program will use to communicate with the tor cloud arguments the subject and issuer smartlists see the documentation in the section on smartlists and certi cates return value return 0 on success and negative values on failure notes this function must be called in order for the tor client to have speci c certi cates if commonname eldvalue pair is passed in it will generate random commonname 1020 characters long see the documentation for subject and issuer smartlists tssi routerstatus t setchosendirserver const char nickname int fascistfirewall description call this with the nickname of any directory server and then whenever mjolnir needs to fetch something it will use that directory arguments 35 top secretcomint20291123top secretcomint20291123 1nickname the nickname of the chosen directory server if it is null or not the nickname for any valid server the dirserver will be chosen randomly 2fascist rewall set to 1 if mjolnir is behind rewall that will not let certain ports out see tors man page for more documentation return value therouterstatus tstructure describing the chosen directory server the return value should be checked to see if it is null indicating an error notes the nickname should be either trusted directory server hardcoded into the library or directory mirror in order to download from mirror mjolnir must rst know which servers are mirrors so it will have to make at least one request from an authoritative directory tssi int update routerdescriptors void description get the router descriptor data from directory server arguments none return value 0 on success negative on failure notes this function must be called every time the program needs to update its listing of routers this must be done at least once before setting up any circuits it may be done an arbitrarily large number of times throughout the life of the program but each fetch will generate sizable amount of trac to one directory server warning this function will always talk to one of the 5 directory servers hard coded into configc529 add default trusted dirservers this behavior should be able to be changed if the chosen directory server is directory mirror see documentation for setchosendirserver warning this function is blocking it will halt program execution until it either times out or receives response see the timeout documentation tssi char get routerdesc string void description return the exact string that the server returns when mjolnir asks for the directory arguments none return value new copy of string containing all router descriptors as received from the directory notes urouterlist t the nition of routerlist tis inorhon lines 930941 the most important eld is the smartlist routers which is smartlist of routerinfo tstructures the one part 36 top secretcomint20291123top secretcomint20291123 of these that will be used most often is probably the nickname eld let us assume there is routerlist named rlist there are rlistroutersnum used routers available and to access their nicknames use rlistrouterslistinickname also see the documentation of smartlist foreach tssi routerinfo t the function routergetrouterlist returns smartlist of routerinfo tstructures see above for more details the most important elds of routerinfo tarenick name and the extend info using this library the programmer should never have to deal directly with the internals of extend infot and will probably never see it at all but if the programmer want to add to the library he will need to look over how it is used the best place for quick example is any of the attack functions detailed incontrolmodc urouterlist t router getrouterlistvoid description return the current list of all known routers arguments none return value the list of all known routers this list will not be populated untilupdaterouterdescriptors has run notes see the routerlist tdocumentation tssi void tor cleanupvoid description cleans up before shutting tor down arguments none return value none notes this must notbe called unless more tor connections or services are needed calling torinitafter calling this function does not work yet it seems that the problem with this is actually in shutting down and resetting the openssl library e2 ssi circuit building ucircuit t the only eld from this structure that the programmer needs to worry about is global identi er this identi er is how the program keeps track of circuits it has built so if program wants to have multiple circuits up at once the programmer must keep track of their respective global identi ers or maintain list of pointers to the actual structures tssi circuit t newarbitrary circuit bynickname char beginrouternickname 37 top secretcomint20291123top secretcomint20291123 description begin new circuit that can be added to at any time so long as the following two conditions are met 1 the client is not one of the nodes in the circuit 2 the same node is not used twice in row it can however be used twice in the same circuit note that the rst of these is not checked in code but in its current state client using this library will never be server so this will not be an issue arguments beginrouter nickname the nickname of the rst hop in the new circuit return value pointer to the new circuit notes this function must be called before attempting to append new hop onto circuit warning this call is blocking it will halt program execution until circuit has been successfully established tssi int append routerbynickname tocircuit byid char nickname int circ id description this function appends the router with the given nickname to the given circuit it looks up the circuit by its global identi er arguments 1nickname the nickname of the next hop in the circuit 2circid the global identi er of the circuit return value 0 on success negative values on failure notes must get the circuit id from circuit returned by newarbitrary circuit bynickname if mjolnir tries to connect to an invalid router eg if the router is down the circuit will close warning this call is blocking it will halt program execution until circuit has been successfully extended tssi int append routerbynickname tocircuit char nickname circuit t circ description append router with the given nickname to the given circuit arguments 1nickname the nickname of the next hop in the circuit 2circ the circuit to which mjolnir should append router return value 0 on success negative values on failure 38 top secretcomint20291123top secretcomint20291123 notes must get the circuit from newarbitrary circuit bynickname warning this call is blocking it will halt program execution until circuit has been successfully extended tssi routerinfo t getrandomrouter routerinfo t exclude description this function gets random router from the global router list so long as the chosen router is not the excluded one arguments exclude gives the programmer the option to exclude certain router it is most useful to exclude the most recently appended router in the circuit as the circuit dies if it tries to go to the same router twice in row return value returns the routerinfo tfor the chosen router this is probably only useful for extending the current attacks in which case it would be useful to study those attacks carefully notes tssi int nickname isknown const char nickname description this function checks to see that the nickname is valid one arguments nickname string with the nickname of some router return value returns 1 if the router is valid returns 0 otherwise the router is valid if the program has routerstatus tinformation about the router with that nickname notes the program may know about an invalid router for example the router may have been taken down since the router descriptor was fetched how ever when mjolnir tries to connect circuit it will fail tssi void close circuitcircuit t circ description given an open circuit close it remove it from global circuitlist and deallocate its memory circisnull on return arguments circ the circuit to be closed return value none however circisnull so it can longer be used notes e3 ufouo sending and receiving data tssi int send payload downcircchar payload size t payload len char ipaddr int port circuit t circ int force description this function sends custom packet down the requested circuit to the speci ed address at the speci ed port 39 top secretcomint20291123top secretcomint20291123 arguments 1payload the custom payload eg an http get request 2payload len length of the payload 3ipaddr the ip address of the ultimate destination in ipv4 form 19216811 as string 4port the destination port 5circ the circuit across which to send this packet 6force if true the function will always try to send payload if false it will check that the address is reachable with the current exit and if it is not it will not send payload return value return 0 on success negative values on failure if it refuses to send packet because it was not forced it returns failure notes it is up to the calling program to check that both the payload and ip addressport are valid before calling this function the payload readhandler must be set before this call is made warning this call will block program execution until it times out or receives response tssi payload readhandler function pointer void payload readhandler const char int description function pointer to userde ned function that gets called when the client receives payload in response to its request arguments 1const char the payload that the client receives in response to its re quest what the calling program actually wants to read 2int length of the payload return value must return void so the return value can be anything the programmer wants notes these functions should be ned by the user to set this variable call setpayload readhandler handler example functions print payload anddonothing are given in tormc tssi timeouts mjolnir times out if it does not receive response in certain amount of time on the test lan we have it set to 1 s which is more than enough time however due to the slow nature of the tor cloud it may be necessary to change the value of the initial timeout estimate our timeout fol lows the tcpstyle timeout rules so once it has started receiving cells it should adjust the timeout on its own the constants that may need adjusting are in timeoutc in particular look at initial estsecandinitial estusecfor the number of seconds and microseconds respectively before it times out see the discussion in the section on sending and receiving data 40 top secretcomint20291123top secretcomint20291123 tssi int router shouldreachaddr int addr int port routerinfo t router description the function checks the routers exit policy and returns non zero if the address is reachable and zero if the address is not reachable arguments 1addr the address to reach as an integer 2port the port to use at addr 3router the router to check return value ifaddrport is reachable returns 1 if not returns 0 notes tssi int router shouldreachaddrstring char ip addr int port routerinfo t router description this function checks the routers exit policy and returns non zero if the address is reachable and zero if the address is not reachable arguments 1ipaddr the address to reach as string in xxxxxxxxxxxx form 2port the port to use at ipaddr 3router the router to check return value if theipaddrport is reachable it returns 1 if not it returns 0 notes this function just converts the string address to an integer and calls routershouldreachaddr tssi int circuit shouldreachaddr int addr int port circuit t circ description mjolnir checks the exit policy of the circuits exit hop and returns nonzero if the address is reachable or zero if the address is unreachable arguments 1addr the address to reach as an integer 2port the port to use at addr 3circ the circuit want to check return value if the addrport is reachable returns 1 if not returns 0 notes this function just grabs the last hop in the circuit calls routershouldreachaddr tssi int circuit shouldreachaddrstring char ip addr int port circuit t circ 41 top secretcomint20291123top secretcomint20291123 description mjolnir checks the exit policy of the circuits exit hop and returns nonzero if the address is reachable or zero if the address is unreachable arguments 1ipaddr the address to reach as string in xxxxxxxxxxxx form 2port the port to use at ipaddr 3circ the circuit to check return value ifipaddrport is reachable returns 1 if not returns 0 notes this function just converts the string address to an integer and calls circuit shouldreachaddr e4 ssi smartlists and certi cate masking usmartlist t tssi the smartlist tstructure contains an array of void s the number of elements used and its total capacity however the programmer should never have to deal with the internals directly instead he should use smartlist create smartlist add and smartlist foreach we use this to ne custom x509 cer cates it is nearly ubiquitous in the rest of the tor code usmartlist t smartlist create void description allocate and return an empty smartlist arguments none return value pointer to the new smartlist notes any smartlist the programmer wants to use must rst be returned by this function uvoid smartlist add smartlist t sl void element description appends an element to the end of the list arguments slis the smartlist that is receiving the element it must have been returned by smartlist create return value none notes technically smartlist may contain pointers to di erent kinds of ob jects though this is highly unrecommended individual elements of the smartlist may be accessed through its list eg sllisti uvoid smartlist remove smartlist t sl void element description removes the element from the list 42 top secretcomint20291123top secretcomint20291123 arguments slis the smartlist that is losing the element slmust have been returned by smartlist create return value none notes preserves the order of any elements before element but elements after it may be rearranged tssi smartlist foreach smartlist type var code description smartlist foreach is macro that will run code for every element in smartlist all elements of the smartlist must be of the given type arguments 1smartlist the smartlist over which mjolnir runs the code 2type the type of data held by the smartlist 3var the variable name by which the macro access the elements of the smartlist the variable does not need to be declared before being used 4code the code to be executed if there is more than one statement it should be in curly braces return value none notes remember that this is macro if the code is bracketed it must be followed the closing brace with right parenthesis and semicolon tssi eldvalue pairt tssi this is very simple structure containing two strings eld and value these should be allocated and set as any other strings in the example program this structure is added to smartlist so that mjolnir can use custom x509 certi cates tssi subject and issuer smartlists smartlist t tssi tor uses selfsigned x509 certi cates during its tls handshake by fault it sends only commonname normally the client or servers nickname and organizationname normally the string tor for both subject and issuer with the only di erence being that the issuer common name is followed by the string identity tssi tor server will check for required x509 elds but not anything else except the subjects commonname and the only restrictions are that the length is greater than 0 and it consists of alphanumeric characters the commonname can also contain period but this creates log message on the other server currently mjolnir treats the period as an illegal character these lists allow the program mer to send any x509 certi cate he wishes instead of always sending the same ones if there is commonname in the subject section the client will generate random string of characters 1020 bytes long to act as the commonname 43 top secretcomint20291123top secretcomint20291123 tssi if the commonname has an illegal character mjolnir will generate random one if mjolnir receives as input an invalid x509 eld it will ignore that eldvalue pair entirely in this way mjolnir provides relatively robust x509 certi cate generation tssi the programmer must create two smartlists of eldvalue pairtstruc tures one each for subject and issuer where the eld variable is the name of the eld in the certi cate and value is set to the appropriate string these two smartlists must then be passed to initkeyssubject rst issuer second tssi see the documentation for smartlist t eldvalue pairtsmartlist add smartlist create and initkeys e5 tssi dosstyle attacks tssi the purpose of these attacks is not actual dos per these simply do not generate enough trac however they may be able to generate sucient trac to force node into hibernation which takes the server out of the tor cloud until the next hibernation period begins could be day week or month tssi circuit t flower attackonerouter char routernick int num petals description set up ddos network attack on one tor node the program will create circuit consisting of random routers alternating with the given router this results in the given router doing much more work than the rest of the nodes on the circuit arguments 1routernick the nickname of the router to attack 2numpetals he number of times the attacked router will be in the resultant circuit therefore the circuit will be 2 numpetals long return value pointer to the circuit tstructure of the newlyformed circuit notes when setting up circuit with nhops the client must send ncells along the circuit so setting up large circuit can be very timeconsuming as well as expensive with regards to both trac generated and cpu time used warning this call is blocking it will halt program execution until circuit has been successfully established for even moderately long circuit this can take substantial amount of time tssi circuit t append flowertocircuit char routernick1 int num petals circuit t circ description similar to appendcoiltocircuit this function appends ower to the end of the given circuit using this mjolnir is anonymized by the structure of the tor cloud 44 top secretcomint20291123top secretcomint20291123 arguments 1routernick1 the router in the middle of the ower 2numpetals the number of times the middle router appears in the ower so the ower will be 2 numpetals long 3circ the original circuit to append the new ower to return value the circuit with the ower added notes see the ower attack documentation tssi circuit t coil attacktworouterschar routernick1 char routernick2 int num coils description similar to the ower attack except that this function generates circuit that bounces back and forth between two nodes in the tor cloud instead of targeting only one router arguments 1routernick1 nickname of the rst attacked router 2routernick2 nickname of the second attacked router if mjolnir sends payload down this circuit the second router will be the nal one 3numcoils the number of times each router will appear in the circuit so the circuit is actually 2 numcoils long return value pointer to the newlyformed circuit notes see the notes under flowerattackonerouter the same applies here warning this call is blocking it will halt program execution until circuit has been successfully established tssi circuit t append coiltocircuit char routernick1 char routernick2 int num coils circuit t circ description similar to the coil attack but puts the coil at the end of given circuit using this mjolnir is anonymized by the structure of the tor cloud arguments 1routernick1 the rst router in the coil 2routernick2 the second router in the coil 3numcoils the number of times each router appears in the coil the resulting circuit will be as long as circplus 2 numcoils 4circ the circuit to which mjolnir appends the coil return value the newlyformed circuit 45 top secretcomint20291123top secretcomint20291123 notes see the documentation for the coil attack warning this call is blocking it will halt program execution until circuit has been successfully extended f ufouo mjolnir for windows f1 u interface tssi the gui provides the user with list of all the circuits created by the client the list displays relevant information about each circuit including its length state and purpose additionally each circuit has an light icon next to its name the light is red if the circuit is closed cannot be used the light is green if the circuit is open and ready for use beneath the circuit list list of the servers in circuit is displayed for the last circuit clicked similar to the circuits the servers each have light next to their names to indicate whether the circuit is open up to that server the displays for the circuit list and the node list are set to update on timer currently set to three seconds on the right the gui provides list of servers that are available for use in circuit the router list does not update on the timer to update the router list the user must click the load routers button f2 ssi creating new circuits tssi the gui provides few di erent ways to create new circuits the most general way to create new circuit is to click the new circuit button this will create null circuit with userspeci ed name and purpose see the tor documentation for more information on circuit purpose the user can then proceed to build circuit by appending servers individually to the end of the circuit alternatively the user can create random circuit of arbitrary length by clicking the new random circuit button the user then speci name and length n and mjolnir will choose nrandom servers from the available router list and create new circuit currently all random circuits are made with general purpose modifying the program so that the user can specify the purpose of random circuit only requires minor change at the library level however it is likely that creating circuits of certain purposes will cause the program to crash see below circuits can also be created using the coil or ower attacks see section 71 dosstyle attacks tssi to append server to circuit the user must rst select the desired circuit by clicking on its name in the circuit list this causes the chosen circuit to become current which means it is the circuit whose node list is currently displayed then the user right clicks on the name of the desired server in the router list and selects append to current circuit any general purpose circuit that is open can have server appended to it tssi it should be noted that circuits created with certain purposes cannot have servers appended to them and trying to do so will crash the program currently only general introducing and establish rend circuits are able to have servers appended 46 top secretcomint20291123top secretcomint20291123 figure 3 tssi appending server to preexisting circuit to them once server is appended to an establish rend circuit its purpose becomes rend ready onehop circuit to rendezvous point and attempting to append any more servers will cause crash this will need to be cleaned up as functionality for creating rendezvous circuits and accessing hidden services is added f3 tssi dosstyle attacks tssi the gui provides an interface for performing the coil and ower dos attacks from the mjolnir library in the coil attack the user chooses two servers to attack and the number of coils in the circuit each server appears once in the circuit for each coil so the length of the circuit will be twice the number of coils for the ower attack the user chooses server to attack and the number of petals where the number of petals is the number of times the selected server will appear in the circuit tssi for both attacks the user has the option to create the coil or ower as new circuit or to append it to an existing circuit however appending coils or owers is more expensive than creating them as new circuits and there is signi cant performance hit for appending large coils and owers to circuits f4 tssi sending arbitrary packets tssi to send packet through circuit the user rst clicks the send packet button then the user selects circuit to send the message through and an ip address and port number to send the message to the user has the option of entering the payload of the packet in either hex or ascii upon clicking send the packet is encrypted with the appropriate layers of encryption and sent through the circuit the exit server will then send the decrypted packet to the selected ip address and destination port 47 top secretcomint20291123top secretcomint20291123 figure 4 tssi the coil attack dialog figure 5 tssi sending custom tcp packet using the mjolnir gui 48 top secretcomint20291123top secretcomint20291123 f5 u future features customizing the certi cates this feature is currently available in the mjolnir library but needs an interface in the gui functionality for creating rendezvous circuits and accessing hidden services as it becomes available in the library f51 u minor changesbug xes add purpose eld to the new random circuit dialog box and deal with issues that arise from attempting to create circuits of certain purposes address the crashes caused by appending servers to circuits of certain purposes either by refusing to allow such an action or xing it at the library level 49 top secretcomint20291123