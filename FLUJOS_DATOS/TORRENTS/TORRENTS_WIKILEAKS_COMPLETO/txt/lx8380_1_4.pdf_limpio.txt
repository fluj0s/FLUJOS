lx8380 data sheet lexra inc revision 14 november 21 2001 lexra proprietary and confidentiallx8380 data sheet revision 14 lexra proprietary and confidential copyright 2001 lexra inc all rights reserved mips mips16 mips abi mips i mips ii mips iv mips v mips32 r3000 r4000 and other mips common law marks are trademarks andor registered trademarks of mips technologies inc lexra inc is not associated with mips technologies inc in any way smoothcore and radiax are trademarks of lexra increvision 14 lexra proprietary confidential ilx8380 table of contents 1 product overview 1 11 introduction 1 12 lx8380 processor overview 3 13 system level building blocks 5 131 simple memory management unit smmu 5 132 local memory interface lmi 5 133 coprocessor interface ci 5 134 custom engine interface cei 6 135 cache bus cbus interface 6 136 lexra bus controller lbc 6 137 block move controller bmc 6 138 ejtag debug support 6 139 building block integration 7 14 rtl core smoothcore licensing models 7 15 eda tool support 7 2 architecture 8 21 hardware architecture 8 22 seven stage pipeline 9 23 ralu data path 9 24 system control coprocessor cp0 9 25 highperformance context switch 11 251 new context registers 11 252 reset 13 253 determining the number of contexts in software 13 254 initiation of context switch 13 255 csw instruction 14 256 lwcsw ltcsw and lqcsw instructions 14 257 wdcsw instructions 14 258 wdlwcsw wdltcsw and wdlqcsw instructions 14 259 pipeline 14 2510 new context selection 15 2511 example context switch for coprocessor operation 17 2512 program access to new registers 18 2513 exceptions 18 3 risc programming model 21 31 summary of basic risc instructions 21 311 alu instructions 22 312 load and store instructions 24 313 conditional move instructions 25 314 branch and jump instructions 26 315 control instructions 27 316 coprocessor instructions 28 32 opcode extension using the custom engine interface cei 30 33 simple memory management unit 31ii lexra proprietary confidential revision 14lx8380 34 exception processing 32 341 exception processing registers 33 342 exception processing entry and exit 34 35 lowoverhead prioritized interrupts 35 36 coprocessors 36 4 instruction extensions 39 41 context switch and data transfer operations 39 42 bit field processing operations 44 43 cross context access operations 55 44 checksum addition 57 45 lx8380 instruction summary 58 5 coprocessor interface 59 51 attaching coprocessor using the coprocessor interface ci 59 52 coprocessor interface ci signals 59 53 coprocessor write operations 60 54 coprocessor read operations 60 55 coprocessor interface and pipeline stages 61 551 pipeline holds 62 552 pipeline invalidation 62 6 local memory 65 61 local memory overview 65 62 cache control register cctl 66 63 cache instruction 68 64 instruction cache icache lmi 68 65 instruction memory imem lmi 70 66 data cache dcache lmi 71 67 scratch pad data memory dmem lmi 75 7 cbus interface 77 71 system interface configuration 77 72 cbus interface write buffer and outoforder processing 78 73 cbus line read interleave order 78 74 cbus byte alignment 79 75 cbus interface signal list 80 76 cbus transaction types 81 77 cbus protocol 81 78 cbus transaction timing diagrams 81 781 backtoback single writes with busy 82 782 line writes 82 783 backtoback single read requests with busy 83 784 line read request 83 785 split read request 84 786 write with split read request 84 787 returning read data 85 788 latency of cbus transactions 86 8 lexra system bus lbus 87 81 connecting the lx8380 to internal devices 87 82 terminology 88 83 bus operations 88 831 single data read 89revision 14 lexra proprietary confidential iiilx8380 832 line read 89 833 burst read 89 834 single data write 90 835 line write 90 836 burst write 90 837 split read 90 838 write split read 90 839 split data 90 84 signal descriptions 91 85 lbus commands 92 86 lbus byte alignment 93 87 split transactions 93 88 lexra bus controller 94 881 lbc commands 95 882 write buffer 95 883 lbc read buffer 95 89 transaction descriptions 96 891 single data read with waits 97 892 single data read with target wait 98 893 line read with waits 98 894 line read with target waits 99 895 line read with initiator waits 100 896 burst read 100 897 single data write with waits 100 898 single data write with waits 101 899 line write with waits 101 8910 line write with target waits 102 8911 line write with initiator waits 103 8912 burst write 103 8913 split read command 103 8914 write split read 104 8915 split data 105 810 ordering rules with split transactions 105 811 lbc signals 106 812 arbitration 107 8121 lbus rules 107 8122 lbc behavior 107 813 connecting the lbc to lbus 107 9 block move controller bmc 109 91 bmc overview 109 92 transfers 110 93 transactions 110 94 transaction sequence due to transfer class 111 95 bmc perchannel registers 112 96 bmc global registers 114 97 perchannel register set selection 115 98 transfer completion 115 99 cpubmc arbitration 116 910 software responsibility for transfer requests 116 911 example transfer flow 116iv lexra proprietary confidential revision 14lx8380 10 ejtag debug 119 101 overview 119 1011 ieee jtagspecific pinout 120 102 program counter pc trace 121 1021 pc trace dclk debug clock 121 1022 pc trace pcst program counter status trace 121 1023 pc trace tpc target program counter 122 1024 singleprocessor pc trace pinout 122 1025 vectored interrupts and pc trace 122 1026 demultiplexing of tdo and tdi during pc trace 123 103 data break exceptions for lx8380 123 1031 data break data matches on lbus split transactions 123 1032 data breaks on write descriptor accesses 123 1033 support for the loadtwin instruction 123 appendix instruction formats 125 a1 major opcodes 125 a2 lexop2 instructions 126 a3 cop0 instructions 129 a4 special instructions 130 appendix b lconfig forms 133 b1 configuration options for the lx8380 processor 133 appendix c port descriptions 135 appendix d pipeline stalls 143 d1 stall definitions 143 d2 instruction groupings 143 d3 nonsequential program flow issue stalls 143 d4 loadstore rules 144 d5 mac ops interlock matrix 145 d6 mvcz stall 145 d7 tlbw stall 145 d8 movecx stall 145 d9 mmu stalls 145 d10 cache miss stalls 146 d11 pipeline diagrams for nonsequential program flow issue stalls 147 d12 pipeline diagram for mac ops interlock stall 148 d13 pipeline diagram for mvcz stall 148 d14 pipeline diagram for tlbw stall 148 d15 pipeline diagrams for dtlb stalls 149 d16 pipeline diagrams for cache misses 150revision 14 lexra proprietary confidential vlx8380 list of tables table 1 eda tool support7 table 2 cp0 registers10 table 3 extended cp0 registers10 table 4 context status register detail13 table 5 scheduler ports16 table 6 alu instructions22 table 7 load and store instructions24 table 8 conditional move instructions25 table 9 branch and jump instructions26 table 10 control instructions27 table 11 coprocessor instructions28 table 12 custom engine interface operations30 table 13 smmu address translation31 table 14 list of exceptions32 table 15 prioritized interrupt exception vectors36 table 16 context switching instructions40 table 17 bit field processing instructions45 table 18 hash instruction key bit definition53 table 19 cross context access instructions56 table 20 checksum addition instructions 57 table 21 instruction summary58 table 22 coprocessor interface signals59 table 23 local memory interface modules66 table 24 icache configurations69 table 25 icache ram interfaces69 table 26 imem configurations70 table 27 imem ram interfaces71 table 28 dcache configurations72 table 29 dcache ram interfaces72 table 30 data cache operations and results74 table 31 dmem configurations75 table 32 dmem ram interfaces76 table 33 line read interleave order79 table 34 cbus byte lane assignment79 table 35 cbus signal list80 table 36 maximum number of outstanding split reads84 table 37 line read interleave order89 table 38 lbus signal description91 table 39 lbus byte lane assignment93 table 40 lbus gtid fields94 table 41 lbus commands issued by the lbc95 table 42 lbc interface signals106 table 43 ejtag pinout120 table 44 ejtag ac characteristics120 table 45 ejtag synthesis constraints120 table 46 singleprocessor pc trace pinout122 table 47 singleprocessor pc trace ac characteristics122 table 48 major opcode instruction formats125 table 49 major opcode bit encodings125vi lexra proprietary confidential revision 14lx8380 table 50 lexop2 load instruction formats126 table 51 lexop2 write descriptor instruction formats126 table 52 lexop2 context checksum and bit field formats127 table 53 cross context move format128 table 54 lexop2 subop bit encodings128 table 55 cop0 instruction formats129 table 56 cop0 subop bit encodings129 table 57 special instruction formats130 table 58 special subop bit encodings130 table 59 special2 instruction formats130 table 60 special2 subop bit encodings131 table 61 configuration options133 table 62 lx8380 processor port summary135 table 63 instruction groupings for stall definition143revision 14 lexra proprietary confidential viilx8380 list of figures figure 1 lx8380 processor overview3 figure 2 processor core module partitioning8 figure 3 context associated registers11 figure 4 insert and extract operations straddle case45 figure 5 packet field compaction with variable alignment52 figure 6 coprocessor write60 figure 7 coprocessor read61 figure 8 exception during coprocessor read63 figure 9 invalidation of coprocessor read63 figure 10 lx8380 system interface configurations77 figure 11 cbus backtoback single writes with busy82 figure 12 cbus line write83 figure 13 cbus backtoback single read requests with busy83 figure 14 cbus line read request83 figure 15 cbus split read requests84 figure 16 cbus write with split read request85 figure 17 cbus read data and dbusy85 figure 18 read data for line read request86 figure 19 latency of cbus transactions86 figure 20 lexra system bus lbus diagram87 figure 21 block move controller109viii lexra proprietary confidential revision 14lx8380revision 14 lexra proprietary confidential 1lx8380 section 1 product overview 1 product overview 11 introduction this data sheet describes lexras lx8380 processor core risc network processor developed for intellectualpropertyiplicensingthelx8380isacarefullyengineeredextensiontotheindustrystandard mipsi isa the major subsystems are the cpu core local memory interfaces lmi the block move controller bmc and lbus controller lbc the technology includes optional interfaces to customer defined coprocessor ci2 and custom engine ce that provide extensions to the mips isa the local instructionmemoriesanddatamemoriesmayincludecachesandfixedramthesizesareconfigurablethe figure also highlights the lx8380 multicontext register file to support fast context switching additional lx8380 extensions include new bitfield operations for efficient packet header processing network communications systems are characterized by demanding realtime performance requirements typicallysystemdesignershaveaddressedtheserequirementswithcustomasicsofftheshelfprocessors and plds the explosive growth in the size and bandwidth of the internet has recently stimulated semiconductorcompaniestodevelopanewtypeofproductcalledanetworkprocessorunitnputoserve these applications these ics incorporate multiple programmable cores and specialized peripherals compared to asic development npus offer the system designer faster timetomarket and flexibility to implementdifferentiatedservicesinsoftwarecomparedtogeneralpurposeofftheshelfcomponentsnpus offer the promise of lower cost and superior performance through architectural specialization lx8380 is scalableprocessorwiththespecializedarchitecturalfeaturesneededforhighperformancepacketprocessing for wide variety of new products the time required to process packets for ip routing and classification is dominated by long latency operationssuchastablelookupsfromlargememoriesandbufferaccesseshoweveradistinguishingfeature of network communications systems is that subsequent packets are readily available for independent processingthereforeafastcontextswitchcanbeexploitedtohidethememorylatencylx8380includesa configurable number 18 of general register sets and program counters along with instructions for fast context switching this enables multiple software threads to efficiently execute on single processor thread is deactivated under software control either i unconditionally ii when load with context switch instruction is coded for long latency load or iii when command is written to shared system device following context switch the cpu activates new thread from the pool of ready threads the context switch does not introduce stall cycles because the new thread has an independent general register set it can quickly resume processing to avoid stalling the new thread while the previous threads data transfer completes the lx8380 incorporates dedicated port to the processors data memory for the transfer of packet data in addition the memory system is nonblocking permitting local accesses and cache hits to operate in parallel with one outstanding global access per context with this architecture context switches may be used frequently to achieve optimal performance packetprocessingalsorequiresfrequentaccesstobitfieldsinthepacketheaderthatarenotbytealignedfor this reason lx8380 has extended the mipsi instruction set architecture isa to include complete set of bitfield operations for field extract insert set and clear deterministic allocation of realtime is another importantprobleminnetworkcommunicationssoftwarethisproblemiscompoundedbymultiprocessing for this reason the lx8380s configuration options include dedicated uncached local instruction and data memories for realtime critical instructions and data in order to avoid cache miss penalties2 lexra proprietary confidential revision 14section 1 product overview lx8380 featuresintroducedinlexrasriscproductlinesupportsystemonchipsocdesignincludingcustomer defined coprocessors and customer extensions to the mips isa are standard in the lx8380 configuration options include enhanced jtag ejtag support for debug and incircuit emulation ice because the lx8380 executes the mips instruction set wide variety of thirdparty software tools are available including compilers operating systems debuggers and incircuit emulators the assembler extensions andacycle accurate instructionset simulator iss aresuppliedby lexraprogrammers can use offtheshelf c compilers for initial coding then replace performancecritical loops with optimized assembler code code development tool support is provided by lexra and by thirdparties for gnu tools and by greenhills software for the multi 2000 ide key features complete processor core highperformance 7stage pipeline executes mipsi isa except unaligned loads stores executes lexras network processing extensions high performance context switch bit field manipulation dual ones complement addition hash key formation jump tables extensive thirdparty tool support highperformance context switch processor provides 18 contexts the number is customerconfigurable independent program counter status and general registers for each context wasted cycles for context switch context switch initiated by program thread reactivation based on completion of data transfer asynchronous external events or program control system level building blocks simplified mmmu smmu local instruction andor cache interfaces configurable sizes local data memory andor cache interfaces configurable sizes optional customerdefined coprocessors optional customerdefined instruction extensions system bus controller optional block move controller bmc optional ejtag draft 200 support for debugging portable rtl model available as synthesizable rtl portable to any 018 µm015µm or 013µm process support for any thirdparty logic and sram libraries foundry partners include tsmc and umcrevision 14 lexra proprietary confidential 3lx8380 section 1 product overview easy asic integration exclusive use of positiveedge clocking fully synchronous design system level building blocks provide easy asic interfaces supports for popular eda tools userconfigurable local memory reset method clock distribution userconfigurable ejtag breakpoints over 30 other configuration options 12 lx8380 processor overview the lx8380 is risc processor that executes the mipsi instruction set1along with lexras networking extensions the clocking pipeline structure pinout and memory interfaces have all been developed by lexra to reflect systemonsilicon design needs deep submicron process technology as well as design methodology advances figure1 shows the structure of the lx8380 processor figure 1 lx8380 processor overview mips i execution the lx8380 supports the mipsi programming model two source operands can be supplied and one destination update performed per cycle the second operand is either register or 16bit immediatetheinstructionsetincludesawideselectionofaluoperationsexecutedbytheralulexras proprietary register based alu the ralu also generates memory addresses for 8bit 16bit and 32bit register loads from stores to memory by adding register base to an immediate offset an extension to the mips isa allows pair of 32bit registers to be loaded from memory branches are based on comparisons between registers rather than flags and are therefore easy to relocate optional links following jump or branch instructions assist with subroutine programming context switching the lx8380 incorporates up to eight independent 32 x 32b general register sets called contexts execution can switch between independent tasks called threads this context switch is performed with wasted cycles and prevents stalls while waiting for data from onchip or offchip shared resources context switches occur under program control when data is loaded from shared resources background load of 32bits 64bits or 128bits from shared resource can be accomplished with single load 1 the mips unaligned load and store instructions lwl lwr swl swr are not supportedinst ramicache ram inst lmi data lmi data ramdcache ramlx8380 cpu corecustom engine cisceidata bus coprocessors 12lbcsystem bus denotes customer logicblockmove controller bmcdebug probeejtag instruction bus cbicbusoptional4 lexra proprietary confidential revision 14section 1 product overview lx8380 instruction special class of instructions called write descriptor wd allow command or data to be directed to sharedresourceincludingarequestforupto128bitsofreturndatathisallowsshareddevicestoefficiently perform operations that atomically examine and modify memory state the processor performs the wd operationinasingleinstructioncyclewithoutstallsbyusingacontextswitchwhenacontextswitchoccurs the program counter of the suspended thread is stored in cp0 register while execution switches to another threadthenextthreadisautomaticallyselectedfromthepoolofreadytorunthreadsofequalpriorityusing windowed roundrobin algorithm isa extensions for network processing lexra has added 32 new instructions to the lx8380 to optimize forhighperformancepacketprocessingbitfieldoperationsareincludedtoacceleratelookupkeyformation used in packet classification specialized hash functions table lookup instructions and onescomplement addition are also included many of the new instructions are used to facilitate highspeed data movement fundamental to network communications64bitscanbeloadedfromlocaldataramintoageneralregisterpairinasinglecycleup to128bitscanbetransferredfromsharedmemorybyasingleinstructionthelexraextensionsalsosupport atomicreadmodifywriteoperationsonthesharedmemorieslatenciesinaccesstosharedmemoryonchip or offchip can be hidden using zerooverhead switch between the eight independent hardware contexts pipeline lx8380 instructions are executed by sevenstage pipeline that has been designed so that all transactions internal to the lx8380 as well as at the interfaces occur on the positive edge of the processor clock twophase clocks are not used the sevenstage pipeline allocates full addressregistertodata outputregister clock cycle to both local instruction access and data access as result the memories have the best timing specification possible and are decoupled from critical paths internal to the processor exception handling the mips r3000 exception model is supported exceptions include both instruction synchronous trapsas well as hardware and software interrupts the cp0 status register controls the interrupt mask and operating mode exceptions are prioritized when an exception is taken control is transferred to the exception vector the current instruction address is saved in the epc register and the exceptionsourceisidentifiedinthecp0causeregisterintheeventofanaddresserrorexceptionthecp0 badvaddrregisterholdsthefailingaddressforthemipsexceptionsaprogramlocatedattheexception vector identifies the cause of the exception and transfers control to the applicationspecific handler in addition to the mips r3000 exceptions the lx8380 supports up to eight prioritized vectored interrupts to meet hard realtime response requirements coprocessorinstructions thelx8380supportsthemipsicoprocessorinstructionstheseincludemoves toandfromthe32bitcoprocessorgeneralregistersandcontrolregistersmtczmfczctczcfcz32 bitcoprocessorloadsandstoreslwczswczandbranchesbasedoncoprocessorconditionflagsbczt bczf performance and ease of use the lx8380 provides excellent priceperformance and timetomarket there are two strategies used to achieve this deliver simple building blocks outside the processor core to enable system level customizations such as coprocessors application specific instructions memories and busses deliver either fully synthesizable verilog source model or fully implemented hard core called smoothcore for customerselected foundries section13 describes the system level building blocks and section14 describes the licensing modelsrevision 14 lexra proprietary confidential 5lx8380 section 1 product overview 13 system level building blocks the lx8380 processor is designed to easily fit into different target applications it provides the following building blocks simplified memory management unit smmu for deeply embedded applications flexible local memory interface lmi that supports instruction cache instruction ram data cache and data ram up to two coprocessor interfaces ci an optimized custom engine interface cei simplified cache bus interface cbus for simplified connection to peripheral devices and main memory an optional lexra bus controller lbc and lexra bus lbus protocol for connection to peripheral devices and main memory an optional block move controller bmc supporting up to eight dma channels for background transfers between local data memory and the system bus the following sections discuss each of these system building block interfaces 131 simple memory management unit smmu the lx8380 smmu is designed for embedded applications using single address space its primary function is to provide memory protection between user space and kernel space the smmu is consistent with the mips address space scheme for userkernel modes mapping and cacheduncached regions the optional lx8380 mips r3000style mmu is designed to permit code to run under major operating systemssuchaslinuxthatrequireatranslationlookasidebuffertlbforrobustprotectionofthirdparty programs and data 132 local memory interface lmi the lx8380s harvard architecture provides local memory interfaces lmis that support instruction memory and data memory synchronous memory interfaces are employed for all memory blocks the lmi block is designed to easily interface with standard memory blocks provided by asic vendors or by third party library vendors the lmis provide directmapped or twoway set associative instruction cache interface and directmapped or twoway set associative data cache interface the data cache can be selected to be either writethrough or writebackthetagcomparelogicaswellasacachereplacementalgorithmareprovidedaspartofthelmi one of the instruction cache sets may be locked down as unswappable local memory lexras sevenstage executionpipeline provides output registers in both theinstruction and data lmis sothat thememories have the best timing specification possible and are decoupled from critical paths internal to the processor 133 coprocessor interface ci lexra supplies an optional coprocessor interface ci for applications that use custom coprocessor up to twocismaybeemployedinonedesignthecoprocessorinterfaceeavesdropsontheinstructionbusifa coprocessor load lwcz or move to mtcz ctcz instruction is decoded data is passed over the data6 lexra proprietary confidential revision 14section 1 product overview lx8380 bus into ci register then supplied to the customerdesigned coprocessor similarly if coprocessor store swcz or move from mfcz cfcz instruction is decoded data is obtained from the coprocessor and loadedintoaciregisterthentransferredontothedatabusinthefollowingcycletheciincludesadatabus fivebitaddressandindependentreadandwriteselectsforcoprocessorgeneralregistersandcontrolregisters the lx8380 pipeline and harvard architecture permit single cycle coprocessor access and transfer an applicationdefined coprocessor condition flag is synchronized by the ci then passed to the lx8380 sequencer for testing in branch instructions 134 custom engine interface cei the lx8380 includes custom engine interface cei that the application may use to extend the mips i alu opcodes with applicationspecific or proprietary operations similar to the standard alu the cei supplies the custom engine two input 32bit operands src1 and src2 one operand is selected from the register file depending on the most significant 6 bits of the opcode the second operand is either selected from the register file or is 16bit signextended immediate the opcode is locally decoded by the custom engine and following execution by the custom engine the result is returned on the 32bit result bus to the lx8380 to support multicycle operations stall input is included in the interface 135 cache bus cbus interface the cbus interface is simple signalling layer between the lx8380 processors cache controllers and the optional lx8380 system bus interface the lbc lx8380 applications that do not require the full feature set of the lbc or that connect to bus protocol other than lbus may optionally eliminate the lbc and provide their own system bus interfaces or devices that connect directly to the lx8380 using the cbus interface 136 lexra bus controller lbc the optional lexra bus controller lbc is the interface between the lx8380 and system bus devices which may include dram and various peripherals the lbc implements lexras lbus protocol non multiplexednonpipelinedbustoprovideasimplebusprotocolfordesignintegrationontheprocessorside the lbc connects to the lx8380 cbus on the system side the lbc is designed to easily interface to industry standard bus protocols such as pci usb and firewire the lbc supports synchronous modes with the lbus operating at full cpu speed or half cpu speed and an asynchronous mode that allows the lbus to be clocked at any speed independent of the cpu speed 137 block move controller bmc thelx8380sbmcperformsdatatransfersbetweentheprocessorslocaldatamemoryandthesystembus these transfers may occur in either direction and are set up using the coprocessor registers of the bmc transferlengthmaybe1262144256kbyteswithbytegranularityintheaddressesandtransfersizedata transfer takes place in the background without stalling the processor the bmc supports up to eight dma channels and is implemented as an optional lexrasupplied coprocessor 3 completion of block moves can be synchronized with the program using conditional branch instructions context switches or interrupts 138 ejtag debug support thelx8380providesoptionalejtagenhancedjtagdebugsupportejtagallowsthirdpartyhardware probes and debug software to access the processor and its attached devices in the same way the processor would access those devices ejtag also supports singlestep instruction execution instruction breakpoints and data breakpointsrevision 14 lexra proprietary confidential 7lx8380 section 1 product overview 139 building block integration the lx8380 configuration script lconfig provides menu of selections for designers to specify building blocks needed number of different memory blocks target speed and target standard cell library next the configuration software automatically generates top level verilog model makefiles and scripts for all steps of the design flow for testability purposes all building blocks contain scan control signals the lexra synthesis scripts support optional scan insertion which allows atpg testing of the entire lx8380 core 14 rtl core smoothcore licensing models lexra delivers lx8380 as either an rtl model or smoothcore rtl model for standard asic designs the rtl model is fully synthesizable and scantestable verilog sourcecodeandmaybetargetedtoanyasicvendorsstandardcelllibrariesinthiscasethedesignermay simplyfollowtheasicvendorsdesignflowtoensurepropersignoffinadditiontotheverilogsourcecode andsystemleveltestbenchlexraprovidessynthesisscriptsaswellasfloorplanguidelinestomaximizethe performance of the lx8380 smoothcore forcotdesignsthataremanufacturedatfoundriessuchastsmcandumcasmoothcore portisthequickestlowestcostandbestperformancechoicelexraprovidesaportingservicethatdeliversa fully implemented and verified hard macro for customerspecific configuration foundry and library all datapathregisterfileandinterfaceoptimizationsareperformedbylexratoensurethesmallestdiesizeand fastest performance possible scan based test pattern is provided for fault coverage during manufacturing tests 15 eda tool support lexra supports mainstream eda software so designers do not have to alter their design methodology the following is snapshot of eda tools currently supported table 1 eda tool support design flow tools supported simulation synopsys vcs cadence verilog xl cadence ncverilog synthesis synopsys design compiler static timing synopsys primetime dft synopsys tetramax pr avant apollo iirevision 14 lexra proprietary confidential 8lx8380 section 2 architecture 2 architecture 21 hardware architecture the lx8380 processor includes the control processor cp0 and the register file and alu ralu cp0 includesinstructionaddresssequencingandexceptionprocessingtheraluperformsaluoperationsand generates data addresses figure 2processor core module partitioningmulticontext register file n x 32 x 32bit r00instruction address and control alu pridexception processing logicpc and sequencerinstructions datadata address and controlflags traps and jump addresscxstatusn cxpcnralu cp0revision 14 lexra proprietary confidential 9lx8380 section 2 architecture 22 seven stage pipeline the lx8380 has seven stage pipeline the seven stage pipeline provides complete processor cycle for the instruction memory and data memory accesses allowing use of larger memories and 2way setassociative caches without degrading cycle time the seven pipeline stages allow the processor clock speed to scale with current silicon processes two cycle penalty is incurred on branch prediction failure however the lx8380s conditional move instructions can be used to avoid any wasted cycles in the control of realtime critical loops 23 ralu data path thelx8380raluincorporatesamulticontext32x32bfourportregisterfileonewriteportisdedicatedto 32bitregisterfileloadsfromthedatabusloadsmfczcfczmovesfromcoprocessortheremaining three ports 2r1w are used for the other operations such as alu operations in the lx8380 the two write ports are also used to support 64bit loads from the data bus theinstructionsetincludesawideselectionofaluoperationsexecutedbytheraluinthecaseofalu operations one operand is register and the second operand is either register or 16bit immediate value the immediate value is signextended or zeroextended depending on the operation signed adds and subtracts can generate the arithmetic overflow trap ov which is sampled by cp0 theralualsogeneratesthevirtualmemoryaddressesforregisterloadsfromstorestomemorybyadding aregisterbasetoasignextended16bitimmediateoffsetdataaddresserrorsgeneratethe adelades trap flags which are sampled by cp0 the lx8380 employs bigendian memory addressing branches are based on comparisons between registers rather than implicit flags permitting the programmer moreflexibilityfromthesecomparisonstheralugenerates nandzflagsforsamplingincp0branchor jump instructions may optionally store in general purpose register the address of the instruction at the memory location following the branch delay slot of jump or branch which is taken this register called thelink holds the return address following subroutine call coprocessor operations permit moves of the general purpose registers tofrom the lx8380s block move controller or to optional applicationspecific coprocessors one or two these transfers occur over the data bus similar to data memory loads and stores 24system control copr ocessor cp0 the system control coprocessor cp0 is responsible for instruction address sequencing and exception processing fornormalexecutionthenextinstructionaddresshasseveralpotentialsourcestheincrementoftheprevious address branch address computed using pcrelative offset or jump target address for jump addresses the absolute target can be included in the instruction or it can be the contents of generalpurpose register transferred from the ralustage name actions 1i instruction fetch 2d decode instruction 3s source operand fetch register file read 4e execute alu operations memory address generation 5a access data memory read data cache store and tags 6m memory data select and format 7w write data to register file and memory10 lexra proprietary confidential revision 14section 2 architecture lx8380 branches are assumed or predicted to be taken in the event of prediction failure two stall cycles are incurred and the correct address is selected from special backup register statistics from several large programssuggestthatthesestallswilldegradeaveragelx8380throughputbyseveralpercenthoweverthe net effect of the lx8380s branch prediction on performance is positive because this technique eliminates certain critical paths and therefore permits higher speed system clock if anexception occurs cp0 selects one of several hardwired vectors for the next instruction address the exception vector depends on the mode and specific trap which occurred this is described further in section34 exception processing the following registers which are visible to the programming model are located in cp0 table 2 cp0 registers epc status cause and badvaddr are described in the section34 the dreg depc and desave registers are used by ejtag probe debug software and are described in the ejtag 200 specification the prid register is readonly register that allows software to identify the lexra processor modelthecctlregisterisalexradefinedcp0registerusedtocontroltheinstructionanddatamemories as described in section62 thecontentsoftheregisterslistedintable2aretransferredtoandfromtheralusgeneralpurposeregister file by the mfc0 and mtc0 instructions as described in section316 the lx8380 implements extended cp0 registers that provide additional functions summarized in table3 table 3 extended cp0 registers the registers listed in table3 are described in detail in section35 the contents of these registers are transferredtoanfromtheralusgeneralpurposeregisterfilebythemflxc0andmtlxc0instructions as described in section316cp0 register number function badvaddr 8 holds bad virtual address if address exception error occurs status 12 interrupt masks mode selects cause 13 exception cause epc 14 holds address for return after exception handler prid 15 processor id readonly 0x0000ce01 for lx8380 dreg 16 ejtag debug control depc 17 ejtag debug exception pc cctl 20 instruction and data memory control desave 31 ejtag debug save register cp0 register number function estatus 0 interrupt masks for prioritized vectored interrupts ecause 1 interrupt pending ﬂags for prioritized vectored interrupts intvec 2 address of vector table for prioritized vectored interruptsrevision 14 lexra proprietary confidential 11lx8380 section 2 architecture 25 highperformance context switch thelx8380cpuincorporatesmultipleindependentregistersetscalled contextsasaresultexecutioncan switch between independent software tasks called threads each running in its own context this switch is called acontext switch conventional risc architectures perform context switching in software however packet processing demands special hardware support to achieve high performance context switching the lx8380providesazerooverheadcontextswitchthatisaninstructioncanbeexecutedfor somecontextin every cycle 251 new context registers thenumberofcontextsiscustomerdefinedusinglexras lconfigutilityonetoeightcontextsaresupported by the lx8380 rtl default is one context each context includes 32 general registers r0 r31 1 32bit cxpc program counter 1 16bit cxstatus register the general registers are located in the ralu the cxpc and cxstatus registers are located in cp0 in addition 3bit register movecx is located in cp0 and is accessible with the mtlxc0mflxc0 instructions variants of the mips standard mtc0mfc0 instructions movecx holds the encoded numberofthetargetcontextforthemfcxcmtcxcandmfcxgmtcxginstructionswhichcanaccess the registers of any context these new registers are illustrated in figure3 the currently active context number is an implicit readonly value that is accessed with the mycx instruction figure 3 context associated registers the mips i isa except for unaligned loads and stores is fully supported in each context as result the general register set for each context is fully consistent with the mips isa requirements for example r0 is hard wired to 0 and r31 is an implied link for certain branch and jump instructions in every context up to two source registers and one destination register may be specified for an alu operation again consistentmulticontext register file context control registers context 7 r0 r31 context 1 r0 r31 context 0 r0 r31context 7 cxpc cxstatus lxc0 control register movecxcontext 1 cxpc cxstatus context 0 cxpc cxstatus 12 lexra proprietary confidential revision 14section 2 architecture lx8380 with the mips programming model cxpcholdsthe32bitvirtualaddressofthenextinstructiontobefetchedbytheassociatedcontextthe16 bit cxstatus register indicates whether the context is waiting for data transfer or io events cxstatus also permits programassigned priority for context reactivation the cxstatusregisterfields are identified in table4 each field is explainedbelow the rdwr or rd onlyindicationsapplytoaccessusingthemtcxcandmfcxcinstructionstheeffectsofotherhardware and software events on the fields is shown explicitly and explained in the following paragraphs the cxstatus waitevent field provides eight event flags that may be controlled by hardware software or combination of the two the flags may be set with the csw instruction or the wdcsw instructionthewdcswinstructionupdatesthewaiteventflagswritesadescriptortothesystembus and performs context switch whenwaiteventbitsaresetwithawdcswinstructiontheprocessorinitiatesanuncachablewriteto the system bus and performs context switch all context switches are performed after oneinstruction delay slot the waitevent bits may be cleared via software from another context with the postcx instruction or by hardware through the event signal inputs when the target device completes the wd operation it notifies the processor with high pulse on the processors corresponding event signal input eight per context the processor then clears the wait event bit in the contexts cxstatus register software can set more than one waitevent bit which will require completion response on each of the corresponding event signal inputs before the context is ready for execution the cxstatus waitload bit indicates that the associated context is waiting for the completion of register load from uncached memory or memorymapped io following execution of lwcsw load word with context switch ltcsw load twinword with context switch or lqcsw load quadword with context switch see section254 for descriptions of these three instructions waitload is set following execution of lwcsw ltcsw lqcsw wdlwcsw wdltcsw or wdlqcsw instructions and cleared by the processor when the load data is transferred to the contexts general register file the threebit threadpriority field in cxstatus allows context scheduling with up to eight priorities an application specific context scheduler can utilize thread priorities to fine tune the context scheduling see section254 for details of the context scheduling hardware interface 15 0000 waitevent threadprio87 4 2 0 84 3waitld 13revision 14 lexra proprietary confidential 13lx8380 section 2 architecture table 4 context status register detail 252 reset at reset the general registers are unaffected by reset context0isactivatedatresetallcxpcsareresettothecommonmipsresetvector0xbfc0000however context 0 may modify the initial cxpc of the other contexts prior to the first context switch 253 determining the number of contexts in software as described above the number of contexts that are implemented in processor is customer defined using lexraslconfigutility in some cases software will be written that must be adaptable to an unknown number ofcontextsforanynonimplementedcontextreadingthecxstatusregisterwillalwaysreturnavalueof zerousingtheinstructionsdescribedinsection2512 programaccesstonewregistersthesoftwarecan attempt to write nonzero value to the cxstatus register for each context if the value zero is returned when attempting to read back the written value then that context is not implemented 254 initiation of context switch context switch is executed by the csw instruction and any of the following instructions that include the csw extensionfieldwidth bitsdescription waitevent 8 rdwr set with csw and wdcsw instructions cleared by external hardware or cleared with postcx instruction reserved 4 rd only reserved waitload 1 rdwr set with lwcsw ltcsw lqcsw wdlwcsw wdltcsw and wdlqcsw instructions cleared by hard ware threadpriority 3 rdwr thread context priority for use by optional custom context scheduler cxstatus150 0x0000 cxpc310 0xbfc00000 movecx20 000 csw rs context switch update cxstatus from rs lwcsw rt displacementbase load word from uncached memory ltcsw rt displacementbase load twinword from uncached memory lqcsw rt displacementbase load quadword from uncached memory wd rs rt device write descriptor to device wdcsw rs rt device write descriptor to device with context switch wdlwcsw rd rs rt device write descriptor load word reply data wdltcsw rd rs rt device write descriptor load twin reply data wdlqcsw rd rs rt device write descriptor load quad reply data14 lexra proprietary confidential revision 14section 2 architecture lx8380 255 csw instruction the context switch csw instruction causes an unconditional context switch allowing the application program to execute context switch under complex programdefined conditions by alternately executing or branching around the csw instruction bits 3124 of the rs register specified in the csw instruction are logically ored with the waitevent field of cxstatus to determine the new waitevent field settings 256 lwcsw ltcsw and lqcsw instructions theloadwordwithcontextswitchlwcswinstructionisusedtoinitiatealonglatencytransferfroman lbus device to general register lwcsw performs split transaction read so that the next context can continue to execute while the memorymapped resource is accessed only two clock cycles of system bus tenurearerequiredtoinitiatethesplitreadtransactionfollowinginitiationthebusisavailableforotheruse the final transfer of the return data uses one cycle of system bus tenure loading the final result into the register file will not stall the currently executing context unless the context is executing load or store instruction at the time the split read data is returned in this case single cycle stall is required to load the splitreaddataintotheregisterfilethecurrentlyexecutingcontextisotherwiseunaffectedbythereturndata similarly ltcsw is used to initiate long latency load of 64bit data into two consecutively numbered general registers starting with the low register address bit equal to 0 up to two processor stalls can occur whenthe64bitdataistransferredintotheregisterfilelqcswisusedtoinitiatealonglatencyloadof128 bit data into four consecutively numbered general registers starting with the two low order register address bitsequalto00uptofourprocessorstallscanoccurwhenthe128bitdataistransferredintotheregisterfile following lwcsw ltcsw or lqcsw waitload in cxstatus is set 257 wdcsw instructions the write descriptor wd instruction forms 64bit descriptor from the contents of two general registers and writes the descriptor over the system bus interface to the specified device an optional context switch may be performed by this instruction by appending csw suffix to the mnemonic these instructions are used to initiate longlatency operations to shared device theseinstructionsformthedescriptorusingrsandrtregistercontentsasdescribedindetailinsection4for wdcsw the upper bits of the descriptor identify the waitevent bits to be set the wd instruction sourcesthefull64bitsofthedescriptoronthesystembusthe32bitsystembusaddressofthetargetdevice is formed by concatenating 24bit configuration defined constant the 5bit device id from the instruction opcode and three bits of 0 258 wdlwcsw wdltcsw and wdlqcsw instructions the wdlwcsw wdltcsw and wdlqcsw instructions provide efficient operation with devices that return3264or128bitsofdatatheseinstructionssetthewaitloadbitinthecxstatusregisterthe wdlwcsw writes 64bit descriptor to device and requests the device to provide split transaction word read response likewise the wdltcsw wdlqcsw instruction writes descriptor and requests the device to provide split transaction twinword quadword read response note that csw suffix is mandatory for these instructions because they must always set waitload these instructions do not set waitevent bits in the cxstatus register 259 pipeline followingexecutionofacontextswitchinstructionlwcswltcswlqcswwdcswwdlwcsw wdltcsw wdlqcsw or csw the next instruction executes to completion in the current contextrevision 14 lexra proprietary confidential 15lx8380 section 2 architecture beforethecontextswitchiseffectiveinotherwordsthecontextswitchasaresultofpipelininghasan architectural delay slot exposed to the programmer this delay slot and restriction on its usage is explained below and is generally consistent with similar branch and jump delay slots in the mips i isa the delay slot is illustrated below in the example contextis inst n1 executes to completion cxpci stores the address of inst n2 the addresswherecontextiresumeswhenitislaterreactivatedafterinstn1iscompletethenextinstruction executedisinstm1incontextjofcoursecontextiandcontextjmayexecutetwocompletelydifferent tasks or execute the same task on different data in this case the pcs will also be unrelated number of restrictions apply to the delay slot instruction 1 branch or jump may be coded in the delay slot context switch changes program ﬂow like the branch or jump this restriction is thus similar to the mips i restriction that back toback branches or jumps can occur 2 the registers loaded by lwcsw ltcsw lqcsw wdlwcsw wdltcsw or wdlqcsw cannot be referenced in the delay slot following the load similar restriction exists for loads in the mips i isa 2510 new context selection following execution of context switching instruction the cpu selects the next context for activation from the available pool the available pool consists of those contexts for which the cxstatus registers wait event and waitload fields are clear if context is available the cpu stalls after executing the context switching instruction and its delay slot stall conditions can arise when all contexts initiate long latency processes for example all contexts might initiateablocktransferwithinashortperiodoftimesuchthatnotransferhascompletedwhenthelastcontext performs its context switch thecpulogicrequiredtoimplementtheabovenextcontextselectionalgorithmispipelinedasaresultthe nextcontextselectioninthedstageofthepipelineacriticalpathcanbeverysimplewiththisapproach the cxstatus register sampling used for next context selection will occur several cycles earlier and may notincludeanewlyavailablecontexthoweverthisisnotadrawbackbecauseeventcompletionsforinactive contexts are asynchronous to the current contexts program the lx8380s internal context scheduler described in the following paragraphs is pipelined such that if there is currently active context all contexts have some wait bit set it takes two cycles from the time that some context has all of its wait bits clear until that contexts cxpc value is driven to the instruction ram the lx8380 processor includes internal context scheduling hardware the scheduler examines the cxstatus register of each context to determine which contexts are ready for execution context for which all of the waitevent and waitload bits are zero may be selected on the next context switch operation the lx8380s internal context scheduler ignores the threadpriority field of the cxstatus register it selects the next context fairly characteristic of this scheduler is that if contexts areperformingsimilartypesofactivitiesovertimetheyexperiencesimilarselectionratesandsimilardelays in selection when there are multiple contexts ready for executioncontexti contextj inst n csw r7 inst m inst n1 addu r3 r2 r1 inst m1 addu r7 r6 r3 inst n2 subu r4 r3 r1 inst m2 16 lexra proprietary confidential revision 14section 2 architecture lx8380 the algorithm employed by the internal scheduler relies on window of ready contexts the following steps in the algorithm are endlessly repeated once window of ready contexts has been chosen other contexts are added to this window if ready context in the window subsequently has one of its wait bits turned on that context is removed from the window since the window contains only inactive contexts thiscanonlyhappenifthecurrentlyactivecontextexecutesamtcxctoturnonanother contextswaitbitthisisanunusualcasebecauseitisexpectedthatmtcxcwillonlybe used during system initialization onebyone as context switches are executed context from the window is selected for the next context switch as each contextswitch takes effect the selected context is removed from the window the selection among the contexts in the window is not architecturallydefinedandapplicationsoftwareshouldnotdependonanyparticularorder the current implementation selects the highest numbered context in the window but this may be changed in future implementations whenthewindowisabouttobecomeemptyanewwindowiscreatedcomprisingallof the currently ready contexts if there are none this step repeats until there is at least one ready context when new nonempty window is obtained the full cycle of this algorithm continues as described above anycontextthatbecomesreadywilleventuallybeincludedinthenextnewwindowandwillbeselectedfor execution therefore this algorithm prevents ready context from being starved out of activation by other contextsthefairnessofthisalgorithmresultsfromthefactthatcontextswhichbecomereadymoreoftenare dispatched more often while those which become ready less often are dispatched less often for applications that require more detailed scheduling the customer may bypass the standard lx8380 schedulerandsupplyanapplicationspecificdesignthathasaccesstothesamepercontextinformationasthe standard scheduler such scheduler may also examine other real time information that is outside the province of lx8380 architecture thefollowingtableliststheportsthattheprocessorsuppliesforeachcontextwhicharedirectlyconnectedto thestandardorapplicationspecificschedulermoduletheportdirectionisrelativetotheprocessoraninput to the processor must be driven from register in the scheduler likewise an output from the processor is driven from register within the processor table 5 scheduler ports processor port direction description cx_stusthwait_rn10 output assertedwhenanywaitﬂagissetincxsta where n is the number of contexts cx_stusthprio_rn310 output threadpriority ﬁeld from cxstatus where n is the number of contexts cx_threadactv_rn10 output 1 if thread context is active where n is the number of contexts ext_nextcntxrdy_p_r input 1 if schedulers next context selection is valid ext_nextcntx_p_r20 input schedulers next context selectionrevision 14 lexra proprietary confidential 17lx8380 section 2 architecture becausetheschedulerdeterminesthecontextthattheprocessorwillactivateonthe nextcontextswitchitcan includeregisterstagesinitsdesigntoavoidanytimingproblemstypicallyeachprocessorisconnectedtoits ownlocalcontextschedulerhowevertheuseofasingleschedulingmodulewhichoperatesoninformation from all processors is not precluded itshouldbenotedthatthecx_threadactv_rsignalsindicatethecurrentactivecontextatthe endofthe pipelineexceptionsandmispredictedbranchescancausecontextswitchestobesquashedfurthermorethe waitbitvaluescanbesetbycontextswitchesormtcxcinstructionsandthesechangesonlytakeeffectat theendofthepipelineafteranypotentialexceptionsorbrancheshavebeenresolvedontheotherhandthe ext_nextcntx_p_rinputsmustbeusedatthe beginning ofthepipelinetoselectanewactivecontextin case of potential context switch toresolvethediscrepancybetweentheendandbeginningofthepipelinecp0inhibitsacontextthatisactive at any stage of the pipeline from being dispatched for context switch regardless of the value of ext_nextcntx_p_r in addition all contexts are inhibited from being dispatched for context switch whilethereisanmtcxcinstructionatanystageofthepipelinethiswillonrareoccasionscausenovalid instructions to be sent down the pipeline but it eliminates the need for the external scheduler to be aware of the pipeline thisinhibitinglogicalsoimpliesthattheexternalscheduleronlyneedstodetectachangeinthevalueofany cx_threadactv_rfromzerotoonetodeterminethatacontextswitchhasactuallytakenplaceanda new context has been dispatched 2511 example context switch for coprocessor operation thefollowingexampleillustrateshowanunconditionalcontextswitchcouldbeusedtoallowothercontexts to execute while coprocessor performs relatively long latency operation on behalf of context the example assumes that coprocessor 2 has been connected to the processors coprocessor interface ci which is available as part of lexras standard product thecoprocessorisassumedtocontainacontrolregister1thatmustcontainthecontextnumbertowhich subsequent coprocessor instructions apply another control register 2 is used to start the coprocessor operation when the coprocessor concludes the operation it signals the processor to clear specific wait event bit for the target context associated with the coprocessor this makes the context ready for dispatchsinceseveralcontextscanusecoprocessor2beforeretrievingtheresults thecurrentcontextmust againbestoredtothecontrolregister1inadditiontothemycxandcswinstructionstheexampleuses the mips standard mtc2 ctc2 mfc2 instructions for accessing coprocessor 2 mycx r1 get current context number ctc2 r1 1 tell cop2 which context this is mtc2 supply other data to cop2 csw r2 switch and wait for cop2 ctc2 r3 2 kick off cop2 in delay slot after the context switch when the cop2 operation completes this context is made ready and eventually gets dispatched here ctc2 r1 1 tell cop2 which context this is mfc2 retrieve results18 lexra proprietary confidential revision 14section 2 architecture lx8380 2512 program access to new registers thenewregistersdescribedinsection251cxpccxstatusmovecxaswellasthegeneralregisters of all contexts are accessible under program control by the active context the movecx register which determines the target context for the mtcxc mfcxc mtcxg mfcxg instructions is loaded by the mtlxc0 instruction and can be read with the mflxc0 instruction the number of the currently executing context can be accessed with the mycx instruction which loads it into general register cxpc and cxstatus are new coprocessor 0 registers these context control registers ct or cd can be moved to or from general registers rt or rd of the active context using the following instructions where ct or cd cxstatus cxpc movecx20 designates the context whose ct or cd is to be accessed mtcxcandmfcxcshould notbeusedtoaccessthecxpcofthecurrentlyactivecontextifctorcdisthe cxpc of the currently active context the result of mtcxc or mfcxc is undefined two additional instructions permit the general registers rt or rd in the active context to be transferred to or from the general registers gt or gd in inactive contexts this capability is useful in debugging so that all registers are accessible without execution of context switch the special case of moves within single context using mtcxg mfcxg is undetectable by the assembler though it would normally be performed using mips i instruction accessing general register in an inactive context will give unpredictable results if load is pending to that register mtcxc mfcxc mtcxg and mfcxg are extensions to the mips isa they function similarly to the mips mtc0 and mfc0 instructions but the opcodes have different object code assignments to allow the numberofcoprocessor0registerstobeextendedaswithmtc0andmfc0acoprocessorusabilitytrap is taken in user mode if cp0 is not designated usable in status mtcxc mfcxc mtcxg mfcxg are always usable in kernel mode 2513 exceptions themipsr3000exceptionprocessingmodelisunchangedbylx8380withonedifferenceexplainedinthe nextparagraphfollowingaprogramsynchronoustraporaninterruptthepcofthecurrentcontextisstored intheprogramvisibleepcregisterexceptionsarepreciseallowinganexceptionhandlertopossiblytake recovery steps and then resume execution at the pc of theexception if there isan activecontext nocontext switch occurs when an exception trap or interrupt is taken the exception handler executes in the same context that was current at the time the exception was taken the handler can use the mycx instruction tomtcxc rt cd moves gen reg rt of the active context to cd mfcxc rd ct moves ct to gen reg rd of the active context mtcxg rt gd moves rt of the active context to gd of context movecx mfcxg rd gt moves gt of context movecx to rd of the active contextrevision 14 lexra proprietary confidential 19lx8380 section 2 architecture determine its context if necessary lx8380 suppresses exceptions that occur in the delay slot of context switch this simplified approach is acceptableinembeddedsystemsexceptionreportingisausefuldebugtoolduringthedevelopmentprocess but is not necessary in production systems this suppression of exceptions applies to both interrupts and all program synchronous traps therefore instructions which deliberately cause exceptions break syscall should never be coded in the delay slot of cswtype instruction an ejtag debugger should neverattempttoinsertansdbbpinthedelayslotandshouldalsonotethatsinglesteppingwillexecutepast the delay slot instruction tofacilitatesystemlevelerrordetectionandreportingtheprocessorhasaspecialresponsetotheassertionof its intreqn7 hardware interrupt input when this interrupt is asserted the processor forces context 0 into ready state by clearing all of the wait flags in context 0s cxstatus register this ensures that there is contextavailabletoservicetheinterrupthowevertheinterruptmaybeservicedbyanyotherreadycontext all contexts share common set of coprocessor 0 registers including the exception processing registers described in section24 system control coprocessor cp020 lexra proprietary confidential revision 14section 2 architecture lx8380revision 14 lexra proprietary confidential 21lx8380 section 3 risc programming model 3 risc programming model this section describes the lx8380 programming model section31 summarizes the basic risc operations supported by the lx8380 these opcodes may be extended by the customer using lexras custom engine interface cei this capability is described in section32 section33 describes the simple memory management unit smmu the smmu provides sufficient memorymanagementcapabilitiesformostembeddedapplicationswhilesupportingexecutionofthirdparty mips software development tools section5 describes the optional programmable mmu the lx8380 supports the mips r3000 exception processing model as described in section34 the lx8380 supports mips i coprocessor operations the customer can include one or two application specificcoprocessorsthelx8380includesanoptionalcoprocessorinterfacecithatprovidesasimplified connectionbetweenacoprocessorandtheinternalsignalsofthelx8380theciisdescribedinsection36 31 summary of basic risc instructions the lx8380 executes the mips i r2000r3000 instructions as detailed in the tables below the lx8380 executes full mips i instruction set excluding the unaligned load and store instructions lwl swl lwr swr which are executed as noops the mtlxc0 mflxc0 movz movn and ltw instructions shown in this section are not mips i instructions additional instructions supported by the lx8380 are described in section4 instruction extensions section42 mac instructions section63 cache instruction the following conventions are employed in the instruction descriptions encloses list of syntax choices from which one must be chosen encloses list of values that are concatented to form larger value n value replicates concatenates value n times value3 bits selected from value rs offset memory address computation and corresponding memory contents 4b0000 sized constant binary value 32h1234_5678 sized constant hexadecimal value expr b select if expr is true otherwise select b cntxreg multicontext reg from context cntx current context if cntx prefix22 lexra proprietary confidential revision 14section 3 risc programming model lx8380 311 alu instructions table 6 alu instructions instruction name and description add addu addi addiurd rs rt rd rs rt rd rs immediate rd rs immediateadd add unsigned add immediate add immediate unsigned rd rs rt immediate add reg rs to either reg rt or 16bit immediate sign extended to 32 bits result is stored in reg rd add and addi can generate overflow trap addu and addiu do not sub suburd rs rt rd rs rtsubtract subtract unsigned rd rs rt subtract reg rt from reg rs result is stored in register rd sub can generate overflow trap subu does not and andird rs rt rd rs immediateand and immediate rd rs rt immediate logicaland of reg rs with either reg rt or 16bit immedi ate zeroextended to 32 bits result is stored in reg rd or orird rs rt rd rs immediateor or immediate rd rs rt immediate logicalor of reg rs with either reg rt or 16bit immediate zeroextended to 32 bits result is stored in reg rd xor xorird rs rt rd rs immediateexclusive or exclusive or immediate d rs rt immediate logicalxorofregrswitheitherregrtora16bitimmediate zeroextended to 32 bits result is stored in reg rd nor rd rs rt nor rd rs rt logicalnor of reg rs with reg rt result is stored in reg rdrevision 14 lexra proprietary confidential 23lx8380 section 3 risc programming model lui rd immediate load upper immediate rd immediate 16b0 the16bitimmediateisstoredintotheupperhalfofregrd the lower half is loaded with zeroes sll sllvrd rt immediate rd rt rsshift left logical shift left logical variable rd rt rs immediate the 5bit shift amount amt is obtained from the immediate field sll or bits 40 of reg rs sllv the contents of reg rt are shifted left amt bits the result is stored in reg rd srl srlvrd rt immediate rd rt rsshift right logical shift right logical variable rd rt rs immediate the 5bit shift amount amt is obtained from the immediate fieldsrlorbits40ofregrssrlvthecontentsofreg rt are shifted right amt bits the result is stored in reg rd sra sravrd rt immediate rd rt rsshift right arithmetic shift right arithmetic variable rd rt rs immediate the 5bit shift amount amt is obtained from the immediate fieldsraorbits40ofregrssravthecontentsofreg rt are arithmetic shifted right amt bits the result is stored in reg rd slt sltu slti sltiurd rs rt rd rs rt rd rs immediate rd rs immediateset on less than set on less than unsigned set on less than immediate set on less than immediate unsigned rd rs rt immediate 1 0 if reg rs is less than rt immediate set rd to 1 else 0 the 16bit immediate is sign extended for slt slti the comparison is signed for slu sltiu the comparison is unsignedinstruction name and description24 lexra proprietary confidential revision 14section 3 risc programming model lx8380 312 load and store instructions table 7 load and store instructions instruction description lb rt offsetrs lbu rt offsetrs lh rt offsetrs lhu rt offsetrs lw rt offsetrsload byte load byte unsigned load halfword load halfword unsigned load word rt memoryrs offset reg rt is loaded from data memory the memory address is computed as base offset where the base is reg rs and the offset is the 16bit offset signextended to 32 bits lb lbu addresses are interpreted as byte addresses to data memorylhlhuashalfword16bitaddresseslwasword 32bit addresses thedatafetchedinlblhlbulhuissignextendedzero extended to 32bits for storage to reg rt rt cannot be referenced in the instruction following load instruction ltw rt offsetrs load twinword rt rt1 memoryrs offset theoffset in bytes is signed rt 13bit quantity that must be divisible by 8 since it occupies only 10 bits of the instruction word the offset is sign extended and added to the contents of the register rt to form the address temp the word addressed by temp is fetched and loaded into rt which must be an even register the word addressed by temp4 is loaded into rt1 iftemp is not twinword aligned an address exception is taken iftheinstructionimmediatelyfollowingltwattemptstouse rt or rt1 the results of that instruction are unpredictable sb rt offsetrs sh rt offsetrs sw rt offsetrsstore byte store halfword store word memoryrs offset rt reg rt is stored to data memory the memory address is computed as base offset where the base is reg rs and the offset is the 16bit offset signextended to 32 bits sbaddressesareinterpretedasbyteaddressestodatamem ory the 8 loworder bits of rt are stored sh addresses are interpretedashalfwordaddressestodatamemorythe16low order bits of rt are storedrevision 14 lexra proprietary confidential 25lx8380 section 3 risc programming model 313 conditional move instructions table 8 conditional move instructions instruction description movz rd rs rt move if zero rd rt 0 rs rd if the contents of general register rt are equal to 0 the general register rd is updated with rs otherwise rd is unchanged movn rd rs rt move if not zero rd rt 0 rs rd if the contents of general register rt are not equal to 0 the gen eral register rd is updated with rs otherwise rd is unchanged26 lexra proprietary confidential revision 14section 3 risc programming model lx8380 314 branch and jump instructions table 9 branch and jump instructions instruction description beq rs rt offset bne rs rt offsetbranch if equal branch if not equal if cond pc pc 4 14 offset15 offset 2b00 else pc pc 8 where cond rs rt for eq rs ne rt for ne and offset is 16bit value for beq bne the instruction after the branch delay slot is always executed blez rs offset bgtz rs offsetbranch if less than or equal to zero branch if greater than zero if cond pc pc 4 14 offset15 offset 2b00 else pc pc 8 where cond rs 0 for rs 0 for gt and offset is 16bit value forblezbgtztheinstructionafterthebranch delayslotis always executed bltz rs offset bgez rs offsetbranch if less than zero branch if greater than or equal to zero if cond pc pc 4 14 offset15 offset 2b00 else pc pc 8 where cond rs 0 for lt rs 0 for ge and offset is 16bit value forbltzbgeztheinstructionafterthebranch delayslotis always executed bltzal rs offset bgezal rs offsetbranch if less than zero and link branch if greater than or equal to zero and link similar to the bltz and bgez except that the address of the instruction following the delay slot is saved in r31 regardless of whether the branch is takenrevision 14 lexra proprietary confidential 27lx8380 section 3 risc programming model 315 control instructions table 10 control instructionsj target jump pc pc3128 target 2b00 the jump target is 26bit absolute value the instruction fol lowing j delay slot is always executed jal target jump and link same as jump j except that the address of the instruction following the delay slot is saved in r31 jr rs jump register pc rs jump to the address specified in rs the instruction following jr delay slot is always executed jalr rs rd jump and link register same as jump register jr except that the address of the instruction following the delay slot is saved in rd instruction description syscall system call the sys trap occurs when syscall is executed break break the bp trap occurs when break is executed rfe restore from exception causes the kuie stack to be popped used when returning from the exception handler see exception processing belowinstruction description28 lexra proprietary confidential revision 14section 3 risc programming model lx8380 316 coprocessor instructions table 11 coprocessor instructions instruction description lwcz rcgen offsetrs load word to coprocessor z rcgen memoryrs offset coprocessor z 13 general reg rcgen is loaded from data memorythememoryaddressiscomputedas baseoffset where the base is reg rs and the offset is the 16bit offset signextended to 32 bits rcgen cannot be referenced in the following instruction one cycle delay swcz rcgen offsetrs store word from coprocessor z memoryrs offset rcgen coprocessor z 13 general reg rcgen is stored to data memorythememoryaddressiscomputedas baseoffset wherethebaseisregrsandtheoffsetisthe16bitoffsetsign extended to 32 bits mtcz rt rcgen ctcz rt rcconmove to coprocessor z move control to coprocessor z in mtczctcz the general register rt is moved to copro cessor z 03 general control reg rcgenrccon rcgen and rccon cannot be referenced in the following instruction mfcz rt rcgen cfcz rt rcconmove from coprocessor z move control from coprocessor z inmfczcfczthecoprocessorz03generalcontrolreg rcgen rccon is moved to the general register rt rt cannot be referenced in the following instructionrevision 14 lexra proprietary confidential 29lx8380 section 3 risc programming model mtlxc0 rt lx0reg move to lexra coprocessor 0 register the contents of general register rt are moved to the lexra defined cp0 register indicated by lx0reg mflxc0 rt lx0reg move from lexra coprocessor 0 register the general register rt is loaded from the contents of the lexradefinedcp0registerindicatedbylx0regrtcannotbe referenced in the following instruction bczt offset bczf offsetbranch if coprocessor z is true branch if coprocessor z is false if cond pc pc 4 14 offset15 offset 2b00 else pc pc 8 where cond cpcondz true for bczt cpcondz false for bczf forbcztbczftheinstructionafterthebranch delayslotis always executedinstruction description30 lexra proprietary confidential revision 14section 3 risc programming model lx8380 32 opcode extension using the custom engine interface cei customers may add proprietary or applicationspecific opcodes to their lx8380 based products using the custom engine interface cei the new instructions take one of the following forms illustrated below and use reserved opcodes table 12 custom engine interface operations lexra permits customer operations to be added using the four 4 iformat opcodes and six 6 rformat opcodes listed in the table above other opcode extensions in future lexra products will notutilize the opcodes reserved above when the custom engine decodes newopi or newopr it must signal the core that custom operation hasbeenexecutedsothatthereservedinstructionritrapwillnotbetakenmulticyclecustomoperations may be executed by asserting the lx8380s cei halt input note the custom operation may choose to ignore the src1 and src2 operands supplied by the cei and referenceinternalcustomengineregistersinsteadresultscanalsobewrittentoanimplicitcustomregister however unless rd 0 is coded register in the processor will also be written see the table entries under custom engine interface on page139 for listing of the cei signalsnew instruction description available opcodes newopi rd rs immed new operation immediate rd rs newopi immed reg rs is supplied to the src1 port of cei and the 16bit immediate sign extended to 32bits is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 24 27 newop rd rs rt new operation rd rs newopr rt reg rs is supplied to the src1 port of cei and reg rt is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 0 and inst50 5658606263revision 14 lexra proprietary confidential 31lx8380 section 3 risc programming model 33 simple memory management unit thelx8380includesasimplememorymanagementunitsmmufortheinstructionmemoryaddressand the data memory address the hardwired virtualtophysical address translation performed by the smmu is sufficient to ensure execution of thirdparty software development tools table 13 smmu address translation thelx8380includesoptionalsupportforafullyprogrammablemipsr3000stylemmuthisisdescribed in section5 memory management unit mmuregion name virtual address physical address cacheability permission kuseg 0x0000_0000 0x7fff_ffff0x4000_0000 0xbfff_ffffcached kernel or user kseg0 0x8000_0000 0x9fff_ffff0x0000_0000 0x1fff_ffffcached kernel kseg1 0xa000_0000 0xbfff_ffff0x0000_0000 0x1fff_ffffuncached kernel kseg2 0xc000_0000 0xfeff_ffff0xc000_0000 0xfeff_ffffcached kernel upperkseg2 0xff00_0000 0xffff_ffff0xff00_0000 0xffff_ffffuncached kernel32 lexra proprietary confidential revision 14section 3 risc programming model lx8380 34 exception processing thelx8380implementsthemipsr3000exceptionprocessingmodeltlbrelatedexceptionsareincluded onlyifthelx8380isconfiguredwiththeoptionalmmutheterm exception referstotrapswhicharenon maskable program synchronous events and interrupts which result from unmasked asynchronous events thelistbelowisnumberedfromhighesttolowestpriorityexccodeisstoredincausewhenanexception is taken sys bp ri cpu can share the same priority level because only one can occur in given time slot table 14 list of exceptions exception priority exccode description reset 1 reset trap adel instruction2 4 address exception trap instruction fetch occurs if the instruction address is not wordaligned or if kernel address is referenced in user mode tlbl instruction3 2 tlb instruction fetch trap occurs when virtual instruc tion address does not match tlb entry ov 4 12 arithmetic overflow trap can occur as result of signed add or subtract operations sys 5 8 syscall instruction trap occurs when syscall instruction is executed bp 5 9 breakinstructiontrapoccurswhenbreakinstruction is executed ri 5 10 reserved instruction trap occurs when reserved opcode is fetched cpu 5 11 coprocessor usability trap occurs when an attempt is made to execute coprocessor z operation and copro cessor z is not enabled via the status register adel data6 4 address exception trap data fetch occurs if the data address is not properly aligned or if kernel address is generated in user mode ades 7 5 address exception trap data store occurs if the data address is not properly aligned or if kernel address is generated in user mode tlbl data8 2 tlbdataloadtrapoccurswhenthevirtualdataaddress of load operation does not match tlb entry tlbs 8 3 tlb data store trap occurs when the virtual data addressofastoreoperationdoesnotmatchatlbentry tlbmod 8 1 tlb data modified trap occurs when the virtual data address of store operation matches tlb entry that is marked valid but not dirty int 9 0 unmasked interrupt from one or more of the six r3000 nonprioritized hardware interrupt requests or the eight lexraspecific prioritized hardware interrupt requestsrevision 14 lexra proprietary confidential 33lx8380 section 3 risc programming model 341 exception processing registers theseregistersarereadorwrittenusingmfc0andmtc0operationsthe0fieldsareignoredonwriteand are 0 on read to ensure compatibility with future lx8380 versions they should be written with 0 status coprocessor 0 general register address 12 cause coprocessor 0 general register address 133128 2723 22 2116 158 76 5 4 3 2 1 0 cu30 0 bev 0 im70 0 kuo ieo kup iep kuc iec field description rw reset cu cuz 1 0 indicates that coprocessor z is usable unusable in coprocessor instructions in kernel mode cp0 is always usable regardless of the setting of cu0rw 0 bev bootstrap exception vector selects between two trap vectors see section342rw 1 im interrupt masks for the six nonprioritized hardware interrupts and two software interruptsrw 0 kuie ku01indicateskernelusermodeinthelx8380usermode virtual addresses must have msb 0 in kernel mode the full address space is addressable ie 1 0 indicates that interrupts are enabled disabled the kuo ieo kup iep kuc and iec fields form threelevel stack hardware stack kuie signals the current values are kuc iec theprevious values are kupiep and the old values those before previous are kuoieo see section342rw 0 31 30 2928 2716 158 7 62 10 bd 0 ce10 0 ip70 0 exccode40 0 field description rw reset bd branch delay indicates that the exception was taken in branch or jump delay slotr0 ce coprocessor exception in the case of coprocessor usability exception indicates the number of the responsible coprocessorr0 ip72 interruptpendingbitsaresetwhenthecorresponding hardware interruptinputintreq_n72requestispendinglevelsensitiver0a after reset is deasserted ip contains values sampled from hardware interrupt sourcesip10 interrupt pending software controllable interrupts level sensitive rw exccode theexccodevalueslistedintable14arestoredherewhenan exception occursr034 lexra proprietary confidential revision 14section 3 risc programming model lx8380 epc coprocessor 0 general register address 14 epc contains the virtual address of the next instruction to be executed following return from the exception handleriftheexceptionoccursinthedelayslotofabranchepcholdstheaddressofthebranchinstruction and bd is set in cause the branch will typically be reexecuted following the exception handler badvaddr coprocessor 0 general register address 8 342 exception processing entry and exit when an exception occurs the instruction address changes to one of the following locations the kuie stack is pushed kuo ieo kup iep kuc iec before push kup iep kuc iec 0 0 after push whichdisablesinterruptsandputstheprograminkernelmodethecodeexccodefortheexceptionsource isloadedintocausesothattheapplicationspecificexceptionhandlercandeterminetheappropriateaction the exception handler should not reenable interrupts until necessary information has been saved31 0 epc field description rw reset epc exception program counter rw 0 31 0 badvaddr field description rw reset badvaddr bad virtual address contains the virtual address instruction or data which generated an adel or ades exception errorr0 reset 0xbfc0_0000 other exceptions bev 0 0x8000_0080 other exceptions bev 1 0xbfc0_0180revision 14 lexra proprietary confidential 35lx8380 section 3 risc programming model to return from the exception the exception handler first moves epc to general register using mfc0 followed by jr operation rfe only pops the kuie stack kup iep kuc iec 0 0 before pop kup iep kup iep kuc iec after pop this example assumes that kuie were not modified by the exception handler therefore typical sequence of operations to return from the exception handler would be 35 lowoverhead prioritized interrupts the lx8380 includes eight lowoverhead hardware interrupt signals that extend the mips r3000 interrupt exceptionmodelthesesignalsarecompatiblewithther3000exceptionprocessingmodelandareusefulfor realtime applications these interrupts are supported with three lexradefined cp0 registers estatus ecause and intvec accessed with the mtlxc0 and mflxc0 variants of the mtc0 and mfc0 instructions the 0 fields in these registers are ignored on write and are 0 on read to ensure compatibility with future lx8380 versions they should be written with 0 as with any cp0 instruction coprocessor unusable exception is taken if these instructions are executed while in user mode and the cu0 bit is 0 in the cp0 status register thethreelexracp0registersareestatus0ecause1andintvec2andaredefinedasfollows estatus lx cp0 reg 0 readwrite ecause lx cp0 reg 1 readonlymfc0 r26 c0_epc r26 is temporary storage register in the ralu jr r26 rfe 31 24 23 16 15 0 0 im158 0 field description rw reset im interrupt masks for the eight prioritized hardware interrupts rw 0 31 24 23 16 15 0 0 ip158 0 field description rw reset ip interrupt pending flags for the eight prioritized hardware interrupts r 0a after reset is deasserted ip contains values sampled from hardware interrupt sources36 lexra proprietary confidential revision 14section 3 risc programming model lx8380 intvec lx cp0 reg 2 readwrite estatus contains the interrupt mask bits im158 which are reset to 0 so that none of the vectored interrupts will be activated regardless of the global interrupt enable flag iec in the cp0 status register see section341 exception processing registers the interrupt pending flags ip158 for the vectored interruptsignalsarelocatedinecauseandarereadonlythesefieldsaresimilartotheim70andip70 fields defined in the r3000 exception processing model except that the vectored interrupts are prioritized in hardware and each has dedicated exception vector ip15hasthehighestprioritywhileip8hasthelowestpriorityhoweverallvectoredinterruptsarehigher priority than ip70 the processor concatenates the program defined base address for the exception vectors with the interrupt number to form the interrupt vector as shown in the table below two instructions can be executed in each vector typically these will consist of jump instruction and its delay slot with the target of the jump being either shared interrupt handler or one that is unique to that particular interrupt table 15 prioritized interrupt exception vectors when vectored interrupt causes an exception all of the standard actions for an exception occur these include updating the epc register and certain subfields of the standard status and cause registers in particulartheexceptioncodeofthecauseregisterindicatesinterruptandthecurrentandprevious mode bits of the status register are updated in the usual manner 36 coprocessors applications may include up to two coprocessors to interface with the lx8380 not including the bmc which is implemented as coprocessor 3 the contents of these coprocessors may include up to thirtytwo 32bitgeneral registers and up to thirtytwo 32bit control registers the general registers may be moved to and from the ralus registers using mtcz mfcz operations or be loaded and stored from data memory using lwcz swcz operations the control registers may only be moved to and from the ralus registers using ctcz cfcz operations31 6 5 0 base 0 field description rw reset base base address of interrupt vector table bits 316 rw 0 interrupt number exception vector 15 base 6b111000 14 base 6b110000 13 base 6b101000 12 base 6b100000 11 base 6b011000 10 base 6b010000 9 base 6b001000 8 base 6b000000 revision 14 lexra proprietary confidential 37lx8380 section 3 risc programming model the lx8380 includes the optional coprocessor interface ci allowing the customer to easily interface coprocessor to the lx8380 the ci supplies set of control address and data busses that may be tied directly to the coprocessor general and control registers the ci is described in more detail in section5 coprocessor interface38 lexra proprietary confidential revision 14section 3 risc programming model lx8380revision 14 lexra proprietary confidential 39lx8380 section 4 instruction extensions 4 instruction extensions 41 context switch and data transfer operations thetablebelowexplainsthedetailsoftheinstructionsthatareusedtocauseacontextswitchandtotransfer data on behalf of context the context switching instructions typically set one or more wait bits in the contexts cxstatus register which prevent the context from being reactivated until its program can usefully resume since thread may wish to wait for notification of up to eight hardware or software events there is user mode instruction postcx which allows another thread to atomically clear any within this processor contexts waitevent bits the instruction mycx allows the program to determine its own context number and if there are multiple processorsinthesystemitsownprocessornumberthisallowsseveralthreadstoexecutethesameprogram but to use their context numbers andor processor numbers to access unique memory regions or remote devices all of these instructions may be executed in user mode and therefore are notsubject to any coprocessor usability exceptions for all of the instructions which cause context switch there is single instruction delay slot that is the instructionimmediatelyfollowingthecontextswitchinginstructionisexecutedinthesamecontextandthat contexts cxpc is loaded with the address of the instruction after the delay slot immediately after the executionofthedelayslotinstructionthenewlyselectedcontextbeginsexecutionattheinstructionspecified by its cxpc register there are restrictions on the type of instruction that can be executed in the delay slot of context switching instructions these restrictions are detailed in note following table16 for several of the instructions the descriptions are nearly identical differing in only few items in order to make it easier for the reader to identify only the differences these are indicated with underlined text for an explanation of the conventions employed in the algorithmic descriptions refer to section31 on page2140 lexra proprietary confidential revision 14section 4 instruction extensions lx8380 table 16 context switching instructions instruction syntax and description mycx rd my context rd 16h0000 procnum70 5b00000 cntxnum20 thecurrentcontextnumberisplacedintord20iftherearemultiple processorsinthesystemthenumberoftheprocessorexecutingthis instruction is placed into rd158 otherwise rd158 is zeroed all other bits of rd are set to zeroes postcx rs rt post event to context cntx rt20 temp cntxcxstatus158 rs3124 cntxcxstatus158 temp bits rt20 are used as the target context cntx bits rs3124 are log icallyandedwithbits158thewaiteventbitsofthecxstatus register for context cntx and that contexts cxstatus register is updated with the result csw rs context switch unconditional temp cxstatus158 rs3124 cxstatus158 temp cxpc pc 8 pc next_contextcxpc bits 158 the waitevent bits from the current contexts cxsta register are logically ored with rs3124 and the cxstatus register is updated with the result an unconditional context switch occurs after the execution of this instructions delay slot the context scheduler determines the next context that is activated lwcsw rt offsetrs load word uncached with context switch temp rs310 20 offset 11 offset 110 rt memorytemp cxstatus3 1b1 cxpc pc 8 pc next_cntxcxpc theoffset in bytes is signed 12bit quantity that must be divisible by4sinceitoccupiesonly10bitsoftheinstructionwordthe offset is sign extended and added to the contents of rs to form the address tempthewordaddressedby tempisfetchedusingasplittransaction and loaded into rt the waitload bit is set in this contexts cxsta register while the fetch is in progress an unconditional context switch occurs after the execution of this instructions delay slot the context scheduler determines the next context that is activated iftempdoesnotspecifyanaddressinuncachablespacetheresultof the operation is undeﬁned iftemp speciﬁes an address in dmem space the result of the opera tion is undeﬁned iftempisnotwordalignedanaddressexceptionistakenandnocon text switch occursrevision 14 lexra proprietary confidential 41lx8380 section 4 instruction extensions ltcsw rt offsetrs load twinword uncached with context switch temp rs310 19 offset 12 offset 120 rt rt1 memorytemp cxstatus3 1b1 cxpc pc 8 pc next_cntxcxpc theoffset in bytes is signed 13bit quantity that must be divisible by8sinceitoccupiesonly10bitsoftheinstructionwordthe offset is sign extended and added to the contents of the register rs to form the address temp the word addressed by temp is fetched using twinwordsplittransactionandloadedintort whichmustbeaneven register the w ord addressed b ytemp4 is loaded into rt1 the waitload bit is set in this contexts cxstatus register while the fetches are in progress an unconditional context switch occurs after the execution of this instructions delay slot the context scheduler determines the next context that is activated iftempdoesnotspecifyanaddressinuncachablespacetheresultof the operation is undeﬁned iftemp speciﬁes an address in dmem space the result of the opera tion is undeﬁned iftempisnottwinwordalignedanaddressexceptionistakenandno context switch occurs lqcsw rt offsetrs load quadword uncached with context switch temp rs310 18 offset 13 offset 130 rt rt1 rt2 rt3 memorytemp cxstatus3 1b1 cxpc pc 8 pc next_cntxcxpc theoffset in bytes is signed 14bit quantity that must be divisible by 16 since it occupies only 10 bits of the instruction word the off set is sign extended and added to the contents of the register rt to formtheaddress tempthewordaddressedby tempisfetchedusing aquadwordsplittransactionandloadedintort whichmustbeareg ister number divisib by four the w ord addressed b ytemp4 is loadedintort1thewordaddressed bytemp8isloadedintort2 the word addressed b ytemp12 is loaded into rt3 the wait load bit is set in this contexts cxstatus register while the fetches are in progress an unconditional context switch occurs after the exe cution of this instructions delay slot the context scheduler deter mines the next context that is activated iftempdoesnotspecifyanaddressinuncachablespacetheresultof the operation is undeﬁned iftemp speciﬁes an address in dmem space the result of the opera tion is undeﬁned iftempisnotquadwordalignedanaddressexceptionistakenandno context switch occursinstruction syntax and description42 lexra proprietary confidential revision 14section 4 instruction extensions lx8380 wdcsw rs rt devid write descriptor addr system_contant230 devid40 3b000 memoryaddr rs rt if csw temp cxstatus158 rs3124 cxstatus158 temp cxpc pc 8 pc next_cntxcxpc a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 if the optionalcsw xtension is speci ﬁed then bits 6356 of the descr iptor are logically ored with the waitevent bits of this conte xts cxstatus register which is updated with the result the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto thevalueofthe5bit devidﬁeldandbits20allzeroesasystembus operation is performed to write bits 630 of the descriptor to the device if the optionalcsw extension is speciﬁed the processor per forms context switch after the execution of this instructions delay slot the context scheduler determines the next context that is acti vatedinstruction syntax and descriptionrevision 14 lexra proprietary confidential 43lx8380 section 4 instruction extensions wdlwcsw rdrsrtdevid write descriptor with load word uncached and context switch addr system_contant230 devid40 3b000 memoryaddr rs rt rd memoryaddr cxstatus3 1b1 cxpc pc 8 pc next_cntxcxpc a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 the waitload bit of this conte xts cxstatus register is set the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto thevalueofthe5bit devidﬁeldandbits20allzeroesasystembus operation is performed to write bits 630 of the descriptor to the device also requesting an uncached split transaction read word response the processor performs context switch after the execu tion of this instructions delay slot when the processor receives the corresponding read word response from the system bus it is loaded into register rd of the originating contexts general purpose register ﬁle and that contexts waitload ﬂag is cleared wdltcsw rdrsrtdevid write descriptor with load twinword uncached and context switch addr system_contant230 devid40 3b000 memoryaddr rs rt rd rd1 memoryaddr cxstatu3 1b1 cxpc pc 8 pc next_cntxcxpc a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 the waitload bit of this conte xts cxstatus register is set the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto the value of the 5bit deviceid ﬁeld and bits 20 all zeroes system bus operation is performed to write bits 630 of the descriptor to the device also requesting an uncached split transaction read twinword response the processor performs context switch after the execu tion of this instructions delay slot the context scheduler determines the next context that is activated when the processor receives the corresponding read twinword response from the system bus the ﬁrst returned word is loaded into register rd which must specify an ven register and the second returned word is loaded into rd1 of the originating contexts general purpose register ﬁle and that contexts waitload ﬂag is clearedinstruction syntax and description44 lexra proprietary confidential revision 14section 4 instruction extensions lx8380 notes the delay slot of the csw lwcsw ltcsw lqcsw wdcsw wdlwcsw wdltcsw and wdlqcsw instructions may not contain branch jump or mtcxc instruction the delay slot of the wdlwcsw wdltcsw wdlqcsw wdlwcsw wdltcswand wdlqcsw instructions may not access to any register loaded by the instruction 42 bit field processing operations table17 explains the details of the instructions used to manipulate bit fields as shown in figure4 for several of these instructions width and insert offset specify subfield of 32bit register that is to be used as target of the instruction for the extiv and insv paired instructions or extii and insi the extract offset and width can specify maximally 32bit subfield which straddles the boundary of two source registers or is completely contained in either one of two potential source registers figure4 insert and extract operations straddle case illustrates the straddle case itisworthnotingthatthestandardmipsinstructionsetincludesbranchonequalandbranchonnotequal instructions therefore the extract instruction can be used to select field that is tested by conditional branch and explicit test instruction is necessary for several of the instructions the descriptions are nearly identical differing in only few items in order to make it easier for the reader to identify only the differences these are indicated with underlined xtwdlqcsw rdrsrtdevid write descriptor with load quadword uncached and context switch addr system_contant230 devid40 3b000 memoryaddr rs rt rd rd1 rd2 rd3 memoryaddr cxstatus3 1b1 cxpc pc 8 pc next_cntxcxpc a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 the waitload bit of this conte xts cxstatus register is set the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto thevalueofthe5bit devidﬁeldandbits20allzeroesasystembus operation is performed to write bits 630 of the descriptor to the device also requesting an uncached split transaction read quadword response the processor performs context switch after the execu tion of this instructions delay slot the context scheduler determines the next context that is activated when the processor receives the corresponding read quadword response from the system bus the ﬁrst returned word is loaded into register rd which must specify register n umber divisib by four thesecondreturnedwordisloadedintord1thethirdreturnedword is loaded into rd2 and the f ourth returned word is loaded into rd3 of the originating contexts general purpose register ﬁle and that texts waitload ﬂag is cleared nomenclature rs rt rd r0 r31 base r0 r31instruction syntax and descriptionrevision 14 lexra proprietary confidential 45lx8380 section 4 instruction extensions figure 4 insert and extract operations straddle case table 17 bit field processing instructions instruction syntax and description seti rt rs width offset set bits immediate rdwidthoffset1offset width 1b1 theoffsetisavaluepintherange031the widthisavaluemin the range 132 which is encoded in the instruction as 5bit valuemodulo32thatisthevalue32isencodedaszerothe bitsrtmp1paresettoonestheremainingbitsofrtarecop ied from the corresponding bits of rs if mp is greater than 32 the results are unpredictable clri rt rs width offset clear bits immediate rdwidthoffset1offset width 1b0 theoffsetisavaluepintherange031the widthisavaluemin the range 132 which is encoded in the instruction as 5bit valuemodulo32thatisthevalue32isencodedaszerothe bits rtmp1p are set to zeroes the remaining bits of rt are copied from the corresponding bits of rs if mp is greater than 32 the results are unpredictablewidth widthextract offset 0 set clearextract insert insert offset31 00 63 32 31 31extract from rt extivextii extract from rt insvinsi unmodified fields from rs seti clri insviwidth insert register46 lexra proprietary confidential revision 14section 4 instruction extensions lx8380 extiv rd rs rt extract bits for insertion variable insert4732 rs150 xoffset rs1510 width rs95 if xoffset32 if xoffsetwidth132 tempwidth10 rtwidthxoffset1offset temp31width 32width 1b0 else temp31xoffset0 rt31xoffset temp3132xoffset 32width 1b0 else temp310 32h0000_0000 rd temp insert310 temp thebits rs1510 are decoded as an extraction offset n in the range063 the bits rs95 are decoded as width m in the range 132 modulo 32 the bits rs40 are decoded as an inser tion offset p in the r ange 031 these parameter fieldsof rs are savedintheimpliedregisterinserttheremainingbitsofrsare ignored considering rt to contain the least significant 32 bits of the extraction source 32bit intermediate extraction value temp is generated as follows 1 ifn32 and nm1 32 least significant word only the bits rtmn1narecopiedinto tempm10andtheremainingbitsof temp are set to zeroes 2ifn32andnm131straddletwowordsthebitsrt31n are copied into temp31n0 and the remaining bits of temp are set to zeroes 3 if n31 most significant word only temp310 is set to all zeroes thetempvalueisstoredinrdandalsosavedintheimpliedregis ter insert ifmnisgreaterthan64theresultsofthisinstructionandasub sequent insv instruction are unpredictableinstruction syntax and descriptionrevision 14 lexra proprietary confidential 47lx8380 section 4 instruction extensions insv rd rs rt insert bits variable xoffset insert4742 width insert4137 ioffset insert3632 temp insert310 if xoffset32 if xoffsetwidth132 result310 temp310 else result31xoffset0 temp31xoffset0 resultwidth132xoffset rtxoffsetwidth330 if width32 result31width 32width 1b0 else resultwidth10 rtxoffsetwidth33xoffset32 result31width 32width 1b0 rdwidthioffset1ioffset resultwidth10 this instruction must be coded as the next sequential instruction in the program sequence after an exti v otherwise its results are unpredictable all exceptions are inhibited for the execution of this instruction thisincludeshardwareinterruptsdebugexceptionsandaddress exceptions theparameterfieldsmn pandtheintermediateextractionvalue temparetakenfromtheimpliedregisterinsertasdescribedfor extiv considering rt to contain the most significant 32 bits of theextractionsourcethefinalextractedvalue resultisgenerated as follows 1 ifn32 and nm1 32 the bits temp310 are copied into result310 2ifn32andnm131thebits temp31n0arecopiedinto result31n0 the bits rtnm330 are copied into resultm 132n the remaining bits of result are set to zeroes 3 if n31 the bits rtnm33n32 are copied into resultm10 the remaining bits of result are set to zeroes the bits from resultm10 are copied into rdmp1p the remaining bits of rd are copied from the corresponding bits of rs if mn is greater than 64 or if mp is greater than 32 the results are unpredictableinstruction syntax and description48 lexra proprietary confidential revision 14section 4 instruction extensions lx8380 extiirdrt width xoffset extract bits for insertion immediate insert4742 xoffset insert4137 width if xoffset32 if xoffsetwidth132 tempwidth10 rtwidthxoffset1offset temp31width 32width 1b0 else temp31xoffset0 rt31xoffset temp3132xoffset 32width 1b0 else temp310 32h0000_0000 rd temp insert310 temp theextractoffsetxoffsetisavaluenintherange031thewidth isavaluemintherange132whichisencodedintheinstruction as 5bit value modulo 32 that is the value 32 is encoded as zero these parameter fields are saved in the implied register insert considering rt to contain the least significant 32 bits of the extraction source 32bit intermediate extraction value temp is generated as follows 1 if nm1 32 least significant word only the bits rtmn 1n are copied into tempm10 and the remaining bits of temp are set to zeroes 2 if nm1 31 straddle two words the bits rt31n are cop ied intotemp31n0 and the remaining bits of temp are set to zeroes thetempvalueisstoredinrdandalsosavedintheimpliedregis ter insertinstruction syntax and descriptionrevision 14 lexra proprietary confidential 49lx8380 section 4 instruction extensions insirdrs rt ioffset insert bits immediate xoffset insert4742 width insert4137 temp insert310 if xoffset32 if xoffsetwidth132 result310 temp310 else result31xoffset0 temp31xoffset0 resultwidth132xoffset rtxoffsetwidth330 if width32 result31width 32width 1b0 else resultwidth10 rtxoffsetwidth33xoffset32 result31width 32width 1b0 rdwidthioffset1ioffset resultwidth10 this instruction must be coded as the next sequential instruction intheprogramsequenceafteranexti iotherwiseitsresultsare unpredictable all exceptions are inhibited for the execution of this instruction thisincludeshardwareinterruptsdebugexceptionsandaddress exceptions the parameter fields m n and the intermediate extraction value temparetakenfromtheimpliedregisterinsertasdescribedfor extiitheinsertoffsetioffsetisavaluepintherange031con sideringrttocontainthemostsignificant32bitsoftheextraction source the final extracted value result is generated as follows 1 if nm1 32 the bits temp310 are copied into result310 2 if nm1 31 the bits temp31n0 are copied into result31 n0 the bits rtnm330 are copied into resultm132n the remaining bits of result are set to zeroes the bits from resultm10 are copied into rdmp1p the remaining bits of rd are copied from the corresponding bits of rs if mp is greater than 32 the results are unpredictableinstruction syntax and description50 lexra proprietary confidential revision 14section 4 instruction extensions lx8380 hash rd rs keysize hash to key rd hash rskeysize10 keysize the5bitkeysizeisavaluekintherange424ifkisoutsidethis rangetheresultsareunpredictablethe32 sourcebitscontained in rs are hashed to form key of k bits the key is stored in rdk 10 the remaining bits of rd are zeroed for given keysize each bit of the key is formed as the logical xorofasubsetofthe sourcebitsforanykeysizethesesubsets are mutually exclusive and exhaustive that is each source bit is included in the xor function of one and only one of the key bits thecompositionofthexorsubsetsforeachkeysizeisindicated in table18 hash instruction key bit definition msb rd rs rt most significant bit encode temp rs rt msb 33 repeat msb msb 1 until tempmsb1 msb0 rd316 0 rd50 msb the 32bit temp is computed as the logical and of rs with rt the6bitresultindicatesthemostsignificantbitthatissetin temp according to the following table where x means dont care temp 00000000 00000000 00000000 00000000 result 0 temp 00000000 00000000 00000000 00000001 result 1 temp 00000000 00000000 00000000 0000001x result 2 temp 00000000 00000000 00000000 000001xx result 3 etc temp 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx result 32 theresult is stored in rd50 the remaining bits of rd are zeroedinstruction syntax and descriptionrevision 14 lexra proprietary confidential 51lx8380 section 4 instruction extensions nomenclature rt rs rd r0 r31 notes for extiv specifying r0 for rs implies insert extract offsets of 0 and width of 32 insv insi must be coded as the next sequential instruction following extiv extii there is only one insert register in the processor not one per context which only exists to pass information from extivextii to insvinsi the processor inhibits exceptions for insvinsi to ensure that if the extivextii instruction completes the immediately subsequent insvinsi will also complete forextiitheextractoffsetmaynotbe32butstraddleisallowedduetoformatconstraintsthisshould not be problem since the immediate is known at compile time if an offset 32 were needed the next most significant register could be used for rt and the offset reduced by 32 theextivandinsvpairofinstructionsareintendedtoallownumerousnoncontiguousfieldsinapacket to be compacted into single contiguous key even if the alignment of the packet in set of registers is not known until run time sequence of 3 instructions per field can be used to accomplish this compaction in theexamplein figure5 packetdata isloaded into source registers s1s2ands3andfieldsf1andf2 are to be compacted into destination register d1 however it is not known until run time which of four byte alignmentcasesofthepacketisvalidatruntimer1isloadedwithavaluecorrespondingtothealignment specifically the value needed in bits 1510 of r1 is the twos complement of the alignment in bits single instruction ori r1 r0 n10 loads the proper value for any of the casesjor rs rt jump to offset register offset rs153 rt120 target3116 rs3116 target153 offset target20 3b000 pc target the 13bit jump offset is computed as the logical or of rt120 with rs153 the 32bit target address is computed as follows target3116 rs3116 target153 offset target20 zeroes the other bits of rt and rs are ignored the program unconditionally jumps to the target address with delayofoneinstructionjustlikethejrinstructionhandlingofthe delay slot instruction for exceptions is the same as for the jr instructioninstruction syntax and description52 lexra proprietary confidential revision 14section 4 instruction extensions lx8380 figure 5 packet field compaction with variable alignment the following code sequence assumes that r1 has been initialized as needed according to the case in question as shown common code path is used regardless of the alignment note that r0 is 0 source and dont care destination the above example shows how the packet alignment is handled with value held in single register placed in the appropriate bit position so that it can be subtracted from the otherwise fixed extraction offsets the widths and insertion offsets are invariant this paradigm works provided that two conditions are met 1 the variability in alignment never causes field to straddle different pairs of source registers sufficient condition is if the extracted field does not cross word boundary in the nominal case in other words the default extract offset is greater than 31 2 the insertion width and alignment never cause field to straddle word boundary in the destination key this problem can be minimized by reordering the fields in the destination key but in the worst case field to may be split into two parts to avoid the issue if necessary both of these restrictions can always be satisfied by splitting some source fields into two fields r1 contains the value to be subtracted from the 6bit default extraction offsets addiu r2 r1 f1_offe10 f1_wid5 f1_offi extiv r0 r2 s2 f1 is from s1 andor s2 insv d1 r0 s1 insert f1 into d1 addiu r2 r1 f2_offe10 f2_wid5 f2_offi extiv r0 r2 s3 f2 is from s2 andor s3 insv d1 d1 s2 merge f2 into d1 more fields handled the same ways1 s2 s3 f1 r1 0 r1 16 10 r1 24 10r1 8 10f2 f1 f2 f1 f2 f1 f2 f1f2d1revision 14 lexra proprietary confidential 53lx8380 section 4 instruction extensions table 18 hash instruction key bit deﬁnition keysize keybit source bits included in xor to form key bit 43 2 1 028 24 20 16 12 8 4 0 29 25 21 17 13 9 5 1 30 26 22 18 14 10 6 2 31 27 23 19 15 11 7 3 keysize keybit source bits keysize keybit source bits 54 3 2 1 026 25 16 9 3 0 28 24 20 12 8 4 29 21 17 13 5 1 30 22 18 14 10 6 2 31 27 23 19 15 11 765 4 3 2 1 026 24 18 10 9 1 25 19 16 11 3 0 28 20 12 8 4 29 21 17 13 5 30 22 14 6 2 31 27 23 15 7 76 5 4 3 2 1 025 16 9 1 26 24 18 10 19 11 3 0 28 20 12 8 4 29 21 17 13 5 30 22 14 6 2 31 27 23 15 787 6 5 4 3 2 1 024 16 8 0 25 17 9 1 26 18 10 2 27 19 11 3 28 20 12 4 29 21 13 5 30 22 14 6 31 23 15 7 keysize keybit source bits keysize keybit source bits keysize keybit source bits 98 7 6 5 4 3 2 1 026 16 9 24 8 0 25 17 1 18 10 2 27 19 11 3 28 20 12 4 29 21 13 5 30 22 14 6 31 23 15 7109 8 7 6 5 4 3 2 1 026 13 9 20 16 3 24 8 0 25 17 1 18 10 2 27 19 11 28 12 4 29 21 5 30 22 14 6 31 23 15 71110 9 8 7 6 5 4 3 2 1 030 7 26 13 9 20 16 3 24 8 0 25 17 1 18 10 2 27 19 11 28 12 4 29 21 5 22 14 6 31 23 15 1211 10 9 8 7 6 5 4 3 2 1 0 7 3 30 26 13 9 20 16 24 8 0 25 17 1 18 10 2 27 19 11 28 12 4 29 21 5 22 14 6 31 23 151312 11 10 9 8 7 6 5 4 3 2 1 020 13 7 3 30 26 25 9 16 0 24 8 17 1 18 10 2 27 19 11 28 12 4 29 21 5 22 14 6 31 23 151413 12 11 10 9 8 7 6 5 4 3 2 1 030 13 20 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 4 29 21 5 22 14 6 31 23 1554 lexra proprietary confidential revision 14section 4 instruction extensions lx8380 1514 13 12 11 10 9 8 7 6 5 4 3 2 1 029 13 30 4 20 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 14 6 31 23 151615 14 13 12 11 10 9 8 7 6 5 4 3 2 1 020 4 29 13 30 14 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 151716 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 4 20 29 13 30 14 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 15 1817 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 029 4 20 13 30 14 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 151918 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 014 29 4 20 13 30 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 152019 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 023 14 29 4 20 13 30 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 15 2120 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 3 23 14 29 4 20 13 30 7 19 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 152221 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 026 3 23 14 29 4 20 13 30 7 19 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 152322 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 9 26 3 23 14 29 4 20 13 30 7 19 10 25 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 15keysize keybit source bits keysize keybit source bits keysize keybit source bitsrevision 14 lexra proprietary confidential 55lx8380 section 4 instruction extensions 43 cross context access operations table19explainsthedetailsofinstructionsthatareusedtoaccessthegeneralregistersorthecontextcontrol registers of another context for the control registers it is also possible for thread to access its own cxstatus register the target context for all of these instructions is specified in new lexra coprocessor 0 register called movecx that register is itself accessed with mtlxc0 and mflxc0 variants of the mips standard mtc0 and mfc0 instructions these new instructions are used to access lexra defined coprocessor 0 registers that are not in the standard mips coprocessor 0 space the encoding of these instructions which use the cop0 major opcode is described in section45 it is expected that these instructions will only be used in kernel mode therefore they are all subject to the coprocessor unusable exception for coprocessor 0 as are the mtlxc0 and mflxc0 instructionskeysize keybit source bits 2423 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 016 9 26 3 23 14 29 4 20 13 30 7 19 10 25 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 1556 lexra proprietary confidential revision 14section 4 instruction extensions lx8380 table 19 cross context access instructions nomenclature notes execution of mtcxc rt cxpc with movecx current context attempt to change the currently executing contexts cxpc results in unpredictable operationinstruction syntax and description mfcxg rd gt move from context general register cntx movecx20 rd cntxgt bitsmovecx20areusedtodeterminethesourcecontext cntx thecontentsofgeneralregistergtincontext cntxareloadedinto the current contexts general register rd mtcxg rt gd move to context general register cntx movecx20 cntxgd rt bits movecx20 are used to determine the target context cntx the general register gd in context cntx is loaded from the tents of the current contexts general register rt mfcxc rd ct move from context control register cntx movecx20 rd cntxct bitsmovecx20areusedtodeterminethesourcecontext cntx thecontentsofcontrolregisterctincontext cntxareloadedinto the current contexts general register rd if mfcxc instruction that reads cxstatus of target text is executed as the ﬁrst instruction immediately following postcx to that context it is unpredictable whether mfcxc returns the new or old value of cxstatus mtcxc rt cd move to context control register cntx movecx20 cntxcd rt bits movecx20 are used to determine the target context cntx thecontrolregistercdincontext cntxisloadedfromthecontents of the current contexts general register rt rt rd gt gd r0 r31 cd ct cxstatus cxpcrevision 14 lexra proprietary confidential 57lx8380 section 4 instruction extensions to examine its own cxstatus register thread can execute this sequence 44 checksum addition table20 explains the instruction that may be used to calculate checksum for an internet protocol header using 16bit ones complement addition table 20 checksum addition instructions notes in ones complement arithmetic there are two representations of zero 0x0000 0 and 0x ffff0 addition of nonzero quantities can never result in 0 only 0 addition of 0 to either 0 or 0 results in 0 this instruction can be used to generate or check the 16bit checksum used in internet packets without regard to halfword alignment all of the 32bit words to be included are incrementally added using acs2 final 16bit shift and one more acs2 instruction is used to fold the checksum into 16 bitsmycx r1 mtlxc0 r1 movecx mfcxc r2 cxstatus instruction syntax and description acs2 rd rs rt dual add for checksum templo160 1b0 rs150 1b0 rt150 templo150 templo150 15h000 templo16 temphi160 1b0 rs3116 1b0 rt3116 temphi150 temphi150 15h000 temphi16 rd temphi150 templo150 dual 16bit ones complement addition considering all quantities as unsigned 16bit integers add the contents of rs1500 to rt1500 and independently add the contents of rs3116 to rt3116foreachindependentadditionifthereisacarryoutof the most significant bit of its result add one to that result to form its final result the final results of the two additions are placed in rd1500 and rd3116 r1 packetaddr get packet address lw r2 0r1 get many words lw r3 4r1 lw r4 8r1 lw r5 12r1 lw r6 16r1 lw r7 20r1 acs2 r2 r2 r3 add them together acs2 r2 r2 r4 acs2 r2 r2 r5 acs2 r2 r2 r6 acs2 r2 r2 r7 srl r3 r2 16 fold over accumulator acs2 r2 r2 r3 r2150 has the answer58 lexra proprietary confidential revision 14section 4 instruction extensions lx8380 45 lx8380 instruction summary table 21 instruction summary instruction description context control operations and data transfers mycx rd read my context postcx rs rt post event to context csw rs context switch ltw rt dispbase load twinword lwcsw rt dispbase load word uncached with context switch ltcsw rt dispbase load twinword uncached with context switch lqcsw rt dispbase load quadword uncached with context switch wdcsw rs rt devid write descriptor to device with context switch wdlwcsw rd rs rt devid write descriptor to device and load wordtwinwordquadword uncached with context switchwdltcsw rd rs rt devid wdlqcsw rd rs rt devid bit field operations seti rt rs width offset set subfield to ones clri rt rs width offset clear subfield to zeroes extiv rd rs rt extract subfield and prepare for insertion variable insv rd rs rt insert extracted subfield variable extii rd rt width offset extractsubfieldandprepareforinsertionimmediate insi rd rs rt offset insert extracted subfield variable immediate acs2 rd rs rt dual 16bit ones complement add for checksum hash rd rs keysize hash data to key msb rd rs rt find most significant bit jor rs rt jump to offset register crosscontext access operations mfcxg rd gt move from context gpr mtcxg rt gd move to context gpr mfcxc rd ct move from context control register mtcxc rt cd move to context control registerrevision 14 lexra proprietary confidential 59lx8380 section 5 coprocessor interface 5 coprocessor interface the lx8380 processor provides coprocessor interfaces cis for the attachment of applicationspecific coprocessors this section provides description of these access points 51 attaching coprocessor using the coprocessor interface ci acoprocessormaycontainupto32generalregistersandupto32controlregisterseachoftheseregistersis up to 32 bits wide typically programs use the general registers for loading and storing data on which the coprocessor operates data is moved to the coprocessors general registers from the processors general registerswiththemtczinstructiondataismovedfromthecoprocessorsgeneralregisterstotheprocessors general registers with the mfcz instruction main memory data is loaded into or stored from the coprocessors general registers with the lwcz and swcz instructions programs may load and store the coprocessors control registers from the processors general registers with the ctcz and cfcz instructions respectively programs may not load or store the control registers directly from main memory the coprocessor may also provide condition flag to the processor the condition flag is tested with the bczt and bczf instructions these instructions indicate that the program should branch if the condition is true bczt or false bczf 52 coprocessor interface ci signals the ci provides the mechanism to attach custom coprocessor to the processor the ci snoops the instruction bus for coprocessor instructions and then gives the coprocessor the signals necessary for reading or writing the general and control registers io is relative to the lx8380 ci table 22 coprocessor interface signals signal io description czcondin input branch ﬂag czrd_addr40 output read address czrd_cntx_20 output cop read context number czrhold output coprocessor must stall when asserted one czrd_gen output general register read command czrd_con output control register read command czrd_data310 input read data czwr_addr40 output write address czwr_cntx20 output cop write context number czwr_gen output general register write command60 lexra proprietary confidential revision 14section 5 coprocessor interface lx8380 in the above table z indicates user coprocessor number 1 or 2 the addresses output data and control signals are supplied to the applications coprocessor on the rising edge of the system clock 53 coprocessor write operations during coprocessor write the ci sends czwr_addr and czwr_data and asserts either czwr_gen or czwr_con the coprocessor write operations are subject to pipeline hold that is if either of the write control signals is asserted while czrhold is asserted the coprocessor must defer the write to the appropriate registeronthesubsequentrisingedgeoftheclockthetargetregisterisadecodingofczwr_addrczwr_gen and czwr_con the lwcz mtcz and ctcz instructions cause coprocessor write figure6 illustrates two coprocessor write operations the operation labeled does not encounter pipeline holdtheoperationlabeledbencountersapipelineholdthatlastsonecycletheczwr_cntx_w20output is not shown in the diagram the transitions on this signal correspond to transitions on czwr_addr_w20 figure 6 coprocessor write 54 coprocessor read operations during coprocessor read the ci sends czrd_addr and asserts either czrd_gen or czrd_con the coprocessor must return valid data through czrd_data in the following clock cycle if the processor asserts czrholdindicatingthatitisnotreadytoacceptthecoprocessordatathecoprocessormustholdtheprevious valueofczrd_datathetargetregisterforthereadisadecodingofczrd_addrczrd_genandczrd_conthe instructions causing coprocessor read are swcz mfcz and cfcz figure7 illustrates three coprocessor read operations the signal names beginning with cz_stage_ represent application specific signals in coprocessor design and are shown to illustrate the pipelining within coprocessor coprocessor designs that perform internal operations as result of read must include such stagesintheirreadlogictoallowforthecancellationofacoprocessorreadthatcouldarisefromanexception thatisencounteredduringanearlierinstructionthisispossibleforexampleifthecoprocessorimplements read fifo see figure8 and figure9 for examples of instruction cancellations in the example of figure7 coprocessor read operation encounters pipeline hold while in the stage operations b and c encounter pipeline hold while in the and w stages respectively although not shown in the diagram coprocessor operations can also be held while they are in the m stage theczwr_con output control register write command czwr_data310 output write data czinvld_m output one indicates invalid instruction in m stage czxcpn_m output exception ﬂag one indicates exception in m stagesignal io description clk czwr_cntx_w20 czwr_addr_w40 czwr_gen_w czwr_data_w310 czrholda b b b d0117revision 14 lexra proprietary confidential 61lx8380 section 5 coprocessor interface czrd_cntx_s20outputisnotshowninthediagramthetransitionsonthissignalcorrespondtotransitions on czrd_addr_s20 figure 7 coprocessor read the cpu stalls the pipeline so that the program can access data read by coprocessor instruction in the immediatelyfollowinginstructionforexampleifanmfczinstructionreadsdatafromthecoprocessorand stores it in the processors general register 4 the program can get access to that data in the following instruction whentheprocessorinitiatesacoprocessorreadthecoprocessormustreturnvaliddatainthefollowingclock cycle the coprocessor cannot stall the cpu applications must ensure that the source code does not access invalid coprocessor data if the coprocessor operations take several clock cycles to complete this is done in one of three ways ensure that software does not access data from the coprocessor until n instructions after the coprocessor operation has started this is the least desirable method as it depends on the relative execution of the processor and coprocessor it can also complicate software debug have the coprocessor send an interrupt to the processor and the service routine for that interrupt accesses the appropriate coprocessor registers have the coprocessor set the czcondin flag when its operation is complete the source code can poll the flag as shown in the example below 55 coprocessor interface and pipeline stages coprocessor writes occur in the w stage of the instruction pipeline for coprocessor reads the processormfc2 4 3 move from cop2 to cpu register 4 subu 5 4 2 subtract r2 from r4 and store in 5 mtc2 2 3 store data to cop2 general register 3 ctc2 3 5 set cop2 control register 5 to start nop loop bc2f loop branch back to loop if czcondin bit off nop branch delay slot mfc2 4 7 get results from cop2 general register 7clk czrd_cntx_s20 czrd_addr_s40 czrd_gen_s czrd_data_e310 cz_stage_a cz_stage_m cz_stage_w czrhold czxcpn_m czinvld_ma b c b c b c b c bc bc d011862 lexra proprietary confidential revision 14section 5 coprocessor interface lx8380 generatesaddressrd_genandrd_consignalsduringtheestageandthecoprocessorreturnsdataduringthe stage which is passed by the ci to the processor in the m stage the processor introduces two pipeline bubbles after coprocessor instructions to ensure that the result of mtcz instruction can be used by the immediately following instruction mtc2 i d s m w bubble 1 i d s m w bubble 2 i d s m w mfc2 i d s m w wr_gen w x rd_gen x rd_data x 551 pipeline holds the czwr_addr czwr_data czwr_gen and czwr_con signals need not be registered the coprocessor may decode these w stage signals directly to the appropriate register however the coprocessor must ignore the assertion of the write control signals when czrhold is asserted see figure6 thecoprocessormustregisterthereadaddressandthecontrolsignalsczrd_genandczrd_conitmusthold the stage registered values of these signals when czrhold is active high and should make the read data output function of the stage registered read address and control signals if the coprocessor includes additional internal stages that perform actions as result of read operation they must also be held by the czrhold signal see figure7 552 pipeline invalidation under certain circumstances the instruction pipeline can contain an instruction that must be discarded this may be due to mispredicted branches cache misses exceptions inserted pipeline bubbles etc in such cases the ci may decode an instruction that must actually be discarded forthecoprocessorwritetypeinstructionstheciwillonlyissuethewstagecontrolsignalsczwr_genand czwr_con for valid instructions the coprocessor does not need to qualify these controls for the coprocessor readtype instructions the ci may issue the stage control signals czrd_gen and czrd_conforinstructionsthatmustbediscardedifthecoprocessorcantoleratespeculativereadsthenitneed notqualifythosesignalshoweverifthecoprocessorperformsdestructivereadssuchasupdatingafifo pointer upon read then it must use the qualifying signals czxcpn_m and czinvld_m as follows when the czxcpn_m signal is asserted by the processor the coprocessor must discard any s and stage operationsevenifczrholdisalsoassertedthisczxcpn_msignalindicatesthatprecedinginstructioninthe mstageoftheprocessorpipelinehastakenanexceptionandthatsubsequentinstructionsinthepipelinemust bediscardedfigure8illustratestheoccurrenceofanexceptionwhileacoprocessorinstructionisatthese or stagesrevision 14 lexra proprietary confidential 63lx8380 section 5 coprocessor interface figure 8 exception during coprocessor read theprocessorassertsczinvld_msignaltoinvalidatetheinstructioninthemstageifthecoprocessorcannot tolerate speculative reads it must tentatively compute its and m stage results for any read operation if czinvld_m is asserted when the read operation is in the m stage including any period when czrohold is assertedthenthecoprocessormustdiscardthetentativeresultsifthereadoperationpassesadvancestothe w stage without the assertion of czinvld_m then the coprocessor must commit its temporary results an example of an invalidated read operation is shown in figure9 figure 9 invalidation of coprocessor readclk czrd_cntx_s20 czrd_addr_s40 czrd_gen_s czrd_data_e310 cz_stage_a10 cz_stage_m10 cz_stage_w10 czrhold czxcpn_m czinvld_ma b c b c b c c d0119 clk czrd_cntx_s20 czrd_addr_s40 czrd_gen_s czrd_data_e310 cz_stage_a cz_stage_m cz_stage_w czrhold czxcpn_m czinvld_ma d012064 lexra proprietary confidential revision 14section 5 coprocessor interface lx8380revision 14 lexra proprietary confidential 65lx8380 section 6 local memory 6 local memory 61 local memory overview thissectiondescribeshowmemoriesareconfiguredandconnectedtothelx8380usingthelocalmemory interfaces lmis this section provides brief summary of the conventions and supported memories section62 describes the control register that allows software control over certain aspects of the lmis the subsequent sections cover each of the lmis in detail this section also discusses configuration options and the ports that customers must access to connect application specific rams that are used by the lx8380 lmis all of the signals between the lmis and rams are automatically configured by lconfig the lx8380 configuration tool lconfigalso produces documentationoftheexactramsrequiredforthechosenconfigurationsettingsandgeneratesrammodels used for rtl simulation thelmisconnecttoramsthatservicethelx8380processorslocalinstructionanddatabussesthelmis alsoprovidethepathwaysfromtheprocessortothesystembusthelx8380includesanlmiforeachofthe local memory types the sizes of the rams are customer selectable the lx8380 lmis directly support synchronous rams that register the address write data and control signals at the ram inputs the lmis also supply redundant read enable and chip select lines for each ram which may be required for some ram types lexra supplies an integration layer for the lmis and the memory devices connected to them in this layer memory devices are instanced as generic modules satisfying the depth and width requirements for each specific memory instance the lconfigutility supplies summary of the memory devices required for the chosen configuration in most cases customers simply need to write wrapper that connects the generic module port list to technology specific ram instance inside the ram wrapper thelx8380isconfigurablefora163264or128bytecachelinesizethetagstoreramsizesshownin the tables of this section assume 32byte line size the documentation produced by lconfigindicates the required tag rams for the selected configuration options including the line size as general rule doubling of the line size results in halving the tag store depth thevalidbitswithintagstoresareautomaticallyclearedbythelmisuponresetthedatacacheimplements writethrough or writeback protocols selectable with lconfig caches do not snoop the system bus the lx8380 uses rams with byte write granularity for its data stores byte write granularity results in more efficient operation of store byte and store halfword instructions the lmis use physical addresses for all operations caches are physically indexed and store physical tags table23 summarizes the local memories that can be integrated with the lx838066 lexra proprietary confidential revision 14section 6 local memory lx8380 table 23 local memory interface modules 62 cache control register cctl cctl cp0 general register address 20 when reading this register the contents of the reserved bits are undefined when writing this register the contents of the reserved bits should be preserved the imemfill and imemoff bits of the cctl register control the contents and use of any local imem memory configured into the lx8380 when the lx8380 is reset the lmi clears an internal register to indicate that the entire imem lmi contents are invalid when imem is invalid all cacheable fetches from the imem region will be serviced by the instruction cache if an instruction cache is present transition from 0 to 1 on imemfill causes the lmi to initiate series of line read operations to fill the imemcontentstheaddressesusedforthesereadsaredefinedbytheconfiguredbaseandtopaddresses oftheimemdescribedinsection65theprocessorstallswhiletheentireimemcontentsarefilledbythe lmi thereafter the lmi sets its internal imem valid bit and will service any access to the imem range from the local imem memory the time that an imem fill takes to complete is the number of line reads needed to fill the imem range multiplied by the latency of one line read assuming there is other system bus traffic transition from 0 to 1 on imemoff causes the lmi to clear its internal imem valid bit subsequent cacheable fetches from the imem region will be serviced by the instruction cache to use the imem again an application must reinitialize the imem contents through the imemfill bit of the cctl register transition from 0 to 1 on dmemoff causes the dcache lmi to disable the dmem subsequent access in thedmemregionwillbeservicedbythedatacachecacheableaddressesorsystemmemoryuncacheable addresses to use the dmem after it has been disabled an software must cause transition from 0 to 1 on dmemon this will reenable the dmem the state of the dmem will be as it was when it was disabled the ilock field controls set locking in the twoway set associative instruction cache when ilock is 00 the instruction cache operates normally when ilock is 10 lockgather mode all cached instruction referencesareforcedtooccupyway1thehardwarewillinvalidatelinesinway0ifnecessarytoaccomplish thiswhenilockis11lockeddownmodelinesinway1areneverdisplacedietheyarelockedinthe cache way 0 is used to hold other lines as needed ilock 01 is reserved if this setting is used results are undefined toutilizethecachelockingfeaturesoftwareshouldexecuteatleastonepassofcriticalsubroutinesorloops withilocksetto10afterthishasbeendoneilockshouldbesetto11tolockthecriticalcodeintoway1name description icache direct mapped or twoway set associative instruction cache imem instruction ram dcache direct mapped or twoway set associative data cache dmem data ram 3112 11 10 9 8 76 5 4 32 1 0 rsrvd dmemoff dmemon dwbinval dwb rsrvd imemoff imemfill ilock iinval dinvalrevision 14 lexra proprietary confidential 67lx8380 section 6 local memory and use way 0 for other code the iinval bit controls hardware invalidation of the instruction cache transition from 0 to 1 on iinval initiates hardware invalidation sequence of the entire instruction cache thedinvaldwbanddwbinvalbitscontrolhardwareinvalidationofthedatacacheatransitionfrom0to 1ondinvalinitiatesahardwareinvalidationsequenceoftheentiredatacacheanydirtylinesarediscarded ie not written back to main memory transition from 0 to 1 on dwb initiates hardware sequence to writeback all dirty lines in the data cache leaving them in the clean state lines that are already clean or invalidhavenooperationperformedatransitionfrom0to1ondwbinvalinitiatesahardwaresequenceto writebackalldirtylinesinthedatacacheandtoinvalidatealllinesinthedatacacheregardlessoftheirinitial stateasimultaneouswithonemtc0instructiontransitionfrom0to1onmorethanoneofdinvaldwb or dwbinval leads to unpredictable results the dmem if present is unaffected data cache cctl operations the hardware invalidation sequence for the instruction and data caches requires up to four cycles per cache line to complete when dirty data must be written back to main memory the amount of time required is dependent on the state of the data cache and the performance of the system bus the lx8380 observes changes in the contents of the cctl register in the w stage instructions that are in progressinearlierstageswillnotbeaffectedbyaninstructioncacheordatacacheinvalidationorimemfill thismeansforexamplethatafterawritetocctlthatinvalidatestheinstructioncacheseveralinstructions that were fetched before the invalidation may be executed even if those instructions were invalidated from the instruction cache ifasmallnumberoflinesknownmustbeinvalidateditismoreefficientforsoftwaretoexecutethecache instruction to affect the state of specific cache lines this is described in the next section68 lexra proprietary confidential revision 14section 6 local memory lx8380 63 cache instruction the cache instruction allows software to affect the state of specific cache lines 64 instruction cache icache lmi the icache lmi supplies the interface for direct mapped or twoway set associative instruction cache attachedtothelx8380localbusthedegreeofassociativityisspecifiedthroughlconfigtheicachelmi participatesincacheableinstructionfetchesbutonlyiftheaddressisnotclaimedbytheimemmodulethe configurations supported by icache and the synchronous rams required for each are summarized in table24 theinstructionstoreforthetwowayicacheconsistsoftwo64bitwidebankswithseparatewriteenable controls the tag store consists of one ram bank with tag and valid bits for way 0 and second ram for way1thatholdsthetagvalidlruleastrecentlyusedandlockbitswhenamissoccursinthetwoway icachethelrubitisexaminedtodeterminewhichwayofthesettoreplacewithway0beingreplacedif lru is 0 and way 1 being replaced if lru is 1 the state of the lru bit is then inverted to optimize the timingofcachereadsthetwowayicacheusesthestateofthelrubittodeterminewhichwayshouldbecache op offsetrs cache operation performs data cache operation at address rs offset an address is computed as base offset wherebase is reg rs and theoffsetisthe16bitoffsetsignextendedto32bitstheaddressis translated using the smmu or the optional mmu as for lb instruc tion to form physical address the op is 5bit data cache opera tionifthelinecontainingthebytewiththespeciﬁedphysicaladdress isnotfoundinthedatacachethennocacheoperationisperformed regardless of the value of op otherwise the following operation is performed 10001 inval the line is invalidated 10101 wbinval the line is written back if dirty and invalidated regardless of state 11001 wb the line is written back if dirty and left in the clean state others reserved the operation is performed even if the address falls within the address range deﬁned for dmema if the mapped or unmapped address translation indicates that the address of the line found in the cache is uncacheable for example by using kseg1 address to access kseg0 line it is undeﬁned whether or not the operation speciﬁed by the instruction is per formed theexecutionofthecacheinstructionissubjectthesameaddress exceptions as the lb instruction and to coprocessor unusable exception under the same conditions as coprocessor instruction that accesses cp0 memory addresses within the dmem range might be held in the data cache if dmem has been disabled with the dmemoff bit in the cctl register this is possible even when dmem access is reenabled with the dmemon bitrevision 14 lexra proprietary confidential 69lx8380 section 6 local memory returned to the cpu in the following cycle theicache determines if the correct way was returnedif not the icache takes an extra cycle to return the correct element to the cpu and inverts the lru bit table 24 icache conﬁgurations table25liststheicachesignalsthatareconnectedtoapplicationspecificramstheic_prefixindicates signals that are driven by the icache lmi module and received by the rams the icr_ prefix indicates signalsthataredrivenbytheicacheramsandreceivedbytheicachelmilexrasuppliestheverilog module that makes all required connections to these wires the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from the table24 table 25 icache ram interfacesconﬁguration icache_inst ram icache_tag ram instruction cache ram required ram required 1k bytes 2way 2 x 64 x 64 bits 16 x 24 and 16 x 26 bits 2k bytes 2way 2 x 128 x 64 bits 32 x 23 and 32 x 25 bits 4k bytes 2way 2 x 256 x 64 bits 64 x 22 and 64 x 24 bits 8k bytes 2way 2 x 512 x 64 bits 128 x 21 and 128 x 23 bits 16k bytes 2way 2 x 1024 x 64 bits 256 x 20 and 256 x 22 bits 32k bytes 2way 2 x 2048 x 64 bits 512 x 19 and 512 x 21 bits 64k bytes 2way 2 x 4096 x 64 bits 1024x18and1024x20bits 1k bytes direct mapped 128 x 64 bits 32 x 23 bits 2k bytes direct mapped 256 x 64 bits 64 x 22 bits 4k bytes direct mapped 512 x 64 bits 128 x 21 bits 8k bytes direct mapped 1024 x 64 bits 256 x 20 bits 16k bytes direct mapped 2048 x 64 bits 512 x 19 bits 32k bytes direct mapped 4096 x 64 bits 1024 x 18 bits 64k bytes direct mapped 8192 x 64 bits 2048 x 17 bits signal description ic_tagindex tag and state ram address line icr_tagrd0 tag and state ram element 0 read path ic_tagwr0 tag and state ram element 0 write path icr_tagrd1 tag and state ram element 1 read path ic_tagwr1 tag and state ram element 1 write path ic_tag0wen tag 0 ram write enable ic_tag0ren tag 0 ram read enable ic_tag0csn tag 0 ram chip select70 lexra proprietary confidential revision 14section 6 local memory lx8380 note n designates an available activelow version of signal 65 instruction memory imem lmi theimemlmisuppliestheinterfaceforanoptionallocalinstructionstoretheimemservesafixedrange of the physical address space determined by configuration settings in lconfig the imem contents are filled and invalidated under the control of the cp0 cctl register described in section62 cache control register cctl the imem module services instruction fetches that falls within its configured range the imemisaconvenientlowcostalternativetoacachethatmakesinstructionmemoryavailabletothecorefor highspeed access the configurations supported by imem and the synchronous rams required for each are summarized in table26 table 26 imem conﬁgurationsic_tag1wen tag 1 ram write enable ic_tag1ren tag 1 ram read enable ic_tag1csn tag 1 ram chip select ic_instindex instruction ram address word icr_inst0rd instruction ram element 0 read path icr_inst1rd instruction ram element 1 read path ic_instwr instruction ram write path to both ways ic_inst0wen10 instruction ram 0 write enable ic_inst0ren instruction ram 0 read enable ic_inst0csn instruction ram 0 chip select ic_inst1wen10 instruction ram 1 write enable ic_inst1ren instruction ram 1 read enable ic_inst1csn instruction ram 1 chip select conﬁguration imem_inst ram local instruction ram ram required 1k bytes 128 x 64 bits 2k bytes 256 x 64 bits 4k bytes 512 x 64 bits 8k bytes 1024 x 64 bits 16k bytes 2048 x 64 bits 32k bytes 4096 x 64 bitssignal descriptionrevision 14 lexra proprietary confidential 71lx8380 section 6 local memory table27 lists the imem signals that are connected to application specific rams the iw_prefix indicates signalsthataredrivenbytheimemlmimoduleandreceivedbyramsthe iwr_prefixindicatessignals thataredrivenbyramsandreceivedbytheimemlmithe cfg_prefixidentifiesconfigurationportson the imem lmi that are typically wired to constant values the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table26 thecfg_wires define where the imem is mapped into the physical address space this configuration informationdefinesthelocalbusaddressregionoftheimemitalsodeterminesthemainmemorylocations thatareaccessedbythelx8380whenanimemfilloperationisstartedbyupdatingtheimemfillbitofthe cp0 cctl register the lconfigutility supplied by lexra will verify that the configured address range does notinterferewithotherregionsdefinedforlx8380thesizeofthememoryregionmustbeapoweroftwo and must be naturally aligned table 27 imem ram interfaces note n designates an available activelow version of signal 66 data cache dcache lmi thedcachelmisuppliestheinterfaceforadatacacheattachedtothelx8380localbusthedatacache is rtl configurable for direct mapped or twoway set associativity and writeback or writethrough operation the data cache participates in cacheable data reads and writes but only if the address is not claimed by the dmem lmi the configurations supported by the data cache and the synchronous rams required for each are summarized in table28 see sectiond4 loadstore rules for detailed descriptions of pipeline stalls that the data cache may cause writes that miss the cache or writes that are performed in writethrough mode may require extra time to be serviced by the lbc if its write buffer is full64k bytes 8192 x 64 bits 128k bytes 16384 x 64 bits 256k bytes 32768 x 64 bits signal description iw_instindex imem index iwr_instrd instruction read data iw_instwr instruction write data iw_instwen10 instruction ram write enable iw_instren instruction ram read enable iw_instcsn instruction ram chip select cfg_iwbase3110 conﬁgured base address modulo 1k bytes cfg_iwtop1710 conﬁgured top address bits that may differ from baseconﬁguration imem_inst ram72 lexra proprietary confidential revision 14section 6 local memory lx8380 table 28 dcache conﬁgurations table29 lists the dcache signals that are connected to application specific rams the dc_ prefix indicatessignalsthataredrivenbythedcachelmimoduleandreceivedbytheramsthedcr_prefix indicatessignalsthataredrivenbythedcacheramsandreceivedbythedcachelmilexrasupplies the verilog module that makes all required connections to these wires the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table28 table 29 dcache ram interfacesconﬁguration dcache_data ram dcache_tag ram data cache ram required ram required 1k bytes 2way 2 x 64 x 64 bits 16 x 24 and 16 x 26 bits 2k bytes 2way 2 x 128 x 64 bits 32 x 23 and 32 x 25 bits 4k bytes 2way 2 x 256 x 64 bits 64 x 22 and 64 x 24 bits 8k bytes 2way 2 x 512 x 64 bits 128 x 21 and 128 x 23 bits 16k bytes 2way 2 x 1024 x 64 bits 256 x 20 and 256 x 22 bits 32k bytes 2way 2 x 2048 x 64 bits 512 x 19 and 512 x 21 bits 64k bytes 2way 2 x 4096 x 64 bits 1024 x 18 and 1024 x 20 bits 1k bytes direct mapped 128 x 64 bits 32 x 23 bits 2k bytes direct mapped 256 x 64 bits 64 x 22 bits 4k bytes direct mapped 512 x 64 bits 128 x 21 bits 8k bytes direct mapped 1024 x 64 bits 256 x 20 bits 16k bytes direct mapped 2048 x 64 bits 512 x 19 bits 32k bytes direct mapped 4096 x 64 bits 1024 x 18 bits 64k bytes direct mapped 8192 x 64 bits 2048 x 17 bits signal description dc_tagindex tag and state ram address dcr_tagrd tag and state ram read path dc_tagwr tag and state ram write path dc_tagwen tag and state ram write enable dc_tagren tag and state ram read enable dc_tagcsn tag and state ram chip select dc_dataindex data ram address word dcr_datard data ram read path dc_datawr data ram write pathrevision 14 lexra proprietary confidential 73lx8380 section 6 local memory note n designates an available activelow version of signal when configured for writeback operation the data cache tag ram includes bit to indicate that line is dirtyeachcachelineiscoveredbyasingledirtybitwhichwhensetindicatesthattheprocessorhasmodified the line in the cache but has not updated main memory when line is filled from system memory the dirty bit is cleared if write hits in the cache and the dirty bit is not set clean line the data cache ram is updated with the write data and the dirty bit is set to one if the line is already dirty when write hits in the cachethedatacacheramisupdatedwiththewritedataandthedirtybitremainssetanycachedwritethat hits the writeback data cache updates the cache only and does not cause any system bus activity whenconfiguredasawritebackcachethedatacachelmialsoincludesanevictbufferinthecaseofaread miss to dirty line the data cache first issues line read operation to fetch the new line if the line currently stored in the cache is dirty the line is copied from the data cache ram to the evict buffer when the current line has been completely copied into the evict buffer the new line is loaded into the data cache ram as soonastheevictbufferisfullthedatacacheissuesalinewriteoperationtheprocessordoesnotstallwhile the line is being written unless the processor causes the data cache to issue another system bus operation before the line write operation is complete cachelinesareonlyallocatedonreadmissesnotwritesifawritemissesinthecacheitwillbeissuedasa single write on the bus and line will be evicted or filled this is the same for both writeback and write through caches the replacement policy for the 2way setassociative configuration is lru least recently used table30 shows the data cache and system bus activity based on the current operation the state of the line currently stored at the cache location and the outcome of the tag compare the table includes some unusual cases such as uncached operation hitting the data cache such conditions are possible because the same physical address can be accessed in both cacheable or uncacheable modes either through kseg0kseg1 addressaliasorthroughmappingsthatareineffectwiththeoptionalmmuthedatacachecontrollertreats these cases in conservative fashion to ensure coherency between the data cache and main memorydc_datawen10 data ram write enable dc_dataren data ram read enable dc_datacsn data ram chip selectsignal description74 lexra proprietary confidential revision 14section 6 local memory lx8380 table 30data cache operations and results operation stateofline currently stored in cachetag compare result actionnew cache state cmdcached uncachedwritethrough writeback read cached x invalid x issue line fill clean x clean hit read from cache clean x clean miss invalidate and issue line fillclean x dirty hit read from cache dirty x dirty miss evictlineandissueline fillclean uncached x invalid x read from system bus invalid x clean hit invalidate and read from system businvalid x clean miss read from system bus clean x dirty hit evictlineandreadfrom system businvalid x dirty miss read from system bus dirty write cached x invalid x write to system bus invalid writeback clean hit write to cache only dirty writethrough clean hit write to cache and system busclean x clean miss write to system bus clean writeback dirty hit write to cache only dirty writethrough dirty hit write to cache and system busdirty x dirty miss write to system bus dirty uncached x invalid x write to system bus invalid x clean hit invalidate and write to system businvalid x clean miss write to system bus clean x dirty hit evict line and write to system businvalid x dirty miss write to system bus dirty x dont carerevision 14 lexra proprietary confidential 75lx8380 section 6 local memory 67 scratch pad data memory dmem lmi the dmem lmi supplies the interface for scratch pad data ram attached to the lx8380 local bus the dmem module services any cacheable or uncacheable data read or write operation that falls within its configured range dmemcanperformreadsorwritesthathitdmemattherateofonepercycleseesectiond4 loadstore rules for detailed descriptions of pipeline stall conditions that may be caused by dmem because write operation to the dmem is never sent to the system bus writes to dmem will not cause processor stalls because of pending system bus activity lx8380 applications may optionally specify the use of 128bit data memory width through an lconfig setting when ram bist or scan collars are enabled with lconfig lx8380 does nottie the dmem ram into the ram bist paths or scan collar muxes other rams remain connected to these options the dmem configurations and the synchronous rams required for each are summarized in the table31 for lx8000 dualport ram may optionally be used for dmem the second port is brought out the processor hierarchy for customer connection table 31dmem conﬁgurations table32liststhedmemsignalsthatareconnectedtoapplicationspecificramsthe dw_prefixindicates signals that are driven by the dmem lmi module and received by rams the dwr_prefix indicates signalsthataredrivenbyramsandreceivedbythedmemlmithe cfg_prefixidentifiesconfiguration ports on the dmem lmi that are typically wired to constant values the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table31 thecfg_wires define where dmem is mapped into the physical address space it is not possible for any dmemreferencetoresultinanoperationonthesystembusthe lconfigutilitysuppliedbylexrawillverify that the configured address range does not interfere with other regions defined for lx8380 the size of the memory region must be power of two and must be naturally alignedconﬁguration dmem_data ram 64bit dmem_data ram 128bit local data memory ram required ram required 1k bytes dual port 128 x 64 bits dual port 64 x 128 bits 2k bytes dual port 256 x 64 bits dual port 128 x 128 bits 4k bytes dual port 512 x 64 bits dual port 256 x 128 bits 8k bytes dual port 1024 x 64 bits dual port 512 x 128 bits 16k bytes dual port 2048 x 64 bits dual port 1024 x 128 bits 32k bytes dual port 4096 x 64 bits dual port 2048 x 128 bits 64k bytes dual port 8192 x 64 bits dual port 4096 x 128 bits 128k bytes dual port 16384 x 64 bits dual port 8192 x 128 bits 256k bytes dual port 32768 x 64 bits dual port 16384 x 128 bits76 lexra proprietary confidential revision 14section 6 local memory lx8380 table 32dmem ram interfaces note n designates an available activelow version of signalsignal description dw_dataindex decoded data ram index dwr_datard data ram read data dw_datawr data ram write data dw_datawen data ram write enable dw_dataren data ram read enable dw_datacsn data ram chip select cfg_dwbase3110 conﬁgured base address modulo 1k bytes cfg_dwtop1710 conﬁgured top address bits that may differ from base dmadw_rclk data ram dual port dma clock optional dmadw_dataindex decoded data ram index dmadw_datard data ram dual port dma read data dmadw_datawr data ram dual port dma write data dmadw_datawen data ram dual port dma write enable dmadw_dataren data ram dual port dma read enable dmadw_datacsn data ram dual port dma chip selectrevision 14 lexra proprietary confidential 77lx8380 section 7 cbus interface 7 cbus interface this section describes the cbus system interface to the lx8380 that is an alternative to the lbus the cbus interface cbi provides simple signalling layer between the lx8380 processors cache controllers and the optional lx8380 system bus interface the lbc see section8 for information on the lbc and lbus lx8380 applications that connect to bus protocol other than lbus may eliminate the lbc and provide their own system bus interfaces or devices that connect directly to the lx8380 using cbus 71 system interface conﬁguration figure10illustratesthelx8380sorganizationforthedifferentsysteminterfaceconfigurationsthissection describes the configuration shown is part b of the figure figure 10 lx8380 system interface configurationslbuscbus_ylbcicache dcache ejtag lx8380 configured with lbus interface cbus_ycbus interface cbi b lx8380 configured with cbus interfacelx8380 processor application logic lx8380 processor application logiccbus interface cbi bmc icache dcache ejtag bmc78 lexra proprietary confidential revision 14section 7 cbus interface lx8380 72 cbus interface write buffer and outoforder processing the cbus interface contains write buffer with depth that is configurable with lconfig all write requests and split read requests from the cpu are posted in the write buffer the cpu will not wait for the write to complete write operations complete in the order they are entered into the buffer if the buffer is full and the data cache generates another write operation to the cbus interface then the cpu is stalled until an entry becomes available lx8380 applications that employ lbus instead of cbus still use the cbi write buffer when the cpu issues nonsplit read operation the cbi will attempt to forward that request to the lexra bus ahead of any pending write operations this significantly improves performance since the cpu must wait for the read operation to complete there are few cases when the cbi will not allow the read operation to pass pending writes 1 theaddressofapendingwriteiswithinthesamecachelineasadatacacheorbmcreadthe cbi will hold the read operation until the matching write operation and all write operations aheadofitcompleteifthereadisforaninstructionfetchitcanstillpassapendingwritethat is inside the same cache line 2 adatacacheorbmcreadistouncacheableaddressspaceallwritescompletebeforetheread is issued this avoids any problems with io devices and their associated controlstatus regis ters 3 pending write is to uncachable address space the cbi holds the read operation until all writesuptoandincludingthewritetouncacheableaddressspacecompletethisfurtheravoids io device problems the write buffer bypass feature can be disabled via lconfig so that reads never pass writes 73 cbus line read interleave order thelinereadoperationreadsasequenceofdatabeatsfrommemorycorrespondingtothesizeofacacheline the cache line size affects how many cycles are required to transfer the entire line the lx8380 supports configurable line size specified through lconfig line size of eight words 32 bytes is assumed here the cbus target may transfer the read data starting with word zero first or starting with the desired word first with word zero first operation the target transfers four 64bit beats of data in sequence starting at the nearest 32bytealigned address smaller or equal to the address that the initiator drives in other words the targetstartsthetransferatthebeginningofthelinecontainingtherequestedaddresswithdesiredwordfirst operationthefirstdatabeatreturnedbythetargetisthebeatcorrespondingtotheaddressinsteadoftheword zero of the line the second beat is the next sequential data beat and so on at the end of the line the target wraps around and returns the first beat of line all devices attached to the cbus must consistently return word zero first or the desired word first the lx8380 is configurable to work with either mode the lx8380 supports two ways of incrementing the address of line fill one is by linear wrap where the addressissimplyincrementedbyonetheotherisby interleavedwrap wherethenextaddressisdetermined bythelogicalxorofthecyclecountandthefirstwordaddresstheinterleavesequenceisshownintable33 theloworderaddressbits43forthefirstdatabeataretheobtainedfromtheaddressofthelinereadrequest the loworder address bits for the subsequent data indicate the corresponding interleave order all devices attachedtothecbusmustconsistentlysupportlinearwraporinterleavedwrapthelx8380isconfigurable to work with either moderevision 14 lexra proprietary confidential 79lx8380 section 7 cbus interface table 33 line read interleave order 74 cbus byte alignment cbusdatamustbedriventothebytelanesaccordingtotherulesshownintable34alignmentsnotshown are not generated by the cpu all multibeat operations transfer multiple twin word beats over cbus table 34 cbus byte lane assignmentinterleaved address43 1st data beat 00 01 10 11 2nd data beat 01 00 11 10 3rd data beat 10 11 00 01 4th data beat 11 10 01 00 cbus bus data byte lanes used transfer sizeaddr20 6356 5548 4740 3932 3124 2316 158 70 byte 000 x byte 001 x byte 010 x byte 011 x byte 100 x byte 101 x byte 110 x byte 111 x half word 000 x x half word 010 x x half word 100 x x half word 110 xx word 000 x x x x word 100 x x x x twin word 000 x x x x x x x x80 lexra proprietary confidential revision 14section 7 cbus interface lx8380 75 cbus interface signal list table35 summarizes the lx8380s cbus signals table 35 cbus signal list name io function cbus_yreqo 0 request 1 processor is initiating request cbus_yaddro310 address cbus_yreado 1read 0write cbus_yszo30 transfer size 4b1000 1 byte 4b1001 2 bytes 4b1011 1 word 4b1100 2 words 4b0000 4 words this signal is dont care when cbus_ylineo is asserted cbus_ylineo 1 line access 0 single access cbus_ydatao630 write data cbus_ysplto 1split 0normal transaction cbus_yltido30 local thread id cbus_yuco 1 uncached access 0 cached access cbus_ysrco30 transaction source within lx8380 4b0001 instruction cache 4b0010 data cache or ejtag dma write 4b0100 ejtag dma read 4b1000 bmc cbus_ydbusyo 1 lx8380 is not ready to receive data any return with cbus_yvaltypeiofdata4b0010isignoredbythelx8380 external logic must hold such data until cbus_ydbusyo is deasserted 0 lx8380 is ready to receive data cbus_ybusyi i 1 external logic cannot accept request the current cbus_y request if any is ignored by external logic 0 external logic is ready to accept request cbus_ydatai630 i read data cbus_yltidi30 i thread associated with read datarevision 14 lexra proprietary confidential 81lx8380 section 7 cbus interface 76 cbus transaction types the following transaction types are supported by the cbus interface 1 single splitnormal read 2 line splitnormal read 3 single write with split read 4 single write 5 line writes 77 cbus protocol the transaction request protocol is controlled with cbus_yreqo output and cbus_ybusyi input 1 the cbus_yreqo output is asserted by the lx8380 to initiate an access to external logic additional cbus_y outputs are driven by the lx8380 to provide the transaction details 2 cbus_yreqo remains asserted until the cbus_ybusyi is not asserted by external logic for write transaction the transaction is completed after step 2 for read transaction additional steps control the return of read data by the external logic using the cbus_yvaltypei30 input and the cbus_ydbusyo output 1 if cbus_yvaltypei indicates instruction cache bmc or ejtag dma data is present on cbus_ydatai the data is always accepted by the lx8380 2 if cbus_yvaltypei indicates that data cache data is present on cbus_ydatai and cbus_ydbusyoisassertedtheexternallogicmustcontinuetodrivecbus_yvaltypei and cbus_ydatai until cbus_ydbusyo deasserts 78 cbus transaction timing diagrams noteallofthefollowingtimingdiagramsassumealinesizeof8wordsforreadsthetransactionrequestis shown in different timing diagram than the returning read data as there is protocol link between the twocbus_yvaltypei30 i indicates valid read data of certain type 4b0000 valid read data 4b0001 instruction cache 4b0010 data cache 4b0100 ejtag dma 4b1000 bmc cbus_yspltszi20 i size of split read data beat 3b000 1 byte 3b001 2 bytes 3b011 1 word 3b100 2 words cbus_yidlei i indicates external cbus_y device is in an idle state ie has pending read or write transactionsname io function82 lexra proprietary confidential revision 14section 7 cbus interface lx8380 781 backtoback single writes with busy in cycle 1 the write to address is accepted by the external logic in cycle 2 the external logic asserts cbus_ybusyi which causes the lx8380 to hold its request in cycle 3 the external logic deasserts cbus_ybusyi and accepts the request in this example cycle 4 could be used by the processor to initiate another request figure 11 cbus backtoback single writes with busy 782 line writes during line write the address is given in cycle 1 external logic signals that it is able to accept line write request by deasserting cbus_ybusyi external logic does not honor line write request when cbus_ybusyi is assertedclk cbus_yreqo cbus_ybusyi cbus_yaddro310 cbus_ydatao630 cbus_ysrco30 cbus_ylineo cbus_yszo30 cbus_yreado cbus_ysplto cbus_yltido30 cbus_yucoa b b b b d00631234 clk cbus_yreqo cbus_ybusyi cbus_yaddro310 cbus_ydatao630 cbus_ysrco30 cbus_ylineo cbus_yszo30 cbus_yreado cbus_ysplto cbus_yltido30 cbus_yucoa a1 a2 a3 a4 d006412345revision 14 lexra proprietary confidential 83lx8380 section 7 cbus interface figure 12 cbus line write 783 backtoback single read requests with busy only the read request is shown here the return data is not shown figure 13 cbus backtoback single read requests with busy 784 line read request line read request takes only one cycle with the data being returned later by the external logic figure 14 cbus line read requestclk cbus_yreqo cbus_ybusyi cbus_yaddro310 cbus_ydatao630 cbus_ysrco30 cbus_ylineo cbus_yszo30 cbus_yreado cbus_ysplto cbus_yltido30 cbus_yucoa b b b d00651234 clk cbus_yreqo cbus_ybusyi cbus_yaddro310 cbus_ydatao630 cbus_ysrco30 cbus_ylineo cbus_yszo30 cbus_yreado cbus_ysplto cbus_yltido30 cbus_yucoa d00661284 lexra proprietary confidential revision 14section 7 cbus interface lx8380 785 split read request thelx8380alwaysissuesasplitdatareadrequestwhenanlwcsworltcsworlqcswinstructionis executedandmayalsobeconfiguredvia lconfigtoissuesplitreadsforallreadoperationsthelx8380may initiate new transaction in the following cycle the processor may have multiple split transaction reads outstanding as defined in table36 table 36 maximum number of outstanding split reads to initiate split read transaction the processor asserts cbus_ysplto cbus_yreqo and cbus_yreado this can occur for word twinword quadword and line reads the cbus_yltido30 output indicates the processor context number or bmc channel number associated with the request the devicethatservicesthesplitreadrequestisresponsibleforretainingthecontextnumberwhileitperformsthe read operation and resourcing the context number when the read data is finally returned figure 15 cbus split read requests 786 write with split read request theprocessorissuesawritewithsplitdatareadrequestwhenawritedescriptorwithsplitloadinstruction wdlwcsw wdltcsw or wdlqcsw is executed this transaction supplies the write data and initiatesthereadrequestinasinglecycletheprocessormayinitiateanewtransactioninthefollowingcycle the limitations on outstanding split data reads defined in table36 apply to the outstanding read transactions that are generated in this waysplit read source cbus_ysrco30 maximum reads outstanding instruction 4b0001 one data read 4b0010 one per processor context ejtag dma read 4b0100 one bmc read 4b1000 limited only by the assertion of the cbus_ybusyi input clk cbus_yreqo cbus_ybusyi cbus_yaddro310 cbus_ydatao630 cbus_ysrco30 cbus_ylineo cbus_yszo30 cbus_yreado cbus_ysplto cbus_yltido30 cbus_yucoa b b b d012112revision 14 lexra proprietary confidential 85lx8380 section 7 cbus interface to initiate write with split read transaction the processor asserts cbus_ysplto and cbus_yreqo and deasserts cbus_yreado this can only occur for word twinword and quadword reads the cbus_yszo30 output indicates the size of the read request the write data size is always twinword the cbus_yltido30 output indicates the processor context number or bmc channel number associated with the request the device that services the split read request is responsible for retaining the contextnumberwhileitperformsthereadoperationandresourcingthecontextnumberwhenthereaddata is finally returned figure 16 cbus write with split read request 787 returning read data external logic supplies read data on the cbus_ydatai and cbus_yltidi inputs while asserting bit withincbus_yvaltypeiifcbus_yvaltypeiindicatesdata4b0010thelx8380onlyacceptsthe readdataifithasdeassertedcbus_ydbusyoifcbus_ydbusyoisassertedtheexternallogicmust maintain cbus_yvaltypei and cbus_ydatai until cbus_ydbusyo is deasserted if the read data is in response to split read request the external logic must also drive cbus_yspltszi to indicate the size of the data beat figure 17 cbus read data and dbusy read line data return is illustrated below the external device asserts the appropriate bit of cbus_yvaltypei for each data beat assertion of cbus_ydbusyo is also illustratedclk cbus_yreqo cbus_ybusyi cbus_yaddro310 cbus_ydatao630 cbus_ysrco30 cbus_ylineo cbus_yszo30 cbus_yreado cbus_ysplto cbus_yltido30 cbus_yucoa d01221 clk cbus_ydbusyo cbus_yvaltypei30 cbus_ydatai630 cbus_yltidi30 cbus_yspltszi2000000000 0100 b 0100 c 0010 0000 b c b c b c d0123123 4 5686 lexra proprietary confidential revision 14section 7 cbus interface lx8380 if the line read data is in response to split read request then each data beat is twinword and the external logic must therefore drive cbus_yspltszi to 3b100 figure 18 read data for line read request 788 latency of cbus transactions figure19illustrateshowthelatencyofacbusreadtransactionaffects thedurationofcpu stallswhilethe cpu waits for the read data to be returned but note the cpu is typically not stalled during split read transactions that are issued as result of the lcsw or wdlcsw instructions figure 19 latency of cbus transactions the overall latency encountered for any cbus transaction depends more on system level behavior and less onthebehaviorofthecbusinterfaceitselfinthisexamplethecbusinterfaceissynchronouslyconnected to fullspeed lbus via an lbc and the lbc is assumed to be parked on the lbus thus the read transactionappearsonlbusonecycleafterthecbusrequestisinitiatedsomenumberofcycleswillpass as the addressed lbus target prepares its data response the lbus target then supplies the data beats coincident with the assertion of trdy the lbc requires only one cycle to pass the first data beat from the lbus to the cbus at which time cbus_yvaltype contains the code 5b00010 to indicate the data responsethecbusinterfaceinturnrequiresonlyonecycletopassthedatatothecpuandreleasethestall condition from this example it is seen that only three stall cycles can be attributed to the cbus interface if synchronous fullspeed lbus is employed for the system bus the lbc and lbus protocol will result in minimum of three additional stalls the addressed lbus target may also insert additional stallsclk cbus_ydbusyo cbus_yvaltypei30 cbus_ydatai630 cbus_yltidi30 cbus_yspltszi2000000000 0010 0000 a0 a1 a2 a3 3b100 d0124123 4 56 clk stall cbus_yreqo lbus_frame lbus_trdy cbus_yvaltypei30 4b00004b0000 4b0010 4b0000d0081revision 14 lexra proprietary confidential 87lx8380 section 8 lexra system bus lbus 8 lexra system bus lbus this section describes the optional lexra system bus lbus and the lexra bus controller lbc that connectsthelx8380tolbusthelbusprovidesaflexiblepcilikeprotocolappropriateforsystemswith multiplemastersandtargetsapplicationswhichdonotrequireasuchasystembusorwhichincludecustom interfacestoothersystembusesmayoptionallyemploythelx8380scbusinterfaceratherthanthelbus see section7 cbus interface 81 connecting the lx8380 to internal devices the lexra bus controller lbc provides the connection between the lx8380 cbus interface cbi and the lexra system bus lbus the lbus supports applicationspecific system bus devices such as main memory usb or ieee1394 firewire the lbc uses protocol similar to that of the peripheral component interface pci bus this is wellknown and proven architecture adding new devices to the lexra bus is straightforward and the performance approaches the highest that can be achieved without adding great deal of complexity to the protocol figure 20 lexra system bus lbus diagram thelexrabussupportsmultiplemastersthisallowsformasteringiocontrollerswithdmaenginestobe connected to the bus the bus has pended architecture in which master holds the bus until all the data is transferred this simplifies the design of usersupplied bus agents and reduces latency for cache miss servicing thelexrabusisasynchronousbussignalsareregisteredandsampledatthepositiveedgeofthebusclock certain logical operations may be made to the sampled signals and then new signals can be driven immediately such as for address decoding this allows samecycle turnaround the lbc supports synchronous modes with the lbus operating at full cpu speed or half cpu speed and an asynchronous mode that allows the lbus to be clocked at any speed independent of the cpu speed thelexrabusdatapathforthelx8380is64bitswidethereforethebuscantransfertwowordsoneword halfword or byte in one bus clock the bus supports line and burst transfers in which several beats 64 bits of data are transferred the lexra bus accomplishes this by transferring data beats in successive clocklexra bus controller lbcbus bridge usb firewirelbusexternal bu s eg pci cbus interface cbibuses to lmis cbusmemoryapplicationspecific modules lx8380 modules88 lexra proprietary confidential revision 14section 8 lexra system bus lbus lx8380 cycles the lbc provides enabling signals to control applicationspecific muxes or tristate buffers this allows the lbus to have either bidirectional or pointtopoint topology 82 terminology thelexrabusborrowsterminologyfromthepcibusspecificationonwhichthelexrabusispartiallybased bus transactions take place between two bus agents one bus agent requests the bus and initiates transfer the second responds to the transfer theagentinitiatingatransferiscalledthe businitiator itisalsoreferredtoasthe busmaster bothtermsare used interchangeably in this document therespondingagentisknownasthebus targetitsamplestheaddresswhenitisvalidanddeterminesifthe address is within the domain of the device if so it indicates such to the initiator and becomes the target aread transfer is bus operation whereby the master requests data from the target awrite transfer is bus operation whereby the master requests to send data to the target asingle data bus operation is used to transfer two words one word halfword or byte of data the data can be transferred in one bus cycle not including the address cycle and device latencies aline transfer is read or write operation where an entire cache line of data is transferred in successive cycles as fast as the initiator and target can sendreceive the data aburst transfer is read or write operation where large amount of data needs to be sent the initiator presents starting address and data is transferred starting at that address in successive cycles for each word transferred the address is incremented by the devices internally abeat is the data up to 64 bits that is transferred in one data cycle aword is 32 bits of data deviceasserts signal when it drives it to its logical true electrical state 83 bus operations the purpose of the lexra bus is to connect together the various components of the system including the lx8380 cpu main system memory io devices and external bus bridges different devices have different transfer requirements for example the lx8380 cpu will request the bus to fetch cache line of data from memory io devices will request large blocks of data to be sent to and from memory lbus supports the various types of transfers needed by both io and the processor single data read line read burst read single data write line write burst write split read write split read split datarevision 14 lexra proprietary confidential 89lx8380 section 8 lexra system bus lbus 831 single data read the single data read operation reads twinword single word halfword or byte from the target device this operationisusuallyusedbythecputoreaddatafromuncachableaddressspaceifthereadaddresswasin cacheableaddressspaceeitherahitwouldoccurresultinginnobusactivityoramisswouldoccurresulting in read line transaction 832 line read thelinereadoperationreadsasequenceofdatabeatsfrommemorycorrespondingtothesizeofacacheline the cache line size affects how many cycles are required to transfer the entire line the lx8380 supports configurable line size specified through lconfig line size of eight words 32 bytes is assumed here thetargetmaytransferthereaddatastartingwith wordzerofirst orstartingwiththe desiredwordfirst with word zero first operation the target transfers four 64bit beats of data in sequence starting at the nearest 32 bitalignedaddresssmallerorequaltotheaddressthattheinitiatordrivesinotherwordsthetargetstartsthe transfer at the beginning of the line containing the requested address with desired word first operation the first data beat returned by the target is the beat corresponding to the address instead of the word zero of the linethesecondbeatisthenextsequentialdatabeatandsoonattheendofthelinethetargetwrapsaround and returns the first beat of line all devices on the system bus must operate consistently with respect to whethertheyreturnwordzerofirstorthedesiredwordfirstthelx8380isconfigurabletoworkwitheither mode of operation the lx8380 supports two ways of incrementing the address of line read one is linear wrap where the addressissimplyincrementedbyonetheotheris interleavedwrap wherethenextaddressisdeterminedby the logical xor of the cycle count and the first word address the interleave sequence is shown in the table belowtheloworderaddressbits43forthefirstdatabeataretheobtainedfromtheaddressofthelineread request the low order address bits for the subsequent data indicate the corresponding interleave order the address increment mode used for line read operation is specified in the bus command as described in section85 the lx8380 is configurable via lconfig to generate bus commands for either mode table 37 line read interleave order 833 burst read theburstreadoperationtransfersanarbitraryamountofdatafromthetargettotheinitiatortheinitiatorfirst presents starting address to the target the target responds by providing multiple cycles of data beats in sequence starting at the initial address the initiator indicates to the target when to stop providing data burst read operations are used by io devices for block dma transfers the lx8380 does not issue burst read operations note that there is adifference between an 8cycle burst and aline read aline read mayuse desiredword first increment and wrap burst will always increment and will never wrapinterleaved address43 1st data beat 00 01 10 11 2nd data beat 01 00 11 10 3rd data beat 10 11 00 01 4th data beat 11 10 01 0090 lexra proprietary confidential revision 14section 8 lexra system bus lbus lx8380 834 single data write the single data write operation writes twinword single word halfword or byte to the target the lx8380 data cache is configurable for writethrough or writeback policies cpu data writes that are performed in writethrough mode generate single data write operation on the system bus cpu data writes thatmissthedatacacheeveninwritebackmodealsogenerateasinglecyclewriteoperationhoweverthe data cache inhibits these bus write operations if the address falls within the cpus local dmem 835 line write thelinewriteoperationwriteasequenceofdatafrommemorycorrespondingtothesizeofacachelinethe cache line size affects how many cycles are required to transfer the full line the lx8380 and the lexra bus support configurable line size specified through lconfig line size of eight words 32 bytes is assumed here line writes always begin with word zero as the first data beat 836 burst write burst write is an operation where the initiator sends an address and then an indefinite sequence of data to thetargettheinitiatorwillinformthetargetwhenithasfinishedsendingdatathisoperationisusedbyio devices for dma transfers it is not used by the lx8380 837 split read the lbc issues split read command when the processor executes an lwcsw ltcsw or lqcsw instructions if the lx8380 is configured for split line reads via lconfig the processor issues split read command for all data and instruction read transactions including line reads the split read bus transaction terminates when the target has accepted the command by asserting trdy the bus is free for other operations while the target device performs the read internally when the target is ready to supply the read data it issues split data or split line data command as bus master described below 838 write split read thelbccanissueawritesplitreadcommandwhentheprocessorexecutesawdlwcswwdltcsw orwdlqcswinstructionthisbuscommandwrites64bitdatatoadevicewhilesimultaneouslymakinga split read request cmd30 specify the size of the read request one two or four words the write split read bus transaction terminates when the target device has accepted the command and the write data by assertingtrdythebusisfreeforotheroperationswhilethedeviceperformsthewriteandreadoperations internally when the target device is ready to supply the read data it issues split data command as bus master described below 839 split data atargetdevicethathasacceptedasplitreadorwritesplitreadcommandsuppliesthedatatotherequestor usingthesplitdatacommandthedevicesavesthegtidobtainedfromthesplitreadorwritesplitread command and performs the read operation internally when the device is ready to supply the read data the deviceactsasanlbusmasterdeviceitissuesasplitdatacommandthatidentifiestheoriginalrequestors gtid and supplies the read data with the command the lbc that matches the gtid will act as lbus target device and accept the data an lbc acts as target only for split data commandsrevision 14 lexra proprietary confidential 91lx8380 section 8 lexra system bus lbus 84 signal descriptions table 38 lbus signal description signal namesource initiatortargetctrldescription bclock ctrl bus clock bcmd80 initiator encoded command active during ﬁrst cycle that bframe is asserted baddr310 initiator address target indicates valid address by asserting bframe bframe initiator asserted by initiator at beginning of operation with address and command signals deasserted when initiator is ready to accept or send last piece of data otherbusmasterssamplethisandbirdytoindicate that the bus will be available on the next cycle birdy initiator forwritesindicatesthatinitiatorisdrivingvaliddata on reads indicates that initiator is ready to accept data bdata630 initiator on writetarget on readdata if driven by initiator birdy indicates valid data onbusifdrivenbytargetbtrdyindicatesvaliddata on bus btrdy target for writes indicates that target is ready to accept data on reads indicates that target is driving valid data bsel target asserted by selected target after initiator asserts bframeindicatesthattargethasdecodedaddress and will respond to the transaction ie has been selected bgtid150 initiator for all transactions except split data indicates the global thread id of the initiator for split data trans actions indicates the global thread id of the target to which the data is directed92 lexra proprietary confidential revision 14section 8 lexra system bus lbus lx8380 85 lbus commands the initiator drives bcmd during the cycle that bframe is asserted the encoding for bcmd is shown below bcmd86 000 read 001 write 010 split read 011 write split read 100 reserved 101 split data 110 reserved 111 reserved bcmd6 0 read 1 write bcmd54a if the processor is not configured to issue split read commands for all read operations cmd54 is always 00 for split read write split read and split data commands00 burst ﬁxed lengthb b for burst transfers the length is determined bcmd3001 burst unlimited number of words 10 line interleaved wrapc c forlinetransfersthelengthisdeterminedbythertllinesizeconﬁgura tion set with lconﬁg not bcmd3011 line linear wrap bcmd30 1000 1 byte 1001 2 bytes 1010 reserved 1011 1 word 1100 2 words 1101 reserved 111x reserved 0000 4 words 0001 8 words 0010 16 words 0011 32 words 01xx reservedrevision 14 lexra proprietary confidential 93lx8380 section 8 lexra system bus lbus 86 lbus byte alignment lbusdatamustbedriventothebytelanesaccordingtotherulesshownintable39alignmentsnotshown are not legal all multibeat operations transfer multiple twin word beats over lbus table 39lbus byte lane assignment the lexra bus does not define unaligned data transfers such as halfword transfer that starts at addr1001 or transfers that would need to wrap to the next data beat 87 split transactions the processor generates split read command as result of executing specific instructions such as lwcsw these instructions also cause the processor to perform context switch the split transaction makes efficient use of the system bus while the processor executes instructions for different context the lx8380 can also beconfigured with lconfigto issue split read commands for all read operations including linereadsthatareinitiatedasaresultofaninstructioncacheordatacachemissalthoughtheprocessordoes not perform context switch in these cases the split transaction can still improve system level performance by making more efficient use of the system bus the split transactions are divided into two parts the first half initiated by an lbc requests data from targetdeviceeitherwithasplitreadorwritesplitreadcommandunlikearegularreadrequestthelbc doesnotholdthebusuntilthereaddataisreturnedoncethelbcknowsthatthetargethasreceivedthesplit readrequestitreleasesthebusandwaitsforthedatatobereturnedatalatertimethedataisreturnedtothe lbc with split data command from the lbus device that accepted the split read request when the processor executes lwcsw ltcsw or lqcsw instruction split read command for onelexra bus data byte lanes used bcmd30 addr20 6356 5548 4740 3932 3124 2316 158 70 1000 000 x 1000 001 x 1000 010 x 1000 011 x 1000 100 x 1000 101 x 1000 110 x 1000 111 x 1001 000 x x 1001 010 x x 1001 100 x x 1001 110 xx 1011 000 x x x x 1011 100 x x x x 1100 100 x x x x x x x x94 lexra proprietary confidential revision 14section 8 lexra system bus lbus lx8380 two or four words will be issued on the lbus cmd30 is used to indicate the size of the read data requested data will be transferred with the request when the processor executes wdlwcsw wdltcsworwdlqcswinstructiononelbustransactionwritesplitreadcommandwillissuethe write data and split read request unlike regular write the size of the write data is always two words cmd30 indicates the size of the requested read data if the processor is configured to issue split read commands for all read operations an instruction or data cache miss will cause the processor to issue split read command that specifies line transfer via cmd54 the line size is configuration dependent and is not conveyed in cmd30 onceanlbustargetdevicehasacceptedthesplitreadrequestitmustreturndataatalatertimethetarget acts as an lbus master device and initiates split data command the target lbc accepts this command and receives the data theglobalthreadidgtidisdrivenwitheachsplitreadrequestthetargetdeviceretainsthegtidvalue associated with the split read request and supplies this value when it initiates the split data transaction to return the data this allows an lbc to identify split read data that is targeted for it and allows the processor associatethedatawiththecorrectcontextatargetsystembusdevicemustsaveall16bitsofthegtidvalue drivenwithasplitreadrequestincludingreservedfieldsandsubsequentlydrivethe16bitvalueontogtid during the split read data transaction table 40 lbus gtid fields the lbc drives gtid all transactions including nonsplit transaction types 88 lexra bus controller thelexrabuscontrollerlbcistheelementofthelx8380thatconnectstothelexrabusitforwardsall transaction requests from the lx8380 cpu to the lexra busgtid15 gtid1413 gtid12 gtid114 gtid30 inst reserved bmc procnum contextnum field name interpretation inst 0 data related request 1 instruction releated request reserved implementation specific bmc 0 contextnum identifies cpu context number 1 contextnum identifies bmc channel number procnum procesor number contextnum withinprocessor context number or bmc channel numberrevision 14 lexra proprietary confidential 95lx8380 section 8 lexra system bus lbus 881 lbc commands the lbc issues only the lbus commands listed in the table below table 41 lbus commands issued by the lbc 882 write buffer the lx8380 includes write buffer in its cbus interface when the lx8380 is configured to include the lbc the cbus interface and its write buffer are always included as an internal lx8380 module see section72 for description of the write buffer 883 lbc read buffer the lbc contains read buffer with depth that is configurable with lconfig all incoming read data from the system bus passes through the read buffer this allows the lbc to accept incoming data as result of cache line fill operation without having to hold the bus when the lbc is configured with an asynchronous interface larger read buffer improves system and processor performance in the event of cache miss when the lbc is configured with synchronous interface the cache can accept nonsplit read data as fast as the lbc can transfer it there is need for large read buffer if split read transactions are not employed through lconfig the size of the read buffer may be reduced to minimum size of two 64bit data entriescommand bcmd86 bcmd54 bcmd30 circumstances read line nonsplit 000 10 or 11 depending on conﬁgu rationundeﬁned cache miss during read by the cpu and the cpu is not conﬁg uredtousesplittransactionsforall reads read single twinwordwordhalf wordbyte000 00 10xx or 1100a read by the cpu from an address in uncachable address space and the cpu is not conﬁg urestousesplittransactionsforall reads write line 001 10 or 11 depending on conﬁgu rationxxxx whenthedatacacheisconﬁgured for writeback operation read miss requires replacement of dirty line write single wordhalfwordbyte001 00 10xx write by the cpu into cacheable or uncachable address space split read 010 00 for split read gle 10 or 11 for split read line10111100 or 0000an lwcsw ltcsw or lqcsw instruction is executed also per formed for all bus read operation if the cpu is conﬁgured to use split transactions for all reads write split read 011 00 10111100 or 0000a wdlwcsw wdltcsw or wdlqcsw instruction is exe cuted96 lexra proprietary confidential revision 14section 8 lexra system bus lbus lx8380 insomeapplicationsthereisaneedtominimizethenumberofgatesthereadbuffersizemaybereducedto twoentriesfortheasynchronouscasethiscausesapenaltyintermsoflbusutilizationsincethelbcmay havetodelaythereadbydeassertingirdyifitcannotholdpartofthelineofdatawhenthereadbufferis the size of cache line this will be rare since simultaneous instruction cache and data cache misses are relatively rare for smaller read buffer delays are likely 89 transaction descriptions this section describes the various types of lbus read and write transactions in detail these operations adhere to the following protocols 1 agentsthatdrivethebusdosoasearlyaspossibleaftertherisingedgeofthebusclockthere is some time to perform combinational logic after the bus clock goes high but the amount of time is determined by the speed of the bus clock and the number of devices on the bus 2 agents sample signals on the bus at the rising edge of the bus clock 3 all bus signals must be driven at all times if the bus is not owned and external device must drive the bus to legal level 4 change in signal ownership requires one cycle during which the signal is not driven if an initiator gives up the bus another initiator needs to wait for one undriven cycle before it can drive the bus if the same initiator issues read operation and then needs to issue write oper ation it also must wait one extra cycle to ensure that the undriven cycle is present 5 agentsthatownsignalsmustdrivethesignalstoalogicaltrueorlogicalfalseallotheragents must disable tristate their output buffers thelexrabusprotocolisbasedonthepcibusprotocol1thelexrabussignalsbframebtrybirdy and bsel have similar function to the pci signals frame trdy irdy and devsel respectively in general the protocol for the lexra bus is as follows 1 the initiator gains control of the bus through arbitration described section 812 on page 107 2 during the ﬁrst bus cycle of its ownership before the ﬁrst rising clock edge the initiator drivestheaddressforthebustransactionontobaddratthesametimeitassertsbframe to indicate that the bus is in use it will deassert bframe before it send or accepts the last data beat in most cases the initiator will assert birdy to indicate that it is ready to receive data or read operations or is driving valid data for write operations if the operation is write the initiator will drive valid data onto bdata 3 at the rising edge of the ﬁrst clock all agents sample baddr and decode it to determine which agent will be the target 4 the agent that determines that the address is within its address space asserts bsel sometime after the ﬁrst rising edge of the bus clock bsel stays asserted until the transaction is com plete 5 the initiator and the target transfer data either in one cycle or in successive cycles the agent driving data the initiator for write the target for read indicates valid data by asserting its readysignalirdyortrdyforwritesandreadsrespectivelytheagentreceivingdatatar getforawriteinitiatorforareadindicatesitsabilitytoreceivethedatabyassertingitsready 1 the lexra bus is not pci compatible it merely borrows concepts from the pci bus speciﬁcationrevision 14 lexra proprietary confidential 97lx8380 section 8 lexra system bus lbus signal either agent may deassert its ready signal to indicate that it cannot source or accept data on this particular clock edge 6 when the initiator is ready to send or receive the last data beat that is when it asserts birdy forthelasttimeitalsodeassertsbframeitwilldeassertbirdywhenthelastdatabeatis transferred 7 the arbiter grants the bus to the next initiator and may do so during bus transfer by differ ent initiator the new initiator must sample bframe and birdy when both birdy and bframe is sampled deasserted and the new initiator has been given grant it can assert bframe the next cycle to start new transaction note in the examples below the signals baddr and bdata are often shown to be in highimpedance state in reality internal bus signals should always be driven even if they are not being sampled the hiz states are shown for conceptual purposes only 891 single data read with waits this operation is used to read twinword word halfword or byte from memory usually in uncachable address space the lbc does not issue nonsplit line read transactions if the processor is configured to employ split reads for all read operations instead split read is issued thisisasimplereadoperationwherethetargetrespondsimmediatelywithdatathisisunlikelysincemost deviceswill requireoneormorecycles toreturn datathisexampleillustratesthemostbasicread operation without waits 1 initiator asserts bframe and drives baddr 2 targetassertsbseltoindicatetoinitiatorthatatargetisrespondinginthisexamplethereis animmediatefetchofdatasotargetdrivesdataandassertsbtrdytoindicatetotargetthatit is driving data the initiator deasserts bframe and asserts birdy to indicate that the next piece of data received will be the last 3 initiatordeassertsibirdyandthetargetdeassertsbselandbtrdytoindicatetheendof the transaction the initiator that has been given grant owns the bus this cycleclock bframe bcmd baddr bdata birdy btrdy bsel d000098 lexra proprietary confidential revision 14section 8 lexra system bus lbus lx8380 892 single data read with target wait this is the same as the single data read except that the target needs time to fetch the data from memory this is common single data read operation 1 initiator asserts bframe and drives baddr 2 target asserts bsel to indicate that it has decoded the address and is acknowledging that it is the target device however it is not ready to send data so it does not assert btrdy initiator deassertsbframeandassertsbirdytoindicatethatthenextpieceofdatawillbethelastit wants 3 target has not asserted btrdy so data is transferred 4 after second wait cycle target drives data and asserts btrdy to indicate that data is on the bus 5 target deasserts bsel and btrdy initiator deasserts birdy another initiator may drive the bus this cycle 893 line read with waits alinereadtransfersdatabeatsthatcompriseacachelineinthisexamplefourdatabeatsaretransferredin sequence without any waits the lbc does not issue nonsplit line read transactions if the processor is configured to employ split reads for all read operations instead split read is issued 1 initiator drives baddr and asserts bframe to indicate beginning of transactionclock bframe bcmd baddr bdata birdy btrdy bsel d0001 clock bframe bcmd baddr bdata birdy btrdy bsel d0002revision 14 lexra proprietary confidential 99lx8380 section 8 lexra system bus lbus 2 target asserts bsel to indicate that it had decoded the address and will send data when it is ready initiator asserts birdy to indicate that it is ready to receive data 3 target drives data and asserts btrdy 4 target drives second data beat and continues to assert btrdy 5 target drives third data beat and continues to assert btrdy 6 target drives last data beat initiator deasserts bframe to indicate that the next data beat it receives will be the last it needs 7 target deasserts btrdy and bsel initiator deasserts birdy another master may gain ownership of the bus this cycle 894 line read with target waits this illustrates what happens when target needs extra time to fetch data it needs to service cache miss 1 initiator asserts bframe and drives baddr 2 targetassertsbseltoindicatethatitisacknowledgingtheoperationinitiatorassertsbirdy to indicate that it is ready to receive data 3 target waits until it has the data 4 target drives ﬁrst data beat and asserts btdry 5 target drives second data beat and asserts btrdy 6 target cannot get third data beat so it deasserts btrdy 7 target drives third data beat and asserts btrdy 8 target cannot get fourth data beat so it deasserts btrdy 9 target drives fourth data beat and asserts btrdyclock bframe bcmd baddr bdata birdy btrdy bsel d0003100 lexra proprietary confidential revision 14section 8 lexra system bus lbus lx8380 895 line read with initiator waits this occurs when line of data is requested from the target and the initiator cannot accept all of the data in successive cycles 1 initiator drives address and asserts bframe 2 targetassertsbselitdoesnthavedatasoitdoesnotassertbtrdyinitiatorassertsbirdy to indicate that it can accept data 3 target now has data so it drives the data and asserts btrdy 4 target drives second data beat initiator cannot accept it so it deasserts birdy 5 target holds second data beat initiator can accept it and asserts birdy 6 target drives third data beat initiator accepts it 7 target drives fourth data beat initiator cannot accept it and deasserts birdy initiator hold bframe until it can assert birdy 8 initiatorassertsbirdytoacceptfourthdatabeatitdeassertsbframetoindicatethisisthe last data beat 896 burst read the burst read transaction is similar to line read except that bcmd indicates burst read the end of the burst is indicated when the initiator deasserts bframe and birdy 897 single data write with waits asingledatawriteoperationoccurswhenthelx8380processorexecutesastoreinstructionthatmissesthe data cache or executes store operation in writethrough mode writes to uncacheable address space also generate single data write single data write operations are used to write twinwords words halfwords and bytes but note the lx8380 does not generate twinword writesclock bframe bcmd baddr bdata birdy btrdy bsel d0004revision 14 lexra proprietary confidential 101lx8380 section 8 lexra system bus lbus single data write without waits requires two cycles 1 initiator asserts bframe and drives address 2 targetsamplesaddressandassertsbselinitiatordrivesdataandassertsbirdyinthiscase target is also able to accept data so it asserts btrdy initiator also deasserts bframe to indicate that it is ready to send the last and only data beat 3 target accepts data deasserts btrdy and bsel initiator deasserts birdy 898 single data write with waits thisisanexampleofasingledatawriteoperationwherethetargetcannotimmediatelyacceptdataandmust insert wait states thisisthesamedescriptionastheaboveexampleexceptthatthetargetinsertstwowaitstatesuntilitasserts birdy to indicate acceptance of data 899 line write with waits line write operationis generally used to transfer amodified cache line from acache to main memory theclock bframe bcmd baddr bdata birdy btrdy bsel d0005 clock bframe bcmd baddr bdata birdy btrdy bsel d0006102 lexra proprietary confidential revision 14section 8 lexra system bus lbus lx8380 following illustrates bestcase scenario with wait states 1 initiator drives address and asserts bframe 2 targetassertsbselandbtrdytoindicateitwillacceptdatainitiatordrivedataandasserts birdy 3 initiator drives next data beat target continues to accept data and indicates as such by continu ing to assert btrdy 4 initiator drives third data beat target continues to accept 5 initiator drives fourth data beat and deasserts bframe to indicate that this will be its last beat sent target accepts data 6 target deasserts btrdy and bsel initiator gives up control of the bus by deasserting birdy 8910 line write with target waits this example is similar to the above example except that during the third and fourth data beat transfer the target cannot accept the data quickly enough so it deasserts btrdy which indicates to the initiator that it should hold the data for an additional cycleclock bframe bcmd baddr bdata birdy btrdy bsel d0007 clock bframe bcmd baddr bdata birdy btrdy bsel d0008revision 14 lexra proprietary confidential 103lx8380 section 8 lexra system bus lbus 8911 line write with initiator waits the example illustrates what happens when the initiator cannot supply data fast enough and has to insert waits 8912 burst write burst write is generally used to transfer large amounts of data from an io device to memory via dma transfer this transaction is similar to line write except that bcmd indicates burst write the end of burst write is indicated when the initiator deasserts bframe and birdy 8913 split read command the processor may be configured with lconfigto issue split read commands for all read operations otherwise the lbc issues split read command only when the processor executes an lwcsw ltcsw or lqcsw instruction the following is an example of single word read request 1 an lbc initiates the transaction by asserting frame and driving the addr for the transac tion it drives the cmd bus with the split read command gtid is also driven by the lbc with the processorcontext number information 2 the target decodes the address and asserts sel and trdy to respond to the request trdy should always be asserted with sel it saves the addr and gtid information which it will use when it returns the data data needs to be transferred so the data bus is inactive frame is deasserted and addr cmd gtid are not driven irdy is asserted 3 thelbcdeassertsirdyandthetargetdevicedeassertsselandtrdytoindicatethesplit read request transaction is completeclock bframe bcmd baddr bdata birdy btrdy bsel d0009 clock bframe bcmd bgtid baddr bdata birdy btrdy bsel d0010104 lexra proprietary confidential revision 14section 8 lexra system bus lbus lx8380 therearenodatastallsallowedsincenodataisbeingtransferredthetargetshouldasserttrdyassoonas it asserts sel the first half of the read transaction is now complete the lbc will wait for the target device to return the requested data using the split data command 8914 write split read when the processor executes wdlwcsw wdltcsw or wdlqcsw instruction the lbc issues write command with split read request with this command the lbc writes data to device while simultaneously making split read request the write data consists of two words the requested read data size may be 1 2 or 4 words indicated by cmd30 1 an lbc initiates the transaction by asserting frame and driving the addr for the transac tion it drives the cmd bus with write split read command and cmd30 indicates either one word or two word split read request gtid is driven with the processorcontext number information 2 thetargetdecodestheaddressandassertsselinthisexamplethetargetisimmediatelyready toacceptthewritedatasoitalsoassertstrdyitsavesthegtidinformationwhichitwilluse when it returns the data the lbc deasserts frame since this is single cycle write it also drives irdy and the data bus addr cmd and gtid are only driven the ﬁrst cycle 3 thelbcdeassertsirdyandthetargetdevicedeassertsselandtrdytoindicatethewrite transactionhascompletedthereadrequesthasalsobeentransferredandthetargetmustissue data response at later time thetransactionwilllookthesameforasplitreadrequestoftwowordsexceptcmd30willindicateatwo word request instead of one word sincewritedataisbeingtransferredwiththesetransactionsdatastallsareallowedtherulesfortrdyand irdy are the same for these write transactions as they are for regular write transactions when an lbc issues split read or write split read command and successfully completes the request to thetargetthelbcwillconsiderthatoperationcompleteitistheresponsibilityofthetargetdevicetoreturn data to the lbc by issuing split data commandclock bframe bcmd bgtid baddr bdata birdy btrdy bsel d0011revision 14 lexra proprietary confidential 105lx8380 section 8 lexra system bus lbus 8915 split data once an lbc has sent split read request either with split read or write split read command and the targetdevicehasacceptedtherequestthedevicemustsupplytherequesteddataandreturnittothelbcto dothisitmustactasanlbusmasterdeviceandinitiateasplitdatacommandthelbcwhichoriginated thesplitreadwillactaslbustargetdeviceandacceptthedataanlbconlyactsasatargetforsplitdata commands 1 the lbus device that accepted the read request now asserts frame to indicate it is ready to returntherequesteddataitdrivescmdwiththesplitdatacommandcmdalsoindicatesthe transaction size the gtid bus is driven with the correct processorcontext information the addr bus must be driven with the address of the requested read data 2 eachlbcexaminesthegtidbustodeterminewhichprocessorthisdataisforthelbcthat is associated with the procnum asserts sel and trdy to accept the two words of data frame is deasserted while irdy is asserted addr cmd and gtid are only driven the ﬁrst cycle 3 the master device deasserts irdy and the lbc deasserts sel and trdy to indicate the transaction is complete the lbc then returns the read data to the context that requested it the cmd encoding indicates the transaction size if the processor is configured to issue split read commands for all read operations the split read data size may be 1 2 4 8 or 16 bytes or cache line otherwise the split read data size is limited to 4 8 or 16 bytes the data is aligned on the data bus based on the original read address according to the rules shown in table39 on page93 datastallsareallowedduringdataresponsetransactionsanlbcwillproperlyhandledatastallsonthebus andmaydeasserttrdytostallthetransactionitselfforperformancereasonsthereadbufferinthelbc should be large enough to avoid this 810 ordering rules with split transactions the lbc follows the same rules for allowing split read request to be issued as it would standard read request once an lbc has issued the split read or write split read command it does not keep track of the read request this means subsequent write transaction could be issued to the same address before the requested data has been returned to the lbc the lbc will not stall the write or try to enforce any coherency in this caseclock bframe bcmd bgtid baddr bdata birdy btrdy bsel d0012106 lexra proprietary confidential revision 14section 8 lexra system bus lbus lx8380 if more than one split readwrite split read request is outstanding on the lbus the corresponding data responses do not have any ordering requirements the lbc will use the gtid that was presented with the split data to return the data to the correct context 811 lbc signals thetablebelowsummarizesthelx8380lbcportsthelbcportcolumnindicatesthenameoftheport suppliedbythelbcthebussignalcolumnindicatesthecorrespondinglexrabussignalthelbcports are strictly unidirectional while the bus signals at least conceptually include multiple sources and sinks the manner in which lbc ports are connected to bus signals is technology dependent and may employ tri state drivers or logic gating in conjunction with the lbcs lcoe ldoe and ltoe outputs table 42 lbc interface signals io lbc port bus signal description output laddro310 baddr310 lbc address output ldatao630 bdata630 lbc data input ldatai630 bdata630 system data output lirdy birdy lbc initiator ready input lirdyi birdy system initiator ready output lframe bframe lbc transaction frame input lframei bframe system transaction frame output lselo bsel lbc slave select input lsel bsel system slave select output ltrdyo btrdy lbc target ready input ltrdy btrdy system target ready output lcmd80 bcmd80 lbc command input lcmdi80 bcmd80 system command output lgtido150 bgtid150 lbc global thread id input lgtidi150 bgtid150 system global thread id output lreq lbc bus request input lgnt system bus grant output lcoe90 lbc command output enable terms output ldoe70 lbc data output enable terms output ltoe lbc transaction output enable termsrevision 14 lexra proprietary confidential 107lx8380 section 8 lexra system bus lbus 812 arbitration 8121 lbus rules the following are the lbus rules for arbitration req request from master gnt grant to the master idle bframe and birdy are both deasserted last birdy and btrdy are both asserted and bframe is deasserted busy birdy or btrdy or bframe are asserted 1 masterassertsreqatthebeginningofacycleandmaystartsamplingforassertedgntinthe same cycle in case gnt is already asserting in the case of park 2 ifbusis idleorifthebusisinthe lastdataphaseoftheprevioustransactionwhenmastersam ples asserted gnt then the master may drive bframe asserted on next cycle 3 if the bus is busy when the master samples gnt the master must also snoop bframe birdyandbtrdyifgntisstillassertedonecycleafterbframeisdeassertedandboth birdy and btrdy are asserted the last data phase the master may drive bframe 8122 lbc behavior when the lbc needs access to lbus it asserts lreq and in the same cycle samples lgnt lframei and either lirdyi or lirdyi ltrdy if these are true the lbc takes ownership of the bus on the next cycle the lbc deasserts lreq the cycle after it asserts lframe if the bus is busy the lbc continues to snoop these four signals for this condition all other lbus arbitration rules are based on this behavior of the lbc 813 connecting the lbc to lbus thelbcprovidesarethreesetsofoutputenablesltoevalidforthelengthofthetransactionlcoevalid for only the first cycle of transaction and ldoe valid for data transfers asserted by the master for writes and by the slave for reads ltoe qualifies ltrdyo lselo lframe and lirdy lcoe qualifies lcmd laddro and lgtido ldoe qualifies ldatao applicationspecific devices may employ similar signals to qualify their lbus outputs instead of using the lbcs ltoe and similar signals from applicationspecific bus devices it may instead be desirable to logically or the frame outputs from the lbc and all devices this can be done either centrally or with one or gate for each target and master the same holds true for irdy trdy and sel outputs this simplifies the connections when relatively few number of devices are used and there are offchip devices connected directly to the lexra bus masters and slaves not taking part in transaction must always keep their frame irdy trdy and sel outputs driven and deasserted108 lexra proprietary confidential revision 14section 8 lexra system bus lbus lx8380revision 14 lexra proprietary confidential 109lx8380 section 9 block move controller bmc 9 block move controller bmc 91 bmc overview the bmc performs arbitrary length transfers between dmem and system devices such as main memory thetransferlengthmaybe1262144256kbyteswithbytegranularitythebmcbreaksthetransferinto aseriesoftransactionrequestswhicharepresentedtothedatalocalmemoryinterfacedlmithedlmi uses its cbus interface to access the system device eachbmctransferisassignedtoa channelthebmcsupportsupto16channelsahardwareregistersetis providedtosetupandcontroleachchannelstransferinthelx8380eachchannelisusuallyassociatedwith processor context bmcregistersareaccessedviathecoprocessor3interfacesoftwarerequestsabmctransferbyperforming move operations to the register set register contents persist between transfer requests reducing the number of instructions required to request subsequent transfers software typically performs context switch after making transfer request thebmcinformsthecpuwhenatransfercompleteseitherthroughaflagthatcanbepolledbysoftwarean interrupt or by clearing the appropriate cpu waitevent bit to activate an idle context the dlmi provides the data interconnect between cbus dmem dcache and the cpu requests for data transfers may be initiated by the cpu or the bmc these requests are processed by the dlmi and passedtothecbusthedlmicanbeconfiguredtoprovideeitheraoneortwoportdmeminterfacewith one port interface cpu and bmc transfers share the port and an arbitration scheme is used with two port interface the cpu and bmc each have dedicated port figure 21 block move controllercpu bmc cop3dlmicpu data requests cbuscoprocessor 3 interface register set 1 per channeltransaction request logic cbi bmc transaction requestsport 1 port 2 optional cpu requests and data bmc requests and datadmem110 lexra proprietary confidential revision 14section 9 block move controller bmc lx8380 92 transfers the bmc is controlled via the coprocessor 3 interface the bmc has one set of registers for each channel software requests bmc transfer by performing move operations to channels register set register contentspersistbetweentransferrequestsreducingthenumberofinstructionsrequiredtorequestsubsequent transfers software may request read or write transfers write transfers move data from dmem to device read transfers move data from device to dmem software typically performs context switch after making transfer request via the csw instruction software must not change the values written to channels register set while transfer request from that channel is pending software may update channels register set after notification of transfer completion transferrequestsareassignedtoatransaction classviaafieldineachchannelsregisterset withinasingle transfer class transfers requests are processed sequentially with the oldest request processed first across transfer classes transfers are interleaved transfers may be interleaved because they are broken into transactions described in the next section interleaved transfers are processed in roundrobin fashion interleaving transfers generally improves system performance assuming that the interleaved transfers target different devices since any one device has more time to process transaction it is less likely to stall the systembus interleavedtransfersmaynotbeappropriateifthetransferstargetthesamedevice forexample in streaming device transactions associated with transfer must occur in sequence in this case all transfers targeting the streaming device must share the same class 93 transactions the bmc breaks each transfer into series of transaction requests the transaction size may be byte word double word or line there are separate control bits to disable word double word and line transactions when read transfer is requested the resulting transactions are split reads the dlmi allows multiple outstanding split read transactions in order to fully utilize the system bus the size of transaction is selected based on the cbus transfer address and transfer length the largest enabled transaction size that meets the following criteria is selected the transaction size must be aligned to the current cbus transfer address the transaction size must not cause the requested transfer length to be exceededrevision 14 lexra proprietary confidential 111lx8380 section 9 block move controller bmc here is an example of this process transfer size 91 bytes word transactions disabled cbus transfer starting address 0x0000_000f line size 32 bytes an option is provided to maintain constant cbus address in this case the transaction size is fixed at the largestenabledtransactionsizeifthetransfersizerequestedisnotanintegermultipleofthistransactionsize the final transaction is padded the padding bits consist of whatever follows the transfer data in dmem here is an example showing the transaction requests generated line transactions disabled cbus transfer starting address 0x0000_0008 transfer size 26 bytes 94 transaction sequence due to transfer class theexamplesintheprevioussectionshowsequencesofsequentialtransactionrequeststhatareallassociated with the same transfer transaction requests occur in this way if the same transfer class is applied to all transfer requests if different transfer classes are applied to pending transfer requests transaction requests alternate between transfer requests on roundrobin basistransaction addresstransaction size 0x0000_000f byte 0x0000_0010 double word 0x0000_0018 double word 0x0000_0020 line 0x0000_0040 line 0x0000_0060 double word 0x0000_0068 byte 0x0000_0069 byte transaction addresstransaction size 0x0000_0008 double word 0x0000_0008 double word 0x0000_0008 double word 0x0000_0008 double word112 lexra proprietary confidential revision 14section 9 block move controller bmc lx8380 for example if four transfer requests are pending with the following characteristics the sequence of transaction requests from the bmc to the dlmi with these pending transfer requests are 95 bmc perchannel registers coprocessor 3 register set exists for each channel perchannel registers are implemented using the coprocessor 3 general registers general registers are read using the mfc3 instruction and written using the mtc3instructionthecontentsofthegeneralregisterspersistuntilanewvalueiswrittenthe0fieldsinthese registers are ignored on write and are 0 on read for compatibility with future lx8380 versions the 0 fields should be written with 0 bmc_cbusadr r16transfer identiﬁertransfer classnumber of transactions required ta 0 2 tb 0 1 tc 1 2 td 2 3 transfer identiﬁertransaction numbertransfer complete ta 0 tc 0 td 0 ta 1 yes tc 1 yes td 1 tb 0 yes td 2 yes 31 0 cbusadr field description rw reset cbusadr cbus transfer physical starting address rw 0revision 14 lexra proprietary confidential 113lx8380 section 9 block move controller bmc bmc_dmemadr r17 bmc_xferlen r18 bmc_param r1931 18 17 0 0000_0000_0000_00 dmemadr field description rw reset dmemadr dmemtransferphysicalstartingaddress onlythebitsusedbythecon ﬁgured dmem size are required eg 64k dmem requires bits 150 other bits are dont carerw 0 31 19 18 0 0000_0000_0000_0 xferlen field description rw reset xferlen transfer length 1 262144 bytes 256k 0 operation 262144 undeﬁnedrw 0 31 24 23 20 19 18 17 16 0000_0000 xfertype 00 intenable bmcpriority 15 8 7 4 3 2 1 0 0000_0000 xferclass nocbusinc noline nodword noword field description rw reset xfertype 0001 read transfer 0010 write transfer other encoding reservedrw 0 intenable 0 disable interrupt 1 enable interrupt rw 0 bmcpriority 0 cpu priority 1 bmc priority rw 0 xferclass transfer class 0 15 rw 0 nocbusinc 0 increment cbus address 1 dont increment cbus address rw 0 noline 0 allow line transactions 1 disable line transactions rw 0 nodword 0 allow dword transactions 1 disable dword transactions rw 0 noword 0 allow word transactions 1 disable word transactions rw 0114 lexra proprietary confidential revision 14section 9 block move controller bmc lx8380 bmc_cmd r20 96 bmc global registers global registers apply to all channels they are used to manage interrupts and the perchannel registers global registers are implemented using the coprocessor 3 control registers control registers are read using thecfc3instructionandwrittenusingthectc3instructionthe0fieldsintheseregistersareignoredonwrite and are 0 on read for compatibility with future lx8380 versions the 0 fields should be written with 0 bmc_regset c16 bmc_donevec c1731 30 3 2 0 bmcbusy 000_0000_0000_0000_0000_0000_0000_0 command field description rw reset bmcbusy 0 transfer in progress 1 transfer in progress set to 1 when transfer is initiated for this channel setto0 whenthetransfercompletesorwhenstoptransfercommandis issuedr0 command 000 clear done 001 start transfer set bmc_donevecs bit for this channel 0 set bmcbusy 1 010 stop transfer set bmc_donevecs bit for this channel 1 set bmcbusy 0 others reservedrw 0 31 9 8 7 4 3 0 0000_0000_0000_0000_0000_000 useactiveset 0000 activeregset field description rw reset useactiveset 0 dont use activeregset instead use active context 1 use activeregsetrw 0 activeregset channel whose register set is the target of coprocessor 3 reads and writesrw 0 31 16 15 0 0000_0000_0000_0000 donevec field description rw reset donevec bit vector corresponding to each channel in any bit position 0 transfer not complete 1 transfer complete channels bit is set 1 when its transfer completes or stop transfer command is issued the bit is set 0 when the clear done or start transfer command is issuedr0revision 14 lexra proprietary confidential 115lx8380 section 9 block move controller bmc bmc_intlow c18 bmc_intenvec c19 97 perchannel register set selection the bmc supports up to 16 channels each channel has its own register set used for specifying and controlling bmc transfers two techniques are provided for selecting which register set is accessed by software during coprocessor 3 reads and writes 1 explicitregistersetselection theregistersetaccessedmaybeselectedbyplacingitsvaluein bmc_regsetactiveregset and setting bmc_regsetuseactiveset 1 this mode allows access to any channels register set 2 automatic register set selection the register set accessed is selected automatically based on what context is active this mode is selected by setting bmc_regsetuseactiveset 0 when using this mode only one transfer request may be pending per context 98 transfer completion transfer associated with particular channel must complete before another transfer is requested using that channel software may check for transfer completion using the following techniques 1 polling software can poll if transfer is in progress bmc_cmdbmcbusy or if transfer is done bmc_donevec the transfer done bit remains asserted until cleared 2 interrupt the bmc interrupt line bmc_int_r_n is an output of the lx8380 processor thecustomermayconnectthissignaltoanyoftheintreq_n152inputsinthelexratest bed environment the bmc interrupt is connected to intreq_n12 the bmc interrupt is the logical or of the bmc_donevec bits for every channel anded with its associated interrupt enable bit the enable bit is available in the perchannel bmc_param register or simultaneously for every channel in the bmc_intenvec regis ter verilog representation of the bmc interrupt signal is interrupt 0 for i 0 i number_of_channels i i 1 interrupt bmc_doneveci bmc_intenveci interrupt31 30 4 3 0 intpending 000_0000_0000_0000_0000_0000_0000 lowestint field description rw reset intpending 0 interrupt pending 1 interrupt pending r 0 lowestint encoded value of lowest numbered channel with pending interrupt r 0 31 16 15 0 0000_0000_0000_0000 intenvec field description rw reset intenvec mirror of the bmc_param intenable bit for each channel rw 0116 lexra proprietary confidential revision 14section 9 block move controller bmc lx8380 the interrupt handler must clear the appropriate bmc_donevec bits when interrupt processing is complete five instructions must pass after the write that clears bmc_donevec before interrupts are reenabled 3 waitevent to use the waitevent mechanism to activate context after transfer completion softwareusesacswinstructionwithwaiteventbit2setseetheexampletransferflowsec tion the context will not reactivate until waitevent bit 2 clears the bmc signals transfer completion by clearing waitevent bit 2 for the context that requested the transfer allowing that context to reactivate some write transactions may be pending in the cbi write buffer when write transfer completion is signalled 99 cpubmc arbitration when one port dmem interface is configured requests for dmem access from the cpu and bmc are arbitrated arbitration applies to dmem accesses related to both read and write bmc transfers each channels register set has control bit bmc_parambmcpriority which is used to select the priority of that channels bmc request relative to the cpu arbitration occurs on per transaction basis this implies that multiple arbitration events are required to complete single transfer 910 software responsibility for transfer requests thedatacacheisneveraccessedasaresultofabmctransactionifthecbusaddressusedforatransaction hitsanaddressthatisresidentinthedatacachethedatacacheandmainmemorybecomeincoherentasresult of the transfer it is softwares responsibility to manage cache coherency softwaremustalsoensurethatnoportionoftherequestedtransferexceedsthelimitsofphysicallyconfigured dmem the bmc provides checking for inconsistent transfer specifications 911 example transfer flow the following bmc transfer flow demonstrates the use of waitevent bits to signal transfer completion 1 for write transfers software moves the write data into dmem 2 software selects the mode for channel selection by using ctc3 instruction to load bmc_regset 3 softwaresetsuptransfercharacteristicsbyusing mtc3instructionstoloadbmcgeneralregis ters 4 software starts the transfer by using mtc3 instruction to load command in bmc_cmd contextswitchviathecswinstructionisnormallyperformedsoanotherthreadcancontinue execution while the transfer is in progress the following code sequence is typical csw r1 r1 contains 0x04000000 to set waitevent bit 2 in this contexts cxstatus mtc3 r2 bmc_cmd start bmc transfer in csw delay slot r2 contains start commandrevision 14 lexra proprietary confidential 117lx8380 section 9 block move controller bmc 5 the bmc makes transaction requests to the dlmi waiting for an acknowledgment before proceeding to the next request while the bmc makes these requests other threads continue execution 6 the dlmi services each request by issuing the appropriate transactions and returning an acknowledgment to the bmc when it is able to accept new request 7 when the ﬁnal transaction request has been acknowledged the bmc clears waitevent bit 2 fortherequestingcontextallowingit toresumeexecutionifthecompletedtransferisawrite transfersoftwaremustcauseawritebufferﬂushtechniquetbdbeforeattemptingtoaccess data the following bmc transfer flow demonstrates the use of interrupts to signal transfer completion 1 for write transfers software moves the write data into dmem 2 software selects the mode for channel selection by using ctc3 instruction to load bmc_regset 3 softwaresetsuptransfercharacteristicsbyusing mtc3instructionstoloadbmcgeneralregis ters the bmc_paramintenable bit must be asserted to allow interrupts 4 software starts the transfer by using mtc3 instruction to load command in bmc_cmd 5 the bmc makes transaction requests to the dlmi waiting for an acknowledgment before proceeding to the next request while the bmc makes these requests software continues exe cution 6 the dlmi services each request by issuing the appropriate transactions and returning an acknowledgment to the bmc when it is able to accept new request 7 when the ﬁnal transaction request has been acknowledged the bmc causes the bmc_int_r_nsignaltoassertthisleadstoahardwareinterrupttheinterrupthandlersoft ware can determine what channel caused the interrupt by examining bmc_donevec and bmc_intenvec if more than one channel is causing the interrupt bmc_intlow pro vides quick method for identifying the lowestnumbered interrupting channel the interrupt handler must clear the interrupting channels request by loading clear done command in bmc_cmd118 lexra proprietary confidential revision 14section 9 block move controller bmc lx8380revision 14 lexra proprietary confidential 119lx8380 section 10 ejtag debug 10 ejtag debug given the increasing complexity of soc designs the nature of embedded processordesign debug hardware and software and the timetomarket requirements of embedded systems debug solution is needed which allows onchip processor visibility in costeffective io constrained manner the ejtag solution uses existing ieee jtag pins providing method of debugging all devices accessible to the processor in the same way the processor would access those devices itself using ejtag debug probe can access all the processor internal registers and caches it can also access devices connected to the lx8380s cbus or lbus bypassing internal caches and memories soc designers need only provide package connections to the lx8380s ejtag signals to obtain the full benefits of embedded system debug using third party hardware probes and debug software ejtagallowssinglesteppingthroughcodeandhaltingonbreakpointshardwareandsoftwareaddressand data with masking for debugging problems that are artifacts of realtime interactions ejtag gives real time program counter pc trace capabilities from which an accurate program execution history is derived 101 overview adebughostcomputercommunicatestotheejtagprobetheprobeinturncommunicatestothelx8380 ejtag hardware via an ieee 11491 jtag interface through the use of the jtag test access port tap controller probe data is shifted into the ejtag data and control registers in the lx8380 to respond to processorrequestsdmaintosystemmemoryconfiguretheejtagcontrollogicenablesinglestepmode or configure the ejtag breakpointregistersthroughtheuseoftheejtagcontrolregisterstheusercanset hardware breakpoints on the instruction address data address or data values physical address range 0xff20_0000 to 0xff3f_ffff is reserved for ejtag use only and should not be mapped to any other device currentlyembeddedperformanceincepiandgreenhillsincprovideejtagdebuggersandprobesfor the lx8380 information on these products is available at the following web sites epi inc httpwwwepitoolscom green hills inc httpwwwghscom lx8380 ejtag implements all required features of version 200 of the ejtag specification including the lx8380 may access debug host resources via addressing of probe memory space debug host can dma directly to or from devices attached to the lx8380s system bus hardware breakpoints may be installed on internal lx8380 instruction and data busses ejtag singlestep execution mode realtime pc trace debug exception and two ejtag debug instructions one for raising debug exception via software and one for returning from debug exception120 lexra proprietary confidential revision 14section 10 ejtag debug lx8380 1011 ieee jtagspeciﬁc pinout ieee jtag pins used by ejtag are shown below these are required for all ejtag implementations jtag_trst_n is an optional pin table 43 ejtag pinout table 44 ejtag ac characteristics1 table 45 ejtag synthesis constraints2signal name io description jtag_tdo_nr output serial output of ejtag tap scan chain jtag_tdi input serial input to ejtag tap scan chain jtag_tms input test mode select connected to each ejtag tap controller jtag_clock input jtag clock connected to each ejtag tap controller jtag_trst_n input tap controller reset connected to each ejtag tap controllera this pin is optional in multiprocessor conﬁgurations signal parameter condition min max unit jtag_clock frequency 1 40 mhz duty cycle 4060 6040 jtag_tms setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdi setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdo_nr outputdelaytckfallingedgetotdo 18v 0 7 ns 1 based on epi interface speciﬁcations for majictm and majicplus tmsignal name probe budget core budget slack remaining for other logic jtag_tdo_nr 0 to 7ns 115ns 135 to 205ns jtag_tdi 5ns 135ns 65ns jtag_tms 5ns 135ns 65ns 2 based on 25ns jtag clock periodrevision 14 lexra proprietary confidential 121lx8380 section 10 ejtag debug 102 program counter pc trace the lx8380 ejtag includes support for realtime program counter pc trace when in pc trace mode the lx8380 serially outputs anew value of the program counter whenever there is change in the pc ie context switch branch or jump instruction or an exception when the pc trace option is set to export in lconfig the following signals will be output from the lx8380 dclk pcst and tpc these are described in more detail in the following subsections the dclk output is used to synchronize the probe with the lx8380s core clock sysclk the pcst pc trace status signals are used to indicate the status of program execution example status indications are sequential instruction pipeline stall branch or exception the tpc pins output the value of the pc every time there is change of program control 1021 pc trace dclk debug clock the maximum speed allowed for the debug clock dclk output is 100mhz as an epi probe requirement as cores typically run in excess of this speed dclk can be set to divided down value of sysclk this is set by the dclk n parameter in lconfig which indicates the ratio of sysclk frequency to dclk 1 2 3 or 4 1022 pc trace pcst program counter status trace theprogramcounterstatuspcstoutputcomprisesnsetsof3bitpcstvalueswherenisthedclkn parameter described in section1021 pcst value is generated every sysclk cycle when dclk is slower than the lx8380s sysclk up to n pcst values are output simultaneously changes in program flow caused by contextswitch are shown by the jmp pcst code in addition the pcst codes for the contextswitch jmp and its branchdelay slot seq are switched so that the branch delay slot will be shown first and any subsequent delay due to context being ready is shown by the stl stall pcst code this causes the following pcst output case1 context switch to immediate dispatch of another context case2 context switch with ready contextcntx pcst 1 foo1a seq 1 csw seq 1 foo1b jmp 2 foo2a seqjmpexp 2 foo2b cntx pcst 1 foo1a seq 1 csw seq 1 foo1b stl nvld stl jmp 2 foo2a seqjmpexp 2 foo2b seq122 lexra proprietary confidential revision 14section 10 ejtag debug lx8380 1023 pc trace tpc target program counter the bus width of the target program counter tpc output is user configured in lconfigvia the m parametertobeoneof124or8bitswhenchangeinprogramflowoccursthecurrentpcvalueisdrivenon the tpc output as the pc is 32bits wide the number of tpc pins affects how quickly the pc is sent for example if the tpc is 4 bits wide the pc will take 8 dclk cycles to be sent if another change in flow occurswhilethepcofthepreviouschangeisbeingtransmittedthenewpcwillbesentandtheremainderof thepreviouspcwillbelostunlesstheprocessorisinsinglestepmodewhenanexceptionoccurstpcalso indicates the exception type with either 3 or 4 bits depending on whether or not vectored interrupts are present this is described in more detail in section1025 the tdo output is used for the least significant bit of tpc or the only bit if m is set to 1 via lconfig 1024 singleprocessor pc trace pinout table 46 singleprocessor pc trace pinout table 47 singleprocessor pc trace ac characteristics1 1025 vectored interrupts and pc trace the ejtag specification states that pc trace provides 3bit code on the tpc output when an exception occursthepcstpinsgivetheexpcodeinordertodistinguishbetweentheeightvectoredinterruptsinthe lx8380 from all other exceptions the lx8380 employs 4bit code for all exceptions other than vectored interrupts the most significant bit of the 4bit code is zero and thesignal name io description jpt_tpc_dr m bitsopthe pc value is output on these pins when pcdiscontinuity occursa tpc0 is multiplexed with tdo in the singleprocessor pc trace solutionjpt_pcst_dr n3 bitsop pc trace status outputs current instruction type every dclk jpt_dclk op pcst and tpc clock frequency determined as fraction of sysclk via the n parameter maximum frequency of dclk is 100mhz signal parameter min max unit jtag_dclk frequency dc 100 mhz dclk high time 4 ns low time 4 ns tpc setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns pcst setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns 1 based on epi interface speciﬁcations for majictm and majicplus tmrevision 14 lexra proprietary confidential 123lx8380 section 10 ejtag debug remaining 3bits are the standard 3bit code note that this includes the standard software and hardware interrupts numbered 0 through 7 for vectored interrupts the most significant bit is always 1 the 4bit code is simply the number of the vectored interrupt from 8 through 15 being taken since the target of the vectored interrupt is determined by the contents of the intvec register the debug softwarewhichmonitorstheejtagpctracecodesmustbeawareofthecontentsofthisregisterinorderto trace the code after the vectored interrupt is taken for probes that do not support 4bit exception code the lx8380 can be configured via the ejtag_xv_bits lconfig option to use only the 3bit standard codes in that case if vectored interrupt is taken the 3bit code for reset will be presented 1026 demultiplexing of tdo and tdi during pc trace normally ejtag tdi and tdo are multiplexed with the debug interrupt dint and tpc0 when in pc trace mode this reduces the number of pins required by pc trace but prevents any access to ejtag registers during pc trace to allow access to ejtag registers during pc trace and to facilitate pc trace in multiprocessor environments the lconfigoption jtag_trst_is_tpcyes causes tdi and tdo to be demultiplexed such that trst is used as tpc0 and dint is generated via ejtag registers 103 data break exceptions for lx8380 the existing ejtag data match architecture does not allow matches for some of the transaction types in the lx8380 this is described in more detail below 1031 data break data matches on lbus split transactions databreakmatchesaddressandordataonlbussplittransactionsarenotsupportedsuchtransactionsare generated by any contextswitch instruction csw instructions 1032 data breaks on write descriptor accesses data breaks on the address or data of write descriptor all wd instructions accesses are not supported 1033 support for the loadtwin instruction data matches on the loadtwin instruction are supported the 32bit entry in the data value break register willbecomparedtobothhalvesofthe64bitdatareturnedbythisinstructionthereforeanymaskingofthe data byte lanes must be copied from bits 74 byte lane mask30 to bits 118 in the data break control register to ensure the same mask is applied across both words returned124 lexra proprietary confidential revision 14section 10 ejtag debug lx8380revision 14 lexra proprietary confidential 125lx8380 appendix instruction formats appendix ainstruction formats this appendix documents the lx8380 instruction encodings that are not included in the standard mipsi r2000r3000 instruction set a1 major opcodes table 48major opcode instruction formats table 49 major opcode bit encodings31 26 25 21 20 16 15 6 assembler mnemonicmajor opcode rs rt immediate cache cache base op offset user deﬁned ce1imm rs rt user deﬁned 655 1 6 inst2826 inst3129 0 1 234567 0 special 1 2 3 ce1imm ce1imm ce1imm ce1imm special2 lexop2 4 5 cache 6 7 lexop126 lexra proprietary confidential revision 14appendix instruction formats lx8380 a2 lexop2 instructions table 50 lexop2 load instruction formats table 51 lexop2 write descriptor instruction formats31 26 25 21 20 16 15 6 5 0 assembler mnemoniclexop2 011 110 rs rt immediatelexop2 subop ltw lexop2 rs rteven 0 displacement8 ltw lwcsw lexop2 base rt displacement4 lwc ltcsw lexop2 base rteven 0 displacement8 ltc lqcsw lexop2 base rtquad 00 displacement16 lqc 655 1 0 6 base rt selects general register r0 r31 rteven selects general register evenodd pair r0r1 r2r3 r30r31 rtquad selects general register quad r0r1r2r3 r28r29r30r31 displacement signed 2scomplement number in bytes 31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 rs rt rd deviceidlexra subop wd lexop2 rs rt 0 deviceid wd wdcsw lexop2 rs rt 0 deviceid wdc wdlwcsw lexop2 rs rt rd deviceid wdlwc wdltcsw lexop2 rs rt rdeven0 deviceid wdltc wdlqcsw lexop2 rs rt rdquad00 deviceid wdlqc 65 555 6 rs rt rd selects general register r0 r31 rdeven selects general register evenodd pair r0r1 r2r3 r30r31 rtquad selects general register quad r0r1r2r3 r28r29r30r31 deviceid indicates bits 73 of system device addressrevision 14 lexra proprietary confidential 127lx8380 appendix instruction formats table 52 lexop2 context checksum and bit field formats 31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 rs rt rd 0lexra subop mycx lexop2 0 0 rd 0 mycx postcx lexop2 rs rt 0 0 postcx csw lexop2 rs 0 0 0 csw extiv lexop2 rs rt rd 0 extiv insv lexop2 rs rt rd 0 insv acs2 lexop2 rs rt rd 0 acs2 msb lexop2 rs rt rd 0 msb jor lexop2 rs rt 0 0 jor 65555 6 31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 rs rt widthkeysize offsetlexra subop seti lexop2 rs rt width offset seti clri lexop2 rs rt width offset clri extii lexop2 width rt rd offset extii insi lexop2 rs rt rd offset insi hash lexop2 rs 0 rd keysize hash 65555 6 rs rt rd selects general register r0 r31 width 5bit encoding of the width parameter modulo 32 ie the value 32 is represented as 0 offset 5bit encoding of the offset parameter in the range 031 keysize 5bit encoding of the keysize parameter in the range 424128 lexra proprietary confidential revision 14appendix instruction formats lx8380 table 53 cross context move format table 54 lexop2 subop bit encodings31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 0 rtgtct rdgdcd 0lexra subop mfcxg lexop2 0 gt rd 0 mfcxg mtcxg lexop2 0 rt gd 0 mtcxg mfcxc lexop2 0 ct rd 0 mfcxc mtcxc lexop2 0 rt cd 0 mtcxc 65555 6 rt rd selects general register r0 r31 in the current context gt gd selects general register r0 r31 in the context specified by movecx ct cd selects context register in the context specified by movecx 00000 cxstatus 00001 cxpc others reserved inst20 inst53 0 1234567 0 hash seti acs2 insv insi 1 jor msb clri extiv extii 2 3 4 mycx mfcxg mtcxg 5 postcx mfcxc mtcxc 6 csw lqc wdc wdlqc ltc lwc wdltc wdlwc 7w d ltwrevision 14 lexra proprietary confidential 129lx8380 appendix instruction formats a3 cop0 instructions table 55 cop0 instruction formats these encodings are variants of the standard mtc0 and mfc0 instructions that allow access to the lexra coprocessor 0 registers listed below as with any cp0 instruction coprocessor unusable exception is taken in user mode if the cu0 bit is 0 in the cp0 status register when these instructions are executed table 56 cop0 subop bit encodings31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniccop0 010 000 rs rt rd 0cop0 subop mflxc0 cop0 mflx 00011rs rd 00000 lxc0 mtlxc0 cop0 mtlx 00111rs rd 00000 lxc0 deret cop0 00000 00000 00000 00000 deret 6555 1 1 rt selects general register r0 r31 rd selects lexra coprocessor 0 register 00000 estatus 00001 ecause 00010 intvec 00011 cvstag for lexra diagnostic purposes only 00100 movecx 00101 reserved 0011x reserved 01xxx reserved 1xxxx reserved inst20 inst53 0 1234567 0 lxc0 1 2 3 deret 4 5 6 7130 lexra proprietary confidential revision 14appendix instruction formats lx8380 a4 special instructions table 57 special instruction formats table 58 special subop bit encodings table 59 special2 instruction formats31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemonicspecial 000 000 copz rs rt rd 0special subop movn special rs rt rd 00000 movn movz special rs rt rd 00000 movz user defined special rs rt rd 00000 ce1reg 65555 6 inst20 inst53 0 1234567 0 1 movz movn 2 3 4 5 6 7ce1reg ce1reg ce1reg ce1reg ce1reg ce1reg 31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemonicspecial2 000 000 copz rs rt 0 0special2 subop sdbbp special2 00000 00000 00000 00000 sdbbp 6 55556revision 14 lexra proprietary confidential 131lx8380 appendix instruction formats table 60 special2 subop bit encodings inst20 inst53 0 1234567 0 1 2 3 4 5 6 7 sdbbp132 lexra proprietary confidential revision 14appendix instruction formats lx8380revision 14 lexra proprietary confidential 133lx8380 appendix b lconfig forms appendix blconﬁg forms b1 conﬁguration options for the lx8380 processor this section provides summary of the configuration options available with lconfig refer to lconfigforms for detailed description of these form options table 61 conﬁguration options lconﬁg option description cbi_wbuf cbus interface write buffer depth ce0 custom engine 0 ce1 custom engine 1 clock_buffers clock buffers at toplevel module contexts number of contexts threads in the processor cop1 coprocessor interface 1 cop2 coprocessor interface 2 cop3 coprocessor interface 3 bmc dcache data cache size dcache_policy data cache writebackwritethrough policy selection dmem local scratch pad data ram ejtag ejtag debug support ejtag_data_break number of data breaks to be compiled ejtag_dclk_n ejtag pctrace dclk n parameter ejtag_inst_break number of instruction breaks to be compiled ejtag_tpc_m ejtag pctrace tpc m parameter ejtag_xv_bits ejtag pctrace number of exception vector bits icache instruction cache size imem local instruction ram with line valid bits jtag internal jtag tap controller with ejtag support jtag_trst_is_tpc trst pin is tpc out instead of tdotpc mux lbc_rbuf lexra bus controller read buffer depth lbc_rdbypass lexra bus controller read bypass enable134 lexra proprietary confidential revision 14appendix b lconfig forms lx8380 lbc_sync_mode lbc synchronousasynchronous selection line_size cache line size in words dmem_width local scratch pad data memory width lmi_range_source source of lmi address ranges mem_first_word cache line ﬁll ﬁrst word mem_line_order cache line ﬁll beat ordering mmu memory management unit implementation mmu_page_size memory page size pc_trace ejtag pc trace pins product lexra processor name regfile_tech register ﬁle technology reset_buffers reset buffers at toplevel module reset_type ﬂipﬂop reset method scan_insert controls scan insertion and synthesis scan_mix_clocks scan chains can cross clock boundaries scan_num_chains number of scan chains scan_scl scan collar insertion on ram interfaces sen_buffers scan enable buffering sen_dist scan enable distribution method system_interface system bus interface type technology identiﬁes target technology thread_scheduler location of thread scheduler tlb_entries number of entries in translation lookaside buffer wdesc_addr write descriptor upper address bits writethrough_range writethrough range for writeback data cachelconﬁg option descriptionrevision 14 lexra proprietary confidential 135lx8380 appendix c port descriptions appendix cport descriptions table62 shows the possible port connections for the top level module of the lx8380 processor known as lx2 the actual lx2 ports that are present depends upon lconfig settings port names that include trailing _n or intermediate _n_ indicate active low signals all other signals are active high unless otherwise indicated all input ports must be connected to valid logiclevel sources the information in the tables timing column indicates the point within cycle when the signal is stable in terms of percent the timing column also includes parenthetical references to these notes 1 clocked in the jtag_clock domain 2 clocked in the busclk domain if is asynchronous otherwise clocked in the sysclk domain 3 does not require constraint eg clock 4 aconstantthatistreatedasafalsepathfortiminganalysistheseinputsmustnotchangeafter the processor is taken out of reset 5 timing is speciﬁed with symbol in techvarsscr script eg ram timing 6 atestrelatedinputoroutputthatistreatedasfalsepathfortiminganalysissuchinputsmust not change during normal atspeed operation 7 an asynchronous input if clock domain is specified the signal is clocked in the sysclk domain forsinglebitsignalsthesignalnameandsignaldescriptionindicatetheactionorfunctionwhenthesignalis in the active state table 62 lx8380 processor port summary port name io timing description clocking reset interrupts and control sysclk input 3 processor clock busclk input 3 bus clock if processor is conﬁgured with async lbc resetn input 10 warm reset or reset button active low cresetn input 10 cold reset or power on active low136 lexra proprietary confidential revision 14appendix c port descriptions lx8380 reset_d1_r_n input 30 sysclkdomainresetcombinationofresetn cresetn ejtag reset_d1_br_n input 30 busclkdomainresetcombinationofresetn cresetn ejtag reset_pwron_c1_n input 30 power on reset copy for jtag reset_pwron_d1_lr_n input 30 sysclk domain power on reset for ejtag reset_d1_r_n_o output 30 sysclkdomainresetcombinationofresetn cresetn ejtag reset_d1_br_n_o output 30 2 busclkdomainresetcombinationofresetn cresetn ejtag reset_pwron_c1_n_o output 30 power on reset copy for jtag reset_pwron_d1_lr_n_o output 30 sysclk domain power on reset for ejtag intreq_n152 input 7 interrupt requests level sensitive active low ext_halt_p input 50 external stall line tie to 0 if not used 1 stall pipeline next cycle 0 advance pipeline if internal stalls conﬁguration cfg_tlb_disable input 4 disable tlb mappings even if the tlb is present cfg_hlenable input 4 strap to one to enable internal hilo registers cfg_memsequential input 4 strap to one if line reads return words in sequential order zero if interleave order cfg_memzerofirst input 4 straptooneiflinereadsreturnwordzeroﬁrst zero if desired word ﬁrst cfg_lbcwbdisable input 4 strap to one to disable read bypass of lbc write buffer zero to allow read bypass cfg_procnum70 input 4 strapped with processor number cfg_ejtnminus110 input 4 strap with ejtag dclk n minus 1 conﬁgura tion 0314 cfg_ejtmlog210 input 4 strap with ejtag m log2 031248 conﬁg uration cfg_ejt3bitxvtpc input 4 strap with etjag 3bit tpc conﬁguration cfg_ejtbit0m16 input 4 strap with ejtag pc bit0 in tpc conﬁgura tion cfg_dwbase3110 input 30 strapped with dmem base address conﬁgura tion value cfg_dwtop2310 input 30 strapped with dmem top address conﬁgura tion value cfg_iwbase3110 input 30 strapped with imem base address conﬁgura tion valueport name io timing descriptionrevision 14 lexra proprietary confidential 137lx8380 appendix c port descriptions cfg_iwtop2310 input 30 strappedwithimemtopaddressconﬁguration value cfg_dwdisw input 4 strap to one to disable processor dmem writes must be zero for lx8380 test and debug jtag_reset_o output 20 1 jtag is in testlogicreset state active low jtag_reset input 6 jtag is in testlogicreset state active low tap_reset_n_o output 20 1 tap controller reset tap_reset_n input 6 tap controller reset jtag_tdo_nr output 50 1 test data out active low jtag_tdi input 60 1 test data in jtag_tms input 60 1 test mode select jtag_clock input 3 test clock jtag_trst_n input 6 test reset jtag_capture output 20 1 jtag is in data register capture state jtag_scanin output 50 1 scan input to chain jtag_scanout input 50 1 scan output from chain jtag_ir40 output 20 1 contents of instruction register jtag_shift_ir output 20 1 jtag is in shift instruction register state jtag_shift_dr output 20 1 jtag is in shift data register state jtag_runtest output 20 1 jtag is in runtest state jtag_update output 20 1 jtag is in data register update state ejc_ecrprobeen_r output 30 one indicates ejtag probe is active jpt_pcst_drm10 output 30 ejtag pc trace status m 1 2 4 or 8 jpt_tpc_drn310 output 30 ejtag pc trace value n 1 2 3 or 4 jpt_dclk output 3 ejtag pc trace clock sen input 6 scan enable active high tmode input 6 test mode active high sink0 input 6 scan input k can range from 7 to 0 soutk0 output 6 scan output k can range from 7 to 0port name io timing description138 lexra proprietary confidential revision 14appendix c port descriptions lx8380 data ram dma access dmadw_rclk input 3 data ram dma clock dmadw_dataindex174 input 5 data ram dma address max size dmadw_datard630 output 5 data ram dma read data 128bit interface is optional dmadw_datawr630 input 5 dataramdmawritedata128bitinterfaceis optional dmadw_datacs input 5 data ram dma chip select dmadw_datacsn input 5 data ram dma chip select active low dmadw_datare input 5 data ram dma read enable dmadw_dataren input 5 data ram dma read enable active low dmadw_datawek0 input 5 data ram dma write enable where k is 3 for word write granularity 15 for byte write granularity dmadw_datawenk0 input 5 data ram dma write enable active low wherekis3forwordwritegranularity15for byte write granularity lbc interface to lbus laddro310 output 20 2 address lcmdo80 output 20 2 output command ldatao630 output 20 2 output data ldatai630 input 50 2 input data lirdyo output 20 2 lbc initiator ready lirdyi input 30 2 system initiator ready lframeo output 20 2 lbc transaction frame lframei input 30 2 system transaction frame lsel input 30 2 system slave select ltrdyi input 30 2 system target ready lgtido150 output 2 20 lbc global thread id lid output 20 2 instructiondata luc output 20 2 1 uncacheable transfer 0 cachable transfer lcoe90 output 20 2 command output enable identical copies are provided to relieve the fanout ltoe output 20 2 transaction output enable ldoe70 output 20 2 data output enable identical copies are pro vided to relieve the fanoutport name io timing descriptionrevision 14 lexra proprietary confidential 139lx8380 appendix c port descriptions lreq output 50 2 bus request lgnt input 30 2 bus grant coprocessor interface z12 czcondin input 80 cop branch ﬂag czrd_addr40 output 50 cop read address czrd_cntx20 output 40 cop read context number czrhold output 45 cop hold condition one stalls coprocessor czrd_gen output 50 cop general register read command czrd_con output 50 cop control register read command czrd_data310 input 80 cop read data czwr_addr40 output 20 cop write address czwr_cntx20 output 30 cop write context number czwr_gen output 20 cop general register write command czwr_con output 20 cop control write address command czwr_data310 output 30 cop write data czinvld_m output 60 cop invalid instruction ﬂag one indicates invalid instruction in m stage czxcpn_m output 60 cop exception ﬂag one indicates exception in m stage custom engine interface cei_ce1hold output 45 cpu is halting custom engine cei_ce1invld_m output 40 instruction is not valid m stage cei_ce1invldp_s_r output 30 instruction is not valid s stage cei_xcpn_m_c1 output 40 cpu reports exception cei_ce1op_s_r110 output 30 custom engine op code cei_instm32_s_r_c1_n output 30 one indicates 32bit instruction mode zero indicates 16bit instruction mode cei_ce1aop_e_r310 output 35 operand cei_ce1bop_e_r310 output 35 b operand ce1_res_e310 input 45 result from custom engine ce1_sel_e_r input 30 one indicates custom engine opcode is present in stage ce1_halt_e_r20 input 20 custom engine stalls processor by driving to ones allows processor to run by driving to zeros copies must be supplied from multiple registers to meet timing requirementsport name io timing description140 lexra proprietary confidential revision 14appendix c port descriptions lx8380 cbus interface cbus_yreqo output 20 0 request present1 request present cbus_yaddro310 output 20 address cbus_yreado output 20 1read 0write cbus_yszo30 output 20 transfer size 4b1000 byte 4b1001 2 bytes 4b1011 word 4b1101 2 words 4b0000 4 words cbus_ylineo output 20 1line access 0single access cbus_ydatao630 output 20 write data cbus_ysplto output 20 1split 0normal transaction cbus_yltido30 output 20 local thread id cbus_yuco output 20 1uncached 0cached access cbus_ysrco30 output 20 transaction source within lx8380 4b0001 instruction cache 4b0010 data cache or ejtag dma write 4b0100 ejtag dma read 4b1000 bmc cbus_ydbusyo output 20 1 lx8380 is not ready to receive data for data read or data split read any return read data with valtype of data read or data split read will be ignored by the lx8380externallogicmustholdsuchdata cbus_ydbusyo is deasserted 0 lx8380 is ready to receive data cbus_ybusyi input 80 1externallogiccannotacceptrequestexter nal logic ignores any current request 0 external logic is ready to accept request cbus_ydatai630 input 80 read data cbus_yltidi30 input 80 context associated with read data cbus_yvaltypei30 input 80 indicates valid read data of certain type 4b0000 valid read data 4b0001 instruction cache 4b0010 data cache 4b0100 ejtag dma 4b1000 bmc cbus_yspltszi20 input 80 size of split read data beat 3b000 1 byte 3b001 2 bytes 3b011 1 word 3b100 2 words cbus_yidlei input 80 indicates external cbus_y device has pending read or write transactionsport name io timing descriptionrevision 14 lexra proprietary confidential 141lx8380 appendix c port descriptions event control and thread scheduling ext_clearwtevnt_r n810input 30 clear status wait event bits where n is the number of contexts cx_stusthwait_r n10 output 30 bits set to one indicate which contexts are waiting for events where n is the number of contexts cx_threadactv_rn10 output 30 abitsetoneindicateswhichcontextifanyis active where n is the number of contexts ext_nxtcntx_p_r20 input 30 external scheduler next context ext_nextcntxrdy_p_r input 30 external scheduler next context is ready cx_stusthprio_rn310 output 30 thread priority statusport name io timing description142 lexra proprietary confidential revision 14appendix c port descriptions lx8380revision 14 lexra proprietary confidential 143lx8380 appendix d pipeline stalls appendix dpipeline stalls this appendix documents the stall conditions that may arise in the lx8380 d1 stall deﬁnitions issue stall an invalid instruction enters each pipe while any other valid instructions in the pipe advance pipeline stall all instructions in the pipe stay in the same stage and do not advance stall if not otherwise qualified means pipeline stall d2 instruction groupings table 63 instruction groupings for stall deﬁnition d3 nonsequential program flow issue stalls jrjalr two issue stalls after the delay slot instruction j jalx and taken branchesgroup name instructions in group miloadstore lb lh lw lbu lhu lwc1 lwc2 lwc3 sb sh sw swc1 swc2 swc3 mimac multu divu mfhi mflo mthi mtlo madh madl mazh mazl msbh msbl mszh mszl micontrol j jalx jr jalr bltzal bgezal linked branches syscall break all copz mfcz cfcz mtcz ctcz bcfz bctz rfe lwcz swcz also in loadstore group mtlxc0 mflxc0 lexraspeciﬁc miunlinkedbranch beq bne blez bgtz bltz bgez migeneral all remaining instructions mivcmove movz movn nvxloadstore ltw ejtagcontrol deret sdbbp144 lexra proprietary confidential revision 14appendix d pipeline stalls lx8380 stall cycles after the delay slot instruction nottaken branches two issue stalls after the delay slot instruction the branch rules are consequence of the fact that all branches are predicted to be taken d4 loadstore rules loaduse astage single cycle pipeline stall afteraloadinstructiontoatargetregisteraninstructionwhichfollowstheloadinthepipelineby two cycles and uses that target register of the load will pipeline stall for one cycle storeload data ram access stall load instruction which follows store instruction by two cycles always causes onecycle stall note this stall only applies if the store instruction hits in the data cache storestore tag ram access stall second store instruction which follows first store instruction by two cycles causes one cycle stall if the first store is to previously clean line of writeback cache note this stall only applies if the first store instruction hits in the data cache storeload data readafterwrite stall aloadinstructionwhichfollowsastoreinstructionbyonecyclecausesatwocyclestallifthe load accesses data at the same word address as the store for twinword load instructions either of the load word addresses may match the store word address storestore tagdirtybit readafterwrite stall hardware detects the case of backtoback stores to the same line and eliminates any replay of the second store to access the tagdirtybit storeload tag invalidate tag ram access stall store or load instruction that follows by two cycles an uncached store or load instruction that causes tag invalidate causes onecycle stall storeload tag invalidate readafterwrite stall astoreorloadinstructionthatfollowsbyonecycleanuncachedstoreorloadinstructionthat causesataginvalidatecausesatwocyclestallifthesecondinstructionaccessesdatainthesamerevision 14 lexra proprietary confidential 145lx8380 appendix d pipeline stalls cache line as the first instruction d5 mac ops interlock matrix themaceliminatesallprogramminghazardsbetweenmacinstructionsbystallingthepipelineasnecessary thisisdonebothtoavoidresourceconflictsaswellastowaitforresultsofafirstinstructionthatisneededby second instruction the following table indicates the number of cycles that must be inserted between the first indicated instructionandthesecondazeroordashindicatesthattheinstructionscanissuebacktobacktothemac pipe with stalls nonzero number indicates the number of stall cycles that will occur if the instructions are issued in consecutive cycles these stall cycles are available for any other nonmac instructions but should not be filled with nops since that would only increase the code footprint without improving performance d6 mvcz stall the coprocessor move instructions mtcz ctcz lwcz mfcz cfcz are always followed by two cycle issue stalls thevariantsofcoprocessormoveinstructionsmtlxc0mflxc0arealwaysfollowedbytwocycleissue stalls the instructions tlbp and tlbr which update coprocessor 0 registers are always followed by two cycle issue stalls d7 tlbw stall the tlb write instructions tlbwi tlbwr are always followed by one cycle issue stall d8 movecx stall inadditiontoitsmvczstallamtlxc0instructiontothemovecxregisterisfollowedbytwomoreissue stalls for total of four issue stalls d9 mmu stalls itlb stall when the program jumps branches or increments from the most recently used page to another page in the itlb single cycle stall is incurred when the program jumps branches or increments to page not in the itlb fourcycle stall is incurred if the target vpn is mapped onecycle if the target vpn is unmapped if the target vpn is not in the joint tlb an exception is recognized when the instruction reaches the mstage tlbwitlbwr instruction invalidates any itlb entry corresponding to the overwritten joint tlb entry itlb issue stall when an itlb stall occurs due to incrementing across page boundary and there is any of the146 lexra proprietary confidential revision 14appendix d pipeline stalls lx8380 following instructions found anywhere in the last doubleword of the page then there is one issue stall in addition to the itlb stalls branch of any kind j jalx ejtag deret dtlb stall whenaloadorstoreusesabaseregisterthatisinthedtlbandhitsavpnthatisinthedtlb there is stall incurred when aload or storeusesabaseregisterthat isin thedtlb but does nothit avpn that isin the dtlb twocycle stall is incurred if the vpn is mapped onecycle if the vpn is unmapped when load or store uses base register that is not in the dtlb threecycle stall is incurred if the vpn is mapped twocycles if the vpn is unmapped notes on dtlb entry maintenance 1 tlbwitlbwr instruction invalidates any dtlb entry corresponding to the overwritten joint tlb entry 2 any instruction that updates base register invalidates on the transition dtlb entries using that register 3 dtlb entry that is invalidated per item 2 is resurrected on the ea transition with the new base register value if the invalidating instruction is one of the following 4 whenanewdtlbentryiscreatedforavpnthereplacementpolicyisfifobubblesinthe fifo that occurred because of item 2 are collapsed d10 cache miss stalls instruction cache miss stall whenaninstructioncachemissoccurstheprocessorisstalledforthedurationofthecachelinefill operation the number of cycles required to complete the line fill is system dependent instruction cache 2way soft miss stall when 2way icache is in use softmiss is defined as hit in the unpredicted way with way prediction defined as follows when not running in lock mode use the lru bit when running in lockeddown mode if the most recent lockeddown icache access hit locked line then predict way 1 the locked way else use the lru bit whenrunninginlockgathermodepredictway1thelockedwaythispreventsahitwithoutaddi addiu slti sltiu andi ori xori lui op3129 001 sll srl sra sllv srlv srav specialop53 000 add addu sub subu and or xor nor specialop53 100revision 14 lexra proprietary confidential 147lx8380 appendix d pipeline stalls softmiss on way 0 thus allowing for the invalidation of way 0 and fill to way 1 in that case also miss is forced in lockgather mode whenever the lock state is clear to allow the lock state to be set for way 1 hit that was not previously locked miss is never allowed to be soft in lockgather mode which forces the fill to way 1 in the case of way 0 hit as noted above soft miss always causes twocycle stall data cache miss stall whenadatacachemissoccursastheresultofaloadinstructiontheprocessorstallswhileitwaits for the data the data cache releases the stall condition after the required word is supplied to the processorevenifadditionalwordsmuststillbefilledintothedatacachehoweveriftheprocessor issues another load or store operation to the data cache while the remainder of the line fill is in progress the cache will again stall the processor until the line fill operation is completed the number of cycles required to complete the line fill is system dependent evict buffer notempty stall whenadataaccessloadorstoreneedstousethesystembusandtheevictbufferisnotemptydue to previous evict operation the processor stalls while it waits for the evict buffer to empty d11 pipeline diagrams for nonsequential program flow issue stalls jr jalr jr i d s m w delayslot i d s m w notvld i notvld i target i d s j jalx and taken branches j i d s m w delayslot i d s m w target i d s m nottaken branches bntkn i d s m w delayslot i d s m w notvld i notvld i delay4 i d s loaduse astage single cycle pipeline stall 00 lw s00a0 i d s m 04 addi a04 i d s m w 08 add s1s0 i d s m w 0c add t1t2 i d s s m w rhold x dload_m x148 lexra proprietary confidential revision 14appendix d pipeline stalls lx8380 storeload data ram access stall 00 sw s000a0 i d s m w 04 foo i d s m m w 08 lw s232a0 i d s m w rhold x storestore tag ram access stall 00 sw s000a0 i d s m w 04 foo i d s m m w 08 sw s232a0 i d s m w rhold x storeload data readafterwrite stall 00 sw s000a0 i d s m w 04 lw s200a0 i d s m w rhold x x d12 pipeline diagram for mac ops interlock stall 00 mult s0s1 i d s m 04 lw s00a0 i d s m m m w 08 lw s10a0 i d s m m m w 0c mflo v0 i d s m w 10 sw v00a1 i d s s s m w multcount4s 0 1 2 3 4 rhold x x d13 pipeline diagram for mvcz stall 00 mtc0 i d s m w 04 foo i d d d s m w 08 foo1 i d s m w d14 pipeline diagram for tlbw stall thehandlerforatlbexceptioncanreturntotheoffendinginstructionafterwritinganewjtlbentrywithrevision 14 lexra proprietary confidential 149lx8380 appendix d pipeline stalls the following canonical code fragment 00 tlbwr i d s m w 04 jr i d d s m w 08 rfe i d s m w 0c foo i d 10 foo i tgt i i i i i d itlbrequest x jtlbresponse x select new pfn to ram x thetargetofthejrcanuseforitsifetchthenewlycreatedjtlbentrythatiswritteninthewstagethisis duetothesingleissuestallafterthetlbwandthefactthatthejrtargetaddressisresolvedintheestageof the jr it is also true that any data access in the target or subsequent instructions can use the newly created jtlb entry d15 pipeline diagrams for dtlb stalls base assumption all cases dtlb entry exists for lw r1 0r2 where r2 is page aligned case 1 stall 00 lw r14r2 i d s m w dtlb_hit_s x case 2 reghit vpnmiss vpn mapped create new entry 00 lw r14r2 i d s m w 04 lw r38r2 i d s s s m w dtlb_reghit_s x x dtlb_vpnhit_s x case 3 regmiss vpn mapped create new entry 00 lw r14r2 i d s m w 04 lw r38r2 i d s s s s m w dtlb_reghit_s x dtlb_vpnhit_s x case 4 reginvalidate vpn mapped 00 lw r20r2 i d s m w 04 foo i d s m w 04 lw r30r2 i d s m w dtlb_reghit_s dtlb_vpnhit_s 150 lexra proprietary confidential revision 14appendix d pipeline stalls lx8380 case 5 reginvalidate and resurrect stall 00 addiu r2r24 i d s m w 04 foo i d s m w 04 lw r30r2 i d s m w dtlb_reghit_s x dtlb_vpnhit_s x case 6 vector add cab stalls after initialization dtlb entries valid for cbase r1 abase r2 bbase r3 all initially page aligned 00 sw r70r1 i d s m w 04 addiu r1r14 i d s m w 08 lw r50r2 i d s m w 0c addiu r2r24 i d s m w 10 lw r60r3 i d s m w 14 addiu r3r34 i d s m w 18 bne r3r900 i d s m w 1c add r7r5r6 i d s m w dtlb_reghit_s x x x dtlb_vpnhit_s x x x d16 pipeline diagrams for cache misses instruction cache miss stall 08 foo0 i d s m w 0c foo1 i d s m w 10 foo2 i d i d s m w rhold x x x x x instruction cache 2way soft miss stall 08 foo0 i d s m w 0c foo1 i d s m w 10 foo2 i d i d s m w 14 foo3 i d s m w rhold x x data cache miss stall 04 lw i d s m w 08 foo1 i d s m m m m m w 0c foo2 i d s m w rhold x x x xrevision 14 lexra proprietary confidential 151lx8380 index address translation smmu 31 alu instructions 22 arbitration lbus 107 b badvaddr register 34 bmc block move controller example transfer ﬂow 116 overview 109 branch instructions 26 bus controller see lbc byte alignment cbus 79 lbus 93 c cache see local memory cause register 33 cbus byte alignment 79 interleave order 78 protocol 81 signals 80 transaction descriptions 81 write buffer 78 ci see coprocessor interface conditional move instructions 25 control instructions 27 coprocessor 36 coprocessor instructions 28 coprocessor interface attaching coprocessors 59 operations 60 pipeline 61 signals 59 cp0 system control processor 9 d data cache see local memory debug interface see ejtag delay slot branch instructions 26 cause register branch delay ﬂag 33 coprocessor instructions 28 exceptions in branch delay slot 34 jump instructions 27 depc register 10 desave register 10 dreg register 10 ecause register 35 ejtag cp0 registers 10 overview 119 pc trace 121signals 120 epc register 34 estatus register 35 exception processing delay slot 34 entry and exit 34 prioritized interrupt exception vectors 36 priority list 32 registers 33 extivinstructions 46 i instruction cache see local memory instructions acs2 57 127 add 22 addi 22 addiu 22 addu 22 alu 22 and 22 andi 22 bczf 29 bczt 29 beq 26 bgez 26 bgezal 26 bgtz 26 blez 26 bltz 26 bltzal 26 bne 26 branch 26 break 27 cache 68 125 cfcz 28 clri 45 127 conditional move 25 control 27 coprocessor 28 csw 40 127 ctcz 28 custom engine 125 130 deret 129 extii 48 127 extiv 127 hash 50 127 insi 49 127 insv 47 127 j2 7 jal 27 jalr 27 jor 51 127 jr 27 jump 26 lb 24 lbu 24 lh 24152 lexra proprietary confidential revision 14lx8380 lhu 24 liu 23 load 24 lqcsw 41 126 ltcsw 41 126 ltw 24 126 lw 24 lwcsw 40 126 lwcz 28 mfcxc 56 128 mfcxg 56 128 mfcz 28 mflxc0 129 movn 25 130 movz 25 130 msb 50 127 mtcxc 56 128 mtcxg 56 128 mtcz 28 mtlxc0 29 129 mycx 40 127 nor 22 or 22 ori 22 postcx 40 127 rfe 27 sb 24 sdbbp 130 seti 45 127 sh 24 sll 23 sllv 23 slt 23 slti 23 sltiu 23 sltu 23 sra 23 srav 23 srl 23 srlv 23 store 24 sub 22 subu 22 sw 24 swcz 28 syscall 27 wd 42 126 wdcsw 42 126 wdlqcsw 44 126 wdltcsw 43 126 wdlwcsw 43 126 xor 22 xori 22 interleave order cbus 78 lbus 89 interrupts nonprioritized 33 prioritized 35 prioritized interrupt exception vectors 36 intvec register 36 j jump instructions 26k kseg0 31 kseg1 31 kseg2 31 kuseg 31 l lbc lexra bus controller commands issued 95 read buffer 95 signals 106 lbus lexra system bus arbitration 107 bus operations 88 byte alignment 93 commands 92 connecting devices to 107 diagram 87 interleave order 89 signals 91 terminology 88 transaction descriptions 96 lconfig conﬁguration forms 133 load instructions 24 local memory cache invalidation control 67 data cache 71 data memory dmem 75 disabling 66 instruction cache 68 instruction cache locking 66 instruction memory imem 70 overview 65 p pc trace ejtag 121 pipeline coprocessor interface 61 processor 9 prid register 10 prioritized interrupts 35 processor modules 8 ralu data path 9 system control processor cp0 9 r ralu data path 9 ram see local memory read buffer lbc 95 registers badvaddr 34 cause 33 cp0 registers table 10 depc 10 desave 10 dreg 10 ecause 35 epc 34 estatus 35 invtec 36 prid 10 status 33 s smmu simple memory management unit 31revision 14 lexra proprietary confidential 153lx8380 status register 33 store instructions 24 system bus see cbus and lbus system control processor cp0 9 u upperkseg2 31 w write buffer cbus 78154 lexra proprietary confidential revision 14lx8380