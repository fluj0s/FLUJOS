lx4580 data sheet revision 31 october 11 2002 lexra inc proprietary and confidential do not copy copy number lx4580 data sheet revision 31 october 11 2002 lexra proprietary and confidential copyright 2002 lexra inc all rights reserved mips and mips32 are trademarks andor registered trademarks of mips technologies inc other trademarks are the property of their respective owners do not copy lx4580 lexra inc proprietary confidential i rev 31 october 11 2002 do not copytable of contents chapter 1 lx4580 product overview 11 introduction 1 12 key features 2 13 specifications 3 14 lx4580 architecture 3 141 lx4580 cpu 3 142 finegrained hardware multithreading hmt 4 15 interfaces 5 16 software support 5 161 operating systems 5 162 development tools 5 chapter 2 mips32 implementation specifics 21 mips32 implementation specifics overview 7 22 mips32 instructions 7 221 llsc 7 222 sync 8 223 pref 8 224 cache 9 225 wait 9 226 divide all variants 9 227 udi 9 23 cp0 registers 10 24 interrupts 13 25 exceptions 14 251 reset context wait and ejboot 15 252 dm wait and ejtag debug exceptions 15 26 address spaces 15 261 noncoherence for different access types 16 27 endianness 16 28 ejtag 16 29 cp0 hazards 17 210 performance counters 17 211 release 2 architecture support 19 2111 release 2 interrupt modes exceptions shadow gprs 19 2112 hazard barrier instructions 19 2113 field rotate shuffle instructions 20 2114 user access to hardware registers 20 2115 cp0 register changes 20 2116 64bit coprocessor fpu 21 2117 1kb pages 21 chapter 3 reset rst 31 reset overview 23 32 reset distribution 23 33 reset operation 24 34 reset external lx4580 interfaces 24 ii lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002chapter 4 lx4580 cpu 41 lx4580 cpu overview 25 42 lx4580 cpu core 25 43 instruction cache 26 44 data cache 26 45 cache line replacement algorithm 26 46 cpu error handling 27 461 bus error handling ibe and dbe 27 462 interrupt error response nmi 27 chapter 5 cbus_z interface zbi 51 cbus_z interface overview 29 52 cbus_z interface signal list 29 53 cbus_z endian mode 30 54 cbus_z line read interleave order 32 55 cbus_z read completion 32 56 cbus_z transaction types 32 57 cbus_z protocol 32 58 cbus_z transaction timing diagrams 33 581 backtoback subline writes with busy 33 582 line writes 34 583 read request 34 584 returning read data 35 chapter 6 ec interface eci 61 overview 37 62 ec interface signals 3 8 63 ec interface endian mode 38 64 ec interface pending requests 40 65 ec interface gasket overview 41 66 supported configurations 41 67 implementation guidance for endian mode 42 671 consistency of endian mode in the system 42 672 address invariance 42 673 data invariance 42 674 reverse endian support not recommend 43 675 endian mode and unaligned loadstore 43 68 cbus_y interface 44 681 cbus_y endian mode 45 682 cbus_y command encoding 46 683 rle rlme eviction address 47 69 ibus interface 48 691 ibus header encoding 48 610 eci actions on cbus_y commands 49 chapter 7 interrupts 71 interrupt overview 5 1 711 cross context interrupt request register cci_req 52 712 cci_intpend register one per context 53 713 cci_intmask register one per context 53 chapter 8 ejtag ej 81 ejtag differences from 200 56 lx4580 lexra inc proprietary confidential iii rev 31 october 11 2002 do not copy811 ejtag tap registers 56 812 ejtag registers in ff3 drseg 58 82 description of lx4580 cpu specific ejtag features 59 821 disable other contexts doc ejtag control registe r bit 6 59 822 context select cxs ejtag control register bits 3029 59 823 context in debug mode cdm ejc bits 2827 59 824 cntxuse cntx in breakpoint control registers 60 825 precise data breaks 60 826 data value break loads 60 827 ejtag_addr 36bit 60 828 pc trace buffer tac 60 829 instruction replay 64 8210 dmwait 64 8211 debug mode overrides disable context 65 8212 ejtag boot 65 8213 the lexra probe 65 8214 access to ejtag memory space 65 chapter 9 interfaces 91 interfaces 67 iv lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002 lx4580 lexra inc proprietary confidential vii rev 31 october 11 2002 do not copylist of figures figure 1 lx4580 diagram 3 figure 2 reset overview 2 3 figure 3 lx4580 cpu and system interface 25 figure 4 cbus_z interface zbi 29 figure 5 cbus_z backtoback subline writes with busy 33 figure 6 cbus_z line write 34 figure 7 cbus_z read requests 34 figure 8 cbus_z subline read data and dbusy 35 figure 9 read data for line read request 35 figure 10 ec interface eci 3 7 figure 11 ec interface gasket eci 41 figure 12 lx4580 interrupt logic 51 figure 13 lx4580 etjag organization 55 figure 14 cpu ejtag block diagram 61 viii lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002 lx4580 lexra inc proprietary confidential ix rev 31 october 11 2002 do not copylist of tables table 1 summary of lx4580 interfaces 5 table 2 standard cp0 registers 10 table 4 interrupt sources 1 3 table 3 implementation dependent cp0 registers 13 table 5 exception list 14 table 6 cntxsel bits 1311 field of perfcnt control regist ers17 table 7 event field of perfcnt control registers 17 table 8 hardware register values 20 table 9 reset external interface 24 table 10 cache line replacement algorithm 26 table 11 cbus_z signal list 29 table 12 effect of endian mode on cbus_z 31 table 13 ec interface signals 38 table 14 effect of endian mode on ec interface 39 table 15 supported configurations 41 table 16 big endian unaligned loadstore address adjustment s 43 table 17 little endian unaligned loadstore address adjust ments44 table 18 cbus_y request interface 44 table 19 cbus reply interface 45 table 20 effect of endian mode on cbus_y 45 table 21 cbus_y commands 46 table 22 cbus_y source encoding 47 table 23 cbus_y destination encoding 47 table 24 cbus_y reply encoding 47 table 25 ibus request interface 48 table 26 ibus reply interface 48 table 27 ibus commands 48 table 28 eci actions on cbus_y requests 49 table 29 eci actions on ibus replies 49 table 30 ejtag tap registers 56 table 31 ejtag drseg registers 58 table 32 cop0 ejtag registers 59 table 33 interface summary 67 x lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002lx4580 lexra inc proprietary confidential 1 rev 31 october 11 2002 do not copychapter 1 lx4580 product overview 11 introduction the lx4580 designed to support lexras family of network communication ics is the highest performance mips32 processor optimized for hightouch packet processing applications based on lexras 3rd generation 7stage pipeline the lx4580 is able to achieve 3x the performance of other 32bit cpu platforms enabling this technology breakthrough is lexras innovative finegrained hardware multithreading hmt hmt dramatically improves system performance by its ability to alternate the execution of four hardware threads the processor stays 100 utilized even while multiple threads are servicing cache ses from system perspective the lx4580 overcomes the fundamental bottleneck to application performance memory latency additional benefits due to hmt are an increase in pipeline efficiency as well as removal of timingcritical forwarding paths stalls due to loadtouse are typically eliminated while commonly used features like branc h prediction are altogether longer needed collectively this results in die area saving and an increa in processor performance the lx4580 includes features like the coprocessor interface ci and user defined instruction udi interface are used to specialize the processor to the target application the lx4580 supports the new mips32 release 20 isa to leverage rich legacy of tools application software and operating systems available for the mips architecture with its optional memory management unit mmu the lx4580 supports linux smp running on the hardware threads in single and multi processor systems software views the lx4580 as four virtual cpus or hardware threads running in parallel cache coherency is maintained for data accesses among the multiple contexts applications using concurrent kernel threads or user processes will run on the lx4580 virtually unchanged while taking full advantage of hmt alternatively single threaded rtos such as vxworks can run on one thread while other threa ds function as coprocessors the lx4580 cpu provides the ultimate in both performance and flexibility required to execute demanding high touch applications the lx4580 cpu implements the mips32 isa with additional specialized instructions for optimized packet processing peak processor performance is 700 dhrystone 21 mips the cpu incorporates lexras innovative finegrained hardware multithreading hmt technology as result high cpu performance can be sustained even while l1 cache misses re serviced the cpu includes 64bit mips ectm interface for connection to main memory and other peripherals this interface provides access to wide range of soc interconnect and modules such as dram controllers pci and amba bridges and custom io interfaces the optional cbus interface provides an easy to use but powerful alternative for connection to proprietary or third party buses target applications for the lx4580 include enterprise security systems these systems provide specialized services such as vpn firewall and intrusion detection for traffic between the enterprise lan or data center and wan the lx4580 can be used for either linuxbased application services or for frontend network processing in these systems web appliances typical products include switches web directors web caches the lx4580 provides consolidated functionality with strong layer 47 decision making for policy and content base load balancing security session and site persistence based on http cookies ip address etc chapter 1 lx4580 product overview 2 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002 network attached storage nas servers new generation nas servers provide remote storageondemand while lowering administration costs and leverage the learning curve of 3rd party internet technology the lx4580 provides tcp termination iscsi protocol conversion and security services 12 key features processor 7stage execution pipeline mips32 release 20 isa specialized instructions for packet processing lexra isa extensions hash with key size 4 to 24 bits dual 16bit onescomplement add finegrained hardware multithreading hmt four hardware threads of execution unique register set interrupts and tlb per thread local memory interface up to 64 kb l1 instruction cache up to 64 kb l1 data cache 4way set associative configurable cache line size 16 32 64 and 128 bytes conforms to mesi coherency protocol writethrough or writeback data cache up to 1 mb fixed local instructiondata memory system bus interface optional cbus or ec interfaces split transaction cbus or pipelined ec 64bit datapath multimaster support burst mode memory management unit mmu 4 kb page size supports 36bit physical addresses 2entry itlb 4entry dtlb 24entry jtlb per thread multiplyaccumulate unit mac twocycle 32x32b multiply multiplyaccumulate enhanced jtag ejtag 200 debug singlestepping address and data breakpoints fullspeed realtime pc trace supports multiprocessor debug13 specifications lx4580 lexra inc proprietary confidential 3 rev 31 october 11 2002 do not copyuser defined instructions udi applicationspecific alu instruction extensions supports 3register operand and 2registerimmediate formats coprocessors an applicationspecific coprocessor can be attached to the coprocessor interface ci 13 specifications technology 013Âµm cmos 500 mhz processor clock worstcase 38 mm2 core area 360 mw power worstcase operating temperature 125 c junction supply voltage 12 v nominal 14 lx4580 architecture 141 lx4580 cpu the lx4580 incorporates four 4 lx4580 cpus illustrated in figure1 the lx4580 is complete risc processor subsystem optimized for highperformance packet processing the major blocks are the register file and alu ralu coprocessor 0 cp0 the local memory interfaces lmi to up to 64kb instruction cache and 6k4b data cachefigure 1 lx4580 diagramdata cache ram up to 64 kb instruction local memory interfaceejtag dataaddress system interface cbus or ec data cache ram up to 64 kbmmu opt 24 entry jtlb per contextregister file one per contextcpu 4 contexts 7stage pipe mips32tm macudi cop2alu cp0fixed inst ram up to 1 mbto debug probe fixed data ram up to 1 mbinstructions data data local memory interfacechapter 1 lx4580 product overview 4 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002lexras lx4580 cpu implements the full release 2 mips32 instruction set the mips32 optional and recommended features included in the cpu are detailed in chapter2 number of implementationspecific issues are also documented in chapter2 lexra has extended the mips32 isa with additional instructions for optimized packet processing these instructions are described in chapter2 the cpu includes an mmu and support 36bit physical addresses the cpu execution pipeline is 7stage and exclusively uses the rising edge of the processor clock the 7 stage pipeline permits full cycle for address register to data output register for both instruction cache read and data cache read as result the cpu pipeline achieves maximum performance for its implementa tion technology and methodology and will readily port to future technologies 142 finegrained hardware multithreading hmt the lx4580 cpu incorporates lexras proprietary implementation of finegrained hardware multi threading hmt although hmt is transparent to software it provides significant performance advantages to the lx4580 customer that deserve attention in this overview in lexras implementation instructions are issued roundrobin from four alternate contexts each context has an independent program counter and general register file other software visible state is also replica ted as detailed in chapter 2 in the absence of an l1 cache miss the four contexts support four independent execution threads in typical network processing programs data cache miss rates are high and singlethreaded proces sor is idle much of the time the problem can be mitigated somewhat with second level cache offering faster service time than main memory however in lexras implementation of hmt as few as two active threads can maintain 100 cpu utilization while cache misses from the other two threads are being served additional performance benefits from hmt result from the following all timingcritical internal forwarding paths are eliminated as result for specific technology and design methodology high processor clock speed is achieved branch prediction is not required there are sufficient cycles between issue slots s that branch outcome can be correctly resolved without prediction other highend risc architectures have devoted significant silicon area and power to minimizing stalls from branch prediction failures loadtouse delay is minimized the 7stage pipeline would normally require two loadto use delay cycles with hmt the loadtouse delay is zero or one cycle depending on the number of actively executing threads as result the frequency of load interlock stalls is reduced lexras simulations indicate that if 3 of instructions cause an cache miss hmt delivers 3x performance benefit compared to similar single issue cpu this performance benefit can be realized in applications with sufficient thread parallelism assigning each thread one or more independent packet flows all ows hmt to be fully exploited in the lx4580 target applications15 interfaces lx4580 lexra inc proprietary confidential 5 rev 31 october 11 2002 do not copy15 interfaces table1 summarizes the interfaces provided by the lx4580 16 software support 161 operating systems two operating systems are provided for the lx4580 linux version 24 and higher with full smp support running on all cpus and hardware threads full source code for the linux kernel is available from montavista and the hardware abstraction layer is available from lexra and montavista vxworks version 54 running on one thread the hardware abstraction layer is available from wind river 162 development tools extensive onchip debug features ejtag performance counters complete development platform cc development tool chain development board device drivers and abstraction layer sample codetable 1 summary of lx4580 interfaces name qtyperformance function ec interfacea rtl is configurable to support ec interface or cbus interface1500 mhz cpu clock interface option to system devices see chapter6 and mips ectm interface speci fication revision 105 cbus interfacea1500 mhz cpu clock interface option to system devices see chapter5 ci 1500 mhz cpu clock coprocessor interface cop2 see xref udi 1500 mhz cpu clock user defined instructions see xref ejtag 140 mhz clock scan chain debug conforms to ejtag 20 provides pctrace multiprocessor supportchapter 1 lx4580 product overview 6 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002lx4580 lexra inc proprietary confidential 7 rev 31 october 11 2002 do not copychapter 2 mips32 implementation specifics 21 mips32 implementation specifics overview the mips32 architecture defines certain features as optional or recommended in which case they ma be completely omitted from compliant implementation other mips32 features are defined as imple mentation dependent in which case one or more choices must be supported for compliance finally there ar optional extensions that an implementation may provide the purpose of this chapter is to detail the implementation dependent features of the lx4580 cpu the specifics of each of the following areas is discussed in its own section instructions cp0 registers interrupts exceptions address spaces endianness ejtag cp0 hazards release 2 features 22 mips32 instructions this section describes implementation specific details of the following mips32 instructions llsc sync pref cache wait divide all variants udi 221 llsc the unit of memory that is used to determine whether the sc should fail is one cache line that is after the ll write to any byte in the line by any other entity will cause the sc to fail in addition any load store or cache instruction between the ll and the sc by the same context when not in debug mode will cause the sc to fail any eret between the ll and sc by the same context will cause the sc to fail any store to the cache line by different context in the same cpu between the ll and sc will cause the sc to fail load or store between the ll and the sc by the same context in debug mode may cause the sc to fail in rare instances the precise conditions are described below chapter 2 mips32 implementation specifics 8 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002the remaining implementation of this feature relies solely on the state of the cache line within the l1 data cache in the cpu as follows note that there is architecturally visible cp0 lladdr register for hmt variant of the lladdr register just the data cache way and index is used for two purposes another context is not allowed to cause replacement eviction of the line between the ll and sc to prevent this the particular data cache way and index of the line used by the ll are saved while the sc is pending or until it is guaranteed to fail whichever comes first another context in the processor can store to the line forcing the sc to fail this is detected by the l1 data cache using the saved way and index if all four contexts have pending sc for the same index each to different way then way of that index is available for replacement eviction any load or store by any context that is not in debug mode will enable way for eviction without impacting the other contexts because it can cause its own context sc to fail however load or store in debug mode that requires replacement eviction in the same index will use the saved way of the context that is executing in debug mode this rare case will also cause the sc to fail for the context in question 222 sync there is only one outstanding data cache miss for either loads or stores at time for each context an uncached load prevents further progress by context until the load data returns therefore all cached loadsstores and uncached loads are strongly ordered for any given context to cover the ordering of uncached stores sync flushes uncached stores previously executed by the same context preventing forward progress by context executing the sync until all such stores are acked by their targets 223 pref the instruction is treated as nopon ll if cache miss request line shared else line is already shared or modified okay on sc if dcache miss sc fails else if already modified sc passes else request line upgrade to modified if invalidated before request completes sc fails else sc passes224 cache lx4580 lexra inc proprietary confidential 9 rev 31 october 11 2002 do not copy224 cache the following operations are supported i index invalidate d index writebackinvalidate index invalidate id index store tag id hit invalidate d hit writebackinvalidate hit invalidate d hit writeback the following are not implemented st anything i fill id index load tag id fetch and lock there are locks in instruction or data cache since the instruction and data caches are shared by all four contexts in the cpu it is the responsibility of software to avoid conflicting cache instruction execution note that the data cache writeback operations and the instruction cache invalidate operations are generally safe across contexts since they do not discard potentially modified data if the store tag operation is only used for initialization that too should be safe to use finally the data cache hit invalidate should be used with caution since it discards data that may ve been written by context different than the one executing the cache instruction 225 wait only code 0 is supported when the wait instruction is executed by context in the lx4580 cpu that context is suspended from further execution the only way to restart context after completion of wait instruction is with an enabled interrupt to that context the epc will point to the instruction after the wait since the other contexts continue execution the wait instruction does not cause the cpu clocks to stop nor are the cpu caches disabled any power savings from the wait instruction would be on gatelevel basis in that reduced pipeline activity would reduce the circuit switching current the primary benefit of the wa it instruction is to reduce contention among contexts for the cpu pipeline slots while one or more contexts are merely waiting for some external event for this reason it is preferred to software sp in loop 226 divide all variants the divider detects when the dividend has leading zeroes reducing its latency in such cases 227 udi the following user defined instructions are implemented hash rd rt keysize hash to key the 5bit keysize is value k in the range 424 the 32 source bits contained in rt are hashed to form key of k bits which is stored in rdk10 the remaining bits of rd are zeroed if k is not in the range 424 the results are unpredictable format 3126 011100 special2 2511 zerortrd 106 keysize 1 50 110000 hashchapter 2 mips32 implementation specifics 10 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002 acs2 rd rs rt dual add for checksum this instruction performs dual 16bit ones complement addition considering all quantities as unsigned 16bit integers add rs150 to rt150 and independently add rs3116 to rt3116 for each addition if there is carry out of the most significant bit of its result add one to that result to form its final result the final results are stored in rd150 and rd3116 format 3126 011100 special2 2511 rsrtrd 106 zero 50 110001 acs2 23 cp0 registers this section describes implementation specific details of the cp0 registers in table2 each of the standard mips32 release 2 cp0 registers is listed together with an indication if the register is not implemented if it is implemented there may be details on how the implementation handles certain fields in the register for registers that are implemented the column labeled hmt indicates whether it is implemented indepe ndently for each context 4 or just once per cpu 1 in table3 the implementation specific cp0 registers are described all of the implementation specific cp0 registers are implemented independently for each context under hmt except cvstag and cxctrl although in cxctrl the context bits in the cpunum field are in fact unique by context table 2 standard cp0 registers name numselhmtfield implementation specific information index 0 0 4 6bits random 1 0 4 see notea entrylo01 23 0 4 pfn 36bit pa supported c only values 2 or 3 supported context 4 0 4 pagemask 5 0 4 only 4kb and 64mb pages see noteb maskx always 211 1kb pages pagegrain 5 1 not implemented wired 6 0 4 hwrena 7 0 4 badvaddr 8 0 4 count 9 0 1 counts cpu clocks entryhi 100 4 compare 110 423 cp0 registers lx4580 lexra inc proprietary confidential 11 rev 31 october 11 2002 do not copystatus 12 0 4 cu321 always 0 fpu coprocessors re always 0 reverseendian rpfrmxpx always 0 ts always 0 sr always 0 impl always 0 kxsxux always 0 r0 always 0 intctl 121 4 ipti always 7 timer interrupt in ip7 ippci always 7 perfcnt interrupt in ip7 eic vs always 0 srsctl 122 1 always 0 srsmap 123 not implemented cause 130 4 dc all contexts must set this to stop count wp always 0 exccode see notec epc 140 4 prid 150 1 lx4580 0x000bd101 ebase 151 4 cpunum same value as cxctrlcpunum config 160 4 m 1 be reset to 1 or 0 per config pin kuk23 value 3 for fixed mapping table when mt3 at always 0 ar always 1 mt reset to 1 or 3 per config pin vi always 0 k0 reset to 2 may be written values 2 or 3table 2 standard cp0 registers continued name num sel hmt field implementation specific informationchapter 2 mips32 implementation specifics 12 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002config1 161 1 m 0 mmu1 24 entry 23 isilia 64byte linesize 64kb or 32kb or 16kb icache size 4 ways dsdlda 64byte linesize 64kb or 32kb or 16kb dcache size4 ways c2md always 0 pc 1 wrca always 0 ep 1 fp always 0 config2 162 not implemented config3 163 not implemented lladdr 17 0 not implemented watchlo 18 not implemented watchhi 19 not implemented debug 230 4 depc 240 4 perfcnt 25071 4 counters with controls see section210 errctl 260 1 not implemented cacheerr 27 1 not implemented taglo 28 02 1 always 0 datalo 28 13 not implemented taghi 29 02 always 0 datahi 29 13 not implemented errorepc 300 4 desave 310 1 the random register is decremented on every instruction completion the two most recently used values by tlbwr in tlbrefill exception are saved and are never used in subse quent tlbwr tbd an lfsr is used to further control the decrement of random b only bits 2625 of the mask field in the pagemask register are implemented writi ng ones to these bits signifies 64mb page all other bit positions return zeroes on reads c the cause register exccode field can have the following values int mod tlbl tlbs adel ades ibe dbe sys bp ri cpu ov tr cacheerr the cause register exccode can never have the following values fpe c2e mdm x watch mchecktable 2 standard cp0 registers continued name num sel hmt field implementation specific information24 interrupts lx4580 lexra inc proprietary confidential 13 rev 31 october 11 2002 do not copy24 interrupts the mips32 architecture defines eight interrupts which are visible as the interrupt pending bits ip70 in the cp0 cause register in table4 the source of each of these pending interrupts is indicatedtable 3 implementation dependent cp0 registers name numselbitsfield implementation specific information cxctrl 166 31cxtas test and set bit is set to 1 after any reada 3024 0 2316sw software usable readwrite field 1512 0 118dc30 disable context in this cpu 75 0 40cpunum same as ebasecpunuma cvstag 167 310cvstag readonly for lexra internal use the cxtas bit allows atomic updates to the remaining fields of the cxctrl register text which reads this bit as one should not update any fields context which reads this bit as zero should restore it to zero whether or not it updates other fields the cpunum is chipwide unique identifier for the current thread of execution the two least significant bits are the context number within the cpu this value is also reada ble from the cpunum field of the ebase cp0 register that is defined by mips32 release 2 or if enabled in user mode using the release 2 rdhwr instruction specifying the cpunum hardware register using those other methods of obtaining cpunum avoids the need to check and possibly clear cxtas table 4 interrupt sources interrupt definition generation ip0 software 0 write to cause ip0 ip1 software 1 write to cause ip1 ip2 hardware 0 cpu cross context interrupts see section423 ip3 hardware 1 external interrupts see section421 ip4 hardware 2 external interrupts see section421 ip5 hardware 3 external interrupts see section421 ip6 hardware 4 external interrupts see section421 ip7 hardware 5 logically or timer interrupt with performance counter interruptchapter 2 mips32 implementation specifics 14 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 200225 exceptions all of the exceptions that are defined by the mips32 architecture are in table5 t he relevant implementation specific aspects are indicated table 5 exception list exception implementation specifics reset softreset implemented like reset debug singlestep debug interrupt imprecise debugdatabreakloads with addressdata match not implemented nmi external input pin machinecheck not implemented interrupt see section24 interrupts deferred watch not implemented debug instructionbreak watch ifetchnot implemented address error ifetch tlb refill ifetch tlb invalid ifetch cache error ifetchnot implemented bus error ifetch sdbbp coproc unusable reserved inst execution exceptionoverflow trap break syscall precise debug databreak1loads with address match only all stores watch not implemented address error data tlb refill data tlb invalid data tlb modified data cache error datanot implemented bus error data precise debug databreak2not implemented loads with addressdata match are always treated as imprecise debug databreak exceptions251 reset context wait and ejboot lx4580 lexra inc proprietary confidential 15 rev 31 october 11 2002 do not copy251 reset context wait and ejboot when the cpu is reset only context 0 is enabled this is accomplished by the hardware initializing the va lue of the dc bits in the cxctrl register so that all contexts other than 0 are disabled it is the responsibility of the reset handler that runs in context 0 to enable the other contexts by clearing their dc bits when its dc bit is cleared each of the other contexts will begin execution of the reset handler as indicated in table2 each context has its own errorepc used to return from the reset exception and each context can control where it begins execution after it completes the reset handler as described in section33 the cpu can optionally begin execution at the time of reset by fetching instructions in debug mode from the ejtag probe from the cpu point of view this functionality is similar to the ejboot feature of ejtag 25 the extensions to ejtag 20 that control this feature are described in chapter8 as in the case of all reset exceptions only context 0 begins execution hence only context 0 enters debug mode in this case the other contexts begin execution at the standard reset exception vec tor in normal mode after their dc bits are cleared 252 dm wait and ejtag debug exceptions the lx4580 cpu implements dm wait feature which prevents more than one context from executing in debug mode at any given time as noted in table2 there is only one instance of various cp0 registers such as desave used to support debug mode furthermore the ejtag probe software is unlikely to support intermixed accesses to the dmseg and drseg regions therefore after one context begins executing in debug mode due to an ejtag exception any other context which takes an ejtag exception is placed in the dm wait queue while in the dm wait state the context does not issue any instructions when the first context leaves debug mode by executing deret instruction the next context in the dm wait queue resumes execution in the ejtag exception handler furthermore the ejtag implementation for the lx4580 cpu has an additional feature which optionally allows an ejtag exception in one context to immediately place all other contexts in the cpu into the dm wait queue suspending their execution when the first context leaves debug mode by executing its deret the other contexts resume execution at whatever point they were suspended this feature lows the ejtag probe software to gain control of the entire cpu without needing to put all contexts into debug mode simultaneously an additional feature of the lx4580 cpu to be noted is that debug mode for context overrides the dc bit for that context this allows the ejtag probe to force context to enter debug mode using the dint ejtag exception even if the context is disabled for normal execution it also prevents contex t that is executing in debug mode from being disabled by another context which could hang the ejtag probe 26 address spaces supervisor mode is not supported kseg2 is supported instead of ksseg 36 physical address bits are supported the only memory access types supported are values 2 uncached and 3 cacheable kseg0 can be either uncached or cacheable according to the k0 field of the cp0 config register when the erl field of the cp0 status register has value 1 kuseg is an unmapped uncached segmen t and all 231 bytes are translated this is the situation upon resetchapter 2 mips32 implementation specifics 16 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002as noted in the cp0 config register mt field at reset the tlb can be disabled in which case the fixed mapping table will be used in this case as noted in the cp0 config register kuk23 field definitions kuseg kseg2 and kseg3 will always be cacheable field value 3 261 noncoherence for different access types the mips32 architecture specifies that results of loads or stores to location using one mem ory access type that follow loads or stores to the same location using different memory access type are unpredictable in general the architecture states that an implementation specific sequence can enforc coherence between such accesses for the lx4580 cpu the only two access types are cacheable and uncached by performing cache instruction with the hit writeback invalidate operation between the acce sses the coherence can be enforced the address used for the cache instruction may have either the cachea ble or uncached access type this implies that the required cache instruction may use the address from either of the access so that it can be done immediately after the first access or immediately before the second access in either case using the same base register and offset as the access in question 27 endianness at reset bigendian or littleendian is selected via an external configuration pin reverse endianness is not supported in mips32 release 2 the wsbh instruction can be used when endian swap is needed see section2113 28 ejtag the cpu generally supports the ejtag 20 specification in manner consistent with the mips32 architecture the exceptions to this are in the following areas pc trace data break exceptions hmt extensions for pc trace the ejtag 20 concept of external trace signals is not supported this is due to t he higher speed of the cpu and the multicontext nature of the lx4580 cpu pipeline instead an onchip trace buffer is used to capture information about instruction execution the controls for the trace buffer allow tracing of single context or tracing of all contexts of the lx4580 cpu simultaneously the trace buffer and associa ted controls are described section828 for debug data break exceptions the cpu implements the concept of precise data breaks t hat is defined in the ejtag 25 specification in particular for loads only the address match applies for stores both the address and data match if enabled apply imprecise data breaks which would require data match for loads are not supported because the lx4580 cpu often resolves loads for given context in the background of execution of other contexts as noted in section252 only single context of the lx4580 cpu is allowed to execute in debug mode at any given time furthermore if the ejtag control register disable other contexts doc bit is set when any context enters debug mode all other contexts suspend execution as indicated in table2 each cont ext has its own cp0 debug and depc registers to provide independent context control of ejtag and to hold the depc for each context that is in dm wait state on the other hand there is only one desave register that i s shared by all contexts since it is only needed during execution in debug mode for both instruction and data breaks the match logic is extended to include an optional match against the context number29 cp0 hazards lx4580 lexra inc proprietary confidential 17 rev 31 october 11 2002 do not copyfor ejtag breaks an additional field in the ejtag control register is used to ind icate whether all contexts are to be interrupted or just specific context is to be interrupted 29 cp0 hazards in all cases the implementation meets or exceeds the typical requirements for instru ction spacing to avoid cp0 hazards as described in the mips32 architecture specification 210 performance counters the lx4580 cpu implements four performance counters as noted in table2 each counter can select from the same set of events to count and each counter can count the selected event for all cont exts or for one particular context the format of the counters and their control registers follows the mips32 release 2 specification with one lexra extension the cntxsel field in bits 1311 of the control registers as defined in table6 the event field bits 105 of the mips32specified counter control registers is defined in table 7 because there is only one set of performance counters they are shared by all contexts and it is the responsibility of software to control their use by more than one context if so desired one particular aspect of the mips32specified control registers that is specific to the lx4580 cpu is the ie field which indicates that performance counter interrupt should become pending under certain conditions in the lx4580 cpu the ie field applies to the context that most recently wrote the control register in question table 6 cntxsel bits 1311 field of perfcnt control registers value bits 1311 context to count 000 count events for all contexts 100 count events for context 0 101 count events for context 1 110 count events for context 2 111 count events for context 3 others reserved table 7 event field of perfcnt control registers value bits 105 event counted 000000 retired instructions 000001 replayed instructions 000010 instruction fetch valid new dstage 000011 icache instruction fetch 000100 icache miss 000101 uncached instruction fetchchapter 2 mips32 implementation specifics 18 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002000110 dcache loada 000111 dcache storea 001000 dcache load miss 001001 dcache store miss 001010 dcache load or storea 001011 dcache load or store miss 001100 uncached load or storea 001101 writeback for replacement 001110 writeback for inquiry 001111 invalidate for inquiry 010000 nop for inquiry 010001 pipeline stall for any reason 010010 pipeline stall for icache fill 010011 pipeline stall for dcache fill 010100 pipeline stall for store from store queue 010101 pipeline stall for write buffer full 010110 execution exception ovtrapbreaksyscall 010111 tlb refill exception instruction 011000 tlb refill exception data 011001 tlb invalid exception instruction 011010 tlb invalid exception data 011011 tlb modified exception 011100 any tlb exception 011101 itlb miss 011110 dtlb miss 011111 interrupt 100001 any exception 100010 store conditional instruction pass or fail 100011 store conditional fail others reserved count counts replayed and retired versions the number of replays does not significantly contribute to the overall counttable 7 event field of perfcnt control registers value bits 105 event counted211 release 2 architecture support lx4580 lexra inc proprietary confidential 19 rev 31 october 11 2002 do not copy211 release 2 architecture support the lx4580 cpu supports the mips32 release 2 architecture changes those changes include numerous optional and implementation dependent features as well as several required features the following sections provide detail on the lx4580 implementation as quick summary the following is list of all of the release 2 features and their support in the lx4580 cpu vectored interrupts not supported external interrupt controller not supported programmable exception vector base supported atomic interrupt enabledisable supported disable count register supported gpr shadow registers not supported field rotate shuffle instructions supported hazard barrier instructions supported user hardware register access supported cp0 register changes supported 64bit fpu not supported 1kb page size not supported 2111release 2 interrupt modes exceptions shadow gprs the release 2 architecture defines compatibility interrupt mode which is equivalent to the release 1 interrupt mode this is the only release 2 interrupt mode supported by the lx4580 cpu the vectored and external interrupt controller eic modes are not supported gpr shadow registers are not supported as noted in section24 the timer and performance counter interrupts are presented as ip 7 therefore the ipti and ippci fields of the release 2 intctl register have that value the other fields of intctl are always zero the cause register fields and pci are implemented to provide direct indication of tim er and performance counter interrupts since eic mode is not supported the status and cause registers never use the ipl and ripl formats for interrupt priority levels because there is only single count register shared by all contexts the dc disable count bit in t he cause register only has an effect if all contexts set their individual dc bit otherwise the count register continues to run the release 2 ebase register is fully implemented within the ebase register the least sign ificant bits of the cpunum field reflect the context number within the lx4580 cpu that is each context reads unique cpunum value from its ebase register there is one ebase register pe r context so that each can independently set its exception base value the release 2 ei and di enable and disable interrupt instructions are implemented as required because shadow register and vectored interrupts are not implemented the srsctl register is alwa ys read as zeroes and srsmap is not implemented furthermore the rdpgpr and wrpgpr instructions simply move the contents of one gpr to another within the executing contexts gpr register set 2112 hazard barrier instructions the release 2 instructions ehb jalrhb jrhb and synci are implemented by the lx4580 cpu to eliminate execution and instruction hazards as described in the release 2 archit ecturechapter 2 mips32 implementation specifics 20 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002one implementation dependent aspect of the synci instruction concerns address exceptions the lx4580 cpu will not take an adel for reference by synci to kernel space while in user mode 2113 field rotate shuffle instructions the following release 2 instructions are implemented as required it is worth noting that programming note in the release 2 specification indicates how the wsbh instruction can be used to swap endianness ext extract bit field ins insert bit field rotr rotate right rotrv rotate right variable seb signextend byte to word seh signextend halfword to word wsbh word swap bytes within halfwords 2114 user access to hardware registers the release 2 instruction rdhwr read hardware register is implemented as required the cp0 register hwrena is also implemented as required to conditionally enable user mode program to read one or more of the defined registers the values that are supplied when the rdhwr instruction is executed if the relevant register is enabled for reading are shown in table 8 2115 cp0 register changes all of the changes and additions to cp0 registers that are associated with t he release 2 architecture are reflected in table2 standard cp0 registers beyond the changes and additions associated with release 2 features that are described in other sections of this document few more cp0 register changes re included in the lx4580 cpu to be compliant with the release 2 architecture in particular the config config2 and config3 have few more fields defined since the config2 and config3 fields all refer to features that are not supported in the lx4580 cpu these registers are not implemented the optional watchhi register has some fields added but since the lx4580 does not implement the w atch registers these are not implemented the perfcnt control registers have wbit added which only applies to mips64 implementations and so is always 0 on the lx4580 cputable 8 hardware register values number name hmt implementation specific information 0 cpunum 4same as cp0 ebasecpunum 1 synci_step 164 2 cc 1same as cp0 count register 3 ccres 1 12116 64bit coprocessor fpu lx4580 lexra inc proprietary confidential 21 rev 31 october 11 2002 do not copy2116 64bit coprocessor fpu since the lx4580 does not support any coprocessors the release 2 changes to support 64bit coprocessors and in particular 64bit fpu are not implemented the instructions associated with this rele ase 2 feature will all take coprocessor unusable exceptions as required 2117 1kb pages the release2 architecture extends the pagemask register by pair of bits and several other cp0 regist ers are extended or modified if 1kb pages are to be supported also if 1kb pages are to be supported pagegrain register is required the lx4580 cpu does not support the 1kb page feature therefore the pagegrain register is not implemented and the changed formats of other registers are not implemented the extra two bits of pagemask are hard coded to 211 as seems to be requiredchapter 2 mips32 implementation specifics 22 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002lx4580 lexra inc proprietary confidential 23 rev 31 october 11 2002 do not copychapter 3 reset rst 31 reset overview the lx4580 employs locally sampled reset strategy synchronous resets registered at the block level the reset strategy ensures the following complete initialization of the lx4580 by the assertion of one external pin reset debug by ejtag the cpu can be placed in state whereby they will all receive debug exception when reset and will fetch their reset vector from ejtag probe space reset of flipflops in multiple clock domains for this reason reset must remain assert ed until it is registered in each domain in the design due to the synchronous nature of resets all clocks must be running when reset is asserted this includes external interface clocks when reset is asserted all blocklevel signals must go to an inert state eg for bus the arbiter must have grant deasserted during resets this allows blocks in different clock domains to come out of reset at different times two external reset pins are provided for power up and debug reset 32 reset distribution the reset system is distributed across the design each block will contains reset flipflop wh ich samples the chiplevel reset in its clock domain the output of the reset flipflop is fed to all the flipflops in that blockfigure 2 reset overviewcreset_n jtag_rst_nejtag cpuclkall other logiclx4580chapter 3 reset rst 24 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 200233 reset operation coldboot sequence would be as follows 1 creset_n is asserted 2 creset_n is deasserted 3 context 0 of the cpu starts executing instructions from the reset vector 4 the software will initialize the multiple context environment and the peripherals typical multiple cpu ejtag boot sequence would be as follows 1 creset_n is asserted 2 creset_n is deasserted 3 the ejtag probe is connected to the cpu in turn setting the probeen bit of the cpus ejtag control register 4 the probe then asserts jtag_rst_n this resets everything in the lx4580 part from the ejtag probeen flop 5 jtag_rst_n is deasserted the cpu jumps to the debug exception vector at 0xff200200 from where the system is under ejtag probe control 34 reset external lx4580 interfaces table 9 reset external interface signal name direction description creset_n input cold reset jtag_rst_n input connection from the ejtag probelx4580 lexra inc proprietary confidential 25 rev 31 october 11 2002 do not copychapter 4 lx4580 cpu 41 lx4580 cpu overview this chapter describes the cpus caches the lx4580 cpu includes the following features 500 mhz operation 7stage pipeline supports release 2 mips32 instruction set four hardware contexts with finegrained hardware multithreading hmt 64 32 or 16 kbyte 4way set associative instruction cache 64 32 or 16 kbyte 4way set associative writeback allocate on write data cache performance counters 42 lx4580 cpu core the lx4580 cpu core implements the full release 2 mips32 instruction set as described in chapter2 the major blocks of the cpu core are the register file and alu ralu control processor cp0 andfigure 3 lx4580 cpu and system interfacecbus requests and request repliesdata reqrepdata cache controller instruction cache controllersystem interfacesram data store and tags ralu 4 x register file cp0 4 x control regsmmu 4 x tlblx4580 cpu core sram inst store and tagsmux inst busdata bus inst reqrepejtagejtag reqreplx4580 cpuchapter 4 lx4580 cpu 26 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002memory management unit mmu architecturally visible registers in these blocks are re plicated to provide separate copy for each of the cpu contexts 43 instruction cache the lx4580 cpu includes 4way set associative instruction cache that operates at the processor c lock speed the instruction cache is organized in 64byte lines with valid and invalid states 44 data cache the lx4580 cpu includes 4way set associative data cache that operates at the processor cl ock speed data in the cache is organized in 64byte lines 45 cache line replacement algorithm when new line must be brought into the instruction cache or data cache it may be necessary to evict line that is currently held the caches use 2 bit most recently filled mrf field to implement the replacement algorithm this value is stored as an extra two bits in tag 0 ram and is updated any time fill data is returned to the cache on fill the stored mrf value indicates which way is currently being filled so t any point in time this value represents the most recently filled line when the data cache needs to allocate location for new line it first examines the valid bits of all 4 ways if any of the 4 ways are invalid the smallest number way 03 that is invalid is selected if all 4 ways are valid the way equal to mrf 1 mod 4 is selected the instruction cache does not examine the valid bits in its replacement algorithm it simply lects the way equal to mrf 1 mod 4 as shown in the last 4 rows of table10 when the data cache has misses for more than one context to the same cache index it tracks the replacement way for each of them and must update the mrf bit in the order that the misses were allocated when more than one context misses to the same cache index the instruction cache simply suspends the second cont ext without making request after the first miss is resolved the suspended context resumes execution nd assuming it misses again then makes its request table 10 cache line replacement algorithm tag state mrf way selected way 0 invalid xxway 0a this row does not apply to the instruction cache which ignores the valid bits in its replacement algorithmway 0 valid way 1 invalid xxway 1a way 01 valid way 2 invalid xxway 2a way 012 valid way 3 invalid xxway 3a way 03 valid 00way 1 way 03 valid 01way 2 way 03 valid 10way 3 way 03 valid 11way 046 cpu error handling lx4580 lexra inc proprietary confidential 27 rev 31 october 11 2002 do not copywithin the data cache lines may be locked using the load linked ll instruction when one thread executes an ll that line is locked until store conditional sc instruction is executed or some other operation breaks the lock see section221 if line is locked it cannot be replaced if the algorit hm above selects line that is locked the algorithm will increment the way by 1 way 1 mod 4 and choose that way if that way is also locked the algorithm increments again until it finds w ay that does not have locked line 46 cpu error handling 461 bus error handling ibe and dbe when bus error is detected it is reported to the cpu and context associated with the request within the cpu the request which caused the bus error must have been one of the following instruction fetch cached or uncached data access with response typically read or cache fill data access without response typically write or eviction for an instruction fetch the bus error replaces the response that would have contained the expected data the context is marked as ibe pending the icache state machine for the context is released wit h change in the cache if the request was cached instruction fetch the context is released from its susp ended state so that it can take the ibe exception as described below for data access with response the bus error replaces the response that would have contained the xpected data the context is marked as dbe pending the dcache state machine for th context is released if replacement eviction was required the cache line will be left in the invalid state if eviction was required the data cache is unchanged if gpr was to be loaded with the data the value of the gpr is unpredictable writing zeroes or leaving the gpr unchanged would not be any more useful to software the context is released from its suspended state so that it can take the dbe exception as described below for data access without response the bus error is an essentially asynchronous event the context is marked dbe pending if the context is suspended for cache misses or any other reason at the time it is marked dbe pending it remains suspended until the associated conditions are resolved at that time it take s the dbe exception as described below when context that is ibe or dbe pending resumes execution and is selected for issue to the pipeline its instruction fetch is inhibited instead benign instruction is inserted into the pipeline when that instruction reaches the end of the pipeline the context takes an ibe or dbe exception as appropriate with ibe ving higher priority if both are pending the pending state is cleared and the context begins execution of the exception handler as per the mips32 standard note that it is possible for context to become ibe or dbe pending while it is executing an exception handler nothing in the mips32 architecture prevents such scenario in this case second level of exception handler is entered for the ibe or dbe 462 interrupt error response nmi an external nmi signal is an input to the lx4580 cpu when the signal makes 0 to 1 transition all contexts are set to the nmi pending state not architecturally visible to soft ware context in that state will take an nmi exception the next time that it issues an instruction flow that is not in debug mode in particular if context is suspended for cache miss for example or dis abled via the cxctrl register it will not take the nmi exception until it is longer suspended or disabled when context that is nmi pending is selected for issue to the pipeline its instruction fetch is inhibite d instead benign instruction is inserted into the pipeline when that instruction reaches the end of thechapter 4 lx4580 cpu 28 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002pipeline the context takes an nmi exception the nmi pending state is cleared for that context and the context begins execution of the nmi exception handler as per the mips32 standard note that the mips32 standard for nmi exceptions requires that the erl and nmi bits be set in the cp0 cause register also note that the entry point for the nmi exception handler is located in uncached space it is the same entry point as the reset handler the erl bit forces accesses to kuseg to be unmapped nd uncached as if they were accesses to kseg1 which allows saving registers using r0 and avoidance of data cache errors if present since all contexts become nmi pending simultaneously it is the responsibility of the nmi exception handler to determine the first context to take the exception and if desired to disable the other contexts when they take the nmi exception if it is desired to perform ejtag debug of the nmi exception handler an instruction break can be placed at the point where the nmi handler branches out of the reset handlerlx4580 lexra inc proprietary confidential 29 rev 31 october 11 2002 do not copychapter 5 cbus_z interface zbi 51 cbus_z interface overview the chapter describes the lx4580s cbus_z interface option which is one of two interfaces options supported by the lx4580 the cbus_z interface zbi translates the cpus internal busses into unified interface that may connect directly to the user system the zbi can also connect to an application s pecific translation layer to support other bus protocols the lx4580 supports the mips ectm interface as an alternative to the cbus_z interface see chapter6 the lx4580 cbus_z interface provides 64bit data path and operates at 1x the cpu core clock rate 52 cbus_z interface signal list table11 summarizes the lx4580s cbus_z signals table 11 cbus_z signal listfigure 4 cbus_z interface zbi name direction function cbus_zreqo output 0 request 1 processor is initiating request cbus_zbusyi input 1 external logic cannot accept request the current cbus_z request if any is ignored by external logic 0 external logic is ready to accept request cbus_zaddro350 output address cbus_zreado output 1read 0write cbus_zsynco output 1sync request 0normal request cbus_zread will indicate write on sync cyclescbus_zdatao cbus_zdataicbus_zreqo lx4580 cpu cbus_zbusyi cbus_zrdyicbus_zdbusyo cbus_zaddro cbus_zreado36 64cbus_zsynco cbus_zszo2 cbus_zlineo 64 cbus_zltido2 cbus_zuco cbus_zsrco2 cbus_zltido2chapter 5 cbus_z interface zbi 30 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 200253 cbus_z endian mode the lx4580 is biendian static input pin cfg_bigendian determines the configured endian mode of the processor and the cbus_z interface the memory contents shown below apply to the examples presented in this sectioncbus_zszo10 output transfer size 2b00 1 byte 2b01 2 bytes 2b10 3 bytes 2b11 1 word this signal is dont care when cbus_zlineo is asserted cbus_zlineo output 1 line access 0 single access cbus_zdatao630 output write data cbus_zltido10 output local thread id cbus_zuco output 1 uncached access 0 cached access cbus_zsrco10 output transaction source within lx4580 2b00 instruction cache 2b01 data cache 2b10 ejtag 2b11 reserved cbus_zrdyi input read data is available cbus_zdbusyo output 1 lx4580 is not ready to receive data external logic must hold cbus_zdatai cbus_zltidi and cbus_zvaltypei until cbus_zdbusyo is deasserted 0 lx4580 is ready to receive data cbus_zdatai630 input read data cbus_zltidi10 input thread associated with read data cbus_zvaltypei10 input indicates read data type 2b00 instruction cache 2b01 data cache 2b10 ejtag 2b11 reserved byte address hex contents 0 88 1 99 2 aa 3 bb 4 cc 5 dd 6 ee 7 ffname direction function53 cbus_z endian mode lx4580 lexra inc proprietary confidential 31 rev 31 october 11 2002 do not copythe program visible behavior of all cacheable and uncacheable loads and stores conform to the formats presented in table12 the cbus_z command is not shown in the table and can be inferred from the size of the valid data in the cbus_z data patterns for the purpose of the unaligned load and store instructions lwl and lwr the address bits shown in cbus_z columns of table12 are adjusted values not the raw address computed by the instruction for lwl in little endian mode and lwr in big endian mode the two low order address bits are forced to zero for all other cases the address bits are unchangedtable 12 effect of endian mode on cbus_z inst and addr20big endian little endian cbus_z addrdataa dash in this column indicates the data is undefinedregb b dash in this column indicates the register contents are not affected loads or are ignored storescbus_z addrdataaregb sblb00 88 000000880 88 00000088 11 99 000000991 99 00000099 22 aa 000000aa2 aa 000000aa 33 bb 000000bb3 bb 000000bb 44 cc 000000cc4 cc 000000cc 55 dd 000000dd5 dd 000000dd 66 ee 000000ee6 ee 000000ee 77 ff 000000ff7 ff 000000ff shlh00 8899 000088990 9988 00009988 22 aabb 0000aabb2 bbaa 0000bbaa 44 ccdd 0000ccdd4 ddcc 0000dcc 66 eeff 0000eeff6 ffee 0000ffee swlw00 8899aabb 8899aabb0 bbaa9988 bbaa9988 44 ccddeeff ccddeeff4 ffeeddcc ffeeddcc double wordc c double word transfers only occur as part of line read or write0 8899aabb ccddeeff na0 ffeeddcc bbaa9988 na lwlswl00 8899aabb 8899aabb0 88 88 11 99aabb 99aabb0 9988 9988 22 aabb aabb0 aa9988 aa9988 33 bb bb0 bbaa9988 bbaa9988 44 ccddeeff ccddeeff4 cc cc 55 ddeeff ddeeff4 ddcc ddcc 66 eeff eeff4 eeddcc eeddcc 77 ff ff4 ffeeddcc ffeeddcc lwrswr00 88 880 bbaa9988 bbaa9988 10 8899 88991 bbaa99 bbaa99 20 8899aa 8899aa2 bbaa bbaa 30 8899aabb 8899aabb3 bb bb 44 cc cc4 ffeeddcc ffeeddcc 54 ccdd ccdd5 ffeedd ffeedd 64 ccddee ccddee6 ffee ffee 74 ccddeeff ccddeeff7 ff ffchapter 5 cbus_z interface zbi 32 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 200254 cbus_z line read interleave order the line read operation reads sequence of data beats from memory corresponding to the size of cach line the cache line size affects how many cycles are required to transfer the entire lin 32 byte line size is assumed here the cbus_z target transfers read data starting with word zero first with word zero first operation the target transfers eight 64bit beats of data in sequence starting at the nearest 32bytealigned address s maller or equal to the address that the initiator drives in other words the target starts the transfer at the beginning of the line containing the requested address 55 cbus_z read completion external logic may manage cbus_z read completion in one of the following ways 1 pended one read request is outstanding at time the cbus_z is unavailable for othe r requests between the time the read request is issued and read data is returned external logic keeps cbus_zbusyi asserted until the read response 2 pipelined multiple read requests are outstanding time read responses occur in the same order that the read request is made 3 split multiple read requests are outstanding at time read re sponses can be returned in different order than the request when the read management technique is pipelined or split write requests can be issued while reads are pending for read response data 25 lines of data buffering is provided read requests can be issued until the amount of pending data is equal to the available data buffering pending reads can be any combination of the following one icache read per thread one dcache read per thread one ejtag read 56 cbus_z transaction types the following transaction types are supported by the cbus_z interface subline read line read subline write line write sync this transaction occurs when cbus_zsynco is asserted other signals behave as in subline write transaction address and data should be ignored 57 cbus_z protocol the transaction request protocol is controlled with cbus_zreqo output and cbus_zbusyi input 1 the cbus_zreqo output is asserted by the zbi to initiate an access to external logic addi tional cbus_z outputs are driven by the zbi to provide the transaction details58 cbus_z transaction timing diagrams lx4580 lexra inc proprietary confidential 33 rev 31 october 11 2002 do not copy2 cbus_zreqo remains asserted until the cbus_zbusyi is not asserted by external logic for write transaction the transaction is completed after step 2 for rea d transaction additional steps control the return of read data by the external logic using the cbus_zrdyi input and the cbus_zdbusyo output 1 if cbus_zvaltypei indicates instruction cache or ejtag data is present on cbus_zdatai the data is always accepted by the lx4580 2 if cbus_zvaltypei indicates that data cache data is present on cbus_zdatai and cbus_zdbusyo is asserted the external logic must continue to drive cbus_zvaltypei and cbus_zdatai until cbus_zdbusyo deasserts 58 cbus_z transaction timing diagrams note all of the following timing diagrams assume line size of 32 bytes for reads the transaction request is shown in different timing diagram than the returning read data as there is protocol link between the two 581 backtoback subline writes with busy in cycle 1 the write to address is accepted by the external logic in cycle 2 t he external logic asserts cbus_zbusyi which causes the lx4580 to hold its request in cycle 3 the external logic deass erts cbus_zbusyi and accepts the request in this example cycle 4 could be used by the processor to initiate another request figure 5 cbus_z backtoback subline writes with busyclk cbus_zreqo cbus_zbusyi cbus_zaddro350 cbus_zdatao630 cbus_zsrco10 cbus_zlineo cbus_zszo10 cbus_zreado cbus_zltido10 cbus_zucoa b b b b d01491234chapter 5 cbus_z interface zbi 34 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002582 line writes during line write the address is given in cycle 1 external logic signals that it is able to accept line write request by deasserting cbus_zbusyi external logic does not honor line write request when cbus_zbusyi is asserted figure 6 cbus_z line write 583 read request line read request takes only one cycle with the data being returned later by the external logic figure 7 cbus_z read requestsclk cbus_zreqo cbus_zbusyi cbus_zaddro350 cbus_zdatao630 cbus_zsrco10 cbus_zlineo cbus_zszo10 cbus_zreado cbus_zltido10 cbus_zucoa a1 a2 a3 a4 d015012345 clk cbus_zreqo cbus_zbusyi cbus_zaddro350 cbus_zdatao630 cbus_zsrco10 cbus_zlineo cbus_zszo10 cbus_zreado cbus_zltido10 cbus_zucoa b b b d015112584 returning read data lx4580 lexra inc proprietary confidential 35 rev 31 october 11 2002 do not copy584 returning read data external logic supplies read data on the cbus_zdatai and cbus_zltidi inputs while asserting bit within cbus_zvaltypei if cbus_zvaltypei indicates data 2b01 the lx4580 only accepts the read data if it has deasserted cbus_zdbusyo if cbus_zdbusyo is asserted with cbus_zvaltypei 2b01 the external logic must maintain cbus_zvaltypei and cbus_zdatai until cbus_zdbusyo is deasserted figure 8 cbus_z subline read data and dbusy read line data return is illustrated below the external device asserts the appropriate bit of cbus_zvaltypei for each data beat assertion of cbus_zdbusyo is also illustrated figure 9 read data for line read requestclk cbus_zdbusyo cbus_zrdyi cbus_zvaltypei10 cbus_zdatai630 cbus_zltidi10a 00 b 10 c 01 b c b c d0152123 4 56 clk cbus_zdbusyo cbus_zrdyi cbus_zvaltypei10 cbus_zdatai630 cbus_zltidi10a 01 a0 a1 a2 a3 d0153123 4 56chapter 5 cbus_z interface zbi 36 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002lx4580 lexra inc proprietary confidential 37 rev 31 october 11 2002 do not copychapter 6 ec interface eci 61 overview the ec interface eci is used in the lx4580 as the interface between the cpu and memory and io devices the chapter describes the lx4580s ec interface eci option which is one of two interfaces options supported by the lx4580 the eci translates the cpus internal busses into unified 64bit interface that may connect directly to the users system the ec protocol is described in the mips ectm interface specification revision 105 the lx4580 supports lexras cbus_z interface zbi as an alternative to the ec interface see chapter5 the lx4580 ec interface provides 64bit data path and operates at 1x or 12x the cpu core clock rate if the lx4580 is configured for 64 or 128byte cache lines multiple 32byte ec interface bursts are required to transfer one cache line figure 10 ec interface ecieb_blast eb_wdataeb_ardy lx4580 cpu eb_ewbe eb_wdrdyeb_avalid eb_a eb_write33 64eb_instr eb_be8 eb_bfirst 64eb_blen2 eb_burst eb_wwbe eb_rdval eb_rdataeb_rberreb_rberrchapter 6 ec interface eci 38 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 200262 ec interface signals 63 ec interface endian mode the lx4580 is biendian static input pin cfg_bigendian determines the endian mode of the processor and the ec interface the memory contents below apply to the examples presente d in this sectiontable 13 ec interface signals signal name direction description command eb_ardy input slave can accept new request address phase eb_avalid output request valid eb_a353 output address bus eb_write output current address phase is for write request else read eb_instr output current address phase is for an instruction fetch else data or ejtag burst control eb_be70 output byte enable eb_bfirst output first address phase of burst eb_blast output last address phase of burst eb_blen10 output burst length beats eb_burst output current address phase is part of burst write buffer synchronization eb_wwbe output master is waiting for external write buffer to empty sync instruction ex ecuted eb_ewbe input external write buffer is empty write data eb_wdrdy input slave is ready to accept write data eb_wberr input bus error on write eb_wdata630 output write data bus read data eb_rdval input read data is valid eb_rberr input bus error on read eb_rdata630 input read data bus byte address hex contents 0 88 1 99 2 aa 3 bb 4 cc 5 dd 6 ee 7 ff63 ec interface endian mode lx4580 lexra inc proprietary confidential 39 rev 31 october 11 2002 do not copythe program visible behavior of all cacheable and uncacheable loads conform to the formats presente d in table14 the ec byte enable flags ec_be70 can be inferred from ec data patterns note that the ec interface signals do not intrinsically employ the concept of endian mode the lx4580 uses the internally generated address bits 20 to make the determination of what ec byte enable signals to assert the three loworder address bits are omitted from the ec interface address lines there is way to determine the endian mode employed for transfer over the ec interfacetable 14 effect of endian mode on ec interface inst and addr20big endian little endian ec dataa aa dash in this column indicates the data is undefinedregb ba dash in this column indicates the register contents are not affected loads or are ignored storesec dataaregb sblb088 00000088 88 00000088 199 00000099 99 00000099 2aa 000000aa aa 000000aa 3bb 000000bb bb 000000bb 4 cc 000000cccc 000000cc 5 dd 000000dddd 000000dd 6 ee 000000eeee 000000ee 7 ff 000000ffff 000000ff shlh08899 00008899 9988 00009988 2aabb 0000aabb bbaa 0000bbaa 4 ccdd 0000ccddddcc 0000ddcc 6 eeff 0000eeffffee 0000ffee swlw08899aabb 8899aabb bbaa9988 bbaa9988 4 ccddeeff ccddeeffffeeddcc ffeeddcc double wordc c double word transfers only occur as part of line read or write8899aabb ccddeeff naffeeddcc bbaa9988 na lwlswl08899aabb 8899aabb 88 88 199aabb 99aabb 9988 9988 2aabb aabb aa9988 aa9988 3bb bb bbaa9988 bbaa9988 4 ccddeeff ccddeeffcc cc 5 ddeeff ddeeffddcc ddcc 6 eeff eeffeeddcc eeddcc 7 ff ffffeeddcc ffeeddcc lwrswr088 88 bbaa9988 bbaa9988 18899 8899 bbaa99 bbaa99 28899aa 8899aa bbaa bbaa 38899aabb 8899aabb bb bb 4 cc ccffeeddcc ffeeddcc 5 ccdd ccddffeedd ffeedd 6 ccddee ccddeeffee ffee 7 ccddeeff ccddeeffff ffchapter 6 ec interface eci 40 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002for the purpose of the unaligned load and store instructions lwl and lwr the address bits shown in cbus columns of table14 are adjusted values not the raw address computed by the instruction fo r lwl in little endian mode and lwr in bit endian mode the two low order address bits are forced to zero for all other cases the address bits are unchanged 64 ec interface pending requests the ec interface specification allows for an unlimited number of outstanding requests in the eci the number of outstanding requests are limited by the amount of internal buffering available the following rules apply for reads up to 25 lines of data buffering is provided read requests can be issued until the amount of pending data is equal to the available data buffering for subline writes one word of buffering is provided write requests can be issued until the amount of pending data is equal to the available data buffering for line writes buffering is provided other requests of any type can be issued until the last beat of write data is accepted by the slave the 4580 cpu has an architectural limitation on the number of reads that may be pending independent of eci buffering those limits are one icache read per thread one dcache read per thread one ejtag read when the 4580 executes sync instruction other requests of any type can be issued until all pending writes complete and the slave asserts eb_webe65 ec interface gasket overview lx4580 lexra inc proprietary confidential 41 rev 31 october 11 2002 do not copy the remainder of this chapter is for internal lexra use 65 ec interface gasket overview the ec interface gasket eci is used in the lx4580 as the interface between the cpu and memory and io devices the cpu connection is provided by the lx4580s cbus and ibus interfaces these interfaces are described in the remaining sections of this chapter the eci interface accepts read data stined for the cbus reply interface and provides write data from the cbus request interface or ibus reply interface 66 supported configurations 1 two burst sequences are required to transfer cache line on the ec interfacefigure 11 ec interface gasket eci table 15 supported configurations ec bus width bitscache line size bytesbeats per burstecicore speed ratiotheoretical bw gbs assumes 500 mhz corecompatibility 64 64 41 1 32 5kc 5kf ec64 64 64 41 12 16 5kc 5kf ec64eb_wdata64 eb_rdataibus_reqicbus_yreqo eb_avalid inquiry controlibus_dbusyo cbus_ybusyieb_ardyibus_rdyo ibus_xbusyi ibus_hdrdataocbus_ydatao cbus_ydatai cbus_yrdyidc_cbdbusy32 64 64 eb_rdvaleb_rwdrdy 128chapter 6 ec interface eci 42 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 200267 implementation guidance for endian mode from logic design and verification perspective there are tradeoffs over how far the endian mode should reach into the processor while for the purposes of verification and the simulation environment it may be preferable for the entire processor to reflect the configured endian mode this is by means necessary in terms of architecture table20 in section63 provides the complete architectural definition of endian modes in the processor th material in the section provides background and implementation information 671 consistency of endian mode in the system the motivation of providing biendian cpu is to permit consistent system view of the endian mode that is software the cpu and system bus devices all should implement the same endian mode if this is not the case the issues that arise are more matter of software and system lev design that of cpu architecture it makes little or sense for software to operate with an endian mode that differs from the cpu caches operate in specific way in response to the endian mode it is more practical and straightforward for applications and the operating system to be consistent with the cpus endian mode or viceversa in some cases software might perform manual conversions of data structures between endian modes when accessing specific devices or data structures that have different endian mode tha n the cpu the best way to treat this is explicitly as needed lastly while it is possible to build systems in which the endian mode of cpu and system devices diff er it is presumed that the biendian lx4580 will be configured to match the mode of the system devices for the above reasons there is mixedendian support required in the lx4580 672 address invariance for any address visible to software or external hardware the cpus implementation of the endian modes must obey the principle of address invariance this means that for reference of given size and address the same address is employed in software and all user visible hardware regardless of endian mode if the cpu responds to the endian mode throughout its entire implementation address invariance will be satisfied without any additional effort in contrast if the cpu maintains big endian mode internally and an endian switch is implemented at some internal interface for example within the eci then the conversion must take care to ensure address invariance 673 data invariance data invariance is analogous to address invariance that is for reference of given size address and endian mode data is driven on different busses using consistent alignment in pure architectural sense the only data alignment that matters is the data which is driven through the system bus interface this specification is neutral on the extent to which data invariance should be supported on the processors internal data paths as suggested in the previous section it is reasonable to brea k data invariance on internal data paths as means of preserving address invariance in an endian switc h supporting data invariance throughout the entire cpu design is double edged sword on the one hand there is some benefit to consistent treatment of endian mode in any interface that could potentially be exposed to customer eg cbus rams for dma on the other hand substantial set of tools have been674 reverse endian support not recommend lx4580 lexra inc proprietary confidential 43 rev 31 october 11 2002 do not copydeveloped to support lexras simulation environment which access internal state and these ssume big endian formats while in the long run these tools might benefit from consistent treatment of endian mode for the entire environment they would first have to be changed to support biendian operation in terms of cpu implementation the easiest way to provide universal data invariance is to implement the endian switch throughout the entire cpu data cache cbus and outward this actually entails ve ry little hardware being limited to logic that decodes low order address bits to control data selection muxes the muxes themselves already exist to reconcile different access sizes in the current big dian implementation changing the endian mode does not add any data inputs to these muxes 674 reverse endian support not recommend the mips32 architecture permits an optional reverse endian mode controlled with the cp0 status registe r re bit when set this bit reverses the endian mode of user mode references only since this only affects user mode it is not an effective means for managing endian difference between cpu and system devices allowing endian mode to vary instruction by instruction in response to this flag is burdensome and not worth the effort therefore it is not recommended that the lx4580 support reverse endian operation 675 endian mode and unaligned loadstore as seen in table 14 in section63 the processor must zero the two low order address bits of the ca lculated addresses of unaligned loads and stores so that the address presented to the system is worda ligned this truncation depends on the endian mode table14 provides concise specification of what the individual instructions must do but it somewhat obscures the real working of the unaligned load and store instructions the tables below illustrate unaligned loads and stores from different perspective they show an objec t in memory consisting of bytes represented by the symbols b c d starting at the aligned location 0 and the unaligned locations 1 2 and 3 the left and right flavors of the unaligned load and store instructions are paired in the manner that they would normally be executed for example for big endian lwl with the two calculated low order address bits equal to 0 the corresponding lwr calculates an address with the low orde r bits equal to 3 from these tables it is clear how these instructions respond the endian mode to access the l eft and right portions of an unaligned word in memory and how the portions are merged in the cpu register table 16 big endian unaligned loadstore address adjustments memory contents 0 1 2 3 4 5 6 7lwlswl lwrswr calculated addr30register contentscalculated addr30adjusted addr30register contents b c d 0 b c d 3 0 b c d b c d 1 b c 4 4 d b c d 2 b 5 4 c d b c d 3 6 4 b c dchapter 6 ec interface eci 44 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 200268 cbus_y interface the cbus_y interface is not available for application use as an alternative to eci simpler version of the cbus_y protocol is available with the cbus_z interface option see xref the cbus_y provides signalling between the cpu ejtag icache dcache and eci certain requests may require an eviction rle rlme wli and wle these evictions are caused by sending n inquiry request on the ibus interface cbus_y requests may be single byte half word tribyte word or line length all line requests are zero word first the cbus_y interface runs at the cpu core clock rate cbus_y requests may be throttled if the ec interface is busy cbus_y requests are also throttled while an inquiry is pending on the ibus interface read reply data from the ec interface is returned over the cbus_y reply interface up to fi ve cbus_y read requests may be pending one per thread transfer on the cbus_y reply interface must not be interrupted buffering is provided for two lines of reply data to meet this requirement transfers on the cbus_y reply interface destined for dcache may be thottled if the dcache is busytable 17 little endian unaligned loadstore address adjustments memory contents 0 1 2 3 4 5 6 7lwlswl lwrswr calculated addr30adjusted addr30register contentscalculated addr30register contents b c d 3 0 b c d 0 b c d b c d 4 4 1 b c d b c d 5 4 b 2 c d b c d 6 4 b c 3 d table 18 cbus_y request interface signal name direction description cbus_yreqo input cbus request cbus_yaddro350 input physical address for request cbus_ydatao310 input data for request cbus_ycmdo30 input cbus request command cbus_yszo10 input size of data for request cbus_ysrco10 input source of request cbus_ydwayo10 input data cache way l1 duplicate tag update unused cbus_yltido10 input thread id of request cbus_ybusyi output ec interface busy681 cbus_y endian mode lx4580 lexra inc proprietary confidential 45 rev 31 october 11 2002 do not copy 681 cbus_y endian mode table20 presents the impact of endian mode on the cbus_y although the cbus_y command is not shown in the table and can be inferred from the size of the valid data in the cbus_y data patterns the effect of endian mode on the ec interface is also shown for conveniencetable 19 cbus reply interface signal name direction description cbus_yrdyi output reply data ready cbus_ydesti20 output destination for reply data cbus_ylstei20 output line state and transaction reply type cbus_yrdltidi10 output thread id for reply cbus_ydatai1270 output reply data dc_cbdbusy input data cache busy table 20 effect of endian mode on cbus_y inst and addr20big endian little endian cbus addrdataaec dataaregbcbus addrdataaec dataaregb sblb00 88 88 000000880 88 88 00000088 11 99 99 000000991 99 99 00000099 22 aa aa 000000aa2 aa aa 000000aa 33 bb bb 000000bb3 bb bb 000000bb 44 cc cc 000000cc4 cc cc 000000cc 55 dd dd 000000dd5 dd dd 000000dd 66 ee ee 000000ee6 ee ee 000000ee 77 ff ff 000000ff7 ff ff 000000ff shlh00 8899 8899 000088990 9988 9988 00009988 22 aabb aabb 0000aabb2 bbaa bbaa 0000bbaa 44 ccdd ccdd 0000ccdd4 ddcc ddcc 0000ddcc 66 eeff eeff 0000eeff6 ffee ffee 0000ffee swlw00 8899aabb 8899aabb 8899aabb0 bbaa9988 bbaa9988 bbaa9988 44 ccddeeff ccddeeff ccddeeff4 ffeeddcc ffeeddcc ffeeddcc double wordc0 8899aabb ccddeeff 8899aabb ccddeeff na0 ffeeddcc bbaa9988 ffeeddcc bbaa9988 na lwlswl00 8899aabb 8899aabb 8899aabb0 88 88 88 11 99aabb 99aabb 99aabb0 9988 9988 9988 22 aabb aabb aabb0 aa9988 aa9988 aa9988 33 bb bb bb0 bbaa9988 bbaa9988 bbaa9988 44 ccddeeff ccddeeff ccddeeff4 cc cc cc 55 ddeeff ddeeff ddeeff4 ddcc ddcc ddcc 66 eeff eeff eeff4 eeddcc eeddcc eeddcc 77 ff ff ff4 ffeeddcc ffeeddcc ffeeddccchapter 6 ec interface eci 46 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002682 cbus_y command encodinglwrswr00 88 88 880 bbaa9988 bbaa9988 bbaa9988 10 8899 8899 88991 bbaa99 bbaa99 bbaa99 20 8899aa 8899aa 8899aa2 bbaa bbaa bbaa 30 8899aabb 8899aabb 8899aabb3 bb bb bb 44 cc cc cc4 ffeeddcc ffeeddcc ffeeddcc 54 ccdd ccdd ccdd5 ffeedd ffeedd ffeedd 64 ccddee ccddee ccddee6 ffee ffee ffee 74 ccddeeff ccddeeff ccddeeff7 ff ff ff dash in this column indicates the data is undefined b dash in this column indicates the register contents are not affected loads or are ignored stores c double word transfers only occur as part of line read or write table 21 cbus_y commands crossbar request message cbus_ycmdo30 cbus_yszo10 rl 1001 na rlm 1101 na rle 1011 na rlme 1111 na rb 1000 00 rh 1000 01 rt 1000 10 rw 1000 11 um 0101 na wli 0011 na wls 0111 na li 0001 na wb 0000 00 wh 0000 01 wt 0000 10 ww 0000 11 sync 0010 natable 20 effect of endian mode on cbus_y continued inst and addr20big endian little endian cbus addrdataaec dataaregbcbus addrdataaec dataaregb683 rle rlme eviction address lx4580 lexra inc proprietary confidential 47 rev 31 october 11 2002 do not copytable 22 cbus_y source encoding 683 rle rlme eviction address the eviction address for the rle and rlme requests is transferred through the cbus_ydatao line to the cbus_y request interface since physical addresses are 36bits and the cbus_ydatao bus is 32bits wide the entire address cannot be transferred however the eviction address is linealigned so only 30 bits are required the format of the address is as followscbus_ysrco10 request source 00 icache 01 dcache 10 ejtag 11 reserved table 23 cbus_y destination encoding cbus_ydesti20 description 000 idle cycle valid data 100 ejtag reply 010 data cache reply 001 instruction cache reply table 24 cbus_y reply encoding cbus_ylstei20 description 000 ds 001 dls unused 010 dle 011 dlm 100 wsa 101 reserved 110 reserved 111 uma unused 3130 296 50 0 address tag a3512 address index a116chapter 6 ec interface eci 48 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 200269 ibus interface in the eci application the ibus is used to purge the dcache eviction buffers an eviction is caused by sending an ire inquiry via the ibus inquiry interface the dcache presents the evicted line on the ibus reply interface the ibus interface runs at the cpu core clock rate 691 ibus header encoding the header of an ibus reply transfer is identical to the crossbar header fo rmat the only ibus reply supported is iratable 25 ibus request interface signal name direction description ibus_reqi output inquiry request ibus_cmdi10 output inquiry request command ibus_chei10 output coherency engine of inquiry request always 2b00 ibus_tidi30 output tid field of inquiry request ibus_addri350 output address of inquiry request ibus_dbusyo input data cache busy table 26 ibus reply interface signal name direction description ibus_rdyo input inquiry reply ready ibus_starto input inquiry reply header data valid ibus_hdrdatao630 input inquiry reply header data bus ibus_xbusyi output ec interface busy table 27 ibus commands crossbar request message ibus_cmdi10 description ii 00 line invalidation unused iie 01 evict line and invalidate unused ide 10 downgrade line state unused ire 11 replacement eviction610 eci actions on cbus_y commands lx4580 lexra inc proprietary confidential 49 rev 31 october 11 2002 do not copy610 eci actions on cbus_y commands notes 1 on subline cbus_y requests the dcache is not checked or updated 2 further cbus_y requests are throttled during an ibus requestreply sequ ence 3 for sync the eci holds all subsequent cbus_y requests until all previou s writes have completed it is not necessary to wait f or outstanding reads to complete because context with an outstanding read is not active and therefore cannot execute sync instructiontable 28 eci actions on cbus_y requests cbus_y request cbus_ycmdoec interface commandsibus request 2cbus_y reply cbus_ylstei rl eb_write eb_burst eb_instr possiblenone dle rlm eb_write eb_burstnone dlm rle eb_write eb_burstire dle rlme eb_write eb_burstire dlm rs 1 eb_write eb_burstnone ds um um none uma wli none ire none wle none ire none li none none none ws 1 eb_write eb_burstnone wsa sync 3 none none none table 29 eci actions on ibus replies ibus reply cbus_ycmdoec interface commands ia iea can not occur ira eb_write eb_burstchapter 6 ec interface eci 50 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002lx4580 lexra inc proprietary confidential 51 rev 31 october 11 2002 do not copychapter 7 interrupts 71 interrupt overview the lx4580 provides two classes of crosscontext interrupts each context includes eight fla gs to indicate pending cross interrupts two classes from each of the four possible source contexts the pending c ross interrupts are signalled through the ip2 bit of the destination contexts cp0 status register the lx4580 has four active high level sensitive hardware interrupt inputs hw_int41 these interrupts are synchronized within the processor and connected to the ip63 of each contexts cp0 status register the lx4580 also has rising edge sensitive non maskable interrupt input nmi this interrupt is synchronized within the processor and converted to pulse which causes an nmi exception within the cpu software may send an interrupt to any context on the cpu by executing an uncached store word instruction that specifies the address of the cross context interrupt request cci_intreq register the contents of thefigure 12 lx4580 interrupt logicintpend setclear logiccci_intpend one per context 8 18 8 883 3cci_intreq initiator writes to signal interrupt target writes to clear pending interrupts target writes to enable or dis able interruptstarget reads to observe pend ing interrupts target reads to observe inter rupt masksconnected to each contexts causeip2cci_intmask one per contextcrosscontext interrupts external hardware interrupts hw_int414connected to each contexts causeip63 non maskable interruptsynchronize nmi connected to cpus nmi inputpulse generation40 1 2 30 1 2 32 0 1 2 3although there are eight pending cross interrupt signals the example waveforms show only fourchapter 7 interrupts 52 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002word being stored identify the destination context and interrupt class the meaning of the two interrupt classes is software defined the hardwares interrupt setclear logic selects the cci_intpend regist er that corresponds to the destination context and sets the intpend bit within that register that corresponds to the source context and interrupt class the mask bits from each contexts cci_intmask register are anded with cross interrupt pending flag s in each contexts cci_intpend register the results are reduction ored and termine the state of the ip2 bit in the cp0 status register for each context when cross interrupt event is captured in cci_intpend register the hardware acknowledges the cpus write to the cci_intreq register software that initiates cross interrupt can use the sync instruction to verify that the interrupt is pending at the target ie observable by the target through read of the target s cci_intpend register 711 cross context interrupt request register cci_req name crosscontext interrupt register cci_req size 32 bits address irr_base 0 3117 16 152 10 0 class 0 tid field bits description rwreset 0 3117 reserved and must be 0 0 class 16 0 set an intpend0 bit the target context corre sponding to the context id that is performing the write to cci_req 1 set an intpend1 bit the target context corre sponding to the context id that is performing the write to cci_reqw 0 0 152 reserved and must be 0 0 tid 10 id of crossinterrupt target context w 0712 cci_intpend register one per context lx4580 lexra inc proprietary confidential 53 rev 31 october 11 2002 do not copy712 cci_intpend register one per context name cci_intpend size 32 bits address as_base 0x0100 713 cci_intmask register one per context name cci_intmask size 32 bits address as_base 0x0104 sw init none restrictions none 3120 1916 154 30 0 intpend1 0 intpend0 field bitsdescription rwreset 0 3120reserved and must be 0 r 0 intpend1 1916 bit vector identifying source contexts of class 1 interrupts 0 interrupt is not pending 1 interrupt is pendingrw1ca w1c write 1 to clear0 0 154reserved and must be 0 r 0 intpend0 30 bit vector identifying source contexts of class 0 interrupts 0 interrupt is not pending 1 interrupt is pendingrw1c 0 one copy of the cci_intpend register exists for each context this register may be read and written only by its associated context interrupts for each target context are generated as follows intreq2_ntarget intpend intmask the source context of the interrupt sets intpend bits by writing to the irr_cci register intpend bits are cleared by the destination context by writing 1 to the appropriate bit in the intpend register 3120 1916 153 30 0 intmask1 0 intmask0 field bits description rwreset 0 3120 reserved and must be 0 r 0 intmask1 1916 mask the intpend1 bits of the cci_indpend register 0 pending interrupt does not cause exception 1 pending interrupt may cause exceptionrw 0 0 154 reserved and must be 0 r 0 intmask0 30 masks the intpend0 bits of the cci_indpend register 0 pending interrupt does not cause exception 1 pending interrupt may cause exceptionrw 0 one copy of this register exists for each context which may be read and written only by its associated context the im2 bit in contexts cp0 status must be set for cross interrupt to cause an exceptionchapter 7 interrupts 54 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002lx4580 lexra inc proprietary confidential 55 rev 31 october 11 2002 do not copychapter 8 ejtag ej the lx4580 has fullyfeatured debug capability which allows full visibility to all lx4580 cpu functions this capability is based on the mips ejtag debug solution 200 with extra features added to support hmt standard features include full control of all lx4580 cpus via the 5 jtag pins tck tms tdi tdo rst_n instruction and data breakpoints number is tbd hardware singlestepping of any context sdbbp software debug breakpoint and deret debug exception return instructions dma access directly to memory avoiding tlb or cache instruction jamming to the lx4580 cpu through the ejtag memorymapped region features added to support hmt include choice of which context takes debug exception when requested by ejtag option to disable other contexts when one context takes debug exception instruction and data breakpoints match against particular context or all contexts internal pc trace buffers with compression internal simultaneous pc trace buffering of all contexts global interrupt of all lx4580 cpus when debug exception occurs in one cpu context optional connection to ejtag via rs232 uarte port on lx4580 lx4580 supplies one set of jtag pins through which the tap controllers for each lx4580 cpu can be daisychained together the tck and tms signals are broadcast so each tap is always in the same state and the tdi and tdo are daisychained tdo from cpu0 goes to tdi of cpu1 tdo of cpu1 goes to tdi of cpu2 etc figure 13 lx4580 etjag organizationlx4580 ejtagtrace bufferlx4580 cpu 0 tapejtagtrace bufferlx4580 cpu 1 tapejtagtrace bufferlx4580 cpu 2 tapejtagtrace bufferlx4580 cpu 3 taptdi tdo tdi tdo tdi tdo tditdi tms tck tdotdochapter 8 ejtag ej 56 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002the remainder of this chapter is for internal lexra use 81 ejtag differences from 200 the following tables describe implementation optionsdifferences between lexras ejtag solution and the mips ejtag debug solution 200 specification the od column indicates an option or difference 811 ejtag tap registers table 30 ejtag tap registers name opfieldodimplementation specific information reset implementation readonly reg ister0x30 1b0 indicates m32 0 41o4b0000 obsolete field 0 5 1b0 instruction breaks implemented 0 6 1b0 data breaks implemented 0 7 1b1 processor breaks not implemented 1 108o3b000 external pc trace 0 1311o3b000 external pc trace 0 16o1b0 m16 not supported 0 17o1b0 icache does not keep dma coherent 0 18o1b0 dcache does not keep dma coherent 0 19o1b1 ejtag_addr 32 bits wide 1 20o1b0 complex breaks not supported 0 2221o2b10 8bit asid field in implementation 2b10 23o1b1 sdbbp is special2 opcode 1 2524o2b00 profiling support 0 29d1b1 lexra internal trace buffer implemented 1 address 0x8350 36bit address register note although dma accesses use 36bit addresses cpu accesses use 32bit addresses which will appear rightjustified in this register0 data 0x9310 32bit data register 0811 ejtag tap registers lx4580 lexra inc proprietary confidential 57 rev 31 october 11 2002 do not copycontrol 0xa0 d pcbuftac pc trace all contexts rw 0 single context traced rst value 1 all contexts traced0 5 1b0 dlock not supported r 0 6 d doc disable other contexts when in dm 0 other contexts not disabled when in dm 1 other contexts disabled when in dm0 10o1b0 dma error is not supported r 0 13o1b0 dma abort is not supported r 0 14dsetdev 1 debug xcpn vector 0xbfc004800 15dprobeen 0 debug xcpn vector 0xbfc004800 19 pracc write not read name incorrect in 200 0 20o1b0 perrst is not supported r 0 23dpcbufen pc trace enable w1r 0 tracing stopped 1 start tracing0 2524dpcbufmode pc trace mode rw 2b00 continuous trace mode 2b01 trigger stops trace mode 2b10 trigger starts trace mode 2b11 reserved0 26o1b0 external pc trace not supported 0 2827dcdm context in dm r displays the context currently in debug mode only valid when brkstatus bit 3 is set0 3029dcxs context select rw context to be sent debug exception when jtag brk bit 12 is set only valid when jtagbrk is set0 31dwasrst cpu was reset rw rst value 1b0 reset on cpu reset probe can set this bit to 1 and if it is ever cleared cpu reset has occurred0 all 0xb990 100bit register containing concatenation of address data and control registers internaltrace 0xc d data from internal trace buffers function described below1table 30 ejtag tap registers continued name op field od implementation specific information resetchapter 8 ejtag ej 58 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002812 ejtag registers in ff3 drseg below is table of the optionsdifferences in drseg registers with respect to ejtag 200 drseg star ts at logical address 0xff300000 from which the offsets below are shown table 31 ejtag drseg registers name offset fieldodimplementation specific information reset debug control 0 0 trace mode not supported 0 1 mask soft reset not supported 0 2 memory protection not supported 0 3 mask nmi in non dm not supported 0 29o1b1 endianness big 1 ibs 4 30o1b1 asid supported in breaks 1 dbs 8 28o1b1 data break enhancements 1 30o1b1 asid supported in breaks 1 iban 0x100 0x10n1 1b0 mips16 support 0 ibcn 0x104 0x10n1 1b0 complex break supported 0 2120dcontext value to match causes match for specific context only when cntxuse enabled0 22dcntxuse context match use 0 match on any context 1 match on context given in context value0 ibmn 0x108 0x10n1 1b0 mips16 support 0 dban 0x200 0x10n312 address to match 0 dbcn 0x204 0x10n1 1b0 complex break not supported 0 12ono load breaks supported 0 data breaks enabled on loads 1 data breaks disabled on loads0 13ono store breaks supported 0 data breaks enabled on stores 1 data breaks disabled on stores0 2120dcontext value to match causes match for specific context only when cntxuse enabled0 22dcntxuse context match use 0 match on any context 1 match on context given in context value0 dbmn 0x204 0x10n312 address mask 0 address is not masked 1 address is masked082 description of lx4580 cpu specific ejtag features lx4580 lexra inc proprietary confidential 59 rev 31 october 11 2002 do not copy82 description of lx4580 cpu specific ejtag features 821 disable other contexts doc ejtag control register bit 6 this bit affects the behavior of the cpu only when context is in dm when this bit is set it causes other contexts not in debug mode to be disabled matter what the value of the disable context bits in the cp0 lx_ctrl registers when there are contexts in debug mode the running state of contexts is determined by their disable contexts bits note there is skid associated with doc existing instructions in the pipeline complete before other contexts are disabled when cleared the doc bit has affect 822 context select cxs ejtag control register bits 3029 the cxs bits allow selection of which context takes debug exception on jtagbrk ejc bit 12 being asserted hence the cxs bits are only valid when jtagbrk is asserted 823 context in debug mode cdm ejc bits 2827 the cdm bits report which context is in debug mode these bits are only valid when brkstatus ejc bit 3 is asserteddbvn 0x20c 0x10n310ddata value to match only matched on stores masked on loads0 pbn 0x300 310 oprocessor breaks not supported 0 table 32 cop0 ejtag registers nameaddr selfieldodimplementation specific information reset debug 230 6 debug complex break status supported 0 10obus error not supported 0 11otlb exception not supported 0 13o utlb miss not supported 0 14onmi status not supported 0 28olsnm not supported 0 depc 240 310 as 200 0 desave 310 310 as 200 0table 31 ejtag drseg registers continued name offset field od implementation specific information resetchapter 8 ejtag ej 60 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002824 cntxuse cntx in breakpoint control registers the cntxuse and cntx bits in both imatch and dmatch control registers allow matches gainst specific context or against all contexts 825 precise data breaks data breaks are precise the load or store that matches the data breakpoint will be squashed 826 data value break loads data value breaks on loads are not supported 827 ejtag_addr 36bit as the lx4580 has 36bit physical address space and 32bit logical address space the ejtag_addr register is 36bits wide to accommodate the physical address ejtag_addr is used for 2 functions determined by the dma acc bit in the ejc dmaacc 1 ejtag_addr is readwrite and contains the physical address for dma transfer dmaacc 0 ejtag_addr is readonly and contains the logical address of processor access only valid with pracc is set so when dmaacc 0 ejtag_addr contains 32bit logical address in 36bit register it is padded as follows 4b0000 logical address this does not require change in behavior however as this register is readonly when dmaacc0 reading out ejtag_addr only requires 32 shifts as before because the logical address is rightjustified 828 pc trace buffer tac 8281 overview the pc trace buffer provides realtime pc trace solution which does not restrict the speed f the cpu and reduces the pin count which is prohibitive for normal pc trace with multiprocessor systems it employs an onchip ram to store compressed pc trace information for retrieval afterthefact by the ejtag probe stored in the ram is all the information needed to fully reconstruct the program flow if tracing is enabled buffer entry is written on every pc discontinuity the buffer entry contains the target of the discontinuity the asid the number of sequential instructions executed since the last buffer entry was written and tracepoint indicator set if trace point occurred since the last entry was written828 pc trace buffer tac lx4580 lexra inc proprietary confidential 61 rev 31 october 11 2002 do not copy8282 cpu ejtag block diagram the diagram shows the structure of the pc trace buffer block pctb the pctb receives pipeflow information from cop0 every clock cycle it reads and writes entries into the pctb ram the control of the pctb comes from the ejtag probe which can scan in and scan out control and data via the tap to initiate pctb functions 8283 block descriptionsfigure 14 cpu ejtag block diagram cop0 this block sends wstage signals to the pctb providing all the pipeline information needed to write buffer entries thisinformation comes in the form of the wstage pc asid contextand instructiontype code pctb this block is the heart of the pc trace buffer it receives trol from the probe via retimed registers in ejtag control when tracing it tests the data from cop0 and decides when to write buffer entry it also keeps count of the sequential instructions executed since the last buffer entry it handles all the ram accounting keeping track of the address ram address wrapping conditions and startstop tracing conditions ram this block contains the ram used by the pctb it is about 50 bits wide and 128 entries deep ejtag control this block contains all the retiming registers for control information scanned in by the probe it also containsthe registers readwritten by the probe to control the pctb probe this is the ejtag probe it is external to the chip it controls ejtag by scanning data in and out of registers in ejtagcp0 pctb ejtag control scan tapram probepc info type context read dataaddrwrite datarw tditmsjtckcpu ejtag ejtag lx2 lx2 off chip cpu ejtag ejtag lx2 lx2 off chiptdochapter 8 ejtag ej 62 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 20028284 ram format here is the description of buffer entry assuming seq field width 8 here is the description of header entrybit name description 0 val 1b0 marker at the beginning of each entry to indicate that the memory entry is ready to be scanned through the asynchronous interface 1 trig trigger occurred between this and the previous entry 92 seq number of sequential instructions since last entry satu rates 1710 asid asid 4817 pc pc logical address bit name description 0 val 1b0 marker at the beginning of each entry to indicate that the memory entry is ready to be scanned through the asynchronous interface 41 seqw width of seq field in buffer 105 rsvd reserved 6b000000 2518 asidw width of asid field always 4b0100 1430 bufe number of valid buffer entries828 pc trace buffer tac lx4580 lexra inc proprietary confidential 63 rev 31 october 11 2002 do not copy8285 mode of operation pctb function is controlled via bits in the ejtag control register these bits are bit 23 pcbufen previously sync bits 2425 pcbufmode previously pclen and bit 27 pcbuftac trace all contexts bit 29 in the implementation register informs the probe of the presence of the buffer and enables the secondary definition of the four mode bits pcbufen cannot be cleared directly by the probe the hardware clears the bit in number of cases 1 buffer full after trigger for trigger start and stop modes 2 by the probe scanning 0x0c into jtag instruction register to read out buffer entries 3 changing the pcbufmode bits pctb for single context when pcbufen1 the trace buffer continues to fill until stop condition occurs or debug mode is entered when debug mode enters the trace buffer records an entry for the debug exception vector address usually 0xff20_0200 on exiting debug mode the trace buffer records the depc address in triggerstart mode when trigger breakpoint occurs the trace buffer marks its most recent entry as the beginning of the buffer the trace buffer will continue to record entries until it wraps around to this start nd then will stop recordingpcbufena bit 23 pcbufen is set by writing 1 to it only during debug mode 01 transi tion resets the bufferpcbufmode bits 2524 buffer modeb b the buffer mode can be scanned in at any time even when not in debug mode if the mode changes during tracing pcbufen will be cleared stop ping trace1 00 continuous wrap resetstate 1 01 any trigger stops trace triggerstop 1 10 any trigger starts trace triggerstart trace stops when buffer fullc c buffer full means that it wrapped around to the first entry1 11 reserved 0 xx buffer disabledreset resetstate pcbuftac bit 27 contexts traced 1 trace all contexts 0 trace context currently in debug modechapter 8 ejtag ej 64 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002in triggerstop mode the trace buffer continues to record entries until trigger breakpoint occurs the trace buffer will then record one more entry when pc trace stops the pcbufen will be cleared the probe will then scan the data out of the buffer to restart the trace pcbufen must be set this resets the buffer to read the buffer the probe reads each entry sequentially new tap instruction register opcode sel ects the buffer to be read this opcode is 0x0c the first time the probe scans the data register dr after scanning in 0x0c opcode it gets the header that describes the widths of the entry fields and the number of entries when the tap controller reaches the update state the hardware reads the first entry into scan buffer through an asynchronous interface since the memory will be operating using sysclk by the time the tap comes back around to the first entry the scan buffer will have the data from the first entry to indica that data is ready the first bit to be scanned is 1b0 if for some reason the tap controller is fa ster than the asynchronous interface and data is not yet ready in the scan buffer the hardware will scan out 1b1 until data is ready after the first entry has been scanned out the tap will leave the scan state as it passes through the update state the next sequential entry is loaded into the scan register note that it is more traditional that the scan buffer be loaded in the capture state however since the asynchronous interface is going to take several cycles using the previous scans update state will get head start on fetching the entry if the probe tries to scan out data past the number of entries given in the header the data read back from 0x0c will be 1b1 indicating data not valid if the probe changes the jtag instruction register from 0x0c the buffer data will be lost it cannot return to 0x0c and read out more data if it does the data will again be 1b1 not valid pctb for all contexts one extra mode of operation is added to support hmt tracing of all contexts simultaneously in this mode data in the buffer is uncompressed and the seq field is used as context field to indicate to which context the data corresponds this information shows the interaction between threads access to the buffer is the same as when single context is being debugged when the probe starts pc trace all pointers and counters are reset such that any data in the buffer from the previous trace will be lost 829 instruction replay one artifact of hmt is that some instructions loads and stores can be speculatively fetched or replay ed when instructions are jammed there is possibility that particular load or store may have to be jammed number of times before it is executed this condition is easily detected as the address reported in ejtag_addr will not increment when replay has occurred 8210 dmwait the hmt cpu implements dm wait feature which prevents more than one context fr om executing in debug mode at any given time as there is only one instance of various cp0 registers such as des ave used to support debug mode furthermore the ejtag probe software is unlikely to support intermixed accesses to the dmseg and drseg regions therefore after one context begins executing in debug mode due to an ejtag exception any other context which takes an ejtag exception is placed in the dm wa it queue8211 debug mode overrides disable context lx4580 lexra inc proprietary confidential 65 rev 31 october 11 2002 do not copywhile in the dm wait state the context does not issue any instructions when the first context leaves debug mode by executing deret instruction the next context in the dm wait queue resumes execution in the ejtag exception handler 8211 debug mode overrides disable context if debug exception occurs on context which is disabled via the disable context bits in the cop0 lx_ctrl the context will become enabled whilst in debug mode this will allow the debug exception to be taken on exit from debug mode the context will disabled as per its disable context bit 8212 ejtag boot via ejtag boot any lx4580 can start execution from probe space after reset in this mode the rese t vector is changed to 0xff200200 thus the first instruction fetched by the lx4580 is from the probe this mode is controlled by the value of ejcprobeen at reset in order for the probeen bit not to be reset its elf it has its own dedicated reset pin on lx2 prbenrst_d1_r_n this pin should only be asserted on cold reset and should not be asserted when jtag_rst_n is asserted to enter ejtag boot mode the following steps should be taken powerup lx4580 normally and assertdeassert cold reset creset_n connect the ejtag probe to the lx4580 and set the probeen bit in the ejtag control register assertdeassert jtag_rst_n the lx4580 will now be fetching from 0xff200200 the cop0 depc register will be 0x00000000 8213 the lexra probe the lexra probe is internal logic which allows host pc via an rs232 connection to control ejtag in the lx4580 null modem cable is connected from the host pc to 2 pins on the lx4580 ejtag_rx and ejtag_tx pins with this scheme external probe is required as any pc can be connected to the lx4580 with great ease via serial connection the lexra probe logic resides inside the ejtag block ejtag commands are sent to the lexra probe in ascii over rs232 uart connection these commands are translated into jtag commands sent via the jtag pins to the ejtag logic responses to the commands are returned in ascii form from the lexra probe to the host lexra provides software interfaces between the lexra probe and mainstream debugger tools such as ghs and xray 8214 access to ejtag memory space the following table describes the target of different memory accesses as implemented by lexra m main memory p ejtag probe dmseg reg ejtag registers drsegchapter 8 ejtag ej 66 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002 access address dbm probeen ff2 ff3 0 0 m m 0 1 m m 1 0 p reg differs from ejtag 200 1 1 p reg for completeness the ejtag 200 specification has the following difference dbm probeen ff2 ff3 1 0 m reg lx4580 lexra inc proprietary confidential 67 rev 31 october 11 2002 do not copychapter 9 interfaces 91 interfaces table 33 interface summary name pinsdirection description clocks and reset 5 pins cpuclk 1input cpu core clock cpuclk_n 1input cpu core clock differential input creset_n 1input cold reset jtag_rst_n 1input connection from the ejtag probe cfg_bigendian 1input static signal designating powerup endian mode 1 big endian 0 little endian interrupts 4 pins hw_int41 1input external hardware interrupt lines active high chip test 4 pins jtag_tdi 1input jtag test data in jtag_tdo 1output jtag test data out jtag_tms 1input jtag test mode select jtad_tck 1input jtag clock ejtag software debug 4 pins ejtag_dtr 1output egjag data terminal ready ejtag_dsr 1input ejtag data set ready ejtag_rxd 1input ejtag receive data etjag_txd 1output ejtag transmit data ec interface 186 pins see mips ectm interface specification revision 105 eb_a352 34 output address bus eb_ardy 1input system address ready eb_avalid 1output cpu address valid eb_be70 8output byte enables eb_bfirst 1output first address cycle eb_blast 1output last address cycle eb_blen10 2output burst length encoded eb_burst 1output burst transaction eb_ewbe 1input write buffer emptychapter 9 interfaces 68 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002eb_instr 1output instruction transfer eb_rberr 1input bus read error eb_rdata630 64 input read data eb_rdval 1input read data valid eb_sblock 1input static configuration for subblock ordering eb_wberr 1input bus write error eb_wdata630 64 output write data eb_wdrdy 1input write data system ready eb_write 1output write transfer wb_wwbe 1output wait for write buffer empty cbus_z interface 182 pins cbus_zreqo 1output 0 request 1 processor is initiating request cbus_zbusyi 1input 1 external logic cannot accept request the cur rent cbus_z request if any is ignored by external logic 0 external logic is ready to accept request cbus_zaddro350 36 output address cbus_zreado 1output 1read 0write cbus_zsynco 1output 1sync request 0normal request cbus_zread will indicate write on sync cycles cbus_zszo10 2output transfer size 2b00 1 byte 2b01 2 bytes 2b10 3 bytes 2b11 1 word this signal is dont care when cbus_zlineo is asserted cbus_zlineo 1output 1 line access 0 single access cbus_zdatao630 64 output write data cbus_zltido10 2output local thread id cbus_zuco 1output 1 uncached access 0 cached access cbus_zsrco10 2output transaction source within lx4580 2b00 instruction cache 2b01 data cache 2b10 ejtag 2b11 reserved cbus_zrdyi 1input read data is availabletable 33 interface summary name pins direction description91 interfaces lx4580 lexra inc proprietary confidential 69 rev 31 october 11 2002 do not copycbus_zdbusyo 1output 1 lx4580 is not ready to receive data external logic must hold cbus_zdatai cbus_zltidi and cbus_zvaltypei until cbus_zdbusyo is deasserted 0 lx4580 is ready to receive data cbus_zdatai630 64 input read data cbus_zltidi10 2input thread associated with read data cbus_zvaltypei10 2input indicates read data type 2b00 instruction cache 2b01 data cache 2b10 ejtag 2b11 reservedtable 33 interface summary name pins direction descriptionchapter 9 interfaces 70 lexra inc proprietary confidential lx4580 do not copy rev 31 october 11 2002