lx8000 data sheet lexra inc release 19 march 29 2001march 29 2001 lx8000 lexra proprietary confidential 2 release 19 lx8000 data sheet revision 13 for rtl release 19 this document is proprietary and confidential to lexra inc copyright 2001 lexra inc all rights reserved mips mips16 mips abi mipsii mipsiv mipsv mips32 r3000 r4000 and other mips common law marks are trademarks andor registered trademarks of mips technologies inc lexra inc is not associated with mips technologies inc in any way smoothcore radiax and netvortex are trademarks of lexra incmarch 29 2001 lx8000 lexra proprietary confidential 3 release 19 table of contents 1 lx8000 product overview 9 11 introduction 9 12 key features 10 13 lx8000 processor overview 11 14 system level building blocks 13 141 smmu 13 142 local memory interface 13 143 coprocessor interface 13 144 custom engine interface 14 145 lexra bus controller 14 146 building block integration 14 15 rtl core smoothcore 14 16 eda tool support 14 2 lx8000 architecture 17 21 hardware architecture 17 211 module partitioning 17 212 six stage pipeline 18 22 ralu data path 18 23 system control coprocessor cp0 18 24 highperformance context switch 19 241 new context registers 19 242 reset 21 243 determining the number of contexts in software 22 244 initiation of context switch 22 245 csw instruction 22 246 lwcsw ltcsw and lqcsw instructions 22 247 wdcsw instructions 22 248 wdlwcsw wdltcsw and wdlqcsw instructions 23 249 pipeline 23 2410 new thread selection 23 2411 example context switch for coprocessor operation 25 2412 program access to new registers 26 2413 exceptions 27 25 lowoverhead prioritized interrupts 27 3 lx8000 risc programming model 29 31 summary of mipsi instructions 29 311 alu instructions 29 312 load and store instructions 30 313 conditional move instructions 31 314 branch and jump instructions 31 315 control instructions 32 316 coprocessor instructions 33 32 opcode extension using the custom engine interface cei 33 321 cei operations 33 322 interface signals 34 33 memory management 35 34 exception processing 35march 29 2001 lx8000 lexra proprietary confidential 4 release 19 341 exception processing registers status cause epc badvaddr 37 342 exception processing entry and exit 38 35 the coprocessor interface ci 38 4 lx8000 instruction extensions 39 41 context switch and data transfer operations 39 42 bit field processing operations 42 43 cross context access operations 50 44 checksum addition 51 45 lx8000 instruction summary and encoding 52 451 lx8000 instruction formats 54 452 load formats 55 453 write descriptor formats 55 454 context checksum and bit field formats 56 455 cross context move format 57 456 lexracoprocessor0 register access instructions 57 457 lexra subop bit encodings 58 5 lx8000 local memory 59 51 local memory overview 59 52 cache control register cctl 60 53 instruction cache icache lmi 61 54 instruction memory imem lmi 62 55 instruction rom irom lmi 64 56 direct mapped write through data cache dcache lmi 65 57 scratch pad data memory dmem lmi 66 6 lx8000 system bus 69 61 connecting the lx8000 to internal devices 69 62 terminology 69 63 bus operations 70 631 singlecycle read 70 632 read line 70 633 burst read 71 634 singlecycle write 71 635 line write 71 636 burst write 71 637 split read 72 638 write split read 72 639 split data 72 64 signal descriptions 73 65 lbus commands 73 66 byte alignment 75 67 split transactions 75 68 lexra bus controller 76 681 lbc commands 76 682 lbc write buffer and outoforder processing 77 683 lbc read buffer 77 684 transfer descriptions 77 685 single cycle read with waits 79 686 single cycle read with target wait 79 687 line read with waits 80 688 line read with target waits 81march 29 2001 lx8000 lexra proprietary confidential 5 release 19 689 line read with initiator waits 81 6810 burst read 82 6811 singlecycle write with waits 82 6812 singlecycle write with waits 82 6813 burst write with waits 83 6814 burst write with target waits 83 6815 burst write with initiator waits 84 6816 split read command 84 6817 write split read 85 6818 split data 86 69 ordering rules with split transactions 87 610 lbc signals 87 611 arbitration 88 6111 rules 88 6112 lbc behavior 88 612 connecting devices to the bus 88 7 lx8000 coprocessor interface 91 71 attaching coprocessor using the coprocessor interface ci 91 72 coprocessor interface ci signals 91 73 coprocessor write operations 92 74 coprocessor read operations 92 75 coprocessor interface and pipeline stages 93 751 pipeline holds 93 752 pipeline invalidation 93 8 lx8000 ejtag 95 81 introduction 95 82 overview 95 821 ieee jtagspecific pinout 96 83 single processor pc trace 96 831 pc trace dclk debug clock 97 832 pc trace pcst program counter status trace 97 833 pc trace tpc target program counter 98 834 singleprocessor pc trace pinout 98 835 vectored interrupts and pc trace 98 836 demultiplexing of tdo and tdi during pc trace 99 84 data break exceptions for lx8000 99 841 data break data matches on lbus split transactions 99 842 data breaks on write descriptor accesses 99 843 support for the loadtwin instruction 99 appendix alx8000 lconfig forms 101 a1 configuration options for the lx8000 packet processor 101 appendix blx8000 port descriptions 103 appendix c lx8000 pipeline stalls 111 c1 stall definitions 111 c2 instruction groupings 111 c3 nonsequential program flow issue stall 111 c4 load subword stall 112 c5 storeload stall 112 c6 storeany storesubword stall 112march 29 2001 lx8000 lexra proprietary confidential 6 release 19 c7 loadstore ops stall matrix 112 c8 mvcz stall 112 c9 immu stall 112 c10 immu issue stall 113 c11 icache miss stall 113 c12 dcache miss stall 113 c13 pipeline timing diagrams for stalls 113 c131 nonsequential program flow issue stalls 113 c132 load subword stall 114 c133 storeload stall 114 c134 storeany store subword stall 114 c135 mvcz stall 114 c136 lwcz stall 114 c137 icache miss stall 115 c138 dcache miss stall 115march 29 2001 lx8000 lexra proprietary confidential 7 release 19 list of figures figure 1 lx8000 processor overview11 figure 2 processor core module partitioning17 figure 3 context associated registers20 figure 4 insert and extract operations straddle case43 figure 5 packet field compaction with variable alignment47 figure 6 lexra system bus diagram69march 29 2001 lx8000 lexra proprietary confidential 8 release 19 list of tables table 1 eda tool support15 table 2 cp0 registers19 table 3 context status register detail21 table 4 scheduler ports25 table 5 prioritized interrupt exception vectors28 table 6 alu instructions29 table 7 load and store instructions30 table 8 conditional move instructions31 table 9 branch and jump instructions31 table 10 control instructions32 table 11 coprocessor instructions33 table 12 custom engine interface operations34 table 13 custom engine interface signals34 table 14 smmu address mapping35 table 15 list of exceptions36 table 16 context switching instructions39 table 17 bit field processing instructions43 table 18 hash instruction key bit definition48 table 19 cross context access instructions50 table 20 checksum addition instructions 51 table 21 instruction summary52 table 22 lexra subop bit encoding58 table 23 local memory interface modules59 table 24 icache configurations61 table 25 icache ram interfaces62 table 26 imem configurations63 table 27 imem ram interfaces63 table 28 irom configurations64 table 29 irom rom interfaces65 table 30 dcache configurations65 table 31 dcache ram interfaces66 table 32 dmem configurations67 table 33 dmem ram interfaces67 table 34 line read interleave order71 table 35 lbus signal description73 table 36 lbus byte lane assignment75 table 37 lbus gtid fields76 table 38 lbus commands issued by the lbc76 table 39 lbc interface signals87 table 40 coprocessor interface signals91 table 41 ejtag pinout96 table 42 ejtag ac characteristics96 table 43 ejtag synthesis constraints96 table 44 singleprocessor pc trace pinout98 table 45 singleprocessor pc trace ac characteristics98 table 46 lx8000 processor port summary103 table 47 instruction groupings for stall definition111 table 48 loadstore ops stall matrix112march 29 2001 lx8000 lexra proprietary confidential 9 release 19 1 lx8000 product overview 11 introduction the lx8000 is based on lexras lx4189 processor complete mips r3000class processor subsystem developedforeaseofintegrationseefigure1onpage11themajorsubsystemsarethecpucorelocal memory interfaces lmi and lbus controller lbc the technology includes optional interfaces to customerdefined coprocessors ci13 and optional customer extensions to the mips isa custom engine the local instruction memories and data memories may include fixed ram andor cache the sizes are configurable the figure also highlights the lx8000 multicontext register file to support fast context switching additional lx8000 extensions include new bitfield operations for efficient packet header processing and dedicated data ram port that the application may use for background data transfers network communications systems are characterized by demanding realtime performance requirements typicallysystemdesignershaveaddressedtheserequirementswithcustomasicsofftheshelfprocessors and plds the explosive growth in the size and bandwidth of the internet has recently stimulated semiconductorcompaniestodevelopanewtypeofproductcalledanetworkprocessorunitnputoserve these applications these ics incorporate multiple programmable cores and specialized peripherals compared to asic development npus offer the system designer faster timetomarket and flexibility to implementdifferentiatedservicesinsoftwarecomparedtogeneralpurposeofftheshelfcomponentsnpus offer the promise of lower cost and superior performance through architectural specialization lx8000 is scalableprocessorwiththespecializedarchitecturalfeaturesneededforhighperformancepacketprocessing for wide variety of new products the time required to process packets for ip routing and classification is dominated by long latency operationssuchastablelookupsfromlargememoriesandbufferaccesseshoweveradistinguishingfeature of network communications systems is that subsequent packets are readily available for independent processingthereforeafastcontextswitchcanbeexploitedtohidethememorylatencylx8000includesa configurable number 18 of general register sets and program counters along with instructions for fast context switching this enables multiple software threads to efficiently execute on single processor thread is deactivated under software control either i unconditionally ii when load with context switch instruction is coded for long latency load or iii when command is written to shared system device following context switch the cpu activates new thread from the pool of ready threads the context switch does not introduce stall cycles because the new thread has an independent general register set it can quickly resume processing to avoid stalling the new thread while the previous threads data transfer completes the lx8000 incorporates dedicated port to the processors data memory for the transfer of packet data in addition the memory system is nonblocking permitting local accesses and cache hits to operate in parallel with one outstanding global access per context with this architecture context switches may be used frequently to achieve optimal performance packetprocessingalsorequiresfrequentaccesstobitfieldsinthepacketheaderthatarenotbytealignedfor this reason lx8000 has extended the mips instruction set architecture isa to include complete set of bitfield operations for field extract insert set and clear deterministic allocation of realtime is another importantprobleminnetworkcommunicationssoftwarethisproblemiscompoundedbymultiprocessing for this reason the lx8000s configuration options include dedicated uncached local instruction and data memories for realtime critical instructions and data in order to avoid cache miss penalties because the lx8000 packet processor executes the mips i instruction set1 wide variety of third party software tools are available including compilers operating systems debuggers and incircuit emulators lexraalsosuppliesassemblerextensionsandacycleaccurateinstructionsetsimulatorissprogrammers mayuseofftheshelfccompilersforinitialcodingthenreplaceperformancecriticalcodewithoptimized 1 unaligned load and store instructions are not supported in hardware or softwaremarch 29 2001 lx8000 lexra proprietary confidential 10 release 19 assembler code 12 key features complete packet processor subsystem executes mips i isa except unaligned loads stores extensive thirdparty tool support highperformance 6stage pipeline local instruction memory andor cache configurable sizes local data memory andor cache configurable sizes memory interface logic included system bus controller split read transactions to system bus devices optional customerdefined coprocessors optional customerdefined instruction extensions support ejtag draft 20 with extensions for multithread debugging highperformance context switch processor provides 18 contexts the number is customerconfigurable independent program counter status and general registers for each context wasted cycles for context switch context switch initiated by program thread reactivation based on completion of data transfer asynchronous external events or program control bitfield instructions singlecycle extract set clear twocycle extractandinsert with source fields that may span two registers dual 16bit ones complement add for checksum portable rtl model available as synthesizable rtl portable to any 025 µm 018µmor 015µm logic and sram process foundry partners include ibm tsmc and umc optional hard macro model processor with 4 contexts 16kb imem 16kb dmem tsmc 015 µm results typical process worst case operating conditions clock 450 mhz area 47 mm2 power 210 mw easy asic design single phase clocking fully synchronous design easy to interface system bus protocol supports popular eda toolsmarch 29 2001 lx8000 lexra proprietary confidential 11 release 19 easy rtl customization userconfigurable local memory reset method clock distribution userconfigurable ejtag breakpoints over 30 other configuration options interfaces for adding applicationspecific instructions ejtag debug optional extension the ejtag 200 specification supports multicontext environment for onchip debug development tools available from third party suppliers supporting the mips architecture includes industry leaders green hills software embedded performance inc and wind river systems 13 lx8000 processor overview thelx8000isariscprocessorthatexecutesthemipsiinstructionset1alongwithlexrasinstructionset extensionshowevertheclockingpipelinestructurepinoutandmemoryinterfaceshaveallbeendesigned by lexra to reflect systemonsilicon design needs deep submicron process technology as well as design methodology advances the figure below shows the structure of the lx8000 processor figure 1 lx8000 processor overview mipsisaexecution thelx8000supportsthemipsiprogrammingmodeltwosourceoperandscanbe supplied and one destination update performed per cycle the second operand is either register or 16bit immediatetheinstructionsetincludesawideselectionofaluoperationsexecutedbytheralulexras proprietary register based alu the ralu also generates memory addresses for 8bit 16bit and 32bit register loads from stores to memory by adding register base to an immediate offset branches are based on comparisons between registers rather than flags and are therefore easy to relocate optional links following jump or branch instructions assist with subroutine programming the mips unaligned load and store instructions are not supported because they represent poor price 1 the mips unaligned load and store instructions lwl lwr swl swr are not supportedinst ramicache ram inst lmi data lmi data ramdcache ramlx8000 cpu corecustom engine ci 13ceiinstruction bus addr data ctl data bus addr data ctl coprocessorlbcsystem bus denotes customer logicinst rom backgrounddmamarch 29 2001 lx8000 lexra proprietary confidential 12 release 19 performance tradeoff for embedded applications their absence does not affect the software programming model isa extensions for network processing lexra has added 32 new instructions to the lx8000 to optimize forhighperformancepacketprocessingbitfieldoperationsareincludedtoacceleratelookupkeyformation used in packet classification specialized hash functions table lookup instructions and onescomplement addition are also included many of the new instructions are used to facilitate highspeed data movement fundamental to network communications64bitscanbeloadedfromlocaldataramintoageneralregisterpairinasinglecycleup to128bitscanbetransferredfromsharedmemorybyasingleinstructionthelexraextensionsalsosupport atomicreadmodifywriteoperationsonthesharedmemorieslatenciesinaccesstosharedmemoryonchip or offchip can be hidden using zerooverhead switch between the eight independent hardware contexts pipeline lx8000 instructions are executed by sixstage pipeline that has been designed so that all transactions internal to the lx8000 as well as at the interfaces occur on the positive edge of the processor clock twophase clocks are not used context switching the lx8000 incorporates up to eight independent 32 x 32b general register sets called contexts execution can switch between independent tasks called threads this context switch is performed with wasted cycles and prevents stalls while waiting for data from onchip or offchip shared resources context switches occur under program control when data is loaded from shared resources background load of 32bits 64bits or 128bits from shared resource can be accomplished with single load instruction special class of instructions called write descriptor wd allow command or data to be directed to sharedresourceincludingarequestforupto128bitsofreturndatathisallowsshareddevicestoefficiently perform operations that atomically examine and modify memory state the processor performs the wd operationinasingleinstructioncyclewithoutstallsbyusingacontextswitchwhenacontextswitchoccurs the program counter of the suspended thread is stored in cp0 register while execution switches to another threadthenextthreadisautomaticallyselectedfromthepoolofreadytorunthreadsofequalpriorityusing windowed roundrobin algorithm exception handling the mips r3000 exception handling model is supported exceptions include both instructionsynchronous trapsaswellashardwareandsoftware interruptsthestatusregistercontrolsthe interrupt mask and operating mode exceptions are prioritized when an exception is taken control is transferred to the exception vector the current instruction address is saved in the epc register and the exceptionsourceisidentifiedinthecauseregisterauserprogramlocatedattheexceptionvectoridentifies thecauseoftheexceptionandtransferscontroltotheapplicationspecifichandlerintheeventofanaddress error exception the badvaddr holds the failing address coprocessoroperations thelx8000supports32bitcoprocessoroperationstheseincludemovestoand from the coprocessor general registers and control registers mtcz mfcz ctcz cfcz coprocessor loads and stores lwcz swcz and branches based on coprocessor condition flags bczt bczf the lexrasuppliedcoprocessorinterfacecansupportcoprocessoroperationsinasinglecyclewithoutpipeline stalls lx8000 provides excellent priceperformance and timetomarket there are two main approaches which lexra has taken to achieve this deliver simple building blocks outside the processor core to enable system level customizations such as coprocessors application specific instructions memories and busses deliver either fully synthesizable verilog source model or fully implemented hardcore called smoothcore for popular pureplay foundriesmarch 29 2001 lx8000 lexra proprietary confidential 13 release 19 section 14 describes the building blocks and section 15 describes the deliverable models 14 system level building blocks the lx8000 processor is designed to easily fit into different target applications it provides the following building blocks simple memory management unit smmu an optimized custom engine interface cei up to three coprocessor interfaces ci flexible local memory interface lmi that supports instruction cache instruction ram instruction rom data cache and data ram lexra bus controller lbc to connect peripheral devices and secondary memories to the processors own local buses the following sections discuss each of these system building block interfaces 141 smmu the lx8000 smmu is designed for embedded applications using single address space its primary function is to provide memory protection between user space and kernel space the smmu is consistent with the mips address space scheme for userkernel modes mapping and cacheduncached regions 142 local memory interface the lx8000s harvard architecture provides local memory interfaces lmis that support instruction memory and data memory synchronous memory interfaces are employed for all memory blocks the lmi block is designed to easily interface with standard memory blocks provided by asic vendors or by third party library vendors the lmis provide twoway set associative instruction cache interface and directmapped writethrough datacacheinterfacethetagcomparelogicaswellasacachereplacementalgorithmareprovidedaspartof the lmi one of the instruction cache sets may be locked down as unswappable local memory local instructionanddatamemoriescanalsobemappedtofixedregionsofthephysicaladdressspaceandinclude nonvolatile memory such as rom flash or eprom 143 coprocessor interface lexrasuppliesanoptionalcoprocessorinterfaceciforapplicationsrequiringthisfunctionalityuptothree cis may be implemented in one design the coprocessor interface eavesdrops on the instruction bus if coprocessor load lwcz or move to mtcz ctcz is decoded data is passed over the data bus into ci register then supplied to the designerdefined coprocessor similarly if coprocessor store swcz or movefrommfczcfczisdecodeddataisobtainedfromthecoprocessorandloadedintoaciregister then transferred onto the data bus in the following cycle the design interface includes data bus fivebit addressandindependentreadandwriteselectsforcoprocessorregistersandcontrolregistersthelx8000 pipeline and harvard architecture permit single cycle coprocessor access and transfer an application defined coprocessor condition flag is synchronized by the ci then passed to the sequencer for testing in branch instructionsmarch 29 2001 lx8000 lexra proprietary confidential 14 release 19 144 custom engine interface the lx8000 includes custom engine interface cei that the application may use to extend the mips i alu opcodes with applicationspecific or proprietary operations similar to the standard alu the cei supplies the custom engine two input 32bit operands src1 and src2 one operand is selected from the register file depending on the most significant 6 bits of the opcode the second operand is either selected from the register file or is 16bit signextended immediate the opcode is locally decoded by the custom engine and following execution by the custom engine the result is returned on the 32bit result bus to the lx8000 to support multicycle operations stall input is included in the interface 145 lexra bus controller thelexrabuscontrollerlbcistheinterfacebetweenthelx8000andtheoutsideworldwhichincludes dram and various peripherals it is nonmultiplexed nonpipelined and nonparity checked bus to providetheeasiestbusprotocolfordesignintegrationontheprocessorsidethelbcprovidesawritebuffer of configurable depth to support the writethrough cache as well as the control for byte and halfword transfers on the peripheral side the lbc is designed to easily interface to industry standard bus protocols such as pci usb and firewire thelbccanrunatanyspeedfrom33mhzuptothespeedofthelx8000processorcoreinboththertl core and smoothcore 146 building block integration the lx8000 configuration script lconfig provides menu of selections for designers to specify building blocks needed number of different memory blocks target speed and target standard cell library next the configuration software automatically generates top level verilog model makefiles and scripts for all steps of the design flow for testability purposes all building blocks contain scan control signals the lexra synthesis scripts include scan insertion which allows atpg testing of the entire lx8000 core 15 rtl core smoothcore lexra delivers lx8000 as rtl core and smoothcore rtlcore forfullasicdesignsthertlisfullysynthesizableandscantestableverilogsourcecodeand maybetargetedtoanyasicvendorsstandardcelllibrariesinthiscasethedesignermaysimplyfollowthe asicvendorsdesignflowtoensurepropersignoffinadditiontotheverilogsourcecodeandsystemlevel test bench lexra provides synthesis scripts as well as floor plan guidelines to maximize the performance of the lx8000 smoothcore forcotdesignsthataremanufacturedatpopularfoundriessuchasibmtsmcandumc smoothcore port is the quickest lowest cost and best performance choice in this case lx8000 has been fully implemented and verified as hard macro all data path register file and interface optimizations have beenperformedtoensurethesmallestdiesizeandfastestperformancepossiblefurthermorethereisascan based test pattern that provides excellent fault coverage during manufacturing tests 16 eda tool support lexra supports mainstream eda software so designers do not have to alter their design methodology the following is snapshot of eda tools currently supportedmarch 29 2001 lx8000 lexra proprietary confidential 15 release 19 table 1 eda tool support design flow tools supported simulation synopsys vcs cadence verilog xl cadence ncverilog synthesis synopsys design compiler static timing synopsys primetime dft synopsys tetramax pr avant apollo iimarch 29 2001 lx8000 lexra proprietary confidential 16 release 19 march 29 2001 lx8000 lexra proprietary confidential 17 release 19 2 lx8000 architecture 21 hardware architecture 211 module partitioning the lx8000 processor core includes two major blocks the ralu register file and alu and the cp0 controlprocessortheraluperformsaluoperationsandgeneratesdataaddresseswhilecp0includes instruction address sequencing exception processing and product specific mode control the ralu and cp0 are looselycoupled and include their own independent instruction decoders figure 2 processor core module partitioningmulticontext register file n x 32 x 32bit r00instruction address and control alu pridexception processing logicpc and sequencerinstructions datadata address and controlflags traps and jump addresscxstatusn cxpcnralu cp0march 29 2001 lx8000 lexra proprietary confidential 18 release 19 212 six stage pipeline the lx8000 has six stage pipeline thesixstagepipelineprovidesacompleteprocessorcyclefortheinstructionmemoryprovidingeaseofuse integrating for allowing use of larger and setassociative memories without degrading cycle time the six pipeline stages allow the processor clock speed to scale with current silicon processes as result of the dstage two cycle penalty is incurred on branch prediction failure vs the onecycle penaltyinthelx4180fivestagepipelinehoweverthelx8000sconditionalmoveinstructionscanbeused to avoid any wasted cycles in the control of realtime critical loops 22 ralu data path thelx8000raluincorporatesamulticontext32x32bfourportregisterfileonewriteportisdedicatedto 32bitregisterfileloadsfromthedatabusloadsmfczcfczmovesfromcoprocessortheremaining three ports 2r1w are used for the other operations such as alu operations in the lx8000 the two write ports are also used to support 64bit loads from the data bus theinstructionsetincludesawideselectionofaluoperationsexecutedbytheraluinthecaseofalu operations one operand is register and the second operand is either register or 16bit immediate value the immediate value is signextended or zeroextended depending on the operation signed adds and subtracts can generate the arithmetic overflow trap ov which is sampled by cp0 theralualsogeneratesthevirtualmemoryaddressesforregisterloadsfromstorestomemorybyadding aregisterbasetoasignextended16bitimmediateoffsetdataaddresserrorsgeneratethe adelades trap flags which are sampled by cp0 the lx8000 employs bigendian memory addressing branches are based on comparisons between registers rather than implicit flags permitting the programmer moreflexibilityfromthesecomparisonstheralugenerates nandzflagsforsamplingincp0branchor jump instructions may optionally store in general purpose register the address of the instruction at the memory location following the branch delay slot of jump or branch which is taken this register called thelink holds the return address following subroutine call coprocessor operations permit moves of the general purpose registers to one of three optional application specific coprocessors the general purpose registers may also be loaded from the coprocessor registers these transfers occur over the data bus similar to data memory loads and stores 23system control copr ocessor cp0 the system control coprocessor cp0 is responsible for instruction address sequencing and exception processing fornormalexecutionthenextinstructionaddresshasseveralpotentialsourcestheincrementoftheprevious address branch address computed using pcrelative offset or jump target address for jump addresses the absolute target can be included in the instruction or it can be the contents of generalpurpose register transferred from the ralustage 1 i instruction fetch stage 2 d decode stage 3 s source fetch register file read stage 4 execution and address generation stage 5 m memory data select read data cache store and tags stage 6 w write back to register filemarch 29 2001 lx8000 lexra proprietary confidential 19 release 19 branches are assumed or predicted to be taken in the event of prediction failure two stall cycles are incurred and the correct address is selected from special backup register statistics from several large programssuggestthatthesestallswilldegradeaveragelx8000throughputbyseveralpercenthoweverthe net effect of the lx8000s branch prediction on performance is positive because this technique eliminates certain critical paths and therefore permits higher speed system clock if anexception occurs cp0 selects one of several hardwired vectors for the next instruction address the exception vector depends on the mode and specific trap which occurred this is described further in section34 exception processing the following registers which are visible to the programming model are located in cp0 table 2 cp0 registers epc status cause and badvaddr are described further in the section34 prid is readonly register that allows the customers software to identify the specific version of the lx8000 that has been implemented in their product the cctl register is lexra defined cp0 register used to control the instruction and data memories as described in section52 cache control register cctl the contents of the above registers can be transferred to and from the ralus generalpurpose register file usingcp0operationsunlikeregisterslocatedincoprocessors13theycannotbeloadedorstoreddirectly to data memory 24 highperformance context switch thelx8000cpuincorporatesmultipleindependentregistersetscalled contextsasaresultexecutioncan switch between independent tasks called threads each running in its own context this switch is called context switch conventional risc architectures perform context switching in software however packet processing demands special hardware support to achieve high performance context switching the lx8000 provides zerooverhead context switch that is an instruction can be executed for somecontext in every cycle 241 new context registers thenumberofcontextsiscustomerdefinedusinglexras lconfigutilityonetoeightcontextsaresupported by the lx8000 rtl default is one context each context includes 32 general registers r0 r31 1 32bit cxpc program counter 1 16bit cxstatus registercp0 register number function badvaddr 8 holds bad virtual address if address exception error occurs status 12 interrupt masks mode selects cause 13 exception cause epc 14 holds address for return after exception handler prid 15 processor id readonly 0x0000c701 for lx8000 cctl 20 instruction and data memory controlmarch 29 2001 lx8000 lexra proprietary confidential 20 release 19 the general registers are located in the ralu the cxpc and cxstatus registers are located in cp0 in addition 3bit register movecx is located in cp0 and is accessible with the mtlxc0mflxc0 instructions variants of the mips standard mtc0mfc0 instructions movecx holds the encoded numberofthetargetcontextforthemfcxcmtcxcandmfcxgmtcxginstructionswhichcanaccess the registers of any context these new registers are illustrated in figure3 the currently active context number is an implicit readonly value that is accessed with the mycx instruction figure 3 context associated registers the mips i isa except for unaligned loads and stores is fully supported in each context as result the general register set for each context is fully consistent with the mips isa requirements for example r0 is hard wired to 0 and r31 is an implied link for certain branch and jump instructions in every context up to two source registers and one destination register may be specified for an alu operation again consistent with the mips programming model cxpc holds the 32bit virtual address of the next instruction to be fetched by the associated thread the 16 bit cxstatus register indicates whether the thread is waiting for data transfer or io events cxstatus also permits programassigned priority for thread reactivation the cxstatusregisterfields are identified in table3 each field is explainedbelow the rdwr or rd onlyindicationsapplytoaccessusingthemtcxcandmfcxcinstructionstheeffectsofotherhardware and software events on the fields is shown explicitly and explained in the following paragraphs the cxstatus waitevent field provides eight event flags that may be controlled by hardware software or combination of the two the flags may be set with the csw instruction or the wdcsw instructionthewdcswinstructionupdatesthewaiteventflagswritesadescriptortothesystembus and performs context switch whenwaiteventbitsaresetwithawdcswinstructiontheprocessorinitiatesanuncachablewriteto the system bus and performs context switch all context switches are performed after oneinstruction delay slot the waitevent bits may be cleared via software from another thread with the postcx instruction or by hardware through the event signal inputs when the target device completes the wd operation it notifies the processor with high pulse on themulticontext register file context control registers context 7 r0 r31 context 1 r0 r31 context 0 r0 r31context 7 cxpc cxstatus lxc0 control register movecxcontext 1 cxpc cxstatus context 0 cxpc cxstatus march 29 2001 lx8000 lexra proprietary confidential 21 release 19 processorscorrespondingeventsignalinputeightperthreadtheprocessorthenclearsthewaitevent bit in the contexts cxstatus register software can set more than one waitevent bit which will requireacompletionresponseoneachofthecorrespondingeventsignalinputsbeforethethreadisreadyfor execution the cxstatus waitload bit indicates that the associated thread is waiting for the completion of register load from uncached memory or memorymapped io following execution of lwcsw load word with context switch ltcsw load twinword with context switch or lqcsw load quadword with context switch see section244 for descriptions of these three instructions waitload is set following execution of lwcsw ltcsw lqcsw wdlwcsw wdltcsw or wdlqcsw instructions and cleared by the processor when the load data is transferred to the contexts general register file thethreebitthreadpriorityfieldincxstatusallowsthreadschedulingwithuptoeightpriorities an application specific thread scheduler can utilize thread priorities to fine tune the thread scheduling see section244 for details of the thread scheduling hardware interface table 3 context status register detail 242 reset at reset the general registers are unaffected by reset thread 0 is activated at reset all cxpcs are reset to the common mips reset vector 0xbfc0000 however thread 0 may modify the initial cxpc of the other threads prior to the first context switchfieldwidth bitsdescription waitevent 8 rdwr set with csw and wdcsw instructions cleared by external hardware or cleared with postcx instruction reserved 4 rd only reserved waitload 1 rdwr set with lwcsw ltcsw lqcsw wdlwcsw wdltcsw and wdlqcsw instructions cleared by hard ware threadpriority 3 rdwr thread priority for use by optional custom thread scheduler cxstatus150 0x0000 cxpc310 0xbfc00000 movecx20 00015 0000 waitevent threadprio87 4 2 0 84 3waitld 13march 29 2001 lx8000 lexra proprietary confidential 22 release 19 243 determining the number of contexts in software as described above the number of contexts that are implemented in processor is customer defined using lexraslconfigutility in some cases software will be written that must be adaptable to an unknown number ofcontextsforanynonimplementedcontextreadingthecxstatusregisterwillalwaysreturnavalueof zerousingtheinstructionsdescribedinsection2412programaccesstonewregistersthesoftwarecan attempt to write nonzero value to the cxstatus register for each context if the value zero is returned when attempting to read back the written value then that context is not implemented 244 initiation of context switch context switch is executed by the csw instruction and any of the following instructions that include the csw extension 245 csw instruction the context switch csw instruction causes an unconditional context switch allowing the application program to execute context switch under complex programdefined conditions by alternately executing or branching around the csw instruction bits 3124 of the rs register specified in the csw instruction are logically ored with the waitevent field of cxstatus to determine the new waitevent field settings 246 lwcsw ltcsw and lqcsw instructions theloadwordwithcontextswitchlwcswinstructionisusedtoinitiatealonglatencytransferfroman lbus device to general register lwcsw performs split transaction read so that the next thread can continue to execute while the memorymapped resource is accessed only two clock cycles of system bus tenurearerequiredtoinitiatethesplitreadtransactionfollowinginitiationthebusisavailableforotheruse the final transfer of the return data uses one cycle of system bus tenure loading the final result into the register file will not stall the currently executing thread unless the thread is executing load or store instruction at the time the split read data is returned in this case single cycle stall is required to load the split read data into the register file the currently executing thread is otherwise unaffected by the return data similarly ltcsw is used to initiate long latency load of 64bit data into two consecutively numbered general registers starting with the low register address bit equal to 0 up to two processor stalls can occur whenthe64bitdataistransferredintotheregisterfilelqcswisusedtoinitiatealonglatencyloadof128 bit data into four consecutively numbered general registers starting with the two low order register address bitsequalto00uptofourprocessorstallscanoccurwhenthe128bitdataistransferredintotheregisterfile following lwcsw ltcsw or lqcsw waitload in cxstatus is set 247 wdcsw instructions the write descriptor wd instruction forms 64bit descriptor from the contents of two general registerscsw rs context switch update cxstatus from rs lwcsw rt displacementbase load word from uncached memory ltcsw rt displacementbase load twinword from uncached memory lqcsw rt displacementbase load quadword from uncached memory wd rs rt device write descriptor to device wdcsw rs rt device write descriptor to device with context switch wdlwcsw rd rs rt device write descriptor load word reply data wdltcsw rd rs rt device write descriptor load twin reply data wdlqcsw rd rs rt device write descriptor load quad reply datamarch 29 2001 lx8000 lexra proprietary confidential 23 release 19 and writes the descriptor over the system bus interface to the specified device an optional context switch may be performed by this instruction by appending csw suffix to the mnemonic these instructions are used to initiate longlatency operations to shared device theseinstructionsformthedescriptorusingrsandrtregistercontentsasdescribedindetailinsection4for wdcsw the upper bits of the descriptor identify the waitevent bits to be set the wd instruction sourcesthefull64bitsofthedescriptoronthesystembusthe32bitsystembusaddressofthetargetdevice is formed by concatenating 24bit configuration defined constant the 5bit device id from the instruction opcode and three bits of 0 248 wdlwcsw wdltcsw and wdlqcsw instructions the wdlwcsw wdltcsw and wdlqcsw instructions provide efficient operation with devices that return3264or128bitsofdatatheseinstructionssetthewaitloadbitinthecxstatusregisterthe wdlwcsw writes 64bit descriptor to device and requests the device to provide split transaction word read response likewise the wdltcsw wdlqcsw instruction writes descriptor and requests the device to provide split transaction twinword quadword read response note that csw suffix is mandatory for these instructions because they must always set waitload these instructions do not set waitevent bits in the cxstatus register 249 pipeline followingexecutionofacontextswitchinstructionlwcswltcswlqcswwdcswwdlwcsw wdltcsw wdlqcsw or csw the next instruction executes to completion in the current context beforethecontextswitchiseffectiveinotherwordsthecontextswitchasaresultofpipelininghasan architectural delay slot exposed to the programmer this delay slot and restriction on its usage is explained below and is generally consistent with similar branch and jump delay slots in the mips i isa the delay slot is illustrated below intheexamplethreadisinstn1executestocompletioncxpcistorestheaddressofinstn2theaddress wherethreadiresumeswhenitislaterreactivatedafterinstn1iscompletethenextinstructionexecuted is inst m1 in threadj of course threadi and threadj may execute two completely different tasks or execute the same task on different data in this case the pcs will also be unrelated number of restrictions apply to the delay slot instruction 1 branch or jump may be coded in the delay slot context switch changes program ﬂow like the branch or jump this restriction is thus similar to the mips i restriction that back toback branches or jumps can occur 2 the registers loaded by lwcsw ltcsw lqcsw wdlwcsw wdltcsw or wdlqcsw cannot be referenced in the delay slot following the load similar restriction exists for loads in the mips i isa 2410 new thread selection following execution of context switching instruction the cpu selects the next thread for activation from the available pool the available pool consists of those threads for which the cxstatus registers wait event and waitload fields are clearthreadi threadj inst n csw r7 inst m inst n1 addu r3 r2 r1 inst m1 addu r7 r6 r3 inst n2 subu r4 r3 r1 inst m2 march 29 2001 lx8000 lexra proprietary confidential 24 release 19 if thread is available the cpu stalls after executing the context switching instruction and its delay slot stall conditions can arise when all threads initiate long latency processes for example all threads might initiateablocktransferwithinashortperiodoftimesuchthatnotransferhascompletedwhenthelastthread performs its context switch thecpulogicrequiredtoimplementtheabovenextthreadselectionalgorithmispipelinedasaresultthe next thread selection in the dstage of the pipeline critical path can be very simple with this approach thecxstatusregistersamplingusedfornextthreadselectionwilloccurseveralcyclesearlierandmaynot include newly available thread however this is not drawback because event completions for inactive threadsareasynchronoustothecurrentthreadsprogramthelx8000sinternalthreadschedulerdescribed in the following paragraphs is pipelined such that if there is currently active thread all threads are have some wait bit set it takes two cycles from the time that some thread has all of its wait bits clear until that threads cxpc value is driven to the instruction ram the lx8000 processor includes internal thread scheduling hardware the scheduler examines the cxstatus register of each context to determine which contexts are ready for execution context for which all of the waitevent and waitload bits are zero may be selected on the next context switch operation the lx8000s internal thread scheduler ignores the threadpriority field of the cxstatusregisteritselectsthenextthreadfairlyacharacteristicofthisscheduleristhatifthreadsare performing similar types of activities over time they experience similar selection rates and similar delays in selection when there are multiple threads ready for execution thealgorithmemployedbytheinternalschedulerreliesonawindowofreadythreadsthefollowingsteps in the algorithm are endlessly repeated once window of ready threads has been chosen other threads are added to this window ifareadythreadinthewindowsubsequentlyhasoneofitswaitbitsturnedonthatthread is removed from the window since the window contains only inactive threads this can only happen if the currently active thread executes mtcxc to turn on another threads wait bit this is an unusual case because it is expected that mtcxc will only be used during system initialization onebyoneascontextswitchesareexecutedathreadfromthewindowisselectedforthe next context switch as each contextswitch takes effect the selected thread is removed from the window the selection among the threads in the window is not architecturally defined and application software should not depend on any particular order the current implementation selects the highest numbered thread in the window but this may be changed in future implementations whenthewindowisabouttobecomeemptyanewwindowiscreatedcomprisingallof the currently ready threads if there are none this step repeats until there is at least one readythreadwhenanewnonemptywindowisobtainedthefullcycleofthisalgorithm continues as described above any thread that becomes ready will eventually be included in the next new window and will be selected for execution therefore this algorithm prevents ready thread from being starved out of activation by other threads the fairness of this algorithm results from the fact that threads which become ready more often are dispatched more often while those which become ready less often are dispatched less often for applications that require more detailed scheduling the customer may bypass the standard lx8000 schedulerandsupplyanapplicationspecificdesign that has accessto thesameperthreadinformationas the standard scheduler such scheduler may also examine other real time information that is outside the province of lx8000 architecturemarch 29 2001 lx8000 lexra proprietary confidential 25 release 19 thefollowingtableliststheportsthattheprocessorsuppliesforeachcontextwhicharedirectlyconnectedto thestandardorapplicationspecificschedulermoduletheportdirectionisrelativetotheprocessoraninput to the processor must be driven from register in the scheduler likewise an output from the processor is driven from register within the processor table 4 scheduler ports becausetheschedulerdeterminesthethreadthattheprocessorwillactivateonthe nextcontextswitchitcan includeregisterstagesinitsdesigntoavoidanytimingproblemstypicallyeachprocessorisconnectedtoits own local thread scheduler however the use of single scheduling module which operates on information from all processors is not precluded itshouldbenotedthatthecx_threadactv_rsignalsindicatethecurrentactivethreadatthe endofthe pipelineexceptionsandmispredictedbranchescancausecontextswitchestobesquashedfurthermorethe waitbitvaluescanbesetbycontextswitchesormtcxcinstructionsandthesechangesonlytakeeffectat theendofthepipelineafteranypotentialexceptionsorbrancheshavebeenresolvedontheotherhandthe ext_nextcntx_p_rinputsmustbeusedatthe beginning ofthepipelinetoselectanewactivethreadin case of potential context switch toresolvethediscrepancybetweentheendandbeginningofthepipelinecp0inhibitsathreadthatisactive at any stage of the pipeline from being dispatched for context switch regardless of the value of ext_nextcntx_p_r in addition all threads are inhibited from being dispatched for context switch whilethereisanmtcxcinstructionatanystageofthepipelinethiswillonrareoccasionscausenovalid instructions to be sent down the pipeline but it eliminates the need for the external scheduler to be aware of the pipeline thisinhibitinglogicalsoimpliesthattheexternalscheduleronlyneedstodetectachangeinthevalueofany cx_threadactv_rfromzerotoonetodeterminethatacontextswitchhasactuallytakenplaceanda new thread has been dispatched 2411 example context switch for coprocessor operation the following example illustrates how an unconditional context switch could be used to allow other threads to execute while coprocessor performs relatively long latency operation on behalf of thread the example assumes that coprocessor 2 has been connected to the processors coprocessor interface ci which is available as part of lexras standard product thecoprocessorisassumedtocontainacontrolregister1thatmustcontainthecontextnumbertowhich subsequent coprocessor instructions apply another control register 2 is used to start the coprocessor operation when the coprocessor concludes the operation it signals the processor to clear specific wait eventbitforthetargetcontextassociatedwiththecoprocessorthismakesthethreadreadyfordispatch since several threads can use coprocessor 2 before retrieving the results the current context must again beprocessor port direction description cx_stusthwait_rn10 output assertedwhenanywaitﬂagissetincxsta where n is the number of contexts cx_stusthprio_rn310 output threadpriority ﬁeld from cxstatus where n is the number of contexts cx_threadactv_rn10 output 1ifthreadisactivewherenisthenumber of contexts ext_nextcntxrdy_p_r input 1 if schedulers next thread selection is valid ext_nextcntx_p_r20 input schedulers next thread selectionmarch 29 2001 lx8000 lexra proprietary confidential 26 release 19 stored to the control register 1 in addition to the mycx and csw instructions the example uses the mips standard mtc2 ctc2 mfc2 instructions for accessing coprocessor 2 2412 program access to new registers thenewregistersdescribedinsection241cxpccxstatusmovecxaswellasthegeneralregisters of all contexts are accessible under program control by the active thread the movecx register which determines the target context for the mtcxc mfcxc mtcxg mfcxg instructions is loaded by the mtlxc0 instruction and can be read with the mflxc0 instruction the number of the currently executing context can be accessed with the mycx instruction which loads it into general register cxpc and cxstatus are new coprocessor 0 registers these context control registers ct or cd can be moved to or from general registers rt or rd of the active thread using the following instructions where ct or cd cxstatus cxpc movecx20 designates the context whose ct or cd is to be accessed mtcxcandmfcxcshould notbeusedtoaccessthecxpcofthecurrentlyactivethreadifctorcdisthe cxpc of the currently active thread the result of mtcxc or mfcxc is undefined two additional instructions permit the general registers rt or rd in the active thread to be transferred to or from the general registers gt or gd in inactive threads this capability is useful in debugging so that all registers are accessible without execution of context switch the special case of moves within single context using mtcxg mfcxg is undetectable by the assembler though it would normally be performed using mips i instruction accessing general register in an inactive context will give unpredictable results if load is pending to thatmycx r1 get current context number ctc2 r1 1 tell cop2 which context this is mtc2 supply other data to cop2 csw r2 switch and wait for cop2 ctc2 r3 2 kick off cop2 in delay slot after the context switch when the cop2 operation completes this thread is made ready and eventually gets dispatched here ctc2 r1 1 tell cop2 which context this is mfc2 retrieve results mtcxc rt cd moves gen reg rt of the active context to cd mfcxc rd ct moves ct to gen reg rd of the active context mtcxg rt gd moves rt of the active context to gd of context movecx mfcxg rd gt moves gt of context movecx to rd of the active contextmarch 29 2001 lx8000 lexra proprietary confidential 27 release 19 register mtcxc mfcxc mtcxg and mfcxg are extensions to the mips isa they function similarly to the mips mtc0 and mfc0 instructions but the opcodes have different object code assignments to allow the numberofcoprocessor0registerstobeextendedaswithmtc0andmfc0acoprocessorusabilitytrap is taken in user mode if cp0 is not designated usable in status mtcxc mfcxc mtcxg mfcxg are always usable in kernel mode 2413 exceptions themipsr3000exceptionprocessingmodelisunchangedbylx8000withonedifferenceexplainedinthe next paragraph following program synchronous trap or an interrupt the pc of the current thread is stored intheprogramvisibleepcregisterexceptionsarepreciseallowinganexceptionhandlertopossiblytake recovery steps and then resume execution at the pc of theexception if there isan activecontext nocontext switch occurs when an exception trap or interrupt is taken the exception handler executes in the same context that was current at the time the exception was taken the handler can use the mycx instruction to determine its context if necessary lx8000 suppresses exceptions that occur in the delay slot of context switch this simplified approach is acceptableinembeddedsystemsexceptionreportingisausefuldebugtoolduringthedevelopmentprocess but is not necessary in production systems this suppression of exceptions applies to both interrupts and all program synchronous traps therefore instructions which deliberately cause exceptions break syscall should never be coded in the delay slot of cswtype instruction an ejtag debugger should neverattempttoinsertansdbbpinthedelayslotandshouldalsonotethatsinglesteppingwillexecutepast the delay slot instruction tofacilitatesystemlevelerrordetectionandreportingtheprocessorhasaspecialresponsetotheassertionof its intreqn7 hardware interrupt input when this interrupt is asserted the processor forces context 0 into ready state by clearing all of the wait flags in context 0s cxstatus register this ensures that there is contextavailabletoservicetheinterrupthowevertheinterruptmaybeservicedbyanyotherreadycontext note that all threads share common set of coprocessor 0 registers including the exception processing registers listed in table2 on page19 and the estatus ecause and intvec registers described in section25 25 lowoverhead prioritized interrupts thelx8000includeseightnewlowoverheadhardwareinterruptsignalsthesesignalsarecompatiblewith the r3000 exception processing model and are useful for realtime applications these interrupts are supported with three new lexra cp0 registers estatus ecause and intvec accessed with the new mtlxc0 and mflxc0 variants of the mtc0 and mfc0 instructions as with any cop0instructionacoprocessorunusableexceptionistakeniftheseinstructionsareexecutedwhileinuser mode and the cu0 bit is 0 in the cp0 status register the three new lexra cp0 registers are estatus 0 ecause 1 and intvec 2 and are defined as follows estatus lx cop0 reg 0 readwrite 31 24 23 16 15 0 0 im158 0march 29 2001 lx8000 lexra proprietary confidential 28 release 19 ecause lx cop0 reg 1 readonly intvec lx cop0 reg 2 readwrite estatus contains the new interrupt mask bits im158 which are reset to 0 so that none of the new interruptswillbeactivatedregardlessoftheglobalinterruptsignaliecip158forthenewinterruptsignals islocatedinecauseandisreadonlythesefieldsaresimilartotheimandipfieldsdefinedinther3000 exception processing model except that the new interrupts are prioritized in hardware and each have dedicated exception vector ip15 has the highest priority while ip8 has the lowest priority however all new interrupts are higher priority than ip70 the program defined base address for the exception vectors is located in intvec the exception vector used for each prioritized interrupt is shown in the table below two instructions can be executedineachvectortypicallythesewillconsistofajumpinstructionanditsdelayslotwiththetargetof the jump being either shared interrupt handler or one that is unique to that particular interrupt table 5 prioritized interrupt exception vectors when vectored interrupt causes an exception all of the standard actions for an exception occur these include updating the epc register and certain subfields of the standard status and cause registers in particulartheexceptioncodeofthecauseregisterindicatesinterruptandthecurrentandprevious mode bits of the status register are updated in the usual manner31 24 23 16 15 0 0 ip158 0 31 6 5 0 base 0 interrupt number exception vector 15 base 111000 14 base 110000 13 base 101000 12 base 100000 11 base 011000 10 base 010000 9 base 001000 8 base 000000march 29 2001 lx8000 lexra proprietary confidential 29 release 19 3 lx8000 risc programming model this section describes the lx8000 programming model section31 summary of mipsi instructions containsalistsummarizingallmipsioperationssupportedbythelx8000theseopcodesmaybeextended by the customer using lexras custom engine interface cei this capability is described in section32 opcode extension using the custom engine interface cei section33 memory management describes the simplified memory management unit smmu which is physically incorporated in the lx8000 lmi the smmu provides sufficient memory management capabilities for most embedded applications while ensuring execution of thirdparty mips software development tools the lx8000 supports the mips r3000 exception processing model as described in section34 exception processing thelx8000supportsallmipsicoprocessoroperationsthecustomercanincludeonetothreeapplication specific coprocessors lexra provides functional block called the coprocessor interface ci which allows thecustomerasimplifiedconnectionbetweentheircoprocessorandtheinternalsignalsofthelx8000the ci is described in section35 the coprocessor interface ci lexras application specific instructionset extensions are described in detail in 4 lx8000 instruction extensions 31 summary of mipsi instructions the lx8000 executes mipsi instructions as detailed in the tables below to summarize the lx8000 executes mipsi instructions with the following exclusions the unaligned loads and stores lwl swl lwrswrarenotsupportedbecausetheyaddsignificantsiliconareaforlittlebenefitinmostapplications the unaligned loads and stores execute as nop this can cause code to execute incorrectly if the programmer expected these instructions to provide the unaligned load or store operations 311 alu instructions table 6 alu instructions instruction description add rd ra rb addu rd ra rb addi rd ra immediate addiu rd ra immediaterd ra rb immediate add reg ra to either reg rb or 16bit immediate sign extendedto32bitsresultisstoredinregrdaddandaddi can generate overflow trap addu and addiu do not sub rd ra rb subu rd ra rbrd ra rb subtract reg rb from reg ra result is stored in register rd sub can generate overflow trap subu does not and rd ra rb andi rd ra immediaterd ra rb immediate logicaland of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rd or rd ra rb ori rd ra immediaterd ra rb immediate logicalor of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rdmarch 29 2001 lx8000 lexra proprietary confidential 30 release 19 312 load and store instructions table 7 load and store instructionsxor rd ra rb xori rd ra immediaterd ra rb immediate logicalxor of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rd nor rd ra rb rd ra rb logicalnor of reg ra with either reg rb or zeroextended 16 bit immediate result is stored in reg rd lui rd immediate rd immediate 160 the 16bit immediate is stored into the upper half of reg rd the lower half is loaded with zeroes sll rd rb immediate sllv rd rb rard rb ra immediate regrbisleftshiftedby031theshiftamountiseitherthe5b immediate of the 5 lsb of ra result is store in reg rd srl rd rb immediate srlv rd rb rard rb ra immediate reg rb is rightshifted by 031 the unsigned shift amount is either the 5b immediate or the 5 lsb of ra result is stored in reg rd sra rd rb immediate srav rd rb rard rb ra immediate reg rb is arithmetic rightshifted by 031 the unsigned shift amount is either the 5b immediate or the 5 lsb of ra result is stored in reg rd slt rd ra rb sltu rd ra rb slti rd ra immediate sltiu rd ra immediaterd 310 1 if ra rb immediate else 0 if reg ra is less than rb immediate set rd to 1 else 0 the 16bitimmediateissignextendedforsltsltithecompari is signed for slu sltiu the comparison is unsigned instruction description lb rd offsetra lbu rd offsetra lh rd offsetra lhu rd offsetra lw rd offsetrard memoryra offset reg rd is loaded from data memory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits lb lbu addresses are interpreted as byte addresses to data memorylhlhuashalfword16bitaddresseslwasword 32bit addresses thedatafetchedinlblhlbulhuissignextendedzero extended to 32bits for storage to reg rd rd cannot be referenced in the instruction following load instructioninstruction descriptionmarch 29 2001 lx8000 lexra proprietary confidential 31 release 19 313 conditional move instructions table 8 conditional move instructions 314 branch and jump instructions table 9 branch and jump instructionssb rb offsetra sh rb offsetra sw rb offsetrarb memoryra offset reg rb is stored to data memory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits sbaddressesareinterpretedasbyteaddressestodatamem ory the 8 lsb of rb are stored sh addresses are interpreted as halfword addresses to data memory the 16 lsb of rb are stored instruction description movz rd rs rt if rt 0 rd rs else rd rd conditional move on equal zero if the contents of general register rt are equal to 0 the general register rd is updated with rs otherwise rd is unchanged movn rd rs rt if rt 0 rd rs else rd rd conditional move on not equal zero if the contents of general register rt are not equal to 0 the gen eral register rd is updated with rs otherwise rd is unchanged instruction description beq ra rb destination bne ra rb destinationif cond pc pc 4 14destination15 destination 00 else pc pc 8 where cond ra rb for eq ra ne rb for ne and desti nation is 16bit value for beq bne the instruction after the branch delay slot is always executedinstruction descriptionmarch 29 2001 lx8000 lexra proprietary confidential 32 release 19 315 control instructions table 10 control instructionsblez ra destination bgtz ra destinationif cond pc pc 4 14destination15 destination 00 else pc pc 8 where cond ra 0 for ra 0 for gt and destina tion is 16bit value forblezbgtztheinstructionafterthebranch delayslotis always executed bltz ra destination bgez ra destinationif cond pc pc 4 14destination15 destination 00 else pc pc 8 where cond ra 0 for lt ra 0 for ge and destina tion is 16bit value forbltzbgeztheinstructionafterthebranch delayslotis always executed bltzal ra destination bgezal ra destinationsimilar to the bltz and bgez except that the address of the instruction following the delay slot is saved in r31 regardless of whether the branch is taken j target pc pc3128 target 00 target is 26bit absolute the instruction following j delay slot is always executed jal target same as above except that the address of the instruction fol lowing the delay slot is saved in r31 jr ra pc ra the instruction following jr delay slot is always executed jalr ra rd same as above except that the address of the instruction fol lowing the delay slot is saved in rd instruction description syscall the sys trap occurs if syscall is executed break the bp trap occurs if break is executed rfe causes the kuie stack to be popped used when returning from the exception handler see exception processing belowinstruction descriptionmarch 29 2001 lx8000 lexra proprietary confidential 33 release 19 316 coprocessor instructions table 11 coprocessor instructions 32 opcode extension using the custom engine interface cei 321 cei operations customers may add proprietary or applicationspecific opcodes to their lx8000 based products using the custom engine interface cei the new instructions take one of the following forms illustrated below and use reserved opcodesinstruction description lwcz rcgen offsetra rcgen memoryra offset coprocessor z general reg rcgen is loaded from data mem ory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits rcgen cannot be referenced in the following instruction one cycle delay swcz rcgen offsetra rcgen memoryra offset coprocessor z general reg rcgen is stored to data memory the memory address is computed as base offset where the base is reg ra and the offset is the16bit offset sign extended to 32 bits mtcz rb rcgen ctcz rb rcconin mtczctcz the general register rb is moved to copro cessor z general control reg rcgenrccon rcgen and rccon cannot be referenced in the following instruction mfcz rb rcgen cfcz rb rcconin mfczcfcz the coprocessor z general control reg rcgenrccon is moved to the general register rb rb cannot be referenced in the following instruction bczt destination bczf destinationpc pc 4 14dest15 dest 00 if cond else pc pc 8 where cond cpcondz true for bczt cpcondz false for bczf forbcztbczftheinstructionafterthebranch delayslotis always executedmarch 29 2001 lx8000 lexra proprietary confidential 34 release 19 table 12 custom engine interface operations lexra permits customer operations to be added using the four 4 iformat opcodes and six 6 rformat opcodes listed in the table above other opcode extensions in future lexra products will notutilize the opcodes reserved above when the cei decodes newopi or newopr it must signal the core that custom operation has been executed so that the reserved instruction trap will not be taken multicycle custom operations may be executed by asserting cesel note the custom operation may choose to ignore the src1 and src2 operands supplied by the cei and reference customer registers instead results can also be written to an implicit customer register however unless d 0 is coded register in the core will also be written 322 interface signals table 13 custom engine interface signalsnew instruction description available opcodes newopi rd ra immed rd ra newopi immed reg ra is supplied to the src1 port of cei and the 16bit immediate sign extended to 32bits is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 24 27 newopr rd ra rb rd ra newopr rb reg ra is supplied to the src1 port of cei and reg rb is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 0 and inst50 5658 606263 signaltype relative to coredescription src1310 output operand supplied to customer logic src2310 output operand supplied to customer logic res310 input result of customer logic supplied to core ceiop110 output instruction op and subop fields to be decoded by customer logic cehalt input indicates that multicycle custom operation is in progress cesel input indicates that cei operation has been decodedmarch 29 2001 lx8000 lexra proprietary confidential 35 release 19 33 memory management thelx8000includesasimplifiedmemorymanagementunitsmmufortheinstructionmemoryaddress and the data memory address these units are physically located in the local memory interface lmi modulesthehardwiredvirtualtophysicaladdressmappingperformedbythesmmuissufficienttoensure execution of thirdparty software development tools table 14 smmu address mapping note the 05 gbyte of physical address space from 0x2000_0000 to 0x3fff_ffff is not accessible with the above memory map 34 exception processing thelx8000implementsthemipsr3000exceptionprocessingmodelasdescribedbelowfeaturesspecific to onchip tlb support are not included in the discussion below the term exception refers to both traps which are nonmaskable program synchronous events and interrupts which result from unmasked asynchronous events thelistbelowisnumberedfromhighesttolowestpriorityexccodeisstoredincausewhenanexception is taken note that sys bp ri cpu can share the same priority level because only one can occur in particular time slotvirtual address space description mapped to physical address 0xff00_0000 to 0xffff_ffffejtag address space 16 mbyte uncached this address range is reserved for ejtag use only0xff00_0000 to 0xffff_ffff 0xc000_0000 to 0xfeff_ffffkseg2 1gbyte minus 16 mbyte addressable only in kernel mode cached0xc000_0000 to 0xfeff_ffff 0xa000_0000 to 0xbfff_ffffkseg1 05 gbyte addressable only in ker nel mode uncached used for io devices0x0000_0000 to 0x1fff_ffff 0x8000_0000 to 0x9fff_ffffkseg0 05 gbyte addressable only in ker nel mode cached0x0000_0000 to 0x1fff_ffff differentiated from kseg1 addresses with an internal signal 0x0000_0000 to 0x7fff_ffffkuseg 2gbyte addressableinkernelor user mode cached0x4000_0000 to 0xbfff_ffffmarch 29 2001 lx8000 lexra proprietary confidential 36 release 19 table 15 list of exceptions exception priority exccode description reset 1 reset trap adel instruction2 4 address exception trap instruction fetch occurs if the instruction address is not wordaligned or if kernel address is referenced in user mode ov 3 12 arithmeticoverflowtrapcanoccurasa result of signed add or subtract opera tions sys 4 8 syscall instruction trap occurs whensyscallinstructionisexecuted bp 4 9 break instruction trap occurs when break instruction is executed ri 4 10 reservedinstructiontrapoccurswhen areservedopcodeisfetchedreserved opcodes are listed below cpu 4 11 coprocessor usability trap occurs when an attempt is made to execute coprocessor n operation and copro cessor n is not enabled adel data 5 4 address exception trap data fetch occurs if the data address is not prop erly aligned or if kernel address is generated in user mode ades 6 5 address exception trap data store occurs if the data address is not prop erly aligned or if kernel address is generated in user mode int 7 0 unmasked interrupt there are six 6 levelsensitive hardware interrupt request signals into the lx8000 core eachissynchronizedbythecoretothe lx8000 system clock in addition pro gram writes to cause98 are soft wareinitiated interrupt requests each of the eight 8 requests has an associ ated mask bit in status int is gener ated by any unmasked request when interrupts are globally enabledmarch 29 2001 lx8000 lexra proprietary confidential 37 release 19 341 exception processing registers status cause epc bad vaddr status coprocessor 0 general register address 12 cu cun 10 indicates that coprocessor n is usableunusable in coprocessor instructions bev bootstrap exception vector selects between two trap vectors see below im interrupt masks for the six hardware interrupts and two software interrupts kuie ku01indicateskernelusermodeinthelx8000usermodevirtualaddressesmusthave msb 0 in kernel mode the full address space is addressable ie 10 indicates that interrupts are enabled disabled kuoieokupiepkuciecformsathreelevelstackhardwarestackkuiesignalsthe currentvaluesarekuciecthe previousvaluesarekupiepandthe oldvaluesthosebefore previous are kuoieo see below status isreadorwrittenusingmtc0andmtf0operationsonresetbev1kuciec0the other bits in status are undefined the 0 fields are ignored on write and are 0 on read it is recommended that the user explicitly write them to 0 to insure compatibility with future versions of the lx8000 cause coprocessor 0 general register address 13 bd branch delay indicates that the exception was taken in branch or jump delay slot ce coprocessorexceptioninthecaseofacoprocessorusabilityexceptionindicatesthenumber of the responsible coprocessor ip interrupt pending each bit in ip70 indicated an associated unmasked interrupt request exccode the exccode listed above for the different exceptions are stored here when as exception occurs cause is read or written using mtc0 and mtf0 operations the only program writable bits in cause are ip10 which are called software interrupts cause is undefined at reset the 0 fields are ignored on write and are 0 on read epc coprocessor 0 general register address 14 epc is 32bit readonly register which contains the virtual address of the next instruction to be executed following return from the exception handler if the exception occurs in the delay slot of branch epc will hold the address of the branch instruction and bd will be set in cause the branch will typically be re executed following the exception handler3128 2723 22 2116 158 76 5 4 3 2 1 0 cu30 0 bev 0 im70 0 kuo ieo kup iep kuc iec 31 30 2928 2716 158 7 62 10 bd 0 ce10 0 ip70 0 exccode40 0march 29 2001 lx8000 lexra proprietary confidential 38 release 19 badvaddr coprocessor 0 general register address 8 badvaddr is 32bit readonly register containing the virtual address instruction or data which generated an adel or ades exception error 342 exception processing entry and exit when an exception occurs the instruction address changes to one of the following locations the kuie stack is pushed kuo ieo kup iep kuc iec ²push kup iep kuc iec 0 0 whichdisablesinterruptsandputstheprograminkernelmodethecodeexccodefortheexceptionsource isloadedintocausesothattheapplicationspecificexceptionhandlercandeterminetheappropriateaction the exception handler should not reenable interrupts until necessary context has been saved to return from the exception the exception handler first moves epc to general register using mfc0 followed by jr operation rfe only pops the kuie stack kup iep kuc iec 0 0 ²pop kup iep kup iep kuc iec this example assumes that kuie were not modified by the exception handler therefore typical sequence of operations to return from the exception handler would be 35 the coprocessor interface ci designers may implement up to three coprocessors to interface with the lx8000 the contents of these coprocessors may include up to thirtytwo 32 32bit general registers and up to thirtytwo 32 32bit controlregisters thegeneralregistersmaybemovedtoandfromtheralusregistersusingmtczmfcz operationsorbeloadedandstoredfromdatamemoryusinglwczswczoperationsthecontrolregisters may only be moved to and from the ralus registers using ctcz cfcz operations lexra supplies simple coprocessor interface ci model allowing the customer to easily interface coprocessor to the lx8000 the ci supplies set of control address and data busses that may be tied directly to the coprocessor general and special registers the ci is described in more detail in section 7 lx8000 coprocessor interfacereset 0xbfc0_0000 other exceptions bev 0 0x8000_0080 other exceptions bev 1 0xbfc0_0180 mfc0 epc r26 r26 is temporary storage register in the ralu jr r26 rfemarch 29 2001 lx8000 lexra proprietary confidential 39 release 19 4 lx8000 instruction extensions 41 context switch and data transfer operations thetablebelowexplainsthedetailsoftheinstructionsthatareusedtocauseacontextswitchandtotransfer data on behalf of context the context switching instructions typically set one or more wait bits in the contexts cxstatus register which prevent the context from being reactivated until its program can usefully resume since thread may wish to wait for notification of up to eight hardware or software events there is user mode instruction postcx which allows another thread to atomically clear any within this processor contexts waitevent bits the instruction mycx allows the program to determine its own context number and if there are multiple processorsinthesystemitsownprocessornumberthisallowsseveralthreadstoexecutethesameprogram but to use their context numbers andor processor numbers to access unique memory regions or remote devices all of these instructions are expected to be executed in user mode and are notsubject to any coprocessor usability exceptions for all of the instructions which cause context switch there is single instruction delay slot that is the instructionimmediatelyfollowingthecontextswitchinginstructionisexecutedinthesamecontextandthat contexts cxpc is loaded with the address of the instruction after the delay slot immediately after the executionofthedelayslotinstructionthenewlyselectedcontextbeginsexecutionattheinstructionspecified by its cxpc register there are restrictions on the type of instruction that can be executed in the delay slot of context switching instructions these restrictions are detailed in note following table16 for several of the instructions the descriptions are nearly identical differing in only few items in order to make it easier for the reader to identify only the differences these are indicated with underlined xt table 16 context switching instructions instruction syntax and description my context mycx rd thecurrentcontextnumberisplacedintord20iftherearemultiple processorsinthesystemthenumberoftheprocessorexecutingthis instruction is placed into rd158 otherwise rd158 is zeroed all other bits of rd are set to zeroes post event to context postcx rs rt bits rt20 are used as the target context cntx bits rs3124 are log icallyandedwithbits158thewaiteventbitsofthecxstatus register for context cntx and that contexts cxstatus register is updated with the result ifamfcxcinstructionisexecutedastheﬁrstinstructionimmediately following the postcx it is unpredictable whether the new or old value of cxstatus is returnedmarch 29 2001 lx8000 lexra proprietary confidential 40 release 19 context switch uncon ditionalcsw rs bits158thewaiteventbitsfromthiscontextscxstatusregis ter are logically ored with rs3124 and the cxstatus register is updated with the result an unconditional context switch occurs after the execution of this instructions delay slot load word uncached with context switchlwcsw rt displacementbase thedisplacement in bytes is signed 12bit quantity that must be divisibleby 4 since it occupies only 10 bits of the instruction word thedisplacement issignextendedandaddedtothecontentsof base to form the address temp the word addressed by temp is fetched usingasplittransactionandloadedintortthewaitloadbitisset in this contexts cxstatus register while the fetch is in progress an unconditional context switch occurs after the execution of this instruc tions delay slot iftempdoesnotspecifyanaddressinuncachablespacetheresultof the operation is undeﬁned iftemp speciﬁes an address in dmem space the result of the opera tion is undeﬁned iftempisnotwordalignedanaddressexceptionistakenandnocon text switch occurs load twinword uncached with context switchltcsw rt displacementbase thedisplacement in bytes is signed 13bit quantity that must be divisibleby 8 since it occupies only 10 bits of the instruction word thedisplacement is sign extended and added to the contents of the registerbasetoformtheaddress tempthewordaddressedby temp isfetchedusinga twinwordsplittransactionandloadedintort which must be an ven register the w ord addressed b ytemp4 is loaded into rt1 the waitload bit is set in this contexts cxstatus reg ister while the fetches are in progress an unconditional context switch occurs after the execution of this instructions delay slot iftempdoesnotspecifyanaddressinuncachablespacetheresultof the operation is undeﬁned iftemp speciﬁes an address in dmem space the result of the opera tion is undeﬁned iftempisnottwinwordalignedanaddressexceptionistakenandno context switch occurs load quadword uncached with context switchlqcsw rt displacementbase thedisplacement in bytes is signed 14bit quantity that must be divisibleby 16 since it occupies only 10 bits of the instruction word thedisplacement is sign extended and added to the contents of the registerbasetoformtheaddress tempthewordaddressedby temp is fetched using quadword split transaction and loaded into rt which must be register n umber divisib by four the w ord addressed b ytemp4 is loaded into rt1 the w ord addressed b temp8 is loaded into rt2 the w ord addressed b ytemp12 is loaded into rt3 the waitload bit is set in this contexts cxsta register while the fetches are in progress an unconditional text switch occurs after the execution of this instructions delay slot iftempdoesnotspecifyanaddressinuncachablespacetheresultof the operation is undeﬁned iftemp speciﬁes an address in dmem space the result of the opera tion is undeﬁned iftempisnotquadwordalignedanaddressexceptionistakenandno context switch occursinstruction syntax and descriptionmarch 29 2001 lx8000 lexra proprietary confidential 41 release 19 load twinword ltw rt displacementbase thedisplacement in bytes is signed 13bit quantity that must be divisibleby 8 since it occupies only 10 bits of the instruction word thedisplacement is sign extended and added to the contents of the registerbasetoformtheaddress tempthewordaddressedby temp isfetched and loaded into rt which m ust be an ven register the word addressed b temp4 is loaded into rt1 iftemp is not twinword aligned an address exception is taken if the instruction immediately following ltw attempts to use rt or rt1 the results of that instruction are unpredictable write descriptor wdcsw rs rt deviceid a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 if the optionalcsw xtension is speci ﬁed then bits 6356 of the descr iptor are logically ored with the waitevent bits of this conte xts cxstatus register which is updated with the result the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto the value of the 5bit deviceid ﬁeld and bits 20 all zeroes system bus operation is performed to write bits 630 of the descriptor to the device if the optionalcsw extension is speciﬁed the processor per forms context switch after the execution of this instructions delay slot write descriptor with load word uncached and context switchwdlwcsw rd rs rt deviceid a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 the waitload bit of this conte xts cxstatus register is set the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto the value of the 5bit deviceid ﬁeld and bits 20 all zeroes system bus operation is performed to write bits 630 of the descriptor to the device also requesting an uncached split transaction read word response the processor performs context switch after the execu tion of this instructions delay slot when the processor receives the corresponding read word response from the system bus it is loaded into register rd of the originating contexts general purpose register ﬁle and that contexts waitload ﬂag is cleared write descriptor with load twinword uncached and context switchwdltcsw rd rs rt deviceid a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 the waitload bit of this conte xts cxstatus register is set the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto the value of the 5bit deviceid ﬁeld and bits 20 all zeroes system bus operation is performed to write bits 630 of the descriptor to the device also requesting an uncached split transaction read twinword response the processor performs context switch after the execu tion of this instructions delay slot when the processor receives the corresponding read twinword response from the system bus the ﬁrst returned word is loaded into register rd which must specify an ven register and the second returned word is loaded into rd1 of the originating contexts general purpose register ﬁle and that contexts waitload ﬂag is clearedinstruction syntax and descriptionmarch 29 2001 lx8000 lexra proprietary confidential 42 release 19 notethefollowingrestrictionsapplytothedelayslotofanycontextswitchinginstructioncswlwcsw ltcsw lqcsw wdcsw wdlwcsw wdltcsw and wdlqcsw all branch or jump type instruction mtcxc instruction wdlwcsw wdltcsw wdlqcsw access to any register loaded by the instruction 42 bit field processing operations table17 explains the details of the instructions used to manipulate bit fields asshowninthefigureforseveraloftheseinstructionsawidthandinsertoffsetspecifyasubfieldofa32bit register that is to be used as target of the instruction for the extiv and insv paired instructions or extii and insi the extract offset and width can specify maximally 32bit subfield which straddles the boundary of two source registers or is completely contained in either one of two potential source registers figure 4 insert and extract operations straddle case illustrates the straddle case itisworthnotingthatthestandardmipsinstructionsetincludesbranchonequalandbranchonnotequal instructions therefore the extract instruction can be used to select field that is tested by conditional branch and explicit test instruction is necessary for several of the instructions the descriptions are nearly identical differing in only few items in order to make it easier for the reader to identify only the differences these are indicated with underlined xtwrite descriptor with load quadword uncached and context switchwdlqcsw rd rs rt deviceid a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 the waitload bit of this conte xts cxstatus register is set the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto the value of the 5bit deviceid ﬁeld and bits 20 all zeroes system bus operation is performed to write bits 630 of the descriptor to the device also requesting an uncached split transaction read quadword response the processor performs context switch after the execu tion of this instructions delay slot when the processor receives the corresponding read quadword response from the system bus the ﬁrst returned word is loaded into register rd which must specify register n umber divisib by four thesecondreturnedwordisloadedintord1thethirdreturnedword is loaded into rd2 and the f ourth returned word is loaded into rd3 of the originating contexts general purpose register ﬁle and that texts waitload ﬂag is cleared nomenclature rs rt rd r0 r31 base r0 r31instruction syntax and descriptionmarch 29 2001 lx8000 lexra proprietary confidential 43 release 19 figure 4 insert and extract operations straddle case table 17 bit field processing instructions instruction syntax and description set bits immediate seti rt rs width offset theoffsetisavaluepintherange031the widthisavaluemin the range 132 which is encoded in the instruction as 5bit valuemodulo32thatisthevalue32isencodedaszerothe bitsrtmp1paresettoonestheremainingbitsofrtarecop ied from the corresponding bits of rs if mp is greater than 32 the results are unpredictable clear bits immediate clri rt rs width offset theoffsetisavaluepintherange031the widthisavaluemin the range 132 which is encoded in the instruction as 5bit valuemodulo32thatisthevalue32isencodedaszerothe bits rtmp1p are set to zeroes the remaining bits of rt are copied from the corresponding bits of rs if mp is greater than 32 the results are unpredictablewidth widthextract offset 0 set clearextract insert insert offset31 00 63 32 31 31extract from rt extivextii extract from rt insvinsi unmodified fields from rs seti clri insviwidth insert registermarch 29 2001 lx8000 lexra proprietary confidential 44 release 19 extract bits for insertion variableextiv rd rs rt thebits rs1510 are decoded as an extraction offset n in the range063 the bits rs95 are decoded as width m in the range 132 modulo 32 the bits rs40 are decoded as an inser tion offset p in the r ange 031 these parameter fieldsof rs are savedintheimpliedregisterinserttheremainingbitsofrsare ignored considering rt to contain the least significant 32 bits of the extraction source 32bit intermediate extraction value temp is generated as follows 1 ifn32 and nm1 32 least significant word only the bits rtmn1narecopiedinto tempm10andtheremainingbitsof temp are set to zeroes 2ifn32andnm131straddletwowordsthebitsrt31n are copied into temp31n0 and the remaining bits of temp are set to zeroes 3 if n31 most significant word only temp310 is set to all zeroes thetempvalueisstoredinrdandalsosavedintheimpliedregis ter insert ifmnisgreaterthan64theresultsofthisinstructionandasub sequent insv instruction are unpredictable insert bits variable ins v rd rs rt this instruction must be coded as the next sequential instruction in the program sequence after an exti v otherwise its results are unpredictable all exceptions are inhibited for the execution of this instruction thisincludeshardwareinterruptsdebugexceptionsandaddress exceptions theparameterfieldsmn pandtheintermediateextractionvalue temparetakenfromtheimpliedregisterinsertasdescribedfor extiv considering rt to contain the most significant 32 bits of theextractionsourcethefinalextractedvalue resultisgenerated as follows 1 ifn32 and nm1 32 the bits temp310 are copied into result310 2ifn32andnm131thebits temp31n0arecopiedinto result31n0 the bits rtnm330 are copied into resultm 132n the remaining bits of result are set to zeroes 3 if n31 the bits rtnm33n32 are copied into resultm10 the remaining bits of result are set to zeroes the bits from resultm10 are copied into rdmp1p the remaining bits of rd are copied from the corresponding bits of rs if mn is greater than 64 or if mp is greater than 32 the results are unpredictableinstruction syntax and descriptionmarch 29 2001 lx8000 lexra proprietary confidential 45 release 19 extract bits for insertion immediateextiirdrt width offset theoffsetisavaluenintherange031thewidthisavaluemin the range 132 which is encoded in the instruction as 5bit value modulo 32 that is the value 32 is encoded as zero theseparameter fieldsaresavedintheimpliedregisterinsert consideringrttocontaintheleastsignificant32bitsoftheextrac tion source 32bit intermediate extraction value temp is gener ated as follows 1 if nm1 32 least significant word only the bits rtmn 1n are copied into tempm10 and the remaining bits of temp are set to zeroes 2 if nm1 31 straddle two words the bits rt31n are cop ied intotemp31n0 and the remaining bits of temp are set to zeroes thetempvalueisstoredinrdandalsosavedintheimpliedregis ter insert insert bits immediate ins i rd rs rt offset this instruction must be coded as the next sequential instruction intheprogramsequenceafteranexti iotherwiseitsresultsare unpredictable all exceptions are inhibited for the execution of this instruction thisincludeshardwareinterruptsdebugexceptionsandaddress exceptions the parameter fields m n and the intermediate extraction value temparetakenfromtheimpliedregisterinsertasdescribedfor extiitheoffsetisavaluepintherange031consideringrtto contain the most significant 32 bits of the extraction source the final extracted value result is generated as follows 1 if nm1 32 the bits temp310 are copied into result310 2 if nm1 31 the bits temp31n0 are copied into result31 n0 the bits rtnm330 are copied into resultm132n the remaining bits of result are set to zeroes the bits from resultm10 are copied into rdmp1p the remaining bits of rd are copied from the corresponding bits of rs if mp is greater than 32 the results are unpredictable hash to key hash rd rs keysize the5bitkeysizeisavaluekintherange424ifkisoutsidethis rangetheresultsareunpredictablethe32 sourcebitscontained in rs are hashed to form key of k bits the key is stored in rdk 10 the remaining bits of rd are zeroed for given keysize each bit of the key is formed as the logical xorofasubsetofthe sourcebitsforanykeysizethesesubsets are mutually exclusive and exhaustive that is each source bit is included in the xor function of one and only one of the key bits the exact composition of the xor subsets for each keysize is indicated in table18 hash instruction key bit definitioninstruction syntax and descriptionmarch 29 2001 lx8000 lexra proprietary confidential 46 release 19 nomenclature rt rs rd r0 r31 notes for extiv specifying r0 for rs implies insert extract offsets of 0 and width of 32 insv insi must be coded as the next sequential instruction following extiv extii there is only one insert register in the processor not one per context which only exists to pass information from extivextii to insvinsi the processor inhibits exceptions for insvinsi to ensure that if the extivextii instruction completes the immediately subsequent insvinsi will also complete forextiitheextractoffsetmaynotbe32butstraddleisallowedduetoformatconstraintsthisshould not be problem since the immediate is known at compile time if an offset 32 were needed the next most significant register could be used for rt and the offset reduced by 32 theextivandinsvpairofinstructionsareintendedtoallownumerousnoncontiguousfieldsinapacket to be compacted into single contiguous key even if the alignment of the packet in set of registers is not known until runtime sequence of 3 instructions per field can be used to accomplish this compaction in theexamplein figure5 packetdata isloaded into source registers s1s2ands3andfieldsf1andf2 are to be compacted into destination register d1 however it is not known until run time which of four byte alignmentcasesofthepacketisvalidatruntimer1isloadedwithavaluecorrespondingtothealignment specifically the value needed in bits 1510 of r1 is the twos complement of the alignment in bits single instruction ori r1 r0 n10 loads the proper value for any of the casesmost significant bit encodemsb rd rs rt the 32bit temp is computed as the logical and of rs with rt the6bitresultindicatesthemostsignificantbitthatissetin temp according to the following table where x means dont care temp 00000000 00000000 00000000 00000000 result 0 temp 00000000 00000000 00000000 00000001 result 1 temp 00000000 00000000 00000000 0000001x result 2 temp 00000000 00000000 00000000 000001xx result 3 etc temp 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx result 32 theresult is stored in rd50 the remaining bits of rd are zeroed jump to offset regis terjor rs rt the 13bit jump offset is computed as the logical or of rt120 with rs153 the 32bit target address is computed as follows target3116 rs3116 target153 offset target20 zeroes the other bits of rt and rs are ignored the program unconditionally jumps to the target address with delayofoneinstructionjustlikethejrinstructionhandlingofthe delay slot instruction for exceptions is the same as for the jr instructioninstruction syntax and descriptionmarch 29 2001 lx8000 lexra proprietary confidential 47 release 19 figure 5 packet field compaction with variable alignment the following code sequence assumes that r1 has been initialized as needed according to the case in question as shown common code path is used regardless of the alignment note that r0 is 0 source and dont care destination the above example shows how the packet alignment is handled with value held in single register placed in the appropriate bit position so that it can be subtracted from the otherwise fixed extraction offsets the widths and insertion offsets are invariant this paradigm works provided that two conditions are met 1 the variability in alignment never causes field to straddle different pairs of source registers sufficient condition is if the extracted field does not cross word boundary in the nominal case in other words the default extract offset is greater than 31 2 the insertion width and alignment never cause field to straddle word boundary in the destination key this problem can be minimized by reordering the fields in the destination key but in the worst case field to may be split into two parts to avoid the issue if necessary both of these restrictions can always be satisfied by splitting some source fields into two fields r1 contains the value to be subtracted from the 6bit default extraction offsets addiu r2 r1 f1_offe10 f1_wid5 f1_offi extiv r0 r2 s2 f1 is from s1 andor s2 insv d1 r0 s1 insert f1 into d1 addiu r2 r1 f2_offe10 f2_wid5 f2_offi extiv r0 r2 s3 f2 is from s2 andor s3 insv d1 d1 s2 merge f2 into d1 more fields handled the same ways1 s2 s3 f1 r1 0 r1 16 10 r1 24 10r1 8 10f2 f1 f2 f1 f2 f1 f2 f1f2d1march 29 2001 lx8000 lexra proprietary confidential 48 release 19 table 18 hash instruction key bit deﬁnition keysize keybit source bits included in xor to form key bit 43 2 1 028 24 20 16 12 8 4 0 29 25 21 17 13 9 5 1 30 26 22 18 14 10 6 2 31 27 23 19 15 11 7 3 keysize keybit source bits keysize keybit source bits 54 3 2 1 026 25 16 9 3 0 28 24 20 12 8 4 29 21 17 13 5 1 30 22 18 14 10 6 2 31 27 23 19 15 11 765 4 3 2 1 026 24 18 10 9 1 25 19 16 11 3 0 28 20 12 8 4 29 21 17 13 5 30 22 14 6 2 31 27 23 15 7 76 5 4 3 2 1 025 16 9 1 26 24 18 10 19 11 3 0 28 20 12 8 4 29 21 17 13 5 30 22 14 6 2 31 27 23 15 787 6 5 4 3 2 1 024 16 8 0 25 17 9 1 26 18 10 2 27 19 11 3 28 20 12 4 29 21 13 5 30 22 14 6 31 23 15 7 keysize keybit source bits keysize keybit source bits keysize keybit source bits 98 7 6 5 4 3 2 1 026 16 9 24 8 0 25 17 1 18 10 2 27 19 11 3 28 20 12 4 29 21 13 5 30 22 14 6 31 23 15 7109 8 7 6 5 4 3 2 1 026 13 9 20 16 3 24 8 0 25 17 1 18 10 2 27 19 11 28 12 4 29 21 5 30 22 14 6 31 23 15 71110 9 8 7 6 5 4 3 2 1 030 7 26 13 9 20 16 3 24 8 0 25 17 1 18 10 2 27 19 11 28 12 4 29 21 5 22 14 6 31 23 15 1211 10 9 8 7 6 5 4 3 2 1 0 7 3 30 26 13 9 20 16 24 8 0 25 17 1 18 10 2 27 19 11 28 12 4 29 21 5 22 14 6 31 23 151312 11 10 9 8 7 6 5 4 3 2 1 020 13 7 3 30 26 25 9 16 0 24 8 17 1 18 10 2 27 19 11 28 12 4 29 21 5 22 14 6 31 23 151413 12 11 10 9 8 7 6 5 4 3 2 1 030 13 20 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 4 29 21 5 22 14 6 31 23 15march 29 2001 lx8000 lexra proprietary confidential 49 release 19 1514 13 12 11 10 9 8 7 6 5 4 3 2 1 029 13 30 4 20 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 14 6 31 23 151615 14 13 12 11 10 9 8 7 6 5 4 3 2 1 020 4 29 13 30 14 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 151716 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 4 20 29 13 30 14 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 15 1817 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 029 4 20 13 30 14 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 151918 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 014 29 4 20 13 30 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 152019 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 023 14 29 4 20 13 30 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 15 2120 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 3 23 14 29 4 20 13 30 7 19 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 152221 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 026 3 23 14 29 4 20 13 30 7 19 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 152322 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 9 26 3 23 14 29 4 20 13 30 7 19 10 25 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 15keysize keybit source bits keysize keybit source bits keysize keybit source bitsmarch 29 2001 lx8000 lexra proprietary confidential 50 release 19 43 cross context access operations table19explainsthedetailsofinstructionsthatareusedtoaccessthegeneralregistersorthecontextcontrol registers of another context for the control registers it is also possible for thread to access its own cxstatus register the target context for all of these instructions is specified in new lexra coprocessor 0 register called movecx that register is itself accessed with mtlxc0 and mflxc0 variants of the mips standard mtc0 and mfc0 instructions these new instructions are used to access lexra defined coprocessor 0 registers that are not in the standard mips coprocessor 0 space the encoding of these instructions which use the cop0 major opcode is described in section45 it is expected that these instructions will only be used in kernel mode therefore they are all subject to the coprocessor unusable exception for coprocessor 0 as are the mtlxc0 and mflxc0 instructions table 19 cross context access instructionskeysize keybit source bits 2423 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 016 9 26 3 23 14 29 4 20 13 30 7 19 10 25 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 15 instruction syntax and description move from context general registermfcxg rd gt bits movecx20 are used to determine the target context cntx thecontentsofgeneralregistergtincontext cntxareloadedinto the current contexts general register rd move to context gen eral registermtcxg rt gd bits movecx20 are used to determine the target context cntx the general register gd in context cntx is loaded from the tents of the current contexts general register rtmarch 29 2001 lx8000 lexra proprietary confidential 51 release 19 nomenclature notes execution of mtcxc rt cxpc with movecx current context attempt to change the currently executing contexts cxpc results in unpredictable operation to examine its own cxstatus register thread can execute this sequence 44 checksum addition table20 explains the instruction that may be used to calculate checksum for an internet protocol header using 16bit ones complement addition table 20 checksum addition instructions notes in ones complement arithmetic there are two representations of zero 0x0000 0 and 0x ffff0 addition of nonzero quantities can never result in 0 only 0 addition of 0 to either 0 or 0 results in 0 this instruction can be used to generate or check the 16bit checksum used in internet packets without regard to halfword alignment all of the 32bit words to be included are incrementally added using acs2 final 16bit shift and one more acs2 instruction is used to fold the checksum into 16 bitsmove from context control registermfcxc rd ct bits movecx20 are used to determine the target context cntx thecontentsofcontrolregisterctincontext cntxareloadedinto the current contexts general register rd move to context trol registermtcxc rt cd bits movecx20 are used to determine the target context cntx thecontrolregistercdincontext cntxisloadedfromthecontents of the current contexts general register rt rt rd gt gd r0 r31 cd ct cxstatus cxpc mycx r1 mtlxc0 r1 movecx mfcxc r2 cxstatus instruction syntax and description dual add for checksumacs2 rd rs rt dual 16bit ones complement addition considering all quantities as unsigned 16bit integers add the contents of rs1500 to rt1500 and independently add the contents of rs3116 to rt3116foreachindependentadditionifthereisacarryoutof the most significant bit of its result add one to that result to form its final result the final results of the two additions are placed in rd1500 and rd3116 r1 packetaddr get packet address lw r2 0r1 get many words lw r3 4r1instruction syntax and descriptionmarch 29 2001 lx8000 lexra proprietary confidential 52 release 19 45 lx8000 instruction summary and encoding table 21 instruction summarylw r4 8r1 lw r5 12r1 lw r6 16r1 lw r7 20r1 acs2 r2 r2 r3 add them together acs2 r2 r2 r4 acs2 r2 r2 r5 acs2 r2 r2 r6 acs2 r2 r2 r7 srl r3 r2 16 fold over accumulator acs2 r2 r2 r3 r2150 has the answer instruction description context control operations and data transfers mycx rd read my context postcx rs rt post event to context csw rs context switch ltw rt dispbase load twinword lwcsw rt dispbase load word uncached with context switch ltcsw rt dispbase load twinword uncached with context switch lqcsw rt dispbase load quadword uncached with context switch wdcsw rs rt deviceid write descriptor to device with context switch wdlwcsw rd rs rt dev write descriptor to device and load wordtwinword quadword uncached with context switchwdltcsw rd rs rt dev wdlqcsw rd rs rt dev bit field operations seti rt rs width offset set subfield to ones clri rt rs width offset clear subfield to zeroes extiv rd rs rt extract subfield and prepare for insertion variable insv rd rs rt insert extracted subfield variable extii rd rt width offset extract subfield and prepare for insertion immediate insi rd rs rt offset insert extracted subfield variable immediate acs2 rd rs rt dual 16bit ones complement add for checksum hash rd rs keysize hash data to keymarch 29 2001 lx8000 lexra proprietary confidential 53 release 19 msb rd rs rt find most significant bit jor rs rt jump to offset register crosscontext access operations mfcxg rd gt move from context gpr mtcxg rt gd move to context gpr mfcxc rd ct move from context control register mtcxc rt cd move to context control registerinstruction descriptionmarch 29 2001 lx8000 lexra proprietary confidential 54 release 19 451 lx8000 instruction formats the lexra formats are introduced into the mips instruction set by designating single iformat as lexop2 then using the inst50 subop field to permit up to 64 new lexra opcodes thus the new opcodes model the mips special opcodes encoded in rformat the diagrams below illustrate the lexop2 codes using iformat 011_110 which is unused in the mips iv isa the default object code for lexop2 is 011_110 however the location can be changed using static reconfiguration this helps insure compatibility of the extensions with future isa extensions released by mips technologies inc this section also provides detail on the mflxc0mtlxc0 instructions which are variants of the mips standardmfc0mtc0instructionsthesevariantsprovideaccesstoaspaceoflexradefinedcoprocessor0 registersmarch 29 2001 lx8000 lexra proprietary confidential 55 release 19 452 load formats 453 write descriptor formats31 26 25 21 20 16 15 6 5 0 assembler mnemoniclexop2 011 110 base rt immediatelexra subop lwcsw lexop2 base rt displacement4 lwc ltcsw lexop2 base rteven 0 displacement8 ltc ltw lexop2 base rteven 0 displacement8 ltw lqcsw lexop2 base rtquad 00 displacement16 lqc 655 1 0 6 base rt selects general register r0 r31 rteven selects general register evenodd pair r0r1 r2r3 r30r31 rtquad selects general register quad r0r1r2r3 r28r29r30r31 displacement signed 2scomplement number in bytes 31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 rs rt rd deviceidlexra subop wd lexop2 rs rt 0 deviceid wd wdcsw lexop2 rs rt 0 deviceid wdc wdlwcsw lexop2 rs rt rd deviceid wdlwc wdltcsw lexop2 rs rt rdeven0 deviceid wdltc wdlqcsw lexop2 rs rt rdquad00 deviceid wdlqc 65 555 6 rs rt rd selects general register r0 r31 rdeven selects general register evenodd pair r0r1 r2r3 r30r31 rtquad selects general register quad r0r1r2r3 r28r29r30r31 deviceid indicates bits 73 of system device addressmarch 29 2001 lx8000 lexra proprietary confidential 56 release 19 454 context checksum and bit field formats 31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 rs rt rd 0lexra subop mycx lexop2 0 0 rd 0 mycx postcx lexop2 rs rt 0 0 postcx csw lexop2 rs 0 0 0 csw extiv lexop2 rs rt rd 0 extiv insv lexop2 rs rt rd 0 insv acs2 lexop2 rs rt rd 0 acs2 msb lexop2 rs rt rd 0 msb jor lexop2 rs rt 0 0 jor 65555 6 31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 rs rt widthkeysize offsetlexra subop seti lexop2 rs rt width offset seti clri lexop2 rs rt width offset clri extii lexop2 width rt rd offset extii insi lexop2 rs rt rd offset insi hash lexop2 rs 0 rd keysize hash 65555 6 rs rt rd selects general register r0 r31 width 5bit encoding of the width parameter modulo 32 ie the value 32 is represented as 0 offset 5bit encoding of the offset parameter in the range 031 keysize 5bit encoding of the keysize parameter in the range 424march 29 2001 lx8000 lexra proprietary confidential 57 release 19 455 cross context move format 456 lexracoprocessor0 register access instructions these are notlexop2 instructions they are variants of the standard mtc0 and mfc0 instructions that allowaccesstothelexracoprocessor0registerslistedbelowaswithanycop0instructionacoprocessor unusable exception is taken in user mode if the cu0 bit is 0 in the cp0 status register when these instructions are executed31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 0 rtgtct rdgdcd 0lexra subop mfcxg lexop2 0 gt rd 0 mfcxg mtcxg lexop2 0 rt gd 0 mtcxg mfcxc lexop2 0 ct rd 0 mfcxc mtcxc lexop2 0 rt cd 0 mtcxc 65555 6 rt rd selects general register r0 r31 in the current context gt gd selects general register r0 r31 in the context specified by movecx ct cd selects context register in the context specified by movecx 00000 cxstatus 00001 cxpc others reserved 31 26 25 21 20 16 15 11 10 0 assembler mnemoniccop0 010 000 copz rs rt rd 0 mflxc0 cop0 mflx 00011rt rd 000 0000 0000 mtlxc0 cop0 mtlx 00111rt rd 000 0000 0000 6555 1 1 rt selects general register r0 r31 rd selects lexra coprocessor 0 register 00000 estatus 00001 ecause 00010 intvec 00011 cvstag for lexra diagnostic purposes only 00100 movecx 00101 reserved 0011x reserved 01xxx reserved 1xxxx reservedmarch 29 2001 lx8000 lexra proprietary confidential 58 release 19 457 lexra subop bit encodings table 22 lexra subop bit encoding inst20 inst53 0 1234567 0 hash seti acs2 insv insi 1 jor msb clri extiv extii 2 3 4 mycx mfcxg mtcxg 5 postcx mfcxc mtcxc 6 csw lqc wdc wdlqc ltc lwc wdltc wdlwc 7 wd ltwmarch 29 2001 lx8000 lexra proprietary confidential 59 release 19 5 lx8000 local memory 51 local memory overview thischapterdescribeshowmemoriesareconfiguredandconnectedtothelx8000usingthelocalmemory interfaces lmis this section provides brief summary of the conventions and supported memories section52 describes the control register that allows software control over certain aspects of the lmis the subsequent sections cover each of the lmis in detail this chapter also discusses configuration options and the ports that customers must access to connect application specific ram and rom devices that are used by the lx8000 lmis all of the signals between the processor core the lmis rams and the system bus controller are automatically configured by lconfig the lx8000 configuration tool lconfigalso produces documentation of the exact rams required for the chosen configuration settings and writes ram models used for rtl simulation the lmis provide connection points for connect to rams that service the lx8000 processors local instruction and data busses the lmis also provide the pathways from the processor to the system bus the lx8000 includes an lmi for each of the local memory types the sizes of the rams and roms are customer selectable the lx8000 lmis directly support synchronous rams that register the address write data and control signals at the ram inputs the lmis also supply redundant read enable and chip select lines for each ram which may be required for some ram types roms may also be connected but may require customer supplied address register at the address inputs lexra supplies an integration layer for the lmis and the memory devices connected to them in this layer memory devices are instanced as generic modules satisfying the depth and width requirements for each specific memory instance the lconfigutility supplies summary of the memory devices required for the chosen configuration in most cases customers simply need to write wrapper that connects the generic module port list to technology specific ram instance inside the ram wrapper the lx8000 is configurable for 16 32 64 or 128 byte cache line size the valid bits in all cache lines are automatically cleared by the lmis upon reset data caches implement writethrough protocol caches do notsnoopthesystembusthelx8000isconfigurabletoworkwithramswithawritegranularityof8bits byteor32bitswordbytewritegranularityresultsinmoreefficientoperationofstorebyteandstorehalf word instructions table23 summarizes the lmis that can be integrated on the local busses table 23 local memory interface modules name description icache direct mapped or twoway set associative instruction cache imem instruction ram irom instruction rom dcache direct mapped data cache dmem data ram or rommarch 29 2001 lx8000 lexra proprietary confidential 60 release 19 52 cache control register cctl cctl cp0 general register address 20 when reading this register the contents of the reserved bits are undefined when writing this register the contents of the reserved bits should be preserved changes in the contents of the cctl register are observed in the w stage however these changes affect instruction fetches currently in progress in the i stage and data load or store operations in progress in the m stage the iromon and iromoff bits of the cctl register control the and use of the optional local irom memory configured into the lx8000 when irom is present and the lx8000 is reset the lmi enables accesstotheiromatransitionfrom0to1oniromoffdisablestheiromallowinginstructionreferences to be serviced imem icache or the system bus transition from 0 to 1 on iromon enables the irom the imemfill and imemoff bits of the cctl register control the contents and use of any local imem memory configured into the lx8000 when the lx8000 is reset the lmi clears an internal register to indicate that the entire imem lmi contents are invalid when imem is invalid all cacheable fetches from the imem region will be serviced by the instruction cache if an instruction cache is present transition from 0 to 1 on imemfill causes the lmi to initiate series of line read operations to fill the imemcontentstheaddressesusedforthesereadsaredefinedbytheconfiguredbaseandtopaddresses oftheimemdescribedinsection54theprocessorstallswhiletheentireimemcontentsarefilledbythe lmi thereafter the lmi sets its internal imem valid bit and will service any access to the imem range from the local imem memory the time that an imem fill takes to complete is the number of line reads needed to fill the imem range multiplied by the latency of one line read assuming there is other system bus traffic transition from 0 to 1 on imemoff causes the lmi to clear its internal imem valid bit subsequent cacheable fetches from the imem region will be serviced by the instruction cache to use the imem again an application must reinitialize the imem contents through the imemfill bit of the cctl register theilockfieldcontrolssetlockinginthetwosetassociativeinstructioncachewhenilockis00or01the instructioncacheoperatesnormallywhenilockis10allcachedinstructionreferencesareforcedtooccupy set1thehardwarewillinvalidatelinesinset0ifnecessarytoaccomplishthiswhenilockis11linesinset 1 are never displaced ie they are locked in the cache set 0 is used to hold other lines as needed toutilizethecachelockingfeaturesoftwareshouldexecuteatleastonepassofcriticalsubroutinesorloops with ilock set to 10 after this has been done ilock should be set to 11 to lock the critical code into set 1 and use set 0 for other code the iinval and dinval fields control hardware invalidation of the instruction cache and data cache transition from 0 to 1 on iinval will initiate hardware invalidation sequence of the entire instruction cache likewisea0to1transitionondinvalwillinitiateahardwareinvalidationsequenceoftheentiredatacache the dmem if present is unaffected by this operation the hardware invalidation sequence for the instruction and data caches requires one cycle per cache line to complete depending on the circumstances software may be able to employ an alternative to full invalidation of the datacacheifasmallnumberoflinesmustbeinvalidatedsoftwaremayperformcachedreadsfromaliasesof318 7 6 5 4 32 1 0 reserved iromoff iromon imemoff imemfill ilock iinval dinvalmarch 29 2001 lx8000 lexra proprietary confidential 61 release 19 thememorylocationsofconcernthisdisplacesdataintheaddressedlocationsofthedatacacheevenifthey do not encache the affected memory location anotheralternativeiftheaffectedmemorylocationhasanaliasinuncacheablekseg1spaceistosimply performanuncachedreadoftheaffectedmemorylocationsifthelocationisresidentinthedatacacheitwill be invalidated this method has the advantage of not displacing data in the cache unless it is absolutely necessary to maintain coherency note that write to kseg1 address has affect on the contents of the data cache with either of these two alternatives it is only necessary to reference one word of each affected cache line 53 instruction cache icache lmi the icache lmi supplies the interface for direct mapped or twoway set associative instruction cache attachedtothelx8000localbusthedegreeofassociativityisspecifiedthroughlconfigtheicachelmi participatesincacheableinstructionfetchesbutonlyiftheaddressisnotclaimedbytheimemmodulethe configurations supported by icache and the synchronous rams required for each are summarized in table24 theinstructionstoreforthetwowayicacheconsistsoftwo64bitwidebankswithseparatewriteenable controlsthetagstoreconsistsofonerambankwithtagandvalidbitsforset0andasecondramforset 1 that holds the tag valid lru least recently used and lock bits when miss occurs in the twoway icache the lru bit is examined to determine which element of the set to replace with element 0 being replacediflruis0andelement1beingreplacediflruis1thestateofthelrubitistheninvertedto optimize the timing of cache reads the twoway icache uses the state of the lru bit to determine which elementshouldbereturnedtothecpuinthefollowingcycletheicachedeterminesifthecorrectelement wasreturnedifnottheicachetakesanextracycletoreturnthecorrectelementtothecpuandinvertsthe lru bit table 24 icache conﬁgurations conﬁguration icache_inst ram icache_tag ram instruction cache ram required ram required 1k bytes 2way 2 x 64 x 64 bits 32 x 24 and 32 x 26 bits 2k bytes 2way 2 x 128 x 64 bits 64 x 23 and 64 x 25 bits 4k bytes 2way 2 x 256 x 64 bits 128 x 22 and 128 x 24 bits 8k bytes 2way 2 x 512 x 64 bits 256 x 21 and 256 x 23 bits 16k bytes 2way 2 x 1024 x 64 bits 512 x 20 and 512 x 22 bits 32k bytes 2way 2 x 2048 x 64 bits 1024x19and1024x21bits 64k bytes 2way 2 x 4096 x 64 bits 2048x18and2048x20bits 1k bytes direct mapped 128 x 64 bits 64 x 23 bits 2k bytes direct mapped 256 x 64 bits 128 x22 bits 4k bytes direct mapped 512 x 64 bits 256 x 21 bits 8k bytes direct mapped 1024 x 64 bits 512 x 20 bits 16k bytes direct mapped 2048 x 64 bits 1024 x 19 bits 32k bytes direct mapped 4096 x 64 bits 2048 x 18 bitsmarch 29 2001 lx8000 lexra proprietary confidential 62 release 19 table25 lists the icache signals that are connected to application specific modules the ic_ prefix indicates signals that are driven by the icache lmi module and received by the rams the icr_ prefix indicates signals that are driven by the icache rams and received by the icache lmi lexra supplies the verilog module that makes all required connections to these wires the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from the table24 table 25 icache ram interfaces note n designates an available activelow version of signal 54 instruction memory imem lmi theimemlmisuppliestheinterfaceforanoptionallocalinstructionstoretheimemservesafixedrange of the physical address space determined by configuration settings in lconfig the imem contents are filled64k bytes direct mapped 8192 x 64 bits 4096 x 17 bits signal description ic_tagindex tag and state ram address line icr_tagrd0 tag and state ram element 0 read path ic_tagwr0 tag and state ram element 0 write path icr_tagrd1 tag and state ram element 1 read path ic_tagwr1 tag and state ram element 1 write path ic_tag0wen tag 0 ram write enable ic_tag0ren tag 0 ram read enable ic_tag0csn tag 0 ram chip select ic_tag1wen tag 1 ram write enable ic_tag1ren tag 1 ram read enable ic_tag1csn tag 1 ram chip select ic_instindex instruction ram address word icr_inst0rd instruction ram element 0 read path icr_inst1rd instruction ram element 1 read path ic_instwr instruction ram write path to both elements ic_inst0wen10 instruction ram 0 write enable ic_inst0ren instruction ram 0 read enable ic_inst0csn instruction ram 0 chip select ic_inst1wen10 instruction ram 1 write enable ic_inst1ren instruction ram 1 read enable ic_inst1csn instruction ram 1 chip selectconﬁguration icache_inst ram icache_tag rammarch 29 2001 lx8000 lexra proprietary confidential 63 release 19 andinvalidatedunderthecontrolofthecp0cctlregisterdescribedinsection52cachecontrolregister cctltheimemmoduleservicesinstructionfetchesthatfallswithinitsconfiguredrangetheimemisa convenientlowcostalternativetoacachethatmakesinstructionmemoryavailabletothecoreforhighspeed access the configurations supported by imem and the synchronous rams required for each are summarized in table26 table 26 imem conﬁgurations table27liststheimemsignalsthatareconnectedtoapplicationspecificmodulesthe iw_prefixindicates signalsthataredrivenbytheimemlmimoduleandreceivedbyramsthe iwr_prefixindicatessignals thataredrivenbyramsandreceivedbytheimemlmithe cfg_prefixidentifiesconfigurationportson the imem lmi that are typically wired to constant values the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table26 thecfg_wires define where the imem is mapped into the physical address space this configuration information defines the local bus address region of the imem it also determines the address of the external resources which are accessed when an imem miss occurs the lconfigutility supplied by lexra will verify that the configured address range does not interfere with other regions defined for lx8000 the size of the memory region must be power of two and must be naturally aligned table 27 imem ram interfacesconﬁguration imem_inst ram local instruction ram ram required 1k bytes 128 x 64 bits 2k bytes 256 x 64 bits 4k bytes 512 x 64 bits 8k bytes 1024 x 64 bits 16k bytes 2048 x 64 bits 32k bytes 4096 x 64 bits 64k bytes 8192 x 64 bits 128k bytes 16384 x 64 bits 256k bytes 32768 x 64 bits signal description iw_instindex imem index iwr_instrd instruction read data iw_instwr instruction write data iw_instwen10 instruction ram write enable iw_instren instruction ram read enable iw_instcsn instruction ram chip selectmarch 29 2001 lx8000 lexra proprietary confidential 64 release 19 note n designates an available activelow version of signal 55 instruction rom irom lmi the irom lmi supplies the interface for an optional readonly local instruction store the irom serves fixed range of the physical address space determined by configuration settings in lconfig irom may be disabled via hardware configuration pin cfg_iroff irom may also be enabled and disabled under softwarecontrolasdescribedinsection52cachecontrolregistercctltheiromisaconvenientlow cost alternative to cache that makes readonly instruction memory available to the core for highspeed access the configurations supported by irom and the synchronous roms required for each are summarized in table28 table 28 irom conﬁgurations table29 lists the irom signals that are connected to application specific modules the ir_ prefix indicates signals that are driven by the irom lmi module and received by the rom the irr_ prefix indicates signals that are driven by rom and received by the irom lmi the cfg_ prefix identifies configuration ports on the irom lmi that are typically wired to constant values lexra supplies the verilog module that makesallrequiredconnectionstothesewiresthewidthoftheindexanddatalinesdependsupontherom connected to the lmi and can be inferred from table27 the cfg_ wires define where the irom is mapped into the physical address space this configuration information defines the local bus address region of the irom it also determines the address of the external resources which are accessed when an irom miss occurs the lconfig utility supplied by lexra will verify that the configured address range does not interfere with other regions defined by the lx8000 note that the size of the memory region must be power of two and must be naturally alignedcfg_iwbase3110 conﬁgured base address modulo 1k bytes cfg_iwtop1710 conﬁgured top address bits that may differ from base conﬁguration irom_data local instruction ram rom required 1k bytes direct mapped 128 x 64 bits 2kbytes direct mapped 256 x 64 bits 4k bytes direct mapped 512 x 64 bits 8k bytes direct mapped 1024 x 64 bits 16k bytes direct mapped 2048 x 64 bits 32k bytes direct mapped 4096 x 64 bits 64k bytes direct mapped 8192 x 64 bits 128k bytes direct mapped 16384 x 64 bits 256k bytes direct mapped 32768 x 64 bitssignal descriptionmarch 29 2001 lx8000 lexra proprietary confidential 65 release 19 table 29 irom rom interfaces note n designates an available activelow version of signal 56 direct mapped write through data cache dcache lmi the dcache lmi supplies the interface for direct mapped write through data cache attached to the lx8000localbusthedcachelmiparticipatesincacheabledatareadsandwritesbutonlyiftheaddress isnotclaimedbythedmemlmi theconfigurationssupportedbydcacheandthesynchronousrams required for each are summarized in table30 the direct mapped dcache module services word or twinword read requests from the core in one cycle when the request hits the cache byte or halfword reads that hit the data cache require an extra cycle for alignmentthedatacachecanstreamwordandtwinwordreadsorwritesthathitthecacheattherateofone per cycle if the lx8000 is configured to work with rams that have word write granularity byte or half wordwritesthatfollowanywritebyonecycleandhitthecacherequireanextracycletomergethedatawith the current cache contents alternatively the lx8000 can be configured to work with rams support byte write granularity which eliminates the extra cycle writesthatareservicedbythedatacachemayrequireextratimetobeservicedbythelbcifitswritebuffer isfullalsowhenacachewriteoperationisimmediatelyfollowedbyacachereadthecachemustdelaythe read for one cycle while the write completes when miss occurs the cache obtains cache line 4 8 16 or 32 words of data from the lexra bus controller lbc write operations that hit the data cache are simultaneously written into the cache and forwarded to the write buffer of the lbc thus if the core subsequently reads the data it will likely be available from the cache for main memory systems that support byte writes all data writes that miss the cache are forwarded to the write buffer of the lbc without disturbing any data currently in the cache for main memory systems that can only write with word granularity byte or halfword write that misses the cachecausesthecachetoperformalinefillfrommainmemorythecachethenmergesthepartialwritedata with the full word data obtained from memory and writes the word to the system bus table 30 dcache conﬁgurationssignal description ir_instindex irom index irr_instrd instruction read data ir_instren instruction rom read enable ir_instcsn instruction rom chip select cfg_irbase3110 conﬁgured base address modulo 1k bytes cfg_irtop1710 conﬁgured top address bits that may differ from base conﬁguration dcache_data ram dcache_tag ram data cache ram required ram required 1k bytes direct mapped 128 x 64 bits 64 x 23 bits 2k bytes direct mapped 256 x 64 bits 128 x 22 bits 4k bytes direct mapped 512 x 64 bits 256 x 21 bitsmarch 29 2001 lx8000 lexra proprietary confidential 66 release 19 table31 lists the dcache signals that are connected to application specific modules the dc_ prefix indicatessignalsthataredrivenbythedcachelmimoduleandreceivedbytheramsthedcr_prefix indicatessignalsthataredrivenbythedcacheramsandreceivedbythedcachelmilexrasupplies the verilog module that makes all required connections to these wires the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table30 table 31 dcache ram interfaces note n designates an available activelow version of signal 57 scratch pad data memory dmem lmi the dmem lmi supplies the interface for scratch pad data ram attached to the lx8000 local bus the dmem module services in any cacheable or uncacheable data read or write operation that falls within its configured range byte or halfword reads that hit the dmem require an extra cycle for alignment dmem can stream word and twinword reads or writes that hit dmem at the rate of one per cycle if the lx8000 is configured to work with rams that have word write granularity byte or halfword writes that follow any write by one cycleandhitdmemrequireanextracycletomergethedatawiththecurrentdmemcontentsalternatively thelx8000canbeconfiguredtoworkwithramssupportbytewritegranularitywhicheliminatestheextra cycle also because write operation to the dmem is never sent to the lbc writes to dmem will not cause the lbc to stall the processor due to full write buffer condition8k bytes direct mapped 1024 x 64 bits 512 x 20 bits 16k bytes direct mapped 2048 x 64 bits 1024 x 19 bits 32k bytes direct mapped 4096 x 64 bits 2048 x 18 bits 64k bytes direct mapped 8192 x 64 bits 4096 x 17 bits signal description dc_tagindex tag and state ram address dcr_tagrd tag and state ram read path dc_tagwr tag and state ram write path dc_tagwen tag and state ram write enable dc_tagren tag and state ram read enable dc_tagcsn tag and state ram chip select dc_dataindex data ram address word dcr_datard data ram read path dc_datawr data ram write path dc_datawen10 data ram write enable dc_dataren data ram read enable dc_datacsn data ram chip selectconﬁguration dcache_data ram dcache_tag rammarch 29 2001 lx8000 lexra proprietary confidential 67 release 19 lx8000 applications may optionally specify the use of 128bit data memory width through an lconfig setting when ram bist or scan collars are enabled with lconfig lx8000 does nottie the dmem ram into the ram bist paths or scan collar muxes other rams remain connected to these options theconfigurationssupportedbythedmemandthesynchronousramsrequiredforeacharesummarized in the table32 for lx8000 dualport rams are used and the second port is brought out the processor hierarchy for customer connection table 32dmem conﬁgurations table33 lists the dmem signals that are connected to application specific modules the dw_prefix indicates signals that are driven by the dmem lmi module and received by rams the dwr_prefix indicates signals that are driven by rams and received by the dmem lmi the cfg_prefix identifies configurationportsonthedmemlmithataretypicallywiredtoconstantvaluesthewidthoftheindexand data lines depends upon the ram connected to the lmi and can be inferred from table32 thecfg_wires define where the dmem is mapped into the physical address space this configuration informationdefinesthelocalbusaddressregionofthedmemitisnotpossibleforanydmemreferenceto result in an operation on the system bus the lconfigutility supplied by lexra will verify that the configured addressrangedoesnotinterferewithotherregionsdefinedforlx8000thesizeofthememoryregionmust be power of two and must be naturally aligned the dmem lmi can also be used as rom controller simply by tying off the write enable and data input lines in the ram wrapper and instancing rom in the ram wrapper for the lx8000 the dmadw_ ram ports are brought out of the lx2 hierarchy for customer connection table 33 dmem ram interfacesconﬁguration dmem_data ram 64bit dmem_data ram 128bit local data ram ram required ram required 1k bytes dual port 128 x 64 bits dual port 64 x 128 bits 2k bytes dual port 256 x 64 bits dual port 128 x 128 bits 4k bytes dual port 512 x 64 bits dual port 256 x 128 bits 8k bytes dual port 1024 x 64 bits dual port 512 x 128 bits 16k bytes dual port 2048 x 64 bits dual port 1024 x 128 bits 32k bytes dual port 4096 x 64 bits dual port 2048 x 128 bits 64k bytes dual port 8192 x 64 bits dual port 4096 x 128 bits 128k bytes dual port 16384 x 64 bits dual port 8192 x 128 bits 256k bytes dual port 32768 x 64 bits dual port 16384 x 128 bits signal description dw_dataindex decoded data ram index dwr_datard data ram read datamarch 29 2001 lx8000 lexra proprietary confidential 68 release 19 note n designates an available activelow version of signaldw_datawr data ram write data dw_datawen data ram write enable dw_dataren data ram read enable dw_datacsn data ram chip select cfg_dwbase3110 conﬁgured base address modulo 1k bytes cfg_dwtop1710 conﬁgured top address bits that may differ from base dmadw_rclk data ram dual port dma clock optional dmadw_dataindex decoded data ram index dmadw_datard data ram dual port dma read data dmadw_datawr data ram dual port dma write data dmadw_datawen data ram dual port dma write enable dmadw_dataren data ram dual port dma read enable dmadw_datacsn data ram dual port dma chip selectsignal descriptionmarch 29 2001 lx8000 lexra proprietary confidential 69 release 19 6 lx8000 system bus 61 connecting the lx8000 to internal devices the lexra system bus lbus is the connection between the lx8000 and other internal devices such as systemmemoryusbieee1394firewireandanexternalbusinterfacethelbcusesaprotocolsimilar to that of the peripheral component interface pci bus this is wellknown and proven architecture addingnewdevicestothelexrabusisstraightforwardandtheperformanceapproachesthehighestthatcan be achieved without adding great deal of complexity to the protocol figure 6 lexra system bus diagram thelexrabussupportsmultiplemastersthisallowsformasteringiocontrollerswithdmaenginestobe connected to the bus the bus has pended architecture in which master holds the bus until all the data is transferred this simplifies the design of usersupplied bus agents and reduces latency for cache miss servicing thelexrabusisasynchronousbussignalsareregisteredandsampledatthepositiveedgeofthebusclock certain logical operations may be made to the sampled signals and then new signals can be driven immediately such as for address decoding this allows for samecycle turnaround the lbc provides an optionalasynchronousinterfacebetweenthecpuandthelexrabusallowingthelexrabusspeedcanbeset to be any speed equal to or less than the cpu clock frequency thelexrabusdatapathforthelx8000is64bitswidethereforethebuscantransfertwowordsoneword halfword or byte in one bus clock the bus supports line and burst transfers in which several words of data are transferred the lexra bus accomplishes this by transferring words of data from incremental addresses on successive clock cycles thelbccontainsawritebufferwhenthecpuissuesawriterequesttoalexrabusdevicetheaddressand data are saved in the buffer and sent to the device sometime later the cpu can continue processing having safely assumed that the write will eventually happen this is described more thoroughly in section682 thelbcdrivesenablingsignalstocontrolmuxesortristatebuffersthisallowsthelexrabustohaveeither bidirectional or pointtopoint topology 62 terminology thelexrabusborrowsterminologyfromthepcibusspecificationonwhichthelexrabusispartiallybased bus transactions take place between two bus agents one bus agent requests the bus and initiates transfer the second responds to the transferlexra bus controller lbcbus bridge usb firewirebus to cpu and local memory interfaceslexra system bus external bus eg pcimarch 29 2001 lx8000 lexra proprietary confidential 70 release 19 theagentinitiatingatransferiscalledthe businitiator itisalsoreferredtoasthe busmaster bothtermsare used interchangeably in this document therespondingagentisknownasthebus targetitsamplestheaddresswhenitisvalidanddeterminesifthe address is within the domain of the device if so indicates as such to the initiator and becomes the target aread transfer is bus operation whereby the master requests data from the target awrite transfer is bus operation whereby the master requests to send data to the target asinglecycle bus operation is used to transfer two words one word halfword or byte of data the data can be transferred in one bus cycle not including the address cycle and device latencies aline transfer is read or write operation where an entire cache line of data is transferred in successive cycles as fast as the initiator and target can sendreceive the data aburst transfer is read or write operation where large amount of data needs to be sent the initiator presents starting address and data is transferred starting at that address in successive cycles for each word transferred the address is incremented by the devices internally some signals on the lexra bus are active low that is they are considered logically true when they are electrically low and logically false when electrically high device assertsa signal when it drives it to its logical true electrical state 63 bus operations the purpose of the lexra bus is to connect together the various components of the system including the lx8000 cpu main system memory io devices and external bus bridges different devices have different transfer requirements for example the lx8000 cpu will request the bus to fetch cache line of data from memoryiodeviceswillrequestlargeblocksofdatatobesenttoandfrommemorythelexrabussupports the various types of transfers needed by both io and the processor the nine types of bus operations are singlecycle read line read burst read singlecycle write line write though this is not used by the lx8000 cpu burst write split read write split read and split data 631 singlecycle read the singlecycle read operation reads twinword single word halfword or byte from the target device this operation is usually used by the cpu to read data from uncachable address space if the read address was in cacheable address space either hit would occur resulting in bus activity or miss would occur resulting in read line transaction 632 read line thereadlineoperationreadsasequenceofdatafrommemorycorrespondingtothesizeofacachelinethe cache line size affects how many cycles are required to transfer the full line the lx8000 and the lexra bus support configurable line size specified through lconfig the default line size of four words 16 bytes ia assumed here there are two ways that the target could transfer the data back to the initiator the conventional way is to transferfourwordsofdatainsequencestartingatthenearest16bytealignedaddresssmallerorequaltothe address that the initiator drives in other words the target starts the transfer at the beginning of the line containing the requested address somememorydevicesmayimplementaperformanceoptimizationcalled desiredwordfirst iftheaddressismarch 29 2001 lx8000 lexra proprietary confidential 71 release 19 notaligned to 16byte boundary then the first data returned by the target is the word corresponding to the addressinsteadofthefirstwordofthelinethesecondwordisthenextsequentialwordofdataandsoonat the end of the line the target wraps around and returns the first word of line thelx8000supportstwowaysofincrementingtheaddressofalinerefilloneisby linearwrap wherethe addressissimplyincrementedbyonetheotherisby interleavedwrap wherethenextaddressisdetermined bythelogicalxorofthecyclecountandthefirstwordaddresstheinterleavesequenceisshowninthetable belowtheloworderaddressbits32forthefirstdatabeataretheobtainedfromtheaddressofthelineread request the low order address bits for the subsequent data indicate the corresponding interleave order table 34 line read interleave order 633 burst read theburstreadoperationtransfersanarbitraryamountofdatafromthetargettotheinitiatortheinitiatorfirst presents starting address to the target the target responds by providing multiple cycles of data words in sequence starting at the initial address the initiator indicates to the target when to stop providing data burstreadoperationsareusedbyiodevicesforblockdmatransfersthelx8000willneverissueaburst read operation note that there is difference between 4cycles burst and line read line read may use desiredword first increment and wrap burst will always increment and will never wrap 634 singlecycle write the singlecycle write operation writes two words single word halfword or byte to the target thelx8000usesacachewithawritethroughpolicyallcpuinstructionsthatwritetomemorygeneratea singlecycle write operation unless the address is in the local scratchpad memory in which case the write operation will not make it out to the lexra bus 635 line write the line write operation is not used by the lx8000 this operation could be used by processor that has data cache that implements writeback policy 636 burst write burst write is an operation where the initiator sends an address and then an indefinite sequence of data to thetargettheinitiatorwillinformthetargetwhenithasfinishedsendingdatathisoperationisusedbyio devices for dma transfers it is not used by the processorinterleaved address32 1st data beat 00 01 10 11 2nd data beat 01 00 11 10 3rd data beat 10 11 00 01 4th data beat 11 10 01 00march 29 2001 lx8000 lexra proprietary confidential 72 release 19 637 split read the lbc issues split read command when the processor executes an lwcsw ltcsw or lqcsw instruction for this command the bus transaction terminates when the target has accepted the command by asserting trdy the bus is free for other operations while the target device performs the read internally when the target is ready to supply the read data it issues split data command as bus master described below 638 write split read thelbccanissueawritesplitreadcommandwhentheprocessorexecutesawdlwcswwdltcsw orwdlqcswinstructionthisbuscommandwrites64bitdatatoadevicewhilesimultaneouslymakinga split read request cmd30 specify the size of the read request one two or four words the write split read bus transaction terminates when the target device has accepted the command and the write data by assertingtrdythebusisfreeforotheroperationswhilethedeviceperformsthewriteandreadoperations internally when the target device is ready to supply the read data it issues split data command as bus master described below 639 split data atargetdevicethathasacceptedasplitreadorwritesplitreadcommandsuppliesthedatatotherequestor usingthesplitdatacommandthedevicesavesthegtidobtainedfromthesplitreadorwritesplitread command and performs the read operation internally when the device is ready to supply the read data the device acts as an lbus master device it issues split data command that identifies the original requestors gtidandsuppliesthereaddatawiththecommandthelbcthatmatchesthegtidwillactaslbustarget device and accept the data an lbc acts as target only for split data commandsmarch 29 2001 lx8000 lexra proprietary confidential 73 release 19 64 signal descriptions table 35 lbus signal description 65 lbus commands the initiator drives bcmd during the cycle that bframe is asserted bcmd86 876 000 read 001 write 010 split read 011 write split read 100 reserved 101 split data 110 reserved 111 reservedsignal namesource initiatortargetctrldescription bclock ctrl bus clock bcmd80 initiator encoded command active during ﬁrst cycle that bframe is asserted baddr310 initiator address target indicates valid address by asserting bframe bframe initiator asserted by initiator beginning of operation with address and command signals deasserted when initiator is ready to accept or send last piece of data otherbusmasterssamplethisandbirdytoindicate that the bus will be available on the next cycle birdy initiator forwritesindicatesthatinitiatorisdrivingvaliddata on reads indicates that initiator is ready to accept data bdata630 initiator on writetarget on readdata if driven by initiator birdy indicates valid data onbusifdrivenbytargetbtrdyindicatesvaliddata on bus btrdy target for writes indicates that target is ready to accept data on reads indicates that target is driving valid data bsel target asserted by selected target after initiator asserts bframeindicatesthattargethasdecodedaddress and will respond to the transaction ie has been selected bgtid150 initiator for all transactions except split data indicates the global thread id of the initiator for split data trans actions indicates the global thread id of the target to which the data is directedmarch 29 2001 lx8000 lexra proprietary confidential 74 release 19 bcmd54 541 00 burst fixed length2 01 burst unlimited number of words 10 line interleaved wrap3 11 line linear wrap bcmd30 32104 1000 1 byte 1001 2 bytes 1010 3 bytes 1011 1 word 1100 2 words 1101 reserved 111x reserved 0000 4 words 0001 8 words 0010 16 words 0011 32 words 01xx reserved 1 cmd54 must be 00 for split read write split read and split data commands 2 the number of words comes from bcmd20 3 length is determined by the line size not bcmd30 4 cmd30 indicates the read data size for split read write split read and split data commandsmarch 29 2001 lx8000 lexra proprietary confidential 75 release 19 66 byte alignment the lexrabus isa big endian bus transactionsmust havetheir data driven to theappropriate busrails the bus mapping is as shown in table36 table 36lbus byte lane assignment the lexra bus does not define unaligned data transfers such as halfword transfer that starts at addr1001 or transfers that would need to wrap to the next word 67 split transactions thereareseveralprocessorcontextswitchinstructionsthatcancausesplittransactionsonthelbusthesplit transactions are divided into two parts the first half initiated by an lbc requests data from target device either with split read or write split read command unlike regular read request the lbc does not hold the bus until the read data is returned once the lbc knows that the target has received the split read requestitreleasesthebusandwaitsforthedatatobereturnedatalatertimethedataisreturnedtothelbc with split data command from the lbus device that accepted the split read request thelbccanissueasplitreadrequestwitheitherareadorwritetransactionwhentheprocessorexecutesa lwcswltcsworlqcswinstructionasimplesplitreadrequestsplitreadcommandforonetwoor four words will be issued on the lbus cmd30 is used to indicate the size of the read data requested data will be transferred with the request when the processor executes wdlwcsw wdltcsw or wdlqcsw instruction one lbus transaction write split read command will issue the write data and splitreadrequestunlikearegularwritethesizeofthewritedataisalwaystwowordscmd30isusedto indicate the size of the requested read data once an lbus target device has accepted the split read request it must return data at later time the target actsasanlbusmasterdeviceandinitiatesasplitdatacommandthetargetlbcwillacceptthiscommandlexra bus data byte lanes used bcmd10 addr20 6356 5548 4740 3932 3124 2316 158 70 00 000 x 00 001 x 00 010 x 00 011 x 00 100 x 00 101 x 00 110 x 00 111 x 01 000 x x 01 010 x x 01 100 x x 01 110 xx 11 000 x x x x 11 100 x x x xmarch 29 2001 lx8000 lexra proprietary confidential 76 release 19 and receive the data theglobalthreadidgtidisdrivenwitheachsplitreadrequestthetargetdeviceretainsthegtidvalue associated with the split read request and supplies this value when it initiates the split data transaction to return the data this allows an lbc to identify split read data that is targeted for it and allows the processor associate the data with the correct context the gtid is made up of two values the processor number and context number the lower 4 bits of the gtid are used for the context number the processor number is an 8bit field the use and interpretation of the reserved field is processor dependent target system bus devicemustsaveall16bitsofthegtidvaluedrivenwithasplitreadrequestandsubsequentlydrivethe16 bit value onto gtid during the split read data transaction table 37 lbus gtid fields the gtid is driven by an lbc for all transactions 68 lexra bus controller thelexrabuscontrollerlbcistheelementofthelx8000thatconnectstothelexrabusitforwardsall transaction requests from the lx8000 cpu to the lexra bus 681 lbc commands the lbc issues the only the lbus commands listed in the table below table 38 lbus commands issued by the lbcgtid1512 gtid114 gtid30 reserved procnum contextnum command bcmd54 bcmd30 circumstances read line 10 or 11 dependingon conﬁguration0000 cache miss during read by the cpu read single wordhalfwordbyte00 10xx read by the cpu from an address in uncachable address space write single twinwordwordhalf wordbyte00 1xxx write by the cpu into cacheable or uncachable address space split read 00 10111100 or 0000an lwcsw ltcsw or lqcsw instruction is executed write split read 00 10111100 or 0000a wdlwcsw wdltcsw or wdlqcsw instruction is exe cutedmarch 29 2001 lx8000 lexra proprietary confidential 77 release 19 682 lbc write buffer and outoforder processing the lbc contains write buffer with depth that is configurable with lconfig all write requests from the cpu are posted in the write buffer the cpu will not wait for the write to complete write operations completeintheordertheyareenteredintothequeueifthequeuefillsthenthecpumustwaituntilanentry becomes available whenthecpu issuesareadoperationthelbcwillattempttoforwardthatrequesttothelexrabus ahead ofanypendingwriteoperationsthissignificantlyimprovesperformancesincethecpuneedstowaitforthe readoperationtocompleteandwouldwastetimeifithadtoalsowaitforunnecessaryorirrelevantwritesto complete there are few cases when the lbc will not allow the read operation to pass pending writes 1 theaddressofapendingwriteiswithinthesamecachelineasthereadthelbcwillholdthe read operation until the matching write operation and all write operations ahead of it com plete if the read is for an instruction fetch it can still pass pending write that is inside the same cache line 2 the read is to uncacheable address space all writes will complete before the read is issued this avoids any problems with io devices and their associated controlstatus registers 3 apendingwriteistouncachableaddressspacethelbcwillholdthereadoperationuntilall writesuptoandincludingthewritetouncacheableaddressspacecompletethisfurtheravoids io device problems the write buffer bypass feature can be disabled so that reads will never pass writes 683 lbc read buffer the lbc contains read buffer with depth that is configurable with lconfig all incoming read data from the system bus passes through the read buffer this allows the lbc to accept incoming data as result of cache line fill operation without having to hold the bus when the lbc is configured with an asynchronous interface larger read buffer improves system and processorperformanceintheeventofcachemisswhenthelbcisconfiguredwithasynchronousinterface thecachecanacceptthedataasfastasthelbccanreaditthereforethereisnoneedforalargereadbuffer customers may reduce the size of the read buffer to minimum size of two 64bit entries insomecasesthereisaneedtominimizethenumberofgatesthereadbuffersizemaybereducedtotwoor fourentriesfortheasynchronouscasethiscausesapenaltyintermsoflbusutilizationsincenowthelbc may have to deassert irdy if it cannot hold part of the line of data when the read buffer is the size of cache line this will be relatively rare since simultaneous instruction cache and data cache misses are relatively rare for smaller read buffer irdy deassertion is almost certainty 684 transfer descriptions this section describes the various types of read and write transfers in detail these operations follow certain patterns and rules the rules for driving and sampling the bus are as follows 1 agentsthatdrivethebusdosoasearlyaspossibleaftertherisingedgeofthebusclockthere is some time to perform some combinational logic after the bus clock goes high but the amount of time is determined by the speed of the bus clock and the number of devices on the busmarch 29 2001 lx8000 lexra proprietary confidential 78 release 19 2 agents sample signals on the bus at the rising edge of the bus clock 3 all bus signals must be driven at all times if the bus is not owned and external device must drive the bus to legal level 4 change in signal ownership requires one dead cycle if an initiator gives up the bus another initiatorneedstowaitforonedeadcyclebeforeitcandrivethebusifthesameinitiatorissues areadoperationandthenneedstoissueawriteoperationitalsomustwaitoneextracyclefor the data bus to turn around 5 agentsthatownsignalsmustdrivethesignalstoalogicaltrueorlogicalfalseallotheragents must disable tristate their output buffers thelexrabusprotocolisbasedonthepcibusprotocol1thelexrabussignalsbframebtrybirdy and bsel have similar function to the pci signals frame trdy irdy and devsel respectively in general the protocol for the lexra bus is as follows 1 the initiator gains control of the bus through arbitration described later in this chapter 2 during the ﬁrst bus cycle of its ownership before the ﬁrst rising clock edge the initiator drivestheaddressforthebustransactionontobaddratthesametimeitassertsbframe to indicate that the bus is in use it will deassert bframe before it send or accepts the last word of data in most cases the initiator will asserts birdy to indicate that it is ready to receivedataorreadoperationsorisdrivingvaliddataforwriteoperationsiftheoperation is write the initiator will drive valid data onto bdata 3 at the rising edge of the ﬁrst clock all agents sample baddr and decode it to determine which agent will be the target 4 the agent that determines that the address is within its address space asserts bsel sometime after the ﬁrst rising edge of the bus clock bsel stays asserted until the transaction is com plete 5 the initiator and the target transfer data either in one cycle or in successive cycles the agent driving data the initiator for write the target for read indicates valid data by asserting its readysignalirdyortrdyforwritesandreadsrespectivelytheagentreceivingdatatar getforawriteinitiatorforareadindicatesitsabilitytoreceivethedatabyassertingitsready signal either agent may deassert its ready signal to indicate that it cannot source or accept data on this particular clock edge 6 when the initiator is ready to send or receive the last word of data that is when it asserts birdy for the last time it also deasserts bframe it will deassert birdy when the last word of data is transferred 7 the arbiter grants the bus to the next initiator and may do so during bus transfer by differ ent initiator the new initiator must sample bframe and birdy when both birdy and bframe is sampled deasserted and the new initiator has been given grant it can assert bframe the next cycle to start new transaction note in the examples below the signals baddr and bdata are often shown to be in highimpedance state in reality internal bus signals should always be driven even if they are not being sampled the hiz states are shown for conceptual purposes only 1 the lexra bus is not pci compatible it merely borrows concepts from the pci bus speciﬁcationmarch 29 2001 lx8000 lexra proprietary confidential 79 release 19 685 single cycle read with waits this operation is used to read twinword word halfword or byte from memory usually in uncachable address space thisisasimplereadoperationwherethetargetrespondsimmediatelywithdatathisisunlikelysincemost bus memory will require one or more cycles to fetch data this example illustrates the most basic read operation without waits 1 initiator asserts bframe and drives baddr 2 targetassertsbseltoindicatetoinitiatorthatatargetisrespondinginthisexamplethereis animmediatefetchofdatasotargetdrivesdataandassertsbtrdytoindicatetotargetthatit is driving data the initiator deasserts bframe and asserts birdy to indicate that the next piece of data received will be the last 3 initiatordeassertsibirdyandthetargetdeassertsbselandbtrdytoindicatetheendof the transaction the initiator that has been given grant owns the bus this cycle 686 single cycle read with target wait this is the same as the singlecycle read except that the target needs time to fetch the data from memory this is common singlecycle read operation 1 initiator asserts bframe and drives baddr 2 target asserts bsel to indicate that it has decoded the address and is acknowledging that it is the target device however it is not ready to send data so it does not assert btrdy initiatorclock bframe baddr bdata birdy btrdy bsel d0000 clock bframe baddr bdata birdy btrdy bsel d0001march 29 2001 lx8000 lexra proprietary confidential 80 release 19 deassertsbframeandassertsbirdytoindicatethatthenextpieceofdatawillbethelastit wants 3 target has not asserted btrdy so data is transferred 4 after second wait cycle target drives data and asserts btrdy to indicate that data is on the bus 5 target deasserts bsel and btrdy initiator deasserts birdy another initiator may drive the bus this cycle 687 line read with waits this operation is used to service cache miss four twinwords of data are transferred in sequence in this example the target is supplying four twinwords of data without any waits 1 initiator drives baddr and asserts bframe to indicate beginning of transaction 2 target asserts bsel to indicate that it had decoded the address and will send data when it is ready initiator asserts birdy to indicate that it is ready to receive data 3 target drives data and asserts btrdy 4 target drives second twinword of data and continues to assert btrdy 5 target drives third twinword of data and continues to assert btrdy 6 targetdriveslasttwinwordofdatainitiatordeassertsbframetoindicatethatthenextword of data it receives will be the last it needs 7 target deasserts btrdy and bsel initiator deasserts birdy another master may gain ownership of the bus this cycleclock bframe baddr bdata birdy btrdy bsel d0002march 29 2001 lx8000 lexra proprietary confidential 81 release 19 688 line read with target waits this illustrates what happens when target needs extra time to fetch data it needs to service cache miss 1 initiator asserts bframe and drives baddr 2 targetassertsbseltoindicatethatitisacknowledgingtheoperationinitiatorassertsbirdy to indicate that it is ready to receive data 3 target waits until it has the data 4 target drives ﬁrst twinword of data and asserts btdry 5 target drives second twinword of data and asserts btrdy 6 target cannot get third twinword of data so it deasserts btrdy 7 target drives third twinword of data and asserts btrdy 8 target cannot get fourth twinword of data so it deasserts btrdy 9 target drives fourth twinword of data and asserts btrdy 689 line read with initiator waits this occurs when line of data is requested from the target and the initiator cannot accept all of the data in successive cycles 1 initiator drives address and asserts bframeclock bframe baddr bdata birdy btrdy bsel d0003 clock bframe baddr bdata birdy btrdy bsel d0004march 29 2001 lx8000 lexra proprietary confidential 82 release 19 2 targetassertsbselitdoesnthavedatasoitdoesnotassertbtrdyinitiatorassertsbirdy to indicate that it can accept data 3 target now has data so it drives the data and asserts btrdy 4 target drives second twinword of data initiator cannot accept it so it deasserts birdy 5 target holds second twinword of data initiator can accept it and asserts birdy 6 target drives third twinword of data initiator accepts it 7 targetdrivesfourthtwinwordofdatainitiatorcannotacceptitanddeassertsbirdyinitiator hold bframe until it can assert birdy 8 initiator asserts birdy to accept fourth twinword of data it deasserts bframe to indicate this is the last word of data 6810 burst read this is identical to the read line 6811 singlecycle write with waits singlecycle write operation occurs almost every time the lx8000 processor executes store instruction thisisbecausethecacheusedintheprocessorusesawritethroughpolicyofcoursewritestouncacheable address space and to an io device will also generate singleword write singleword write operations are used to write words halfwords and bytes singleword write without waits requires two cycles 1 initiator asserts bframe and drives address 2 targetsamplesaddressandassertsbselinitiatordrivesdataandassertsbirdyinthiscase target is also able to accept data so it asserts btrdy initiator also deasserts bframe to indicate that it is ready to send the last and only word of data 3 target accepts data deasserts btrdy and bsel initiator deasserts birdy 6812 singlecycle write with waits this is an example of singlecycle write operation where the target cannot immediately accept data andclock bframe baddr bdata birdy btrdy bsel d0005march 29 2001 lx8000 lexra proprietary confidential 83 release 19 must insert wait states thisisthesamedescriptionastheaboveexampleexceptthatthetargetinsertstwowaitstatesuntilitasserts birdy to indicate acceptance of data 6813 burst write with waits aburstwriteoperationisgenerallyusedtotransferlargeamountsofdatafromaniodevicetomemoryvia dma transfer the following illustrates bestcase scenario with wait states 1 initiator drives address and asserts bframe 2 targetassertsbselandbtrdytoindicateitwillacceptdatainitiatordrivedataandasserts birdy 3 initiator drives next twinword of data target continues to accept data and indicates as such by continuing to assert btrdy 4 initiator drives third twinword of data target continues to accept 5 initiatordrivesfourthtwinwordofdataanddeassertsbframetoindicatethatthiswillbeits last word sent target accepts data 6 target deasserts btrdy and bsel initiator gives up control of the bus by deasserting birdy 6814 burst write with target waits this example is similar to the above example except that during the third and fourth data word transfer the target cannot accept the data quickly enough so it deasserts btrdy which indicates to the initiator that itclock bframe baddr bdata birdy btrdy bsel d0006 clock bframe baddr bdata birdy btrdy bsel d0007march 29 2001 lx8000 lexra proprietary confidential 84 release 19 should hold the data for an additional cycle 6815 burst write with initiator waits the example illustrates what happens when the initiator cannot supply data fast enough and has to insert waits 6816 split read command an lbc issues split read command when the processor executes an lwcsw ltcsw or lqcsw instruction the following is an example of single word read request 1 an lbc initiates the transaction by asserting frame and driving the addr for the transac tion it drives the cmd bus with the split read command gtid is also driven by the lbc with the processorcontext number informationclock bframe baddr bdata birdy btrdy bsel d0008 clock bframe baddr bdata birdy btrdy bsel d0009 clock bframe bgtid baddr bdata birdy btrdy bsel d0010march 29 2001 lx8000 lexra proprietary confidential 85 release 19 2 the target decodes the address and asserts sel and trdy to respond to the request trdy should always be asserted with sel it saves the addr and gtid information which it will use when it returns the data data needs to be transferred so the data bus is inactive frame is deasserted and addr cmd gtid are not driven irdy is asserted 3 the lbc deasserts irdy and the target device deasserts sel and trdy to indicate the split read request transaction is complete therearenodatastallsallowedsincenodataisbeingtransferredthetargetshouldasserttrdyassoonas it asserts sel the first half of the read transaction is now complete the lbc will wait for the target device to return the requested data using the split data command 6817 write split read when the processor executes wdlwcsw wdltcsw or wdlqcsw instruction the lbc issues write command with split read request with this command the lbc writes data to device while simultaneously making split read request the write data consists of two words the requested read data size may be 1 2 or 4 words indicated by cmd30 1 an lbc initiates the transaction by asserting frame and driving the addr for the transac tion it drives the cmd bus with write split read command and cmd30 indicates either one word or two word split read request gtid is driven with the processorcontext number information 2 thetargetdecodestheaddressandassertsselinthisexamplethetargetisimmediatelyready toacceptthewritedatasoitalsoassertstrdyitsavesthegtidinformationwhichitwilluse when it returns the data the lbc deasserts frame since this is single cycle write it also drives irdy and the data bus addr cmd and gtid are only driven the ﬁrst cycle 3 the lbc deasserts irdy and the target device deasserts sel and trdy to indicate the write transactionhascompletedthereadrequesthasalsobeentransferredandthetargetmustissue data response at later time thetransactionwilllookthesameforasplitreadrequestoftwowordsexceptcmd30willindicateatwo word request instead of one word sincewritedataisbeingtransferredwiththesetransactionsdatastallsareallowedtherulesfortrdyandclock bframe bgtid baddr bdata birdy btrdy bsel d0011march 29 2001 lx8000 lexra proprietary confidential 86 release 19 irdy are the same for these write transactions as they are for regular write transactions an lbc will never deassert irdy to cause data stall during write transactions when an lbc issues split read or write split read command and successfully completes the request to thetargetthelbcwillconsiderthatoperationcompleteitistheresponsibilityofthetargetdevicetoreturn data to the lbc by issuing split data command 6818 split data once an lbc has sent split read request either with split read or write split read command and the targetdevicehasacceptedtherequestthedevicemustsupplytherequesteddataandreturnittothelbcto do this it must act as an lbus master device and initiate split data command the lbc which originated thesplitreadwillactaslbustargetdeviceandacceptthedataanlbconlyactsasatargetforsplitdata commands 1 the lbus device that accepted the read request now asserts frame to indicate it is ready to return the requested data it drives cmd with the split data command and indicates it is two word read the gtid bus is driven with the correct processorcontext information the addr bus must be driven with the address of the requested read data 2 eachlbcexaminesthegtidbustodeterminewhichprocessorthisdataisforthelbcthat is associated with the procnum asserts sel and trdy to accept the two words of data frame is deasserted while irdy is asserted addr cmd and gtid are only driven the ﬁrst cycle 3 themasterdevicedeassertsirdyandthelbcdeassertsselandtrdytoindicatethetrans action is complete the lbc then returns the read data to the context that requested it thetransactioncansupplyoneortwowordsofdataonthebusasindicatedbycmd30fortheoneword case the word is aligned on the data bus based on the original read address according to the rules shown in table36 on page75 datastallsareallowedduringdataresponsetransactionsanlbcwillproperlyhandledatastallsonthebus and may deassert trdy to stall the transaction itself for performance reasons the read buffer in the lbc should be large enough to avoid thisclock bframe bgtid baddr bdata birdy btrdy bsel d0012march 29 2001 lx8000 lexra proprietary confidential 87 release 19 69 ordering rules with split transactions the lbc follows the same rules for allowing split read request to be issued as it would standard read request all split reads are uncacheable and therefore are not allowed to bypass pending writes once an lbc has issued the split read or write split read command it does not keep track of the read request this means subsequent write transaction could be issued to the same address before the requested data has been returned to the lbc the lbc will not stall the write or try to enforce any coherency in this case if more than one split readwrite split read request is outstanding on the lbus the corresponding data responses do not have any ordering requirements the lbc will use the gtid that was presented with the split data to return the data to the correct context 610lbc signals thetablebelowsummarizesthelx8000lbcportsthelbcportcolumnindicatesthenameoftheport suppliedbythelbcthebussignalcolumnindicatesthecorrespondinglexrabussignalthelbcports are strictly unidirectional while the bus signals at least conceptually include multiple sources and sinks the manner in which lbc ports are connected to bus signals is technology dependent and may employ tri state drivers or logic gating in conjunction with the lbcs lcoe ldoe and ltoe outputs table 39 lbc interface signals io lbc port bus signal description output laddro310 baddr310 lbc address output ldatao630 bdata630 lbc data input ldatai630 bdata630 system data output lirdy birdy lbc initiator ready input lirdyi birdy system initiator ready output lframe brame lbc transaction frame input lframei bframe system transaction frame output lselo bsel lbc slave select input lsel bsel system slave select output ltrdyo btrdy lbc target ready input ltrdy btrdy system target ready output lcmd80 bcmd80 lbc command input lcmdi80 bcmd80 system command output lgtido150 bgtid150 lbc global thread id input lgtidi150 bgtid150 system global thread id output lreq lbc bus request input lgnt system bus grant output lcoe90 lbc command output enable termsmarch 29 2001 lx8000 lexra proprietary confidential 88 release 19 611 arbitration 6111 rules the following are the rules for arbitration gntgrant reqrequest 1 masterassertsreqatthebeginningofacycleandmaystartsamplingforassertedgntinthe same cycle in case gnt is already asserting in the case of park 2 if bus is idle or it is the last data phase of the previous transaction when master samples asserted gnt master may assert frame on next cycle 3 ifthebusisbusywhenthemastersamplesgntismustalsosnoopframeirdyandtrdy onecycleafterframeisnotassertedandbothirdyandtrdyareassertedindicatingthe last data phase if gnt is still asserted master may now drive frame ie gnt frame_r irdy_r trdy_r 6112 lbc behavior the lbc when it need access to the bus asserts req and in the same cycle samples gnt frame and either irdy or irdy trdy if these are true then the lbc will on the next cycle take ownership of the bus req is deasserted on the cycle after lbc asserts frame if the bus is busy lbc continues to snoop these four signals for this condition all other lbus arbitration rules can be based on this behavior of the lbc 612connecting devices to the bus there are three sets of output enables toevalid for the length of the transaction coe valid for only the first cycle of transaction and doe valid for data transfers asserted by the master for writes and by the slave for reads toe is intended to qualify frame irdy coe is intended to qualify cmd addr gtid doe is intended to qualify data there is output enable to qualify trdy and sel these are defined by customer logic for slave devicesoutput ldoe70 lbc data output enable terms output ltoe lbc transaction output enable termsio lbc port bus signal descriptionmarch 29 2001 lx8000 lexra proprietary confidential 89 release 19 insteadofusingtoeitmaybedesirabletoinsteadoralloftheframesignalseithercentrallyoroneor gate for each target and master the same holds true for irdy trdy and sel this simplifies the connections when relatively few number of devices are used and there are offchip devices connected directly to the lexra bus therefore it is defined that masters and slaves not taking part in transaction always keep frame irdy trdy and sel driven and deassertedmarch 29 2001 lx8000 lexra proprietary confidential 90 release 19 march 29 2001 lx8000 lexra proprietary confidential 91 release 19 7 lx8000 coprocessor interface thelx8000processorprovidescustomeraccesspointsforthecoprocessorinterfacesthissectionprovides description of these access points attachment of memory devices to the lmis the system bus and the ejtag interface are described in separate chapters 71 attaching coprocessor using the coprocessor interface ci acoprocessormaycontainupto32generalregistersandupto32controlregisterseachoftheseregistersis up to 32 bits wide typically programs use the general registers for loading and storing data on which the coprocessor operates data is moved to the coprocessors general registers from the cores general registers with the mtcz instruction data is moved from the coprocessors general registers to the cores general registers with the mfcz instruction main memory data is loaded into or stored from the coprocessors general registers with the lwcz and swcz instructions programs may load and store the coprocessors control registers from the cores general registers with the ctczandcfczinstructionsrespectivelyprogramsmaynotloadorstorethecontrolregistersdirectlyfrom main memory the coprocessor may also provide condition flag to the core the condition flag can be bit of control registeroralogicalfunctionofseveralcontrolregistervaluestheconditionflagistestedwiththebcztand bczfinstructionstheseinstructionsindicatethattheprogramshouldbranchiftheconditionistruebczt or false bczf 72 coprocessor interface ci signals the ci provides the mechanism to attach the custom coprocessor to the core the ci snoops the instruction bus for coprocessor instructions and then gives the coprocessor the signals necessary for reading or writing the general and control registers table 40 coprocessor interface signals signal direction description czcondin input cop branch ﬂag czrd_addr40 output cop read address czrhold output cop hold condition one stalls coprocessor czrd_gen output cop general register read command czrd_con output cop control register read command czrd_data310 input cop read data czwr_addr40 output cop write address czwr_gen output cop general register write command czwr_con output cop control write address command czwr_data310 output cop write data czinvld_m output cop invalid instruction ﬂag one indicates invalid instruction in m stagemarch 29 2001 lx8000 lexra proprietary confidential 92 release 19 theaddressesoutputdataandcontrolsignalsaresuppliedtotheuserscoprocessorontherisingedgeofthe system clock in the case of read cycle the coprocessor must supply the data from either the control or generalregisteronczrd_databytheendofthesamecyclesimilarlythewriteofdatafromczwr_data to the addressed control or general register must be complete by the end of the cycle the ci incorporates forwarding path so that data which is written in instructionn can be read in instruction n 2 the coprocessor registers should be implemented as positiveedge flipflops using the lx8000 system clock 73 coprocessor write operations duringacoprocessorwritethecisendsczwr_addrandczwr_dataandassertseitherczwr_genor czwr_con the coprocessor must ensure that the coprocessor completes the write to the appropriate register on the subsequent rising edge of the clock the target register is decoding of czwr_addr czwr_gen and czwr_con use these instructions to cause coprocessor write lwcz mtcz and ctcz 74 coprocessor read operations during coprocessor read the ci sends czrd_addr and asserts either czrd_gen or czrd_con the coprocessor must return valid data through czrd_data in the following clock cycle if the core asserts czrhold indicating that it is not ready to accept the coprocessor data the coprocessor must hold the previous value of czrd_data the target register for the read is decoding of czrd_addr czrd_gen and czrd_con the instructions causing coprocessor read are swcz mfcz and cfcz the cpu stalls the pipeline so that the program can access data read by coprocessor instruction in the immediatelyfollowinginstructionforexampleifanmfczinstructionreadsdatafromthecoprocessorand stores it in the cores general register 4 the program can get access to that data in the following instruction when the core initiates coprocessor read the coprocessor must return valid data in the following clock cycle the coprocessor cannot stall the cpu applications must ensure that the source code does not access invalid coprocessor data if the coprocessor operations take several clock cycles to complete this is done in one of three ways ensure that code does not access data from the coprocessor until n instructions after the coprocessor operation has stared this is the least desirable method as it depends on the relative execution of the core and coprocessor it can also complicate software debug have the coprocessor send an interrupt to the core and the service routine for that interrupt accesses the appropriate coprocessor registers havethecoprocessorsettheczcondinflagwhenitsoperationiscompletethesourceczxcpn_m output copexceptionﬂagoneindicatesexception in m stage czrd_cntx20 output cop read context number czwr_cntx20 output cop write context number mfc2 4 3 move from cop2 to cpu register 4 subu 5 4 2 subtract r2 from r4 and store in 5signal direction descriptionmarch 29 2001 lx8000 lexra proprietary confidential 93 release 19 code can poll the flag as shown in the example below 75 coprocessor interface and pipeline stages coprocessorwritesoccurinthewstageoftheinstructionpipelineforcoprocessorreadsthecoregenerates address rd_gen and rd_con signals during the s stage and the coprocessor returns data during the stage whichispassedbythecitothecoreinthemstagethecoreintroducesapipelinebubbleaftercoprocessor instructions to ensure that the result of mtcz instruction can be used by the immediately following instruction in particular if there are backtoback mtcz and mfcz instructions that access the same coprocessor register the pipeline bubble still does not allow cycle between the w stage write and stage read as required in this case special forwarding path within the ci is used that is the true data from the coprocessor is ignored instead the exact data from the mtcz is used mtc2 i d s m w bubble i d mfc2 i d s m w data forwarded by ci from mtc2 wr_gen w x rd_gen s x rd_datae x theforwardingpathcancausesideeffectsifthecoprocessordoesnotimplementallofthebitsofaregister contains readonly bits or updates the register value upon reading the register in such cases the mfc2 instructionreturnsdifferentdatafromwhatitwouldifthecoredidnotactivatetheforwardingpathtoavoid the forwarding path another instruction must be inserted between the mtc2 and mfc2 mtc2 i d s m w bubble i d foo i d s m w mfc2 i d s m w read data from coprocessor wr_gen w x rd_datae x 751 pipeline holds thecoprocessormustregisterthereadaddressandthecontrolsignalsrd_genandrd_conitmustholdthee stage registered values of these signals when cz_rhold is active high and should make the read data output function of the stage registered read address and control signals thewr_addrwr_datawr_genandwr_consignalsneednotberegisteredthecoprocessormaydecodethese w stage signals directly to the appropriate register 752 pipeline invalidation under certain circumstances the instruction pipeline can contain an instruction that must be discarded thismtc2 2 3 store data to cop2 general register 3 ctc2 3 5 set cop2 control register 5 to start nop loop bc2f loop branch back to loop if czcondin bit off nop branch delay slot mfc2 4 7 get results from cop2 general register 7march 29 2001 lx8000 lexra proprietary confidential 94 release 19 can be due to mispredicted branches cache misses exceptions inserted pipeline bubbles etc in such cases the ci may decode an instruction that must actually be discarded for the coprocessor writetype instructions the ci will only issue the w stage control signals wr_gen and wr_con for valid instructions the coprocessor does not need to qualify these controls forthecoprocessorreadtypeinstructionsthecimayissuethesstagecontrolsignalsrd_genandrd_confor instructions that must be discarded if the coprocessor can tolerate speculative reads then it need not qualify those signals however if the coprocessor performs destructive reads such as updating fifo pointer upon read then it must use the qualifying signals cz_xcpn_m and cz_invld_m as follows thesignalcz_xcpn_msignalisusedtodiscardanysstagefromcird_genorrd_consignalandanye stage registered in the coprocessor rd_gen or rd_con signal it indicates that preceding instruction in the pipe has taken an exception and that subsequent instructions in the pipe must be discarded the signal cz_invld_m signal is used to invalidate the operation of the current instruction in the m stage this can be for various reasons not limited to an exception on preceding instruction if the coprocessor cannot tolerate speculative reads it must register an m stage version of rd_gen and rd_con the coprocessor must use the cz_rhold signal to hold this m stage version as well as the stage version if cz_invld_m is asserted then any such m stage signals must be discarded to summarize rd_gen or rd_con instruction can retire only if it reaches the m stage and neither cz_rhold nor cz_invld_m is assertedmarch 29 2001 lx8000 lexra proprietary confidential 95 release 19 8 lx8000 ejtag 81 introduction given the increasing complexity of soc designs the nature of embedded processordesign debug hardware and software and the timetomarket requirements of embedded systems debug solution is needed which allows onchip processor visibility in costeffect io constrained manner lexrasejtagsolutionmeetsallsuchrequirementsitusesexistingieeejtagpinsaswellasfastbringup on new designs it provides way of debugging all devices accessible to the processor in the same way the processor would access those devices itself using ejtag debug probe can access all the processor internalregistersandcachesitcanalsoaccessdevicesconnectedtothelexrabusbypassinginternalcaches and memories software debug is enhanced by ejtag features that allow singlestepping through code and halting on breakpoints hardware and software address and data with masking for debugging problems that are artifacts of realtime interactions ejtag gives realtime program counter trace capabilities from which an accurate program execution history is derived for the codesystem perspective pc profiling provides statistical analysis of code usage to aim code optimization 82 overview adebughostcomputercommunicatestotheejtagprobethrougheitheraserialorparallelportorethernet connectiontheprobeinturncommunicatestothelx8000ejtaghardwareviatheincludedieee11491 jtaginterfacethroughtheuseofthejtagtapcontrollerprobedataisshiftedintototheejtagdataand control registers in the lx8000 to respond to processor requests dma into system memory configure the ejtag control logic enable singlestep mode or configure the ejtag breakpointregistersthroughtheuse of the ejtag control registers the user can set hardware breakpoints on the instruction cache address data cache address or data cache data values when ejtag is included in configuration physical address range 0xff20_0000 to 0xff3f_ffff is reserved for ejtag use only and should not be mapped to any other device currentlyembeddedperformanceincepiandgreenhillsincprovideejtagdebuggersandprobesfor the lx8000 information on these products is available at the following web sites epi inc httpwwwepitoolscom green hills inc httpwwwghscom lx8000 ejtag implements all required features of version 200 of the ejtag specification and includes support for the following features processor access of host via addressing of probe memory space host probe can dma directly into system memory or io devices hardware breakpoints on internal instruction and data busses singlestep execution mode realtime program counter trace debug exception and two new debug instructions one for raising debug exception via software and one for returning from debug exceptionmarch 29 2001 lx8000 lexra proprietary confidential 96 release 19 821 ieee jtagspeciﬁc pinout ieee jtag pins used by ejtag are shown below these are required for all ejtag implementations jtag_trst_n is an optional pin table 41 ejtag pinout table 42 ejtag ac characteristics1 table 43 ejtag synthesis constraints2 83 single processor pc trace the lx8000 ejtag includes support for realtime program counter trace pc trace when in pc tracesignal name direction description jtag_tdo_nr output serial output of ejtag tap scan chain jtag_tdi input serial input to ejtag tap scan chain jtag_tms input test mode select connected to each ejtag tap controller jtag_clock input jtag clock connected to each ejtag tap controller jtag_trst_n input tap controller reset connected to each ejtag tap controllera this pin is optional in multiprocessor conﬁgurations signal parameter condition min max unit jtag_clock frequency 1 40 mhz duty cycle 4060 6040 jtag_tms setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdi setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdo_nr outputdelaytckfallingedgetotdo 18v 0 7 ns 1 based on epi interface speciﬁcations for majictm and majicplus tmsignal name probe budget core budget slack remaining for other logic jtag_tdo_nr 0 to 7ns 115ns 135 to 205ns jtag_tdi 5ns 135ns 65ns jtag_tms 5ns 135ns 65ns 2 based on 25ns jtag clock periodmarch 29 2001 lx8000 lexra proprietary confidential 97 release 19 mode the lx8000 will serially output new value of the program counter whenever change in program control occurs ie context switch branch or jump instruction or an exception when the pc trace option is set to export in lconfig the following signals will be output from the lx8000 dclk pcst and tpc these are described in more detail in the following subsections the dclk output is used to synchronize the probe with the lx8000s sysclk the pcst pc trace status signals are used to indicate the status of program execution example status indications are sequential instruction pipeline stall branch or exception the tpc pins output the value of the pc every time there is change of program control 831 pc trace dclk debug clock the maximum speed allowed for the debug clock dclk output is 100mhz as an epi probe requirement as cores typically run in excess of this speed dclk can be set to divided down value of sysclk this is set by the dclk n parameter in lconfig which indicates the ratio of sysclk frequency to dclk 1 2 3 or 4 832 pc trace pcst program counter status trace theprogramcounterstatuspcstoutputcomprisesnsetsof3bitpcstvalueswherenisconfigurable as123or4via lconfigapcstvalueisgeneratedeverysysclkcyclewhendclkisslowerthanthe lx8000s sysclk up to n pcst values are output simultaneously changes in program flow caused by contextswitch are shown by the jmp pcst code in addition the pcst codes for the contextswitch jmp and its branchdelay slot seq are switched so that the branch delay slot will be shown first and any subsequent delay due to context being ready is shown by the stl stall pcst code this causes the following pcst output case1 context switch to immediate dispatch of another context case2 context switch with ready contextcntx pcst 1 foo1a seq 1 csw seq 1 foo1b jmp 2 foo2a seqjmpexp 2 foo2b cntx pcst 1 foo1a seq 1 csw seq 1 foo1b stl nvld stl jmp 2 foo2a seqjmpexp 2 foo2b seqmarch 29 2001 lx8000 lexra proprietary confidential 98 release 19 833 pc trace tpc target program counter the bus width of the target program counter tpc output is user configured in lconfig via the m parametertobeoneof124or8bitswhenchangeinprogramflowoccursthecurrentpcvalueissentout oftpcasthepcis32bitswidethenumberoftpcpinsaffectshowquicklythepcissentforexample if the tpc is 4 bits wide the pc will take 8 dclk cycles to be sent if another change in flow occurs while thepcofthepreviouschangeisbeingtransmittedthenewpcwillbesentandtheremainderoftheprevious pc will be lost the tpc bus also outputs the exception type when an exception occurs the exception type fieldwidth is either3or4bitsdependingonwhetherornotvectoredinterruptsarepresentthisiscoveredinmoredetail below toreducepinoutthetdooutputisusedfortheleastsignificantbitoftpcortheonlybitifmissetto1 834 singleprocessor pc trace pinout table 44 singleprocessor pc trace pinout table 45 singleprocessor pc trace ac characteristics1 835 vectored interrupts and pc trace the ejtag pc trace facility specifies 3bit code be output on the tpc output when an exception occurs thepcstpinsgivetheexpcodeinordertodistinguishtheeightvectoredinterruptsinthelx8000from all other exceptions 4bit code is used insteadsignal name io description jpt_tpc_dr m bitsopthe pc value is output on these pins when pcdiscontinuity occursa tpc0 is multiplexed with tdo in the singleprocessor pc trace solutionjpt_pcst_dr n3 bitsop pc trace status outputs current instruction type every dclk jpt_dclk op pcst and tpc clock frequency determined as fraction of sysclk via the n parameter maximum frequency of dclk is 100mhz signal parameter min max unit jtag_dclk frequency dc 100 mhz dclk high time 4 ns low time 4 ns tpc setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns pcst setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns 1 based on epi interface speciﬁcations for majictm and majicplus tmmarch 29 2001 lx8000 lexra proprietary confidential 99 release 19 for all exceptions otherthan vectored interrupts the most significant bit of the 4bit code is zero and the remaining 3bits are the standard 3bit code note that this includes the standard software and hardware interrupts numbered 0 through 7 for vectored interrupts the most significant bit is always 1 the 4bit code is simply the number of the vectored interrupt from 8 through 15 being taken since the target of the vectored interrupt is determined by the contents of the intvec register the debug softwarewhichmonitorstheejtagpctracecodesmustbeawareofthecontentsofthisregisterinorderto trace the code after the vectored interrupt is taken for probes that do not support 4bit exception code the lx8000 can be configured via the ejtag_xv_bits lconfig option to use only the 3bit standard codes in that case if vectored interrupt is taken the 3bit code for reset will be presented 836 demultiplexing of tdo and tdi during pc trace in normal ejtag pc trace tdi and tdo are multiplexed with the debug interrupt dint and the lsb of the tpc tpc0 when in pc trace mode this reduces the number of pins required by pc trace but has the unfortunate sideaffect of preventing any access to ejtag registers during pc trace in order to allow access to ejtag registers during pc trace and to facilitate pc trace in multiprocessor environments the lconfig option jtag_trst_is_tpcyes causes tdi and tdo to be demultiplexed suchthattrstisusedastpc0anddintisgeneratedviaejtagregistersnotesettingthisoptionmay require changes in ejtag probe hardware check with probe manufacturer for details 84 data break exceptions for lx8000 the existing ejtag data match architecture does not allow matches for some of the transaction types in the lx8000 this is described in more detail below 841 data break data matches on lbus split transactions databreakmatchesaddressandordataonlbussplittransactionsarenotsupportedsuchtransactionsare generated by any contextswitch instruction csw instructions 842 data breaks on write descriptor accesses data breaks on the address or data of write descriptor all wd instructions accesses are not supported 843 support for the loadtwin instruction data matches on the loadtwin instruction are supported the 32bit entry in the data value break register willbecomparedtobothhalvesofthe64bitdatareturnedbythisinstructionthereforeanymaskingofthe data byte lanes must be copied from bits 74 byte lane mask30 to bits 118 in the data break control register to ensure the same mask is applied across both words returnedmarch 29 2001 lx8000 lexra proprietary confidential 100 release 19 march 29 2001 lx8000 lexra proprietary confidential 101 release 19 appendix lx8000 lconﬁg forms a1 conﬁguration options for the lx8000 packet processor this section provides summary of the configuration options available with lconfig refer to lconfigforms for detailed description of these form options product lexra processor name product_type indicates product type technology identifies target technology testbed_env identifies simulation testbed environment type reset_type flipflop reset method reset_dist reset distribution method sleep include clock sleep support reset_buffers reset buffers at toplevel module clock_buffers clock buffers at toplevel module ram_clock_buffers lmi ram clock distribution method cop1 coprocessor interface 1 cop2 coprocessor interface 2 cop3 coprocessor interface 3 ce0 custom engine 0 ce1 custom engine 1 m16_support 16bit opcode support mem_line_order cache line fill beat ordering mem_first_word cache line fill first word mem_granularity main memory system partial word write support system_interface system bus interface type wdesc_addr write descriptor upper address bits lbc_wbuf lexra bus controller write buffer depth lbc_rbuf lexra bus controller read buffer depth lbc_rdbypass lexra bus controller read bypass enable lbc_sync_mode lbc synchronousasynchronous selection line_size cache line size in words icache instruction cache size dcache data cache size imem local instruction ram with line valid bits irom local instruction rom dmem_width local scratch pad data memory width dmem local scratch pad data ram lmi_data_granularity dcache and dmem write granularity lmi_range_source source of lmi address ranges lmi_ram_arb allow external agents to arbitrate for lmi rams jtag internal jtag tap controller with ejtag support ejtag ejtag debug support ejtag_inst_break number of instruction breaks to be compiled ejtag_data_break number of data breaks to be compiled jtag_trst_is_tpc trst pin is tpc out instead of tdotpc mux pc_trace ejtag pc trace pins ejtag_dclk_n ejtag pctrace dclk n parameter ejtag_tpc_m ejtag pctrace tpc m parameter ejtag_xv_bits ejtag pctrace number of exception vector bits ejtag_pc_isabit ejtag pctrace include isa as pc bit0 scan_insert controls scan insertion and synthesismarch 29 2001 lx8000 lexra proprietary confidential 102 release 19 scan_mix_clocks scan chains can cross clock boundaries with lockup latches scan_num_chains number of scan chains scan_scl scan collar insertion on ram interfaces sen_dist scan enable distribution method sen_buffers scan enable buffering ram_bist_mux include test ram mux and ports thread_scheduler location of thread scheduler contexts number of contexts threads in the processormarch 29 2001 lx8000 lexra proprietary confidential 103 release 19 appendix b lx8000 port descriptions all ports must be connected to valid logiclevel sources the timing information indicates the point within cycle when the signal is stable in terms of percent the timing information also includes parenthetical references to these notes 1 clocked in the jtag_clock domain 2 clocked in the busclk domain if crossbar or lbc are asynchronous otherwise clocked in the sysclk domain 3 does not require constraint eg clock 4 false path eg conﬁguration input tied to constant 5 timing is speciﬁed with symbol in techvarsscr script eg ram timing thetablebelowshowstheportconnectionsforthetoplevelmoduleofthelx8000processorknownaslx2 the timing information and notes have the same meaning as for the previous table table 46 lx8000 processor port summary port name io timing description clocking reset interrupts and control sysclk input 3 processor clock resetn input 4 warm reset or reset button cresetn input 4 cold reset or power on reset_d1_r_n input 4 sysclk domain reset combination of resetn cresetn ejtag reset_d1_br_n input 4 busclk domain reset combination of resetn cresetn ejtag reset_pwron_c1_n input 4 power on reset copy for jtag reset_pwron_d1_lr_n input 4 sysclk domain power on reset for ejtag reset_d1_r_n_o output 30 sysclk domain reset combination of resetn cresetn ejtag reset_d1_br_n_o output 30 2busclk domain reset combination of resetn cresetn ejtag reset_pwron_c1_n_o output 30 power on reset copy for jtag reset_pwron_d1_lr_n_o output 30 sysclk domain power on reset for ejtag intreq_n152 input 4 interrupt requests ext_halt_p input 50 external stall line conﬁgurationmarch 29 2001 lx8000 lexra proprietary confidential 104 release 19 cfg_tlb_disable input 4 disable tlb mappings even if pop_tlb cfg_sleepenable input 4 sleep enable conﬁguration cfg_rad_lexop50 input 4 lexop encoding must be 011111 for lx8000 cfg_rad_disable input 4 lexop disable conﬁguration must be zero for lx8000 cfg_singleissue input 4 single issue mode conﬁguration must be zero for lx8000 cfg_hlenable input 4 strap to one to enable internal hilo registers cfg_macenable input 4 strap to one to enable internal mac if present cfg_memsequential input 4 strap to one if line reads return words in sequential order zero if interleave order cfg_memzerofirst input 4 strap to one if line reads return word zero ﬁrst zero if desired word ﬁrst cfg_memfullword input 4 strap to one if main memory must be written with 32bit words zero if byte and halfword writes are allowed cfg_lbcwbdisable input 4 strap to one to disable read bypass of lbc write buffer zero to allow read bypass cfg_procnum70 input 4 strapped with processor number cfg_ejtnminus110 input 4 strap with ejtag dclk n minus 1 conﬁguration 0314 cfg_ejtmlog210 input 4 strap with ejtag m log2 031248 conﬁguration cfg_ejt3bitxvtpc input 4 strap with etjag 3bit tpc conﬁgura tion cfg_ejtbit0m16 input 4 strap with ejtag pc bit0 in tpc ﬁguration cfg_dwbase3110 input 4 strapped with dmem base address conﬁguration value cfg_dwtop2310 input 4 strapped with dmem top address ﬁguration value cfg_iwbase3110 input 4 strappedwithimembaseaddresscon ﬁguration value cfg_iwtop2310 input 4 strapped with imem top address ﬁguration value cfg_iwrom input 4 straptoonetotreatimemlikearom note new applications should use irom instead of romlike imemport name io timing descriptionmarch 29 2001 lx8000 lexra proprietary confidential 105 release 19 cfg_iroff input 4 strap to one to disable irom cfg_dwdisw input 4 strap to one to disable processor dmem writes must be zero for lx8000 cfg_ejdis input 4 must be strapped to zero test and debug jtag_reset_o output 20 1 jtag is in testlogicreset state jtag_reset input 4 jtag is in testlogicreset state tap_reset_n_o output 20 1 tap controller reset tap_reset_n input 4 tap controller reset jtag_tdo_nr output 50 1 test data out jtag_tdi input 60 1 test data in jtag_tms input 60 1 test mode select jtag_clock input 3 test clock jtag_trst_n input 4 test reset ejc_ecrprobeen_r output 30 one indicates ejtag probe is active jtag_capture output 201 jtag is in data register cap ture state jtag_scanin output 501 scan input to chain jtag_scanout input 501 scan output from chain jtag_ir40 output 201 contents of instruction regis ter jtag_shift_ir output 201 jtagisinshiftinstructionreg ister state jtag_shift_dr output 201 jtag is in shift data register state jtag_runtest output 201 jtag is in runtest state jtag_update output 201 jtag is in data register update state sen input 4 scan enable tmode input 4 test mode pins sink0 input 4 scan input k can range from 7 to 0 soutk0 output 4 scan output k can range from 7 to 0port name io timing descriptionmarch 29 2001 lx8000 lexra proprietary confidential 106 release 19 rbc_sel70 input 4 ram bist ram select code 10000000 instruction mem 01000000 data mem 00100000 dcache data store 00010000 dcache tag store 00001000 icache tag store set 1 00000100 icache inst store set 1 00000010 icache tag store set 0 00000001 icache inst store set 0 rbc_wek0 input 4 rambistwriteenablewherekis1 for word write granularity 7 for byte write granularity rbc_re input 4 ram bist read enable rbc_cs input 4 ram bist select rbc_addr150 input 4 ram bist address rbc_datawr630 input 4 ram bist write data rbm_datard630 output 4 ram bist read data data ram dma access dmadw_rclk input 3 data ram dma clock dmadw_dataindex174 max input 5 data ram dma address dmadw_datard630 output 5 data ram dma read data 128bit interface is optional dmadw_datawr630 input 5 data ram dma write data 128bit interface is optional dmadw_datacs input 5 data ram dma chip select dmadw_datacsn input 5 data ram dma chip select active low dmadw_datare input 5 data ram dma read enable dmadw_dataren input 5 data ram dma read enable active low dmadw_datawek0 input 5 data ram dma write enable where k is 3 for word write granularity 15 for byte write granularity dmadw_datawenk0 input 5 data ram dma write enable active low where k is 3 for word write gran ularity 15 for byte write granularity lbc interface to lbus or crossbar laddro310 output 2 20 address lcmdo80 output 2 20 output command ldatao630 output 2 20 output data ldatai630 input 2 50 input data lirdyo output 2 20 initiator readyport name io timing descriptionmarch 29 2001 lx8000 lexra proprietary confidential 107 release 19 lirdyi input 2 30 other initiators ready lframeo output 2 20 transaction frame lframei input 2 30 frame from other initiators lseli input 2 30 slave select ltrdyi input 2 30 target ready lgtido150 output 2 20 lbc global thread id lgtidi150 input 2 30 lbus global thread id xbrdvld input 2 30 crossbar read data valid xbrdsize input 2 30 split read data size spltrdfull output 2 30 read data queue full lid output 2 20 instructiondata luc output 2 20 bus request lcoe90 output 2 20 command output enable ltoe output 2 20 transaction output enable ldoe70 output 2 20 data output enable lreq output 2 50 bus request lgnt input 2 30 bus grant shared ram requestgrant interface ext_iwreqram_r input 30 external hardware drives to one to request access to imem iw_gntram_r output 30 cpu drives to one to grant external imem access request ext_dwreqram_r input 30 external hardware drives to one to request access to dmem dw_gntram_r output 30 cpu drives to one to grant external dmem access request ext_icreqram_r input 30 external hardware drives to one to request access to icache ic_gntram_r output 30 cpu drives to one to grant external icache access request ext_dcreqram_r input 30 external hardware drive to one to request access to dcache dc_gntram_r output 30 cpu drives to one to grant external dcache access request coprocessor interface czcondin input 80 cop branch ﬂag czrd_addr40 output 50 cop read addressport name io timing descriptionmarch 29 2001 lx8000 lexra proprietary confidential 108 release 19 czrhold output 45 cop hold condition one stalls copro cessor czrd_gen output 50 cop general register read command czrd_con output 50 cop control register read command czrd_data310 input 80 cop read data czwr_addr40 output 20 cop write address czwr_gen output 20 cop general register write command czwr_con output 20 cop control write address command czwr_data310 output 30 cop write data czinvld_m output 60 cop invalid instruction ﬂag one indi cates invalid instruction in m stage czxcpn_m output 60 cop exception ﬂag one indicates exception in m stage czrd_cntx20 output 40 cop read context number czwr_cntx20 output 30 cop write context number c3cnt_iparet output 20 count instructions retired pipe c3cnt_ipbret output 20 count instructions retired pipe b c3cnt_ifetch output 20 count instruction fetches c3cnt_imiss output 20 count icache misses c3cnt_istall output 20 count icache stalls c3cnt_dmiss output 20 count dcache misses c3cnt_dstall output 20 count dcache stalls c3cnt_dload output 20 count data load operations c3cnt_dstore output 20 count data store operations event control and thread observation ext_clearwtevnt_rn8 10input 30 clear status wait event bits where n is the number of contexts cx_stusthwait_rn10 output 30 bits set to one indicate which contexts arewaitingforeventswherenisthe number of contexts cx_threadactv_rn10 output 30 abitsetoneindicateswhichcontextif anyisactivewherenisthenumber of contexts ext_nxtcntx_p_r20 input 30 external scheduler next context ext_nextcntxrdy_p_r input 30 external scheduler next context is ready cx_stusthprio_rn310 output 30 thread priority statusport name io timing descriptionmarch 29 2001 lx8000 lexra proprietary confidential 109 release 19 block transfer engine rxtz_ctl_r input 30 receive tbus control 1control beat 0data beat rxtz_data_r630 input 30 receive tbus data rxtz_rdy_r output 30 asserted when new receive descriptor is available txtz_rdy_r input 30 asserted when transmit scheduler is ready to accept transmit data txtz_incseq_r input 30 asserted when transmit scheduler wants btes to increment their sequence number txtz_done_r input 30 asserted when tbus will be idle in the next cycle txtz_busy_r output 30 asserted when the bte is transmitting data deasserted 2 cycles before ﬁn ishing txtz_ctl_r output 30 transmit tbus control 1control beat 0data beat txtz_data_r630 output 30 transmit tbus dataport name io timing descriptionmarch 29 2001 lx8000 lexra proprietary confidential 110 release 19 march 29 2001 lx8000 lexra proprietary confidential 111 release 19 appendix c lx8000 pipeline stalls this section documents stall conditions that may arise in the lx8000 c1 stall deﬁnitions issue stall an invalid instruction enters the pipe while any other valid instructions in the pipe advance pipeline stall all instructions in either pipe stay in the same stage and do not advance stall if not otherwise qualified means pipeline stall c2 instruction groupings these instruction groupings are used to describe stall conditions that are based on the type of instructions in the pipeline table 47 instruction groupings for stall deﬁnition c3 nonsequential program flow issue stall jr jalr two issue stalls after the delay slot instruction j jal and taken branches stall cycles after the delay slot instruction nottaken branches two issue stalls after the delay slot instruction the branch rules are consequence of the fact that all branches are predicted to be takengroup name instructions in group miloadstore lb lh lw lbu lhu lwc1 lwc2 lwc3 sb sh sw swc1 swc2 swc3 micontrol j jalx jr jalr bltzal bgezal linked branches syscall break all copz mfcz cfcz mtcz ctcz bcfz bctz rfe lwcz swcz also in loadstore group miunlinkedbranch beq bne blez bgtz bltz bgez migeneral all remaining instructions mivcmove movz movn ejtagcontrol deret sdbbp m16sdbbpmarch 29 2001 lx8000 lexra proprietary confidential 112 release 19 c4 load subword stall load instructions which have byte or halfword operands always cause onecycle stall c5 storeload stall load instruction which follows store instruction by one cycle causes onecycle stall if the store instruction hits in the dcache or has byte or halfword operand c6 storeany storesubword stall if the lx8000 is configured to work with rams that have word write granularity store instruction which has byte or halfword operand and which follows any store instruction by one cycle always causes onecycle stall alternatively the lx8000 can be configured to work with rams support byte write granularity which eliminates the stall c7 loadstore ops stall matrix thefollowingtablesummarizesthestallrulesrelatedtoloadandstoreinstructionsdescribedaboveinthis table the 2nd op refers to an instruction which issues in the cycle after the 1st op table 48 loadstore ops stall matrix notes means stalls xu indicates unconditional stall for the indicated number of cycles xs indicates stall only if 2ndop source 1stop loadtarget xw indicates stall if data rams have wordwrite granularity c8 mvcz stall the coprocessor move instructions lwcz mtcz mfcz and mtlxc0 mflxc0 are always followed by single cycle issue stall c9 immu stall whentheprogramjumpsbranchesorincrementsbetweenthetwomostrecentlyusedpagesasinglecycle stall is incurred when the program jumps branches or increments to third page twocycle stall is incurred1st op 2nd op lw lt milbulhu sb sh sw non loadstore 1u lw lbu lhu 1u 1w 1u sb sh 1u 1w 1u sw 1u march 29 2001 lx8000 lexra proprietary confidential 113 release 19 c10 immu issue stall whenanimmustalloccursduetoincrementingacrossapageboundaryandthereisanyofthefollowing instructionsfoundanywhereinthelastdoublewordofthepagethenthereisoneissuestallinadditiontothe immu stalls branch of any kind j jal ejtag dret c11 icache miss stall when an instruction cache miss occurs the processor is stalled for the duration of the cache line fill operation the number of cycles required to complete the line fill is system dependent c12 dcache miss stall when data cache miss occurs as the result of load instruction the processor stalls while it waits for the data the data cache releases the stall condition after the required word is supplied to the processor even if additionalwordsmuststillbefilledintothedatacachehoweveriftheprocessorissuesanotherloadorstore operation to the data cache while the remainder of the line fill is in progress the cache will again stall the processor until the line fill operation is completed whenadatacachemissoccursasaresultofaloadbyteorloadhalfwordtheprocessorstallsfortheduration of the cache line fill operation the number of cycles required to complete the line fill is system dependent c13 pipeline timing diagrams for stalls c131 nonsequential program flow issue stalls jrjalr jr i d s m w delayslot i d s m w notvld i notvld i target i d s j jal and taken branches j i d s m w delayslot i d s m w target i d s mmarch 29 2001 lx8000 lexra proprietary confidential 114 release 19 nottaken branches bntkn i d s m w delayslot i d s m w notvld i notvld i delay4 i d s c132 load subword stall lb i d s m m w foo2 i d s m w foo4 i d s s m w rhold x c133 storeload stall sw s04a0 i d s m w lw s20a0 i d s m m w foo3 i d s m w rhold x c134 storeany store subword stall sw s04a0 i d s m w sb s20a0 i d s m m w foo3 i d s m w rhold x sh s04a0 i d s m m w sb s20a0 i d s m m w foo2 i d s s m w rhold x x c135 mvcz stall mtc0 i d s m w foo i d d s m w foo1 i d s m w c136 lwcz stall lwc0 i d s m w foo i d d s m w foo1 i d s m wmarch 29 2001 lx8000 lexra proprietary confidential 115 release 19 c137 icache miss stall foo0 i d s m m m m m m w foo2 i d s m w foo4 i d i d s m w rhold x x x x x c138 dcache miss stall lw i d s m w foo2 i d s m m m m m w foo4 i d s m w rhold x x x xmarch 29 2001 lx8000 lexra proprietary confidential 116 release 19