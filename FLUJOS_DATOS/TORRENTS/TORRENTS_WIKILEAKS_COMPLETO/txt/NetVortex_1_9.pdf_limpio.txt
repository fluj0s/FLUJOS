netvortex data sheet lexra inc release 19 april 2 2001 lexra proprietary and conﬁdentialapril 2 2001 netvortex lexra proprietary confidential 2 release 19 netvortex data sheet revision 13 for rtl release 19 this document is proprietary and confidential to lexra inc copyright 2001 lexra inc all rights reserved mips mips16 mips abi mipsii mipsiv mipsv mips32 r3000 r4000 and other mips common law marks are trademarks andor registered trademarks of mips technologies inc lexra inc is not associated with mips technologies inc in any way smoothcore radiax and netvortex are trademarks of lexra incapril 2 2001 netvortex lexra proprietary confidential 3 release 19 table of contents 1 netvortex product overview 9 11 introduction 9 12 key features 10 13 lx8000 processor overview 12 14 netvortex system overview 14 15 system level building blocks 15 151 smmu 16 152 local memory interface 16 153 coprocessor interface 16 154 custom engine interface 16 155 lexra bus controller 16 156 block transfer controllers 17 157 crossbar device interfaces 17 158 device management interface 17 159 building block integration 17 16 rtl core smoothcore 17 17 eda tool support 18 2 lx8000 architecture 19 21 hardware architecture 19 211 module partitioning 19 212 six stage pipeline 20 22 ralu data path 20 23 system control coprocessor cp0 20 24 highperformance context switch 21 241 new context registers 21 242 reset 23 243 determining the number of contexts in software 24 244 initiation of context switch 24 245 csw instruction 24 246 lwcsw ltcsw and lqcsw instructions 24 247 wdcsw instructions 25 248 wdlwcsw wdltcsw and wdlqcsw instructions 25 249 pipeline 25 2410 new thread selection 26 2411 example context switch for coprocessor operation 27 2412 program access to new registers 28 2413 exceptions 29 25 lowoverhead prioritized interrupts 29 3 lx8000 risc programming model 31 31 summary of mipsi instructions 31 311 alu instructions 31 312 load and store instructions 32 313 conditional move instructions 33 314 branch and jump instructions 33 315 control instructions 34 316 coprocessor instructions 35 32 opcode extension using the custom engine interface cei 35april 2 2001 netvortex lexra proprietary confidential 4 release 19 321 cei operations 35 322 interface signals 36 33 memory management 37 34 exception processing 37 341 exception processing registers status cause epc badvaddr 39 342 exception processing entry and exit 40 35 the coprocessor interface ci 40 4 lx8000 instruction extensions 41 41 context switch and data transfer operations 41 42 bit field processing operations 44 43 cross context access operations 52 44 checksum addition 53 45 lx8000 instruction summary and encoding 54 451 lx8000 instruction formats 56 452 load formats 57 453 write descriptor formats 57 454 context checksum and bit field formats 58 455 cross context move format 59 456 lexracoprocessor0 register access instructions 59 457 lexra subop bit encodings 60 5 lx8000 local memory 61 51 local memory overview 61 52 cache control register cctl 61 53 instruction memory imem lmi 62 54 scratch pad data memory dmem lmi 63 6 lx8000 coprocessor interface 65 61 attaching coprocessor using the coprocessor interface ci 65 62 coprocessor interface ci signals 65 63 coprocessor write operations 66 64 coprocessor read operations 66 65 coprocessor interface and pipeline stages 67 651 pipeline holds 67 652 pipeline invalidation 67 7 lx8000 ejtag 69 71 introduction 69 72 overview 69 721 ieee jtagspecific pinout 70 73 single processor pc trace 71 731 pc trace dclk debug clock 71 732 pc trace pcst program counter status trace 71 733 pc trace tpc target program counter 71 734 singleprocessor pc trace pinout 72 735 vectored interrupts and pc trace 72 736 demultiplexing of tdo and tdi during pc trace 73 74 multiprocessor ejtag 73 741 connectivity requirements 73 742 multiprocessor pc trace using internal trace buffers 73 8 netvortex crossbar interconnect 75 81 processortodevice paths 76april 2 2001 netvortex lexra proprietary confidential 5 release 19 82 devicetoprocessor paths 78 83 bandwidth and latency 79 84 crossbar port configuration 81 85 address decoding 81 851 memory mapped devices 82 852 write descriptor devices 82 853 address error handling 82 86 arbitration 83 87 asynchronous interface 83 88 queue depths 83 89 instruction ram fill 83 810 device management interface 83 8101 dmi read and write request interface 83 8102 dmi request waveforms 85 8103 dmi split read data interface 86 8104 dmi read data waveforms 87 811 direct fifo interface for devices 88 8111 device request interface 89 8112 device request waveforms 90 8113 device read data interface 91 8114 device read data waveforms 92 9 netvortex test and set engine 95 91 semaphore addressing 95 92 single word read basic test and set 95 93 single word splitread enqueue and wait for semaphore free 95 94 single word write dequeue wait or clear semaphore 95 95 ram requirements for semaphore queues 96 96 semaphore usage for critical code section 96 97 semaphore usage for cross processor wait and post 97 98 initialization 98 10 netvortex block transfer subsystem 99 101 overview 99 102 block transfer buffers and transfer descriptors 100 103 example transaction flow 102 104 detailed description of block transfer modules 103 1041 block transfer engine 103 1042 rx and tx block transfer controllers 104 1043 utopia level 4 rx and tx interfaces 105 appendix anetvortex lconfig forms 107 a1 introduction 107 a2 packet processor unit 107 a3 four processor tile with level 1 crossbar 107 a4 memorymapped crossbar device 108 a5 writedescriptor crossbar device 108 a6 test and set engine crossbar device 109 a7 netvortex system with level 2 crossbar 109 a8 general form notes 109 a9 example netvortex form 110 a10 configuration options for the lx8000 packet processor 112 a11 configuration options for memorymapped devices 113april 2 2001 netvortex lexra proprietary confidential 6 release 19 a12 configuration options for the test set engine 113 a13 configuration options for writedescriptor devices 114 a14 configuration options for the crossbar 114 appendix bnetvortex port descriptions 115 appendix c lx8000 pipeline stalls 127 c1 stall definitions 127 c2 instruction groupings 127 c3 nonsequential program flow issue stall 127 c4 load subword stall 128 c5 storeload stall 128 c6 storeany storesubword stall 128 c7 loadstore ops stall matrix 128 c8 mvcz stall 128 c9 immu stall 128 c10 immu issue stall 129 c11 icache miss stall 129 c12 dcache miss stall 129 c13 pipeline timing diagrams for stalls 129 c131 nonsequential program flow issue stalls 129 c132 load subword stall 130 c133 storeload stall 130 c134 storeany store subword stall 130 c135 mvcz stall 130 c136 lwcz stall 130 c137 icache miss stall 131 c138 dcache miss stall 131april 2 2001 netvortex lexra proprietary confidential 7 release 19 list of tables table 1 eda tool support18 table 2 cp0 registers21 table 3 context status register detail23 table 4 scheduler ports27 table 5 prioritized interrupt exception vectors30 table 6 alu instructions31 table 7 load and store instructions32 table 8 conditional move instructions33 table 9 branch and jump instructions33 table 10 control instructions34 table 11 coprocessor instructions35 table 12 custom engine interface operations36 table 13 custom engine interface signals36 table 14 smmu address mapping37 table 15 list of exceptions38 table 16 context switching instructions41 table 17 bit field processing instructions45 table 18 hash instruction key bit definition50 table 19 cross context access instructions52 table 20 checksum addition instructions 53 table 21 instruction summary54 table 22 lexra subop bit encoding60 table 23 local memory interface modules61 table 24 imem configurations62 table 25 imem ram interfaces63 table 26 dmem configurations63 table 27 dmem ram interfaces64 table 28 coprocessor interface signals65 table 29 ejtag pinout70 table 30 ejtag ac characteristics70 table 31 ejtag synthesis constraints70 table 32 singleprocessor pc trace pinout72 table 33 singleprocessor pc trace ac characteristics72 table 35 dmi request signals84 table 36 dmi split read data signals86 table 37 device request signals89 table 38 device read data signals91 table 39 semaphore engine ram requirements96 table 40 block transfer descriptor101 table 41 btc reserved fields in transfer buffer102 table 42 receive port signals105 table 44 lconfig block types107 table 45 memory mapped device address masks108 table 46 netvortex top level port summary115 table 47 lx8000 singleprocessor port summary119 table 48 instruction groupings for stall definition127 table 49 loadstore ops stall matrix128april 2 2001 netvortex lexra proprietary confidential 8 release 19 list of figures figure 1 netvortex lx8000 processor overview13 figure 2 netvortex system overview14 figure 3 processor core module partitioning19 figure 4 context associated registers22 figure 5 insert and extract operations straddle case45 figure 6 packet field compaction with variable alignment49 figure 7 construction of chained tap controllers for multiprocessor ejtag73 figure 8 crossbar for 16 processors and dmi to 6 devices77 figure 9 crossbar for 6 devices to 16 processors and dmi79 figure 10 processor to device transaction flow80 figure 11 device to processor transaction flow81 figure 12 single dmi request without grant delay85 figure 13 single dmi request with grant delay86 figure 14 back to back dmi requests without delay86 figure 15 multiple back to back dmi requests with grant delay86 figure 16 single dmi read data response without delay87 figure 17 single dmi read data response with busy delay88 figure 18 back to back dmi read data response without delay88 figure 19 back to back dmi read data response with busy delay88 figure 20 single request enqueue90 figure 21 back to back request enqueue90 figure 23 single split read return92 figure 24 rddequeue delay92 figure 25 back to back split read responses without rddequeue delay93 figure 26 back to back split read responses with rddequeue delay93 figure 27 organization of the block transfer controller100april 2 2001 netvortex lexra proprietary confidential 9 release 19 1 netvortex product overview 11 introduction thisdatasheetdescribesnetvortexascalablemultiprocessorarchitecturedevelopedspecificallyforusein network communications systems netvortex employs lexras lx8000 processor and incorporates significant architectural features to support emerging network communications applications multi processor ic based on netvortex can perform ip routing and classification tasks at data rates up to oc192 30m packetssecond the lx8000 is based on lexras lx4189 processor complete mips r3000class processor subsystem developedforeaseofintegrationseefigure1onpage13themajorsubsystemsarethecpucorelocal memory interfaces lmi and lbus controller lbc the technology includes an optional interface to customerdefined coprocessor ci2 and optional customer extensions to the mips isa custom engine the local instruction memories and data memories may include caches and fixed ram the sizes are configurable the figure also highlights the lx8000 multicontext register file to support fast context switching additional lx8000 extensions include new bitfield operations for efficient packet header processingandablocktransferenginebteattachedtoadedicatedramportthatisusedinnetvortex for background data transfers network communications systems are characterized by demanding realtime performance requirements typicallysystemdesignershaveaddressedtheserequirementswithcustomasicsofftheshelfprocessors and plds the explosive growth in the size and bandwidth of the internet has recently stimulated semiconductorcompaniestodevelopanewtypeofproductcalledanetworkprocessorunitnputoserve these applications these ics incorporate multiple programmable cores and specialized peripherals compared to asic development npus offer the system designer faster timetomarket and flexibility to implementdifferentiatedservicesinsoftwarecomparedtogeneralpurposeofftheshelfcomponentsnpus offerthepromiseoflowercostandsuperiorperformancethrougharchitecturalspecializationnetvortexisa scalable multiprocessor with the specialized architectural features needed for highperformance packet processing for wide variety of new products the time required to process packets for ip routing and classification is dominated by long latency operationssuchastablelookupsfromlargememoriesandbufferaccesseshoweveradistinguishingfeature of network communications systems is that subsequent packets are readily available for independent processingthereforeafastcontextswitchcanbeexploitedtohidethememorylatencynetvortexincludes configurable number 18 of general register sets and program counters along with instructions for fast context switching this enables multiple software threads to efficiently execute on single processor thread is deactivated under software control either i unconditionally ii when load with context switch instruction is coded for long latency load or iii when command is written to shared system device following context switch the cpu activates new thread from the pool of ready threads the context switch does not introduce stall cycles because the new thread has an independent general register set it can quickly resume processing to avoid stalling the new thread while the previous threads data transfer completes the lx8000 incorporates block transfer engine bte connected to each processors data memory for the transfer of packet data in addition the memory system is nonblocking permitting local accesses and cache hits to operate in parallel with one outstanding global access per context with this architecture context switches may be used frequently to achieve optimal performance packetprocessingalsorequiresfrequentaccesstobitfieldsinthepacketheaderthatarenotbytealignedfor thisreasonnetvortexhasextendedthemipsinstructionsetarchitectureisatoincludeacompletesetof bitfield operations for field extract insert set and clear deterministic allocation of realtime is another importantprobleminnetworkcommunicationssoftwarethisproblemiscompoundedbymultiprocessing for this reason the lx8000s configuration options include dedicated uncached local instruction and data memories for realtime critical instructions and data in order to avoid cache miss penaltiesapril 2 2001 netvortex lexra proprietary confidential 10 release 19 atypicalsystemdesignbasedonnetvortexisillustratedinfigure2onpage14whichshows16processors that include local instruction and data storage not shown high bandwidth crossbar connects the processors to shared devices such as tcams srams and custom logic device management interface allows an applicationspecific management processor to access the shared devices netvortexprovidestwooptionalperipheralsthetestandsetengineandtheblocktransfercontrollerthe test and set engine attaches to the crossbar and supports up to 32 unique semaphores these semaphores maybeusedtocontrolaccesstoresourcessharedamonganyoftheprocessorsandcontextsthathaveaccess to the semaphores the block transfer controller is connected to dedicated port of each processors data memory and transfers packet data over dedicated busses to external ports ic designs using netvortex can costeffectively support wide spectrum of network communications systems netvortexemployslexraslx8000packetprocessorwhichisanextensionlexraslx4189processorthe lx8000 incorporates the lx4189s 6stage risc pipeline as result netvortex can achieve high system clock performance in portable cellbased design the 6stage pipeline also decouples customer configurable rams from critical paths internal to the core because the lx8000 packet processor executes the mips i instruction set1 wide variety of third party software tools are available including compilers operating systems debuggers and incircuit emulators lexraalsosuppliesassemblerextensionsandacycleaccurateinstructionsetsimulatorissprogrammers mayuseofftheshelfccompilersforinitialcodingthenreplaceperformancecriticalcodewithoptimized assembler code this data sheet describes the base lx4189 processor as well as lx8000 extensions to the lx4189 the remaining sections of this data sheet describe hardware and instructions that support context switching section2 the general risc programming model section3 lx8000 instruction extensions including instructionsforcontextswitchandbitfieldprocessingsection4processormemoryinterfacessection5 coprocessorinterfacessection6embeddeddebugsupportsection7thenetvortexcrossbarinterconnect betweenprocessorsandshareddevicesandthedeviceinterfaceprotocolsection8theoptionalnetvortex test and set engine section9 and the optional netvortex block transfer controller section10 12 key features complete packet processor subsystem executes mips i isa except unaligned loads stores extensive thirdparty tool support highperformance 6stage pipeline local instruction memory configurable sizes local data memory configurable sizes memory interface logic included crossbar interface to access system devices split read transactions over crossbar interface optional customerdefined coprocessor optional customerdefined instruction extensions support ejtag draft 20 with extensions for multithread debugging 1 unaligned load and store instructions are not supported in hardware or softwareapril 2 2001 netvortex lexra proprietary confidential 11 release 19 highperformance context switch processor provides 18 contexts the number is customerconfigurable independent program counter status and general registers for each context wasted cycles for context switch context switch initiated by program thread reactivation based on completion of data transfer asynchronous external events or program control block transfer controller performs block transfer between processors and external interfaces supports one or two utopia4 receivetransmit pairs at 415 mhz 32 bits fully integrated with each processors local data ram can handle up to 4 simultaneously active transfers internal busses move up to 256 bits of data per cycle internal data bandwidth is 115 gbitss at 450 mhz maintains packet ordering bitfield instructions singlecycle extract set clear twocycle extractandinsert with source fields that may span two registers dual 16bit ones complement add for checksum supports up to 16 lx8000 packet processing engines highspeed risc cpus optimized for packet processing applications 16processor system provides performance of 7200 mips at 450 mhz can process all seven networking protocol layers crossbar bus architecture high bandwidth transfer paths between processors and shared devices such as srams and tcams 288 gbitss of read bandwidth and 288 gbitss of write bandwidth per device at 450 mhz 288 gbitss of read bandwidth and 144 gbitss of write bandwidth per processor at 450 mhz the test set engine optional crossbarattached device supplies up to 32 unique semaphores controls access to shared resources portable rtl model available as synthesizable rtl portable to any 025 µm 018µmor 015µm logic and sram process foundry partners include ibm tsmc and umcapril 2 2001 netvortex lexra proprietary confidential 12 release 19 optional hard macro model sizteen processors each with 4 contexts 16kb imem 16kb dmem block transfer controller tsmc 015 µm results typical process worst case operating conditions clock 450 mhz area 64 mm2 power 68 w easy asic design single phase clocking fully synchronous design easy to interface system bus protocol supports popular eda tools easy rtl customization userconfigurable local memory reset method clock distribution userconfigurable ejtag breakpoints over 30 other configuration options interfaces for adding applicationspecific instructions ultimate scalability single lx8000 processor for soho vpn for example up to 16 lx8000 processors for an oc192 router ejtag debug optional extension the ejtag 200 specification supports multiprocessor and multicontext environment for onchip debug development tools available from third party suppliers supporting the mips architecture includes industry leaders green hills software embedded performance inc and wind river systems 13 lx8000 processor overview thelx8000isariscprocessorthatexecutesthemipsiinstructionset1alongwithlexrasinstructionset extensionshowevertheclockingpipelinestructurepinoutandmemoryinterfaceshaveallbeendesigned by lexra to reflect systemonsilicon design needs deep submicron process technology as well as design methodology advances 1 the mips unaligned load and store instructions lwl lwr swl swr are not supportedapril 2 2001 netvortex lexra proprietary confidential 13 release 19 the figure below shows the structure of the lx8000 processor as used in netvortex figure 1 netvortex lx8000 processor overview mipsisaexecution thelx8000supportsthemipsiprogrammingmodeltwosourceoperandscanbe supplied and one destination update performed per cycle the second operand is either register or 16bit immediatetheinstructionsetincludesawideselectionofaluoperationsexecutedbytheralulexras proprietary register based alu the ralu also generates memory addresses for 8bit 16bit and 32bit register loads from stores to memory by adding register base to an immediate offset branches are based on comparisons between registers rather than flags and are therefore easy to relocate optional links following jump or branch instructions assist with subroutine programming the mips unaligned load and store instructions are not supported because they represent poor price performance tradeoff for embedded applications their absence does not affect the software programming model isa extensions for network processing lexra has added 32 new instructions to the lx8000 to optimize forhighperformancepacketprocessingbitfieldoperationsareincludedtoacceleratelookupkeyformation used in packet classification specialized hash functions table lookup instructions and onescomplement addition are also included many of the new instructions are used to facilitate highspeed data movement fundamental to network communications64bitscanbeloadedfromlocaldataramintoageneralregisterpairinasinglecycleup to128bitscanbetransferredfromsharedmemorybyasingleinstructionthelexraextensionsalsosupport atomicreadmodifywriteoperationsonthesharedmemorieslatenciesinaccesstosharedmemoryonchip or offchip can be hidden using zerooverhead switch between the eight independent hardware contexts pipeline lx8000 instructions are executed by sixstage pipeline that has been designed so that all transactions internal to the lx8000 as well as at the interfaces occur on the positive edge of the processor clock twophase clocks are not used context switching the lx8000 incorporates up to eight independent 32 x 32b general register sets called contexts execution can switch between independent tasks called threads this context switch is performed with wasted cycles and prevents stalls while waiting for data from onchip or offchip shared resources context switches occur under program control when data is loaded from shared resources background load of 32bits 64bits or 128bits from shared resource can be accomplished with single load instruction special class of instructions called write descriptor wd allow command or data to be directed to sharedresourceincludingarequestforupto128bitsofreturndatathisallowsshareddevicestoefficiently perform operations that atomically examine and modify memory state the processor performs the wd operationinasingleinstructioncyclewithoutstallsbyusingacontextswitchwhenacontextswitchoccursinst ram inst lmi data lmi data ramlx8000 cpu core ciinstruction bus addr data data bus addr data ctl coprocessorlbcsystem bus denotes customer logicbte txbus rxbuscustom engineceiapril 2 2001 netvortex lexra proprietary confidential 14 release 19 the program counter of the suspended thread is stored in cp0 register while execution switches to another threadthenextthreadisautomaticallyselectedfromthepoolofreadytorunthreadsofequalpriorityusing windowed roundrobin algorithm exception handling the mips r3000 exception handling model is supported exceptions include both instructionsynchronous trapsaswellashardwareandsoftware interruptsthestatusregistercontrolsthe interrupt mask and operating mode exceptions are prioritized when an exception is taken control is transferred to the exception vector the current instruction address is saved in the epc register and the exceptionsourceisidentifiedinthecauseregisterauserprogramlocatedattheexceptionvectoridentifies thecauseoftheexceptionandtransferscontroltotheapplicationspecifichandlerintheeventofanaddress error exception the badvaddr holds the failing address coprocessoroperations thelx8000supports32bitcoprocessoroperationstheseincludemovestoand from the coprocessor general registers and control registers mtcz mfcz ctcz cfcz coprocessor loads and stores lwcz swcz and branches based on coprocessor condition flags bczt bczf the lexrasuppliedcoprocessorinterfacecansupportcoprocessoroperationsinasinglecyclewithoutpipeline stalls block transfer engine in netvortex system the lx8000 processor includes dedicated block transfer enginebtethatprovidesefficienthighbandwidthpackettransferbetweentheprocessorslocaldataram dmem and the netvortex utopia4 interfaces software initiates transfers with write descriptor instructionswdthatpassatransferdescriptortothebtethebtecanholdeighttransferdescriptorsper thread consisting of up to four rx descriptors and up to four tx descriptors 14 netvortex system overview the netvortex system includes up to 16 lx8000 processors and adds packet transfer pathways shared device interfaces and crossbar to provide highbandwidth lowlatency communication between the processors and shared devices the figure below shows the structure of the netvortex system which uses the lx8000 processor as building block figure 2 netvortex system overview block transfer controllers the block transfer controllers btcs are responsible for moving datalx8000 packet processorscrossbar p0 p1 p2 p13 p14 p15 tx btc utopia4sram ifcustom if rx btcrx btc tx btctxbus0 rxbus1sram ejtag probedebug if txbus1rxbus0 utopia4device management interfacecustom logic custom ifcustom logic sram ifsram tcam iftcam denotes customer logicapril 2 2001 netvortex lexra proprietary confidential 15 release 19 between each processors bte and the external utopia4 receive rx and transmit tx ports the btcs utopia4 interfaces operate at 415 mhz and are 32 bits wide crossbar interconnect the crossbar operates at 450 mhz and supports simultaneous full duplex data transfer between the processors and device interfaces the crossbar provides sustainable data transfer bandwidth of 58 gbitssec per device interface each processor can pass one 64bit write or read request to the crossbar every two cycles device interfaces accept write or read requests every cycle and can source 64 bits of read data every cycle the crossbar incorporates queues that are dedicated to each device and processor to prevent headofline blocking arbitrationisperformedbyindependentperqueuearbiterseacharbiterimplementswindowedroundrobin selection the lx8000 processor context switches are used in processor to hide the latency of transactions that are performed over the crossbar shared device interfaces the crossbar connects the processors to shared device interfaces that in turn connect to onchip or offchip resources these interfaces are shared among the processors and provide the bandwidth and flexibility required for wide spectrum of applications device management interface the crossbars optional device management interface dmi provides port for accessing the crossbar devices this port may be used by management processor or other application specific logic netvortex provides excellent priceperformance and timetomarket there are two main approaches which lexra has taken to achieve this deliver simple building blocks outside the processor core to enable system level customizations such as coprocessors application specific instructions memories and busses deliver either fully synthesizable verilog source model or fully implemented hardcore called smoothcore for popular pureplay foundries section15 describes the building blocks and section16 describes the deliverable models 15 system level building blocks the lx8000 processor is designed to easily fit into different target applications it provides the following building blocks simple memory management unit smmu an optimized custom engine interface cei one optional coprocessor interface ci per processor local memory interface lmi supports instruction ram imem and data ram dmem lexra bus controller lbc to connect peripheral devices and secondary memories to the processors own local buses netvortexemploysmultiplelx8000processorsandadditionalmodulestoprovideacompletesystemona chip for high performance packet processing block transfer controllers btcs with utopia level 4 interfaces coordinate the transferapril 2 2001 netvortex lexra proprietary confidential 16 release 19 of packets between external data path components and internal dmem crossbar device interfaces for attachment of applicationspecific tcams srams and network coprocessors device management interface dmi to for management processor access to shared devices the following sections discuss each of these system building block interfaces 151 smmu the lx8000 smmu is designed for embedded applications using single address space its primary function is to provide memory protection between user space and kernel space the smmu is consistent with the mips address space scheme for userkernel modes mapping and cacheduncached regions 152 local memory interface the lx8000s harvard architecture provides local memory interfaces lmis that support instruction memory and data memory synchronous memory interfaces are employed for all memory blocks the lmi block is designed to easily interface with standard memory blocks provided by asic vendors or by third party library vendors 153 coprocessor interface lexra supplies an optional coprocessor interface ci for applications requiring this functionality the coprocessor interface eavesdrops on the instruction bus if coprocessor load lwcz or move to mtczctczisdecodeddataispassedoverthedatabusintoaciregisterthensuppliedtothedesigner defined coprocessor similarly if coprocessor store swcz or move from mfcz cfcz is decoded dataisobtainedfromthecoprocessorandloadedintoaciregisterthentransferredontothedatabusinthe following cycle the design interface includes data bus fivebit address and independent read and write selectsforcoprocessorregistersandcontrolregistersthelx8000pipelineandharvardarchitecturepermit single cycle coprocessor access and transfer an applicationdefined coprocessor condition flag is synchronized by the ci then passed to the sequencer for testing in branch instructions 154 custom engine interface the netvortex includes custom engine interface cei that the application may use to extend the mips i alu opcodes with applicationspecific or proprietary operations similar to the standard alu the cei supplies the custom engine two input 32bit operands src1 and src2 one operand is selected from the register file depending on the most significant 6 bits of the opcode the second operand is either selected from the register file or is 16bit signextended immediate the opcode is locally decoded by the custom engine and following execution by the custom engine the result is returned on the 32bit result bus to the lx8000 to support multicycle operations stall input is included in the interface 155 lexra bus controller the lexra bus controller lbc is the interface between the lx8000 and shared devices attached to the crossbar on the processor side the lbc provides command buffer of configurable depth to prevent processor stalls on the crossbar side the lbc provides configurabledepth queue for read dataapril 2 2001 netvortex lexra proprietary confidential 17 release 19 156 block transfer controllers theblocktransfercontrollersbtcsmovedatabetweenlx8000datamemorythroughthebteandthe external receive rx and transmit tx ports therxbtcandtxbtcmodulespassdataandcontrolinformationbetweentheexternalinterfacesandthe internal buses the external interfaces support utopia level 4 at 415 mhz with 32bit data bus each of the two rxbuses and two txbuses are 64 bits wide they provide an aggregate internal transfer bandwidth of 115 gbitssec at 450 mhz support for spi level 4 phase 2 is planned for future releases 157 crossbar device interfaces the crossbar connects the processors to shared device interfaces that in turn connect to onchip or offchip resources such as tcams srams and networkspecific coprocessors these resources are shared among the processors and provide the bandwidth and flexibility required for wide spectrum of applications storeinstructionsloadinstructionsandwritedescriptorwdinstructionsareusedtocontroltransactions between the processors and shared devices the interfaces support atomic readmodifywrite operations enabling devices to implement advanced functions such as statistics and metering 158 device management interface the crossbars optional device management interface dmi provides port for accessing the crossbar devices with management processor or other application specific logic the dmi provides support for all crossbaroperationstothedevicesthroughthedmiamanagementprocessorcanreadormodifytheshared device contents for instance to update routing tables or poll statistics memory 159 building block integration the netvortex configuration script lconfig provides menu of selections for designers to specify building blocks needed number of different memory blocks target speed and target standard cell library next the configuration software automatically generates top level verilog model makefiles and scripts for all steps of the design flow for testability purposes all building blocks contain scan control signals the lexra synthesis scripts include scan insertion which allows atpg testing of the entire netvortex core 16 rtl core smoothcore lexra delivers netvortex as rtl core and smoothcore rtlcore forfullasicdesignsthertlisfullysynthesizableandscantestableverilogsourcecodeand maybetargetedtoanyasicvendorsstandardcelllibrariesinthiscasethedesignermaysimplyfollowthe asicvendorsdesignflowtoensurepropersignoffinadditiontotheverilogsourcecodeandsystemlevel test bench lexra provides synthesis scripts as well as floor plan guidelines to maximize the performance of the netvortex smoothcore forcotdesignsthataremanufacturedatpopularfoundriessuchasibmtsmcandumc asmoothcoreportisthequickestlowestcostandbestperformancechoiceinthiscasenetvortexhasbeen fully implemented and verified as hard macro all data path register file and interface optimizations have beenperformedtoensurethesmallestdiesizeandfastestperformancepossiblefurthermorethereisascan based test pattern that provides excellent fault coverage during manufacturing testsapril 2 2001 netvortex lexra proprietary confidential 18 release 19 17 eda tool support lexra supports mainstream eda software so designers do not have to alter their design methodology the following is snapshot of eda tools currently supported table 1 eda tool support design flow tools supported simulation synopsys vcs cadence verilog xl cadence ncverilog synthesis synopsys design compiler static timing synopsys primetime dft synopsys tetramax pr avant apollo iiapril 2 2001 netvortex lexra proprietary confidential 19 release 19 2 lx8000 architecture 21 hardware architecture 211 module partitioning the lx8000 processor core includes two major blocks the ralu register file and alu and the cp0 controlprocessortheraluperformsaluoperationsandgeneratesdataaddresseswhilecp0includes instruction address sequencing exception processing and product specific mode control the ralu and cp0 are looselycoupled and include their own independent instruction decoders figure 3 processor core module partitioningmulticontext register file n x 32 x 32bit r00instruction address and control alu pridexception processing logicpc and sequencerinstructions datadata address and controlflags traps and jump addresscxstatusn cxpcnralu cp0april 2 2001 netvortex lexra proprietary confidential 20 release 19 212 six stage pipeline the lx8000 has six stage pipeline thesixstagepipelineprovidesacompleteprocessorcyclefortheinstructionmemoryprovidingeaseofuse integrating for allowing use of larger and setassociative memories without degrading cycle time the six pipeline stages allow the processor clock speed to scale with current silicon processes 22 ralu data path thelx8000raluincorporatesamulticontext32x32bfourportregisterfileonewriteportisdedicatedto 32bitregisterfileloadsfromthedatabusloadsmfczcfczmovesfromcoprocessortheremaining three ports 2r1w are used for the other operations such as alu operations in the lx8000 the two write ports are also used to support 64bit loads from the data bus theinstructionsetincludesawideselectionofaluoperationsexecutedbytheraluinthecaseofalu operations one operand is register and the second operand is either register or 16bit immediate value the immediate value is signextended or zeroextended depending on the operation signed adds and subtracts can generate the arithmetic overflow trap ov which is sampled by cp0 theralualsogeneratesthevirtualmemoryaddressesforregisterloadsfromstorestomemorybyadding aregisterbasetoasignextended16bitimmediateoffsetdataaddresserrorsgeneratethe adelades trap flags which are sampled by cp0 the lx8000 employs bigendian memory addressing branches are based on comparisons between registers rather than implicit flags permitting the programmer moreflexibilityfromthesecomparisonstheralugenerates nandzflagsforsamplingincp0branchor jump instructions may optionally store in general purpose register the address of the instruction at the memory location following the branch delay slot of jump or branch which is taken this register called thelink holds the return address following subroutine call coprocessor operations permit moves of the general purpose registers to an optional applicationspecific coprocessor the general purpose registers may also be loaded from the coprocessor registers these transfers occur over the data bus similar to data memory loads and stores 23system control copr ocessor cp0 the system control coprocessor cp0 is responsible for instruction address sequencing and exception processing fornormalexecutionthenextinstructionaddresshasseveralpotentialsourcestheincrementoftheprevious address branch address computed using pcrelative offset or jump target address for jump addresses the absolute target can be included in the instruction or it can be the contents of generalpurpose register transferred from the ralu branches are assumed or predicted to be taken in the event of prediction failure two stall cycles are incurred and the correct address is selected from special backup register statistics from several large programssuggestthatthesestallswilldegradeaveragelx8000throughputbyseveralpercenthoweverthe net effect of the lx8000s branch prediction on performance is positive because this technique eliminatesstage 1 i instruction fetch stage 2 d decode stage 3 s source fetch register file read stage 4 execution and address generation stage 5 m memory data select read data cache store and tags stage 6 w write back to register fileapril 2 2001 netvortex lexra proprietary confidential 21 release 19 certain critical paths and therefore permits higher speed system clock if anexception occurs cp0 selects one of several hardwired vectors for the next instruction address the exception vector depends on the mode and specific trap which occurred this is described further in section34 exception processing the following registers which are visible to the programming model are located in cp0 table 2 cp0 registers epc status cause and badvaddr are described further in the section34 prid is readonly register that allows the customers software to identify the specific version of the lx8000 that has been implemented in their product the cctl register is lexra defined cp0 register used to control the instruction and data memories as described in section52 cache control register cctl the contents of the above registers can be transferred to and from the ralus generalpurpose register file usingcp0operationsunlikeregisterslocatedincoprocessors13theycannotbeloadedorstoreddirectly to data memory 24 highperformance context switch thelx8000cpuincorporatesmultipleindependentregistersetscalled contextsasaresultexecutioncan switch between independent tasks called threads each running in its own context this switch is called context switch conventional risc architectures perform context switching in software however packet processing demands special hardware support to achieve high performance context switching the lx8000 provides zerooverhead context switch that is an instruction can be executed for somecontext in every cycle 241 new context registers thenumberofcontextsiscustomerdefinedusinglexras lconfigutilityonetoeightcontextsaresupported by the lx8000 rtl default is one context each context includes 32 general registers r0 r31 1 32bit cxpc program counter 1 16bit cxstatus register the general registers are located in the ralu the cxpc and cxstatus registers are located in cp0 in addition 3bit register movecx is located in cp0 and is accessible with the mtlxc0mflxc0 instructions variants of the mips standard mtc0mfc0 instructions movecx holds the encodedcp0 register number function badvaddr 8 holds bad virtual address if address exception error occurs status 12 interrupt masks mode selects cause 13 exception cause epc 14 holds address for return after exception handler prid 15 processor id readonly 0x0000c701 for lx8000 cctl 20 instruction and data memory controlapril 2 2001 netvortex lexra proprietary confidential 22 release 19 numberofthetargetcontextforthemfcxcmtcxcandmfcxgmtcxginstructionswhichcanaccess the registers of any context these new registers are illustrated in figure4 the currently active context number is an implicit readonly value that is accessed with the mycx instruction figure 4 context associated registers the mips i isa except for unaligned loads and stores is fully supported in each context as result the general register set for each context is fully consistent with the mips isa requirements for example r0 is hard wired to 0 and r31 is an implied link for certain branch and jump instructions in every context up to two source registers and one destination register may be specified for an alu operation again consistent with the mips programming model cxpc holds the 32bit virtual address of the next instruction to be fetched by the associated thread the 16 bit cxstatus register indicates whether the thread is waiting for data transfer or io events cxstatus also permits programassigned priority for thread reactivation the cxstatusregisterfields are identified in table3 each field is explainedbelow the rdwr or rd onlyindicationsapplytoaccessusingthemtcxcandmfcxcinstructionstheeffectsofotherhardware and software events on the fields is shown explicitly and explained in the following paragraphs the cxstatus waitevent field provides eight event flags that may be controlled by hardware software or combination of the two the flags may be set with the csw instruction or the wdcsw instructionthewdcswinstructionupdatesthewaiteventflagswritesadescriptortothesystembus and performs context switch whenwaiteventbitsaresetwithawdcswinstructiontheprocessorinitiatesanuncachablewriteto the system bus and performs context switch all context switches are performed after oneinstruction delay slot the waitevent bits may be cleared via software from another thread with the postcx instruction or by hardware through the event signal inputs when the target device completes the wd operation it notifies the processor with high pulse on the processorscorrespondingeventsignalinputeightperthreadtheprocessorthenclearsthewaitevent bit in the contexts cxstatus register software can set more than one waitevent bit which will requireacompletionresponseoneachofthecorrespondingeventsignalinputsbeforethethreadisreadyformulticontext register file context control registers context 7 r0 r31 context 1 r0 r31 context 0 r0 r31context 7 cxpc cxstatus lxc0 control register movecxcontext 1 cxpc cxstatus context 0 cxpc cxstatus april 2 2001 netvortex lexra proprietary confidential 23 release 19 execution theoptionalnetvortexblocktransfercontrollerbtcisanexampleofasystembusdevicethatresponds to thewd family of instructions when thebtc ispresent in thenetvortex system configuration two of the eight waitevent bits are dedicated to monitor its completion signalling the cxstatus waitload bit indicates that the associated thread is waiting for the completion of register load from uncached memory or memorymapped io following execution of lwcsw load word with context switch ltcsw load twinword with context switch or lqcsw load quadword with context switch see section244 for descriptions of these three instructions waitload is set following execution of lwcsw ltcsw lqcsw wdlwcsw wdltcsw or wdlqcsw instructions and cleared by the processor when the load data is transferred to the contexts general register file thethreebitthreadpriorityfieldincxstatusallowsthreadschedulingwithuptoeightpriorities an application specific thread scheduler can utilize thread priorities to fine tune the thread scheduling see section244 for details of the thread scheduling hardware interface table 3 context status register detail 242 reset at reset the general registers are unaffected by reset thread 0 is activated at reset all cxpcs are reset to the common mips reset vector 0xbfc0000 however thread 0 may modify the initial cxpc of the other threads prior to the first context switchfieldwidth bitsdescription waitevent 8 rdwr set with csw and wdcsw instructions cleared by external hardware or cleared with postcx instruction reserved 4 rd only reserved waitload 1 rdwr set with lwcsw ltcsw lqcsw wdlwcsw wdltcsw and wdlqcsw instructions cleared by hard ware threadpriority 3 rdwr thread priority for use by optional custom thread scheduler cxstatus150 0x0000 cxpc310 0xbfc00000 movecx20 00015 0000 waitevent threadprio87 4 2 0 84 3waitld 13april 2 2001 netvortex lexra proprietary confidential 24 release 19 243 determining the number of contexts in software as described above the number of contexts that are implemented in processor is customer defined using lexraslconfigutility in some cases software will be written that must be adaptable to an unknown number ofcontextsforanynonimplementedcontextreadingthecxstatusregisterwillalwaysreturnavalueof zerousingtheinstructionsdescribedinsection2412 programaccesstonewregistersthesoftwarecan attempt to write nonzero value to the cxstatus register for each context if the value zero is returned when attempting to read back the written value then that context is not implemented 244 initiation of context switch context switch is executed by the csw instruction and any of the following instructions that include the csw extension 245 csw instruction the context switch csw instruction causes an unconditional context switch allowing the application program to execute context switch under complex programdefined conditions by alternately executing or branching around the csw instruction bits 3124 of the rs register specified in the csw instruction are logically ored with the waitevent field of cxstatus to determine the new waitevent field settings 246 lwcsw ltcsw and lqcsw instructions theloadwordwithcontextswitchlwcswinstructionisusedtoinitiatealonglatencytransferfroman lbus device to general register lwcsw performs split transaction read so that the next thread can continue to execute while the memorymapped resource is accessed only two clock cycles of system bus tenurearerequiredtoinitiatethesplitreadtransactionfollowinginitiationthebusisavailableforotheruse the final transfer of the return data uses one cycle of system bus tenure loading the final result into the register file will not stall the currently executing thread unless the thread is executing load or store instruction at the time the split read data is returned in this case single cycle stall is required to load the split read data into the register file the currently executing thread is otherwise unaffected by the return data similarly ltcsw is used to initiate long latency load of 64bit data into two consecutively numbered general registers starting with the low register address bit equal to 0 up to two processor stalls can occur whenthe64bitdataistransferredintotheregisterfilelqcswisusedtoinitiatealonglatencyloadof128 bit data into four consecutively numbered general registers starting with the two low order register address bitsequalto00uptofourprocessorstallscanoccurwhenthe128bitdataistransferredintotheregisterfile in netvortex the twocycle bus tenure needed to issue split read request applies only to the processors crossbar interface within the crossbar and at the device interface split read request and 64bit data return eachrequireonlyonecycleoftenurethereturnof128bitdatarequirestwocyclesoftenureatthecrossbar interfacecsw rs context switch update cxstatus from rs lwcsw rt displacementbase load word from uncached memory ltcsw rt displacementbase load twinword from uncached memory lqcsw rt displacementbase load quadword from uncached memory wd rs rt device write descriptor to device wdcsw rs rt device write descriptor to device with context switch wdlwcsw rd rs rt device write descriptor load word reply data wdltcsw rd rs rt device write descriptor load twin reply data wdlqcsw rd rs rt device write descriptor load quad reply dataapril 2 2001 netvortex lexra proprietary confidential 25 release 19 following lwcsw ltcsw or lqcsw waitload in cxstatus is set 247 wdcsw instructions the write descriptor wd instruction forms 64bit descriptor from the contents of two general registers and writes the descriptor over the system bus interface to the specified device an optional context switch may be performed by this instruction by appending csw suffix to the mnemonic these instructions are used to initiate longlatency operations to shared device for example the wdcsw instruction is used to start block transfers using the optional block transfer controller supplied with netvortex theseinstructionsformthedescriptorusingrsandrtregistercontentsasdescribedindetailinsection4for wdcsw the upper bits of the descriptor identify the waitevent bits to be set the wd instruction sourcesthefull64bitsofthedescriptoronthesystembusthe32bitsystembusaddressofthetargetdevice is formed by concatenating 24bit configuration defined constant the 5bit device id from the instruction opcode and three bits of 0 248 wdlwcsw wdltcsw and wdlqcsw instructions the wdlwcsw wdltcsw and wdlqcsw instructions provide efficient operation with devices that return3264or128bitsofdatatheseinstructionssetthewaitloadbitinthecxstatusregisterthe wdlwcsw writes 64bit descriptor to device and requests the device to provide split transaction word read response likewise the wdltcsw wdlqcsw instruction writes descriptor and requests the device to provide split transaction twinword quadword read response note that csw suffix is mandatory for these instructions because they must always set waitload these instructions do not set waitevent bits in the cxstatus register 249 pipeline followingexecutionofacontextswitchinstructionlwcswltcswlqcswwdcswwdlwcsw wdltcsw wdlqcsw or csw the next instruction executes to completion in the current context beforethecontextswitchiseffectiveinotherwordsthecontextswitchasaresultofpipelininghasan architectural delay slot exposed to the programmer this delay slot and restriction on its usage is explained below and is generally consistent with similar branch and jump delay slots in the mips i isa the delay slot is illustrated below intheexamplethreadisinstn1executestocompletioncxpcistorestheaddressofinstn2theaddress wherethreadiresumeswhenitislaterreactivatedafterinstn1iscompletethenextinstructionexecuted is inst m1 in threadj of course threadi and threadj may execute two completely different tasks or execute the same task on different data in this case the pcs will also be unrelated number of restrictions apply to the delay slot instruction 1 branch or jump may be coded in the delay slot context switch changes program ﬂow like the branch or jump this restriction is thus similar to the mips i restriction that back toback branches or jumps can occur 2 the registers loaded by lwcsw ltcsw lqcsw wdlwcsw wdltcsw or wdlqcsw cannot be referenced in the delay slot following the load similar restriction exists for loads in the mips i isathreadi threadj inst n csw r7 inst m inst n1 addu r3 r2 r1 inst m1 addu r7 r6 r3 inst n2 subu r4 r3 r1 inst m2 april 2 2001 netvortex lexra proprietary confidential 26 release 19 2410 new thread selection following execution of context switching instruction the cpu selects the next thread for activation from the available pool the available pool consists of those threads for which the cxstatus registers wait event and waitload fields are clear if thread is available the cpu stalls after executing the context switching instruction and its delay slot stall conditions can arise when all threads initiate long latency processes for example all threads might initiateablocktransferwithinashortperiodoftimesuchthatnotransferhascompletedwhenthelastthread performs its context switch thecpulogicrequiredtoimplementtheabovenextthreadselectionalgorithmispipelinedasaresultthe next thread selection in the dstage of the pipeline critical path can be very simple with this approach thecxstatusregistersamplingusedfornextthreadselectionwilloccurseveralcyclesearlierandmaynot include newly available thread however this is not drawback because event completions for inactive threadsareasynchronoustothecurrentthreadsprogramthelx8000sinternalthreadschedulerdescribed in the following paragraphs is pipelined such that if there is currently active thread all threads are have some wait bit set it takes two cycles from the time that some thread has all of its wait bits clear until that threads cxpc value is driven to the instruction ram the lx8000 processor includes internal thread scheduling hardware the scheduler examines the cxstatus register of each context to determine which contexts are ready for execution context for which all of the waitevent and waitload bits are zero may be selected on the next context switch operation the lx8000s internal thread scheduler ignores the threadpriority field of the cxstatusregisteritselectsthenextthreadfairlyacharacteristicofthisscheduleristhatifthreadsare performing similar types of activities over time they experience similar selection rates and similar delays in selection when there are multiple threads ready for execution thealgorithmemployedbytheinternalschedulerreliesonawindowofreadythreadsthefollowingsteps in the algorithm are endlessly repeated once window of ready threads has been chosen other threads are added to this window ifareadythreadinthewindowsubsequentlyhasoneofitswaitbitsturnedonthatthread is removed from the window since the window contains only inactive threads this can only happen if the currently active thread executes mtcxc to turn on another threads wait bit this is an unusual case because it is expected that mtcxc will only be used during system initialization onebyoneascontextswitchesareexecutedathreadfromthewindowisselectedforthe next context switch as each contextswitch takes effect the selected thread is removed from the window the selection among the threads in the window is not architecturally defined and application software should not depend on any particular order the current implementation selects the highest numbered thread in the window but this may be changed in future implementations whenthewindowisabouttobecomeemptyanewwindowiscreatedcomprisingallof the currently ready threads if there are none this step repeats until there is at least one readythreadwhenanewnonemptywindowisobtainedthefullcycleofthisalgorithm continues as described above any thread that becomes ready will eventually be included in the next new window and will be selected for execution therefore this algorithm prevents ready thread from being starved out of activation by otherapril 2 2001 netvortex lexra proprietary confidential 27 release 19 threads the fairness of this algorithm results from the fact that threads which become ready more often are dispatched more often while those which become ready less often are dispatched less often for applications that require more detailed scheduling the customer may bypass the standard lx8000 schedulerandsupplyanapplicationspecificdesign that has accessto thesameperthreadinformationas the standard scheduler such scheduler may also examine other real time information that is outside the province of lx8000 architecture thefollowingtableliststheportsthattheprocessorsuppliesforeachcontextwhicharedirectlyconnectedto thestandardorapplicationspecificschedulermoduletheportdirectionisrelativetotheprocessoraninput to the processor must be driven from register in the scheduler likewise an output from the processor is driven from register within the processor table 4 scheduler ports becausetheschedulerdeterminesthethreadthattheprocessorwillactivateonthe nextcontextswitchitcan includeregisterstagesinitsdesigntoavoidanytimingproblemstypicallyeachprocessorisconnectedtoits own local thread scheduler however the use of single scheduling module which operates on information from all processors is not precluded itshouldbenotedthatthecx_threadactv_rsignalsindicatethecurrentactivethreadatthe endofthe pipelineexceptionsandmispredictedbranchescancausecontextswitchestobesquashedfurthermorethe waitbitvaluescanbesetbycontextswitchesormtcxcinstructionsandthesechangesonlytakeeffectat theendofthepipelineafteranypotentialexceptionsorbrancheshavebeenresolvedontheotherhandthe ext_nextcntx_p_rinputsmustbeusedatthe beginning ofthepipelinetoselectanewactivethreadin case of potential context switch toresolvethediscrepancybetweentheendandbeginningofthepipelinecp0inhibitsathreadthatisactive at any stage of the pipeline from being dispatched for context switch regardless of the value of ext_nextcntx_p_r in addition all threads are inhibited from being dispatched for context switch whilethereisanmtcxcinstructionatanystageofthepipelinethiswillonrareoccasionscausenovalid instructions to be sent down the pipeline but it eliminates the need for the external scheduler to be aware of the pipeline thisinhibitinglogicalsoimpliesthattheexternalscheduleronlyneedstodetectachangeinthevalueofany cx_threadactv_rfromzerotoonetodeterminethatacontextswitchhasactuallytakenplaceanda new thread has been dispatched 2411 example context switch for coprocessor operation the following example illustrates how an unconditional context switch could be used to allow other threads to execute while coprocessor performs relatively long latency operation on behalf of thread theprocessor port direction description cx_stusthwait_rn10 output assertedwhenanywaitﬂagissetincxsta where n is the number of contexts cx_stusthprio_rn310 output threadpriority ﬁeld from cxstatus where n is the number of contexts cx_threadactv_rn10 output 1ifthreadisactivewherenisthenumber of contexts ext_nextcntxrdy_p_r input 1 if schedulers next thread selection is valid ext_nextcntx_p_r20 input schedulers next thread selectionapril 2 2001 netvortex lexra proprietary confidential 28 release 19 example assumes that coprocessor 2 has been connected to the processors coprocessor interface ci which is available as part of lexras standard product thecoprocessorisassumedtocontainacontrolregister1thatmustcontainthecontextnumbertowhich subsequent coprocessor instructions apply another control register 2 is used to start the coprocessor operation when the coprocessor concludes the operation it signals the processor to clear specific wait eventbitforthetargetcontextassociatedwiththecoprocessorthismakesthethreadreadyfordispatch since several threads can use coprocessor 2 before retrieving the results the current context must again be stored to the control register 1 in addition to the mycx and csw instructions the example uses the mips standard mtc2 ctc2 mfc2 instructions for accessing coprocessor 2 2412 program access to new registers thenewregistersdescribedinsection241cxpccxstatusmovecxaswellasthegeneralregisters of all contexts are accessible under program control by the active thread the movecx register which determines the target context for the mtcxc mfcxc mtcxg mfcxg instructions is loaded by the mtlxc0 instruction and can be read with the mflxc0 instruction the number of the currently executing context can be accessed with the mycx instruction which loads it into general register cxpc and cxstatus are new coprocessor 0 registers these context control registers ct or cd can be moved to or from general registers rt or rd of the active thread using the following instructions where ct or cd cxstatus cxpc movecx20 designates the context whose ct or cd is to be accessed mtcxcandmfcxcshould notbeusedtoaccessthecxpcofthecurrentlyactivethreadifctorcdisthe cxpc of the currently active thread the result of mtcxc or mfcxc is undefined two additional instructions permit the general registers rt or rd in the active thread to be transferred to ormycx r1 get current context number ctc2 r1 1 tell cop2 which context this is mtc2 supply other data to cop2 csw r2 switch and wait for cop2 ctc2 r3 2 kick off cop2 in delay slot after the context switch when the cop2 operation completes this thread is made ready and eventually gets dispatched here ctc2 r1 1 tell cop2 which context this is mfc2 retrieve results mtcxc rt cd moves gen reg rt of the active context to cd mfcxc rd ct moves ct to gen reg rd of the active contextapril 2 2001 netvortex lexra proprietary confidential 29 release 19 from the general registers gt or gd in inactive threads this capability is useful in debugging so that all registers are accessible without execution of context switch the special case of moves within single context using mtcxg mfcxg is undetectable by the assembler though it would normally be performed using mips i instruction accessing general register in an inactive context will give unpredictable results if load is pending to that register mtcxc mfcxc mtcxg and mfcxg are extensions to the mips isa they function similarly to the mips mtc0 and mfc0 instructions but the opcodes have different object code assignments to allow the numberofcoprocessor0registerstobeextendedaswithmtc0andmfc0acoprocessorusabilitytrap is taken in user mode if cp0 is not designated usable in status mtcxc mfcxc mtcxg mfcxg are always usable in kernel mode 2413 exceptions themipsr3000exceptionprocessingmodelisunchangedbylx8000withonedifferenceexplainedinthe next paragraph following program synchronous trap or an interrupt the pc of the current thread is stored intheprogramvisibleepcregisterexceptionsarepreciseallowinganexceptionhandlertopossiblytake recovery steps and then resume execution at the pc of theexception if there isan activecontext nocontext switch occurs when an exception trap or interrupt is taken the exception handler executes in the same context that was current at the time the exception was taken the handler can use the mycx instruction to determine its context if necessary lx8000 suppresses exceptions that occur in the delay slot of context switch this simplified approach is acceptableinembeddedsystemsexceptionreportingisausefuldebugtoolduringthedevelopmentprocess but is not necessary in production systems this suppression of exceptions applies to both interrupts and all program synchronous traps therefore instructions which deliberately cause exceptions break syscall should never be coded in the delay slot of cswtype instruction an ejtag debugger should neverattempttoinsertansdbbpinthedelayslotandshouldalsonotethatsinglesteppingwillexecutepast the delay slot instruction tofacilitatesystemlevelerrordetectionandreportingtheprocessorhasaspecialresponsetotheassertionof its intreqn7 hardware interrupt input when this interrupt is asserted the processor forces context 0 into ready state by clearing all of the wait flags in context 0s cxstatus register this ensures that there is contextavailabletoservicetheinterrupthowevertheinterruptmaybeservicedbyanyotherreadycontext note that all threads share common set of coprocessor 0 registers including the exception processing registers listed in table2 on page21 and the estatus ecause and intvec registers described in section25 25 lowoverhead prioritized interrupts thelx8000includeseightnewlowoverheadhardwareinterruptsignalsthesesignalsarecompatiblewith the r3000 exception processing model and are useful for realtime applications these interrupts are supported with three new lexra cp0 registers estatus ecause and intvec accessed with the new mtlxc0 and mflxc0 variants of the mtc0 and mfc0 instructions as with any cop0instructionacoprocessorunusableexceptionistakeniftheseinstructionsareexecutedwhileinuser mode and the cu0 bit is 0 in the cp0 status registermtcxg rt gd moves rt of the active context to gd of context movecx mfcxg rd gt moves gt of context movecx to rd of the active contextapril 2 2001 netvortex lexra proprietary confidential 30 release 19 the three new lexra cp0 registers are estatus 0 ecause 1 and intvec 2 and are defined as follows estatus lx cop0 reg 0 readwrite ecause lx cop0 reg 1 readonly intvec lx cop0 reg 2 readwrite estatus contains the new interrupt mask bits im158 which are reset to 0 so that none of the new interruptswillbeactivatedregardlessoftheglobalinterruptsignaliecip158forthenewinterruptsignals islocatedinecauseandisreadonlythesefieldsaresimilartotheimandipfieldsdefinedinther3000 exception processing model except that the new interrupts are prioritized in hardware and each have dedicated exception vector ip15 has the highest priority while ip8 has the lowest priority however all new interrupts are higher priority than ip70 the program defined base address for the exception vectors is located in intvec the exception vector used for each prioritized interrupt is shown in the table below two instructions can be executedineachvectortypicallythesewillconsistofajumpinstructionanditsdelayslotwiththetargetof the jump being either shared interrupt handler or one that is unique to that particular interrupt table 5 prioritized interrupt exception vectors when vectored interrupt causes an exception all of the standard actions for an exception occur these include updating the epc register and certain subfields of the standard status and cause registers in particulartheexceptioncodeofthecauseregisterindicatesinterruptandthecurrentandprevious mode bits of the status register are updated in the usual manner31 24 23 16 15 0 0 im158 0 31 24 23 16 15 0 0 ip158 0 31 6 5 0 base 0 interrupt number exception vector 15 base 111000 14 base 110000 13 base 101000 12 base 100000 11 base 011000 10 base 010000 9 base 001000 8 base 000000april 2 2001 netvortex lexra proprietary confidential 31 release 19 3 lx8000 risc programming model this section describes the lx8000 programming model section31 summary of mipsi instructions containsalistsummarizingallmipsioperationssupportedbythelx8000theseopcodesmaybeextended by the customer using lexras custom engine interface cei this capability is described in section32 opcode extension using the custom engine interface cei section33 memory management describes the simplified memory management unit smmu which is physically incorporated in the lx8000 lmi the smmu provides sufficient memory management capabilities for most embedded applications while ensuring execution of thirdparty mips software development tools thelx8000supportsthemipsr3000exceptionprocessingmodelasdescribedinsection34 exception processing thelx8000supportsallmipsicoprocessoroperationsthecustomercanincludeonetothreeapplication specific coprocessors lexra provides functional block called the coprocessor interface ci which allows thecustomerasimplifiedconnectionbetweentheircoprocessorandtheinternalsignalsofthelx8000the ci is described in section35 the coprocessor interface ci lexras application specific instructionset extensions are described in detail in section4 lx8000 instruction extensions 31 summary of mipsi instructions the netvortex executes mipsi instructions as detailed in the tables below to summarize the netvortex executes mipsi instructions with the following exclusions the unaligned loads and stores lwl swl lwrswrarenotsupportedbecausetheyaddsignificantsiliconareaforlittlebenefitinmostapplications the unaligned loads and stores execute as nop this can cause code to execute incorrectly if the programmer expected these instructions to provide the unaligned load or store operations 311 alu instructions table 6 alu instructions instruction description add rd ra rb addu rd ra rb addi rd ra immediate addiu rd ra immediaterd ra rb immediate add reg ra to either reg rb or 16bit immediate sign extendedto32bitsresultisstoredinregrdaddandaddi can generate overflow trap addu and addiu do not sub rd ra rb subu rd ra rbrd ra rb subtract reg rb from reg ra result is stored in register rd sub can generate overflow trap subu does not and rd ra rb andi rd ra immediaterd ra rb immediate logicaland of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rd or rd ra rb ori rd ra immediaterd ra rb immediate logicalor of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rdapril 2 2001 netvortex lexra proprietary confidential 32 release 19 312 load and store instructions table 7 load and store instructionsxor rd ra rb xori rd ra immediaterd ra rb immediate logicalxor of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rd nor rd ra rb rd ra rb logicalnor of reg ra with either reg rb or zeroextended 16 bit immediate result is stored in reg rd lui rd immediate rd immediate 160 the 16bit immediate is stored into the upper half of reg rd the lower half is loaded with zeroes sll rd rb immediate sllv rd rb rard rb ra immediate regrbisleftshiftedby031theshiftamountiseitherthe5b immediate of the 5 lsb of ra result is store in reg rd srl rd rb immediate srlv rd rb rard rb ra immediate reg rb is rightshifted by 031 the unsigned shift amount is either the 5b immediate or the 5 lsb of ra result is stored in reg rd sra rd rb immediate srav rd rb rard rb ra immediate reg rb is arithmetic rightshifted by 031 the unsigned shift amount is either the 5b immediate or the 5 lsb of ra result is stored in reg rd slt rd ra rb sltu rd ra rb slti rd ra immediate sltiu rd ra immediaterd 310 1 if ra rb immediate else 0 if reg ra is less than rb immediate set rd to 1 else 0 the 16bitimmediateissignextendedforsltsltithecompari is signed for slu sltiu the comparison is unsigned instruction description lb rd offsetra lbu rd offsetra lh rd offsetra lhu rd offsetra lw rd offsetrard memoryra offset reg rd is loaded from data memory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits lb lbu addresses are interpreted as byte addresses to data memorylhlhuashalfword16bitaddresseslwasword 32bit addresses thedatafetchedinlblhlbulhuissignextendedzero extended to 32bits for storage to reg rd rd cannot be referenced in the instruction following load instructioninstruction descriptionapril 2 2001 netvortex lexra proprietary confidential 33 release 19 313 conditional move instructions table 8 conditional move instructions 314 branch and jump instructions table 9 branch and jump instructionssb rb offsetra sh rb offsetra sw rb offsetrarb memoryra offset reg rb is stored to data memory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits sbaddressesareinterpretedasbyteaddressestodatamem ory the 8 lsb of rb are stored sh addresses are interpreted as halfword addresses to data memory the 16 lsb of rb are stored instruction description movz rd rs rt if rt 0 rd rs else rd rd conditional move on equal zero if the contents of general register rt are equal to 0 the general register rd is updated with rs otherwise rd is unchanged movn rd rs rt if rt 0 rd rs else rd rd conditional move on not equal zero if the contents of general register rt are not equal to 0 the gen eral register rd is updated with rs otherwise rd is unchanged instruction description beq ra rb destination bne ra rb destinationif cond pc pc 4 14destination15 destination 00 else pc pc 8 where cond ra rb for eq ra ne rb for ne and desti nation is 16bit value for beq bne the instruction after the branch delay slot is always executedinstruction descriptionapril 2 2001 netvortex lexra proprietary confidential 34 release 19 315 control instructions table 10 control instructionsblez ra destination bgtz ra destinationif cond pc pc 4 14destination15 destination 00 else pc pc 8 where cond ra 0 for ra 0 for gt and destina tion is 16bit value forblezbgtztheinstructionafterthebranch delayslotis always executed bltz ra destination bgez ra destinationif cond pc pc 4 14destination15 destination 00 else pc pc 8 where cond ra 0 for lt ra 0 for ge and destina tion is 16bit value forbltzbgeztheinstructionafterthebranch delayslotis always executed bltzal ra destination bgezal ra destinationsimilar to the bltz and bgez except that the address of the instruction following the delay slot is saved in r31 regardless of whether the branch is taken j target pc pc3128 target 00 target is 26bit absolute the instruction following j delay slot is always executed jal target same as above except that the address of the instruction fol lowing the delay slot is saved in r31 jr ra pc ra the instruction following jr delay slot is always executed jalr ra rd same as above except that the address of the instruction fol lowing the delay slot is saved in rd instruction description syscall the sys trap occurs if syscall is executed break the bp trap occurs if break is executed rfe causes the kuie stack to be popped used when returning from the exception handler see exception processing belowinstruction descriptionapril 2 2001 netvortex lexra proprietary confidential 35 release 19 316 coprocessor instructions table 11 coprocessor instructions 32 opcode extension using the custom engine interface cei 321 cei operations customers may add proprietary or applicationspecific opcodes to their netvortex based products using the custom engine interface cei the new instructions take one of the following forms illustrated below and use reserved opcodesinstruction description lwcz rcgen offsetra rcgen memoryra offset coprocessor z general reg rcgen is loaded from data mem ory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits rcgen cannot be referenced in the following instruction one cycle delay swcz rcgen offsetra rcgen memoryra offset coprocessor z general reg rcgen is stored to data memory the memory address is computed as base offset where the base is reg ra and the offset is the16bit offset sign extended to 32 bits mtcz rb rcgen ctcz rb rcconin mtczctcz the general register rb is moved to copro cessor z general control reg rcgenrccon rcgen and rccon cannot be referenced in the following instruction mfcz rb rcgen cfcz rb rcconin mfczcfcz the coprocessor z general control reg rcgenrccon is moved to the general register rb rb cannot be referenced in the following instruction bczt destination bczf destinationpc pc 4 14dest15 dest 00 if cond else pc pc 8 where cond cpcondz true for bczt cpcondz false for bczf forbcztbczftheinstructionafterthebranch delayslotis always executedapril 2 2001 netvortex lexra proprietary confidential 36 release 19 table 12 custom engine interface operations lexra permits customer operations to be added using the four 4 iformat opcodes and six 6 rformat opcodes listed in the table above other opcode extensions in future lexra products will notutilize the opcodes reserved above when the cei decodes newopi or newopr it must signal the core that custom operation has been executed so that the reserved instruction trap will not be taken multicycle custom operations may be executed by asserting cesel note the custom operation may choose to ignore the src1 and src2 operands supplied by the cei and reference customer registers instead results can also be written to an implicit customer register however unless d 0 is coded register in the core will also be written 322 interface signals table 13 custom engine interface signalsnew instruction description available opcodes newopi rd ra immed rd ra newopi immed reg ra is supplied to the src1 port of cei and the 16bit immediate sign extended to 32bits is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 24 27 newopr rd ra rb rd ra newopr rb reg ra is supplied to the src1 port of cei and reg rb is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 0 and inst50 5658 606263 signaltype relative to coredescription src1310 output operand supplied to customer logic src2310 output operand supplied to customer logic res310 input result of customer logic supplied to core ceiop110 output instruction op and subop fields to be decoded by customer logic cehalt input indicates that multicycle custom operation is in progress cesel input indicates that cei operation has been decodedapril 2 2001 netvortex lexra proprietary confidential 37 release 19 33 memory management thelx8000includesasimplifiedmemorymanagementunitsmmufortheinstructionmemoryaddress and the data memory address these units are physically located in the local memory interface lmi modulesthehardwiredvirtualtophysicaladdressmappingperformedbythesmmuissufficienttoensure execution of thirdparty software development tools table 14 smmu address mapping note the 05 gbyte of physical address space from 0x2000_0000 to 0x3fff_ffff is not accessible with the above memory map 34 exception processing thelx8000implementsthemipsr3000exceptionprocessingmodelasdescribedbelowfeaturesspecific to onchip tlb support are not included in the discussion below the term exception refers to both traps which are nonmaskable program synchronous events and interrupts which result from unmasked asynchronous events thelistbelowisnumberedfromhighesttolowestpriorityexccodeisstoredincausewhenanexception is taken note that sys bp ri cpu can share the same priority level because only one can occur in particular time slotvirtual address space description mapped to physical address 0xff00_0000 to 0xffff_ffffejtag address space 16 mbyte uncached this address range is reserved for ejtag use only0xff00_0000 to 0xffff_ffff 0xc000_0000 to 0xfeff_ffffkseg2 1gbyte minus 16 mbyte addressable only in kernel mode cached0xc000_0000 to 0xfeff_ffff 0xa000_0000 to 0xbfff_ffffkseg1 05 gbyte addressable only in ker nel mode uncached used for io devices0x0000_0000 to 0x1fff_ffff 0x8000_0000 to 0x9fff_ffffkseg0 05 gbyte addressable only in ker nel mode cached0x0000_0000 to 0x1fff_ffff differentiated from kseg1 addresses with an internal signal 0x0000_0000 to 0x7fff_ffffkuseg 2gbyte addressableinkernelor user mode cached0x4000_0000 to 0xbfff_ffffapril 2 2001 netvortex lexra proprietary confidential 38 release 19 table 15 list of exceptions exception priority exccode description reset 1 reset trap adel instruction2 4 address exception trap instruction fetch occurs if the instruction address is not wordaligned or if kernel address is referenced in user mode ov 3 12 arithmeticoverflowtrapcanoccurasa result of signed add or subtract opera tions sys 4 8 syscall instruction trap occurs whensyscallinstructionisexecuted bp 4 9 break instruction trap occurs when break instruction is executed ri 4 10 reservedinstructiontrapoccurswhen areservedopcodeisfetchedreserved opcodes are listed below cpu 4 11 coprocessor usability trap occurs when an attempt is made to execute coprocessor n operation and copro cessor n is not enabled adel data 5 4 address exception trap data fetch occurs if the data address is not prop erly aligned or if kernel address is generated in user mode ades 6 5 address exception trap data store occurs if the data address is not prop erly aligned or if kernel address is generated in user mode int 7 0 unmasked interrupt there are six 6 levelsensitive hardware interrupt requestsignalsintothenetvortexcore eachissynchronizedbythecoretothe netvortex system clock in addition program writes to cause98 are soft wareinitiated interrupt requests each of the eight 8 requests has an associ ated mask bit in status int is gener ated by any unmasked request when interrupts are globally enabledapril 2 2001 netvortex lexra proprietary confidential 39 release 19 341 exception processing registers status cause epc bad vaddr status coprocessor 0 general register address 12 cu cun 10 indicates that coprocessor n is usableunusable in coprocessor instructions bev bootstrap exception vector selects between two trap vectors see below im interrupt masks for the six hardware interrupts and two software interrupts kuie ku01indicateskernelusermodeinthelx8000usermodevirtualaddressesmusthave msb 0 in kernel mode the full address space is addressable ie 10 indicates that interrupts are enabled disabled kuoieokupiepkuciecformsathreelevelstackhardwarestackkuiesignalsthe currentvaluesarekuciecthe previousvaluesarekupiepandthe oldvaluesthosebefore previous are kuoieo see below status isreadorwrittenusingmtc0andmtf0operationsonresetbev1kuciec0the other bits in status are undefined the 0 fields are ignored on write and are 0 on read it is recommended that the user explicitly write them to 0 to insure compatibility with future versions of the netvortex cause coprocessor 0 general register address 13 bd branch delay indicates that the exception was taken in branch or jump delay slot ce coprocessorexceptioninthecaseofacoprocessorusabilityexceptionindicatesthenumber of the responsible coprocessor ip interrupt pending each bit in ip70 indicated an associated unmasked interrupt request exccode the exccode listed above for the different exceptions are stored here when as exception occurs cause is read or written using mtc0 and mtf0 operations the only program writable bits in cause are ip10 which are called software interrupts cause is undefined at reset the 0 fields are ignored on write and are 0 on read epc coprocessor 0 general register address 14 epc is 32bit readonly register which contains the virtual address of the next instruction to be executed following return from the exception handler if the exception occurs in the delay slot of branch epc will hold the address of the branch instruction and bd will be set in cause the branch will typically be re executed following the exception handler3128 2723 22 2116 158 76 5 4 3 2 1 0 cu30 0 bev 0 im70 0 kuo ieo kup iep kuc iec 31 30 2928 2716 158 7 62 10 bd 0 ce10 0 ip70 0 exccode40 0april 2 2001 netvortex lexra proprietary confidential 40 release 19 badvaddr coprocessor 0 general register address 8 badvaddr is 32bit readonly register containing the virtual address instruction or data which generated an adel or ades exception error 342 exception processing entry and exit when an exception occurs the instruction address changes to one of the following locations the kuie stack is pushed kuo ieo kup iep kuc iec ²push kup iep kuc iec 0 0 whichdisablesinterruptsandputstheprograminkernelmodethecodeexccodefortheexceptionsource isloadedintocausesothattheapplicationspecificexceptionhandlercandeterminetheappropriateaction the exception handler should not reenable interrupts until necessary context has been saved to return from the exception the exception handler first moves epc to general register using mfc0 followed by jr operation rfe only pops the kuie stack kup iep kuc iec 0 0 ²pop kup iep kup iep kuc iec this example assumes that kuie were not modified by the exception handler therefore typical sequence of operations to return from the exception handler would be 35 the coprocessor interface ci designers may implement up to three coprocessors to interface with the lx8000 the contents of these coprocessors may include up to thirtytwo 32 32bit general registers and up to thirtytwo 32 32bit controlregisters thegeneralregistersmaybemovedtoandfromtheralusregistersusingmtczmfcz operationsorbeloadedandstoredfromdatamemoryusinglwczswczoperationsthecontrolregisters may only be moved to and from the ralus registers using ctcz cfcz operations lexra supplies simple coprocessor interface ci model allowing the customer to easily interface coprocessor to the netvortex the ci supplies set of control address and data busses that may be tied directly to the coprocessor general and special registers the ci is described in more detail in section6 lx8000 coprocessor interfacereset 0xbfc0_0000 other exceptions bev 0 0x8000_0080 other exceptions bev 1 0xbfc0_0180 mfc0 epc r26 r26 is temporary storage register in the ralu jr r26 rfeapril 2 2001 netvortex lexra proprietary confidential 41 release 19 4 lx8000 instruction extensions 41 context switch and data transfer operations thetablebelowexplainsthedetailsoftheinstructionsthatareusedtocauseacontextswitchandtotransfer data on behalf of context the context switching instructions typically set one or more wait bits in the contexts cxstatus register which prevent the context from being reactivated until its program can usefully resume since thread may wish to wait for notification of up to eight hardware or software events there is user mode instruction postcx which allows another thread to atomically clear any within this processor contextswaiteventbitsforcrossprocessornotificationtheoptionaltestandsetenginemaybeused as described in section9 netvortex test and set engine the instruction mycx allows the program to determine its own context number and if there are multiple processorsinthesystemitsownprocessornumberthisallowsseveralthreadstoexecutethesameprogram but to use their context numbers andor processor numbers to access unique memory regions or remote devices all of these instructions are expected to be executed in user mode and are notsubject to any coprocessor usability exceptions for all of the instructions which cause context switch there is single instruction delay slot that is the instructionimmediatelyfollowingthecontextswitchinginstructionisexecutedinthesamecontextandthat contexts cxpc is loaded with the address of the instruction after the delay slot immediately after the executionofthedelayslotinstructionthenewlyselectedcontextbeginsexecutionattheinstructionspecified by its cxpc register there are restrictions on the type of instruction that can be executed in the delay slot of context switching instructions these restrictions are detailed in note following table16 for several of the instructions the descriptions are nearly identical differing in only few items in order to make it easier for the reader to identify only the differences these are indicated with underlined xt table 16 context switching instructions instruction syntax and description my context mycx rd thecurrentcontextnumberisplacedintord20iftherearemultiple processorsinthesystemthenumberoftheprocessorexecutingthis instruction is placed into rd158 otherwise rd158 is zeroed all other bits of rd are set to zeroes post event to context postcx rs rt bits rt20 are used as the target context cntx bits rs3124 are log icallyandedwithbits158thewaiteventbitsofthecxstatus register for context cntx and that contexts cxstatus register is updated with the result ifamfcxcinstructionisexecutedastheﬁrstinstructionimmediately following the postcx it is unpredictable whether the new or old value of cxstatus is returnedapril 2 2001 netvortex lexra proprietary confidential 42 release 19 context switch uncon ditionalcsw rs bits158thewaiteventbitsfromthiscontextscxstatusregis ter are logically ored with rs3124 and the cxstatus register is updated with the result an unconditional context switch occurs after the execution of this instructions delay slot load word uncached with context switchlwcsw rt displacementbase thedisplacement in bytes is signed 12bit quantity that must be divisibleby 4 since it occupies only 10 bits of the instruction word thedisplacement issignextendedandaddedtothecontentsof base to form the address temp the word addressed by temp is fetched usingasplittransactionandloadedintortthewaitloadbitisset in this contexts cxstatus register while the fetch is in progress an unconditional context switch occurs after the execution of this instruc tions delay slot iftempdoesnotspecifyanaddressinuncachablespacetheresultof the operation is undeﬁned iftemp speciﬁes an address in dmem space the result of the opera tion is undeﬁned iftempisnotwordalignedanaddressexceptionistakenandnocon text switch occurs load twinword uncached with context switchltcsw rt displacementbase thedisplacement in bytes is signed 13bit quantity that must be divisibleby 8 since it occupies only 10 bits of the instruction word thedisplacement is sign extended and added to the contents of the registerbasetoformtheaddress tempthewordaddressedby temp isfetchedusinga twinwordsplittransactionandloadedintort which must be an ven register the w ord addressed b ytemp4 is loaded into rt1 the waitload bit is set in this contexts cxstatus reg ister while the fetches are in progress an unconditional context switch occurs after the execution of this instructions delay slot iftempdoesnotspecifyanaddressinuncachablespacetheresultof the operation is undeﬁned iftemp speciﬁes an address in dmem space the result of the opera tion is undeﬁned iftempisnottwinwordalignedanaddressexceptionistakenandno context switch occurs load quadword uncached with context switchlqcsw rt displacementbase thedisplacement in bytes is signed 14bit quantity that must be divisibleby 16 since it occupies only 10 bits of the instruction word thedisplacement is sign extended and added to the contents of the registerbasetoformtheaddress tempthewordaddressedby temp is fetched using quadword split transaction and loaded into rt which must be register n umber divisib by four the w ord addressed b ytemp4 is loaded into rt1 the w ord addressed b temp8 is loaded into rt2 the w ord addressed b ytemp12 is loaded into rt3 the waitload bit is set in this contexts cxsta register while the fetches are in progress an unconditional text switch occurs after the execution of this instructions delay slot iftempdoesnotspecifyanaddressinuncachablespacetheresultof the operation is undeﬁned iftemp speciﬁes an address in dmem space the result of the opera tion is undeﬁned iftempisnotquadwordalignedanaddressexceptionistakenandno context switch occursinstruction syntax and descriptionapril 2 2001 netvortex lexra proprietary confidential 43 release 19 load twinword ltw rt displacementbase thedisplacement in bytes is signed 13bit quantity that must be divisibleby 8 since it occupies only 10 bits of the instruction word thedisplacement is sign extended and added to the contents of the registerbasetoformtheaddress tempthewordaddressedby temp isfetched and loaded into rt which m ust be an ven register the word addressed b temp4 is loaded into rt1 iftemp is not twinword aligned an address exception is taken if the instruction immediately following ltw attempts to use rt or rt1 the results of that instruction are unpredictable write descriptor wdcsw rs rt deviceid a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 if the optionalcsw xtension is speci ﬁed then bits 6356 of the descr iptor are logically ored with the waitevent bits of this conte xts cxstatus register which is updated with the result the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto the value of the 5bit deviceid ﬁeld and bits 20 all zeroes system bus operation is performed to write bits 630 of the descriptor to the device if the optionalcsw extension is speciﬁed the processor per forms context switch after the execution of this instructions delay slot write descriptor with load word uncached and context switchwdlwcsw rd rs rt deviceid a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 the waitload bit of this conte xts cxstatus register is set the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto the value of the 5bit deviceid ﬁeld and bits 20 all zeroes system bus operation is performed to write bits 630 of the descriptor to the device also requesting an uncached split transaction read word response the processor performs context switch after the execu tion of this instructions delay slot when the processor receives the corresponding read word response from the system bus it is loaded into register rd of the originating contexts general purpose register ﬁle and that contexts waitload ﬂag is cleared write descriptor with load twinword uncached and context switchwdltcsw rd rs rt deviceid a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 the waitload bit of this conte xts cxstatus register is set the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto the value of the 5bit deviceid ﬁeld and bits 20 all zeroes system bus operation is performed to write bits 630 of the descriptor to the device also requesting an uncached split transaction read twinword response the processor performs context switch after the execu tion of this instructions delay slot when the processor receives the corresponding read twinword response from the system bus the ﬁrst returned word is loaded into register rd which must specify an ven register and the second returned word is loaded into rd1 of the originating contexts general purpose register ﬁle and that contexts waitload ﬂag is clearedinstruction syntax and descriptionapril 2 2001 netvortex lexra proprietary confidential 44 release 19 notethefollowingrestrictionsapplytothedelayslotofanycontextswitchinginstructioncswlwcsw ltcsw lqcsw wdcsw wdlwcsw wdltcsw and wdlqcsw all branch or jump type instruction mtcxc instruction wdlwcsw wdltcsw wdlqcsw access to any register loaded by the instruction 42 bit field processing operations table17 explains the details of the instructions used to manipulate bit fields asshowninthefigureforseveraloftheseinstructionsawidthandinsertoffsetspecifyasubfieldofa32bit register that is to be used as target of the instruction for the extiv and insv paired instructions or extii and insi the extract offset and width can specify maximally 32bit subfield which straddles the boundary of two source registers or is completely contained in either one of two potential source registers figure5 insert and extract operations straddle case illustrates the straddle case itisworthnotingthatthestandardmipsinstructionsetincludesbranchonequalandbranchonnotequal instructions therefore the extract instruction can be used to select field that is tested by conditional branch and explicit test instruction is necessary for several of the instructions the descriptions are nearly identical differing in only few items in order to make it easier for the reader to identify only the differences these are indicated with underlined xtwrite descriptor with load quadword uncached and context switchwdlqcsw rd rs rt deviceid a64bitdescriptorisformedwiththecontentsofrsinbits6332and the contents of rt in bits 310 the waitload bit of this conte xts cxstatus register is set the processor constructs system bus addresswithbits318settoasystemspeciﬁcconstantbits73setto the value of the 5bit deviceid ﬁeld and bits 20 all zeroes system bus operation is performed to write bits 630 of the descriptor to the device also requesting an uncached split transaction read quadword response the processor performs context switch after the execu tion of this instructions delay slot when the processor receives the corresponding read quadword response from the system bus the ﬁrst returned word is loaded into register rd which must specify register n umber divisib by four thesecondreturnedwordisloadedintord1thethirdreturnedword is loaded into rd2 and the f ourth returned word is loaded into rd3 of the originating contexts general purpose register ﬁle and that texts waitload ﬂag is cleared nomenclature rs rt rd r0 r31 base r0 r31instruction syntax and descriptionapril 2 2001 netvortex lexra proprietary confidential 45 release 19 figure 5 insert and extract operations straddle case table 17 bit field processing instructions instruction syntax and description set bits immediate seti rt rs width offset theoffsetisavaluepintherange031the widthisavaluemin the range 132 which is encoded in the instruction as 5bit valuemodulo32thatisthevalue32isencodedaszerothe bitsrtmp1paresettoonestheremainingbitsofrtarecop ied from the corresponding bits of rs if mp is greater than 32 the results are unpredictable clear bits immediate clri rt rs width offset theoffsetisavaluepintherange031the widthisavaluemin the range 132 which is encoded in the instruction as 5bit valuemodulo32thatisthevalue32isencodedaszerothe bits rtmp1p are set to zeroes the remaining bits of rt are copied from the corresponding bits of rs if mp is greater than 32 the results are unpredictablewidth widthextract offset 0 set clearextract insert insert offset31 00 63 32 31 31extract from rt extivextii extract from rt insvinsi unmodified fields from rs seti clri insviwidth insert registerapril 2 2001 netvortex lexra proprietary confidential 46 release 19 extract bits for insertion variableextiv rd rs rt thebits rs1510 are decoded as an extraction offset n in the range063 the bits rs95 are decoded as width m in the range 132 modulo 32 the bits rs40 are decoded as an inser tion offset p in the r ange 031 these parameter fieldsof rs are savedintheimpliedregisterinserttheremainingbitsofrsare ignored considering rt to contain the least significant 32 bits of the extraction source 32bit intermediate extraction value temp is generated as follows 1 ifn32 and nm1 32 least significant word only the bits rtmn1narecopiedinto tempm10andtheremainingbitsof temp are set to zeroes 2ifn32andnm131straddletwowordsthebitsrt31n are copied into temp31n0 and the remaining bits of temp are set to zeroes 3 if n31 most significant word only temp310 is set to all zeroes thetempvalueisstoredinrdandalsosavedintheimpliedregis ter insert ifmnisgreaterthan64theresultsofthisinstructionandasub sequent insv instruction are unpredictable insert bits variable ins v rd rs rt this instruction must be coded as the next sequential instruction in the program sequence after an exti v otherwise its results are unpredictable all exceptions are inhibited for the execution of this instruction thisincludeshardwareinterruptsdebugexceptionsandaddress exceptions theparameterfieldsmn pandtheintermediateextractionvalue temparetakenfromtheimpliedregisterinsertasdescribedfor extiv considering rt to contain the most significant 32 bits of theextractionsourcethefinalextractedvalue resultisgenerated as follows 1 ifn32 and nm1 32 the bits temp310 are copied into result310 2ifn32andnm131thebits temp31n0arecopiedinto result31n0 the bits rtnm330 are copied into resultm 132n the remaining bits of result are set to zeroes 3 if n31 the bits rtnm33n32 are copied into resultm10 the remaining bits of result are set to zeroes the bits from resultm10 are copied into rdmp1p the remaining bits of rd are copied from the corresponding bits of rs if mn is greater than 64 or if mp is greater than 32 the results are unpredictableinstruction syntax and descriptionapril 2 2001 netvortex lexra proprietary confidential 47 release 19 extract bits for insertion immediateextiirdrt width offset theoffsetisavaluenintherange031thewidthisavaluemin the range 132 which is encoded in the instruction as 5bit value modulo 32 that is the value 32 is encoded as zero theseparameter fieldsaresavedintheimpliedregisterinsert consideringrttocontaintheleastsignificant32bitsoftheextrac tion source 32bit intermediate extraction value temp is gener ated as follows 1 if nm1 32 least significant word only the bits rtmn 1n are copied into tempm10 and the remaining bits of temp are set to zeroes 2 if nm1 31 straddle two words the bits rt31n are cop ied intotemp31n0 and the remaining bits of temp are set to zeroes thetempvalueisstoredinrdandalsosavedintheimpliedregis ter insert insert bits immediate ins i rd rs rt offset this instruction must be coded as the next sequential instruction intheprogramsequenceafteranexti iotherwiseitsresultsare unpredictable all exceptions are inhibited for the execution of this instruction thisincludeshardwareinterruptsdebugexceptionsandaddress exceptions the parameter fields m n and the intermediate extraction value temparetakenfromtheimpliedregisterinsertasdescribedfor extiitheoffsetisavaluepintherange031consideringrtto contain the most significant 32 bits of the extraction source the final extracted value result is generated as follows 1 if nm1 32 the bits temp310 are copied into result310 2 if nm1 31 the bits temp31n0 are copied into result31 n0 the bits rtnm330 are copied into resultm132n the remaining bits of result are set to zeroes the bits from resultm10 are copied into rdmp1p the remaining bits of rd are copied from the corresponding bits of rs if mp is greater than 32 the results are unpredictable hash to key hash rd rs keysize the5bitkeysizeisavaluekintherange424ifkisoutsidethis rangetheresultsareunpredictablethe32 sourcebitscontained in rs are hashed to form key of k bits the key is stored in rdk 10 the remaining bits of rd are zeroed for given keysize each bit of the key is formed as the logical xorofasubsetofthe sourcebitsforanykeysizethesesubsets are mutually exclusive and exhaustive that is each source bit is included in the xor function of one and only one of the key bits the exact composition of the xor subsets for each keysize is indicated in table18 hash instruction key bit definitioninstruction syntax and descriptionapril 2 2001 netvortex lexra proprietary confidential 48 release 19 nomenclature rt rs rd r0 r31 notes for extiv specifying r0 for rs implies insert extract offsets of 0 and width of 32 insv insi must be coded as the next sequential instruction following extiv extii there is only one insert register in the processor not one per context which only exists to pass information from extivextii to insvinsi the processor inhibits exceptions for insvinsi to ensure that if the extivextii instruction completes the immediately subsequent insvinsi will also complete forextiitheextractoffsetmaynotbe32butstraddleisallowedduetoformatconstraintsthisshould not be problem since the immediate is known at compile time if an offset 32 were needed the next most significant register could be used for rt and the offset reduced by 32 theextivandinsvpairofinstructionsareintendedtoallownumerousnoncontiguousfieldsinapacket to be compacted into single contiguous key even if the alignment of the packet in set of registers is not known until runtime sequence of 3 instructions per field can be used to accomplish this compaction in theexamplein figure6 packetdata isloaded into source registers s1s2ands3andfieldsf1andf2 are to be compacted into destination register d1 however it is not known until run time which of four byte alignmentcasesofthepacketisvalidatruntimer1isloadedwithavaluecorrespondingtothealignment specifically the value needed in bits 1510 of r1 is the twos complement of the alignment in bits single instruction ori r1 r0 n10 loads the proper value for any of the casesmost significant bit encodemsb rd rs rt the 32bit temp is computed as the logical and of rs with rt the6bitresultindicatesthemostsignificantbitthatissetin temp according to the following table where x means dont care temp 00000000 00000000 00000000 00000000 result 0 temp 00000000 00000000 00000000 00000001 result 1 temp 00000000 00000000 00000000 0000001x result 2 temp 00000000 00000000 00000000 000001xx result 3 etc temp 1xxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx result 32 theresult is stored in rd50 the remaining bits of rd are zeroed jump to offset regis terjor rs rt the 13bit jump offset is computed as the logical or of rt120 with rs153 the 32bit target address is computed as follows target3116 rs3116 target153 offset target20 zeroes the other bits of rt and rs are ignored the program unconditionally jumps to the target address with delayofoneinstructionjustlikethejrinstructionhandlingofthe delay slot instruction for exceptions is the same as for the jr instructioninstruction syntax and descriptionapril 2 2001 netvortex lexra proprietary confidential 49 release 19 figure 6 packet field compaction with variable alignment the following code sequence assumes that r1 has been initialized as needed according to the case in question as shown common code path is used regardless of the alignment note that r0 is 0 source and dont care destination the above example shows how the packet alignment is handled with value held in single register placed in the appropriate bit position so that it can be subtracted from the otherwise fixed extraction offsets the widths and insertion offsets are invariant this paradigm works provided that two conditions are met 1 the variability in alignment never causes field to straddle different pairs of source registers sufficient condition is if the extracted field does not cross word boundary in the nominal case in other words the default extract offset is greater than 31 2 the insertion width and alignment never cause field to straddle word boundary in the destination key this problem can be minimized by reordering the fields in the destination key but in the worst case field to may be split into two parts to avoid the issue if necessary both of these restrictions can always be satisfied by splitting some source fields into two fields r1 contains the value to be subtracted from the 6bit default extraction offsets addiu r2 r1 f1_offe10 f1_wid5 f1_offi extiv r0 r2 s2 f1 is from s1 andor s2 insv d1 r0 s1 insert f1 into d1 addiu r2 r1 f2_offe10 f2_wid5 f2_offi extiv r0 r2 s3 f2 is from s2 andor s3 insv d1 d1 s2 merge f2 into d1 more fields handled the same ways1 s2 s3 f1 r1 0 r1 16 10 r1 24 10r1 8 10f2 f1 f2 f1 f2 f1 f2 f1f2d1april 2 2001 netvortex lexra proprietary confidential 50 release 19 table 18 hash instruction key bit deﬁnition keysize keybit source bits included in xor to form key bit 43 2 1 028 24 20 16 12 8 4 0 29 25 21 17 13 9 5 1 30 26 22 18 14 10 6 2 31 27 23 19 15 11 7 3 keysize keybit source bits keysize keybit source bits 54 3 2 1 026 25 16 9 3 0 28 24 20 12 8 4 29 21 17 13 5 1 30 22 18 14 10 6 2 31 27 23 19 15 11 765 4 3 2 1 026 24 18 10 9 1 25 19 16 11 3 0 28 20 12 8 4 29 21 17 13 5 30 22 14 6 2 31 27 23 15 7 76 5 4 3 2 1 025 16 9 1 26 24 18 10 19 11 3 0 28 20 12 8 4 29 21 17 13 5 30 22 14 6 2 31 27 23 15 787 6 5 4 3 2 1 024 16 8 0 25 17 9 1 26 18 10 2 27 19 11 3 28 20 12 4 29 21 13 5 30 22 14 6 31 23 15 7 keysize keybit source bits keysize keybit source bits keysize keybit source bits 98 7 6 5 4 3 2 1 026 16 9 24 8 0 25 17 1 18 10 2 27 19 11 3 28 20 12 4 29 21 13 5 30 22 14 6 31 23 15 7109 8 7 6 5 4 3 2 1 026 13 9 20 16 3 24 8 0 25 17 1 18 10 2 27 19 11 28 12 4 29 21 5 30 22 14 6 31 23 15 71110 9 8 7 6 5 4 3 2 1 030 7 26 13 9 20 16 3 24 8 0 25 17 1 18 10 2 27 19 11 28 12 4 29 21 5 22 14 6 31 23 15 1211 10 9 8 7 6 5 4 3 2 1 0 7 3 30 26 13 9 20 16 24 8 0 25 17 1 18 10 2 27 19 11 28 12 4 29 21 5 22 14 6 31 23 151312 11 10 9 8 7 6 5 4 3 2 1 020 13 7 3 30 26 25 9 16 0 24 8 17 1 18 10 2 27 19 11 28 12 4 29 21 5 22 14 6 31 23 151413 12 11 10 9 8 7 6 5 4 3 2 1 030 13 20 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 4 29 21 5 22 14 6 31 23 15april 2 2001 netvortex lexra proprietary confidential 51 release 19 1514 13 12 11 10 9 8 7 6 5 4 3 2 1 029 13 30 4 20 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 14 6 31 23 151615 14 13 12 11 10 9 8 7 6 5 4 3 2 1 020 4 29 13 30 14 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 151716 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 4 20 29 13 30 14 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 15 1817 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 029 4 20 13 30 14 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 151918 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 014 29 4 20 13 30 23 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 152019 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 023 14 29 4 20 13 30 7 19 3 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 15 2120 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 3 23 14 29 4 20 13 30 7 19 26 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 152221 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 026 3 23 14 29 4 20 13 30 7 19 10 25 9 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 152322 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 9 26 3 23 14 29 4 20 13 30 7 19 10 25 16 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 15keysize keybit source bits keysize keybit source bits keysize keybit source bitsapril 2 2001 netvortex lexra proprietary confidential 52 release 19 43 cross context access operations table19explainsthedetailsofinstructionsthatareusedtoaccessthegeneralregistersorthecontextcontrol registers of another context for the control registers it is also possible for thread to access its own cxstatus register the target context for all of these instructions is specified in new lexra coprocessor 0 register called movecx that register is itself accessed with mtlxc0 and mflxc0 variants of the mips standard mtc0 and mfc0 instructions these new instructions are used to access lexra defined coprocessor 0 registers that are not in the standard mips coprocessor 0 space the encoding of these instructions which use the cop0 major opcode is described in section45 it is expected that these instructions will only be used in kernel mode therefore they are all subject to the coprocessor unusable exception for coprocessor 0 as are the mtlxc0 and mflxc0 instructions table 19 cross context access instructionskeysize keybit source bits 2423 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 016 9 26 3 23 14 29 4 20 13 30 7 19 10 25 0 24 8 17 1 18 2 27 11 28 12 21 5 22 6 31 15 instruction syntax and description move from context general registermfcxg rd gt bits movecx20 are used to determine the target context cntx thecontentsofgeneralregistergtincontext cntxareloadedinto the current contexts general register rd move to context gen eral registermtcxg rt gd bits movecx20 are used to determine the target context cntx the general register gd in context cntx is loaded from the tents of the current contexts general register rtapril 2 2001 netvortex lexra proprietary confidential 53 release 19 nomenclature notes execution of mtcxc rt cxpc with movecx current context attempt to change the currently executing contexts cxpc results in unpredictable operation to examine its own cxstatus register thread can execute this sequence 44 checksum addition table20 explains the instruction that may be used to calculate checksum for an internet protocol header using 16bit ones complement addition table 20 checksum addition instructions notes in ones complement arithmetic there are two representations of zero 0x0000 0 and 0x ffff0 addition of nonzero quantities can never result in 0 only 0 addition of 0 to either 0 or 0 results in 0 this instruction can be used to generate or check the 16bit checksum used in internet packets without regard to halfword alignment all of the 32bit words to be included are incrementally added using acs2 final 16bit shift and one more acs2 instruction is used to fold the checksum into 16 bitsmove from context control registermfcxc rd ct bits movecx20 are used to determine the target context cntx thecontentsofcontrolregisterctincontext cntxareloadedinto the current contexts general register rd move to context trol registermtcxc rt cd bits movecx20 are used to determine the target context cntx thecontrolregistercdincontext cntxisloadedfromthecontents of the current contexts general register rt rt rd gt gd r0 r31 cd ct cxstatus cxpc mycx r1 mtlxc0 r1 movecx mfcxc r2 cxstatus instruction syntax and description dual add for checksumacs2 rd rs rt dual 16bit ones complement addition considering all quantities as unsigned 16bit integers add the contents of rs1500 to rt1500 and independently add the contents of rs3116 to rt3116foreachindependentadditionifthereisacarryoutof the most significant bit of its result add one to that result to form its final result the final results of the two additions are placed in rd1500 and rd3116 r1 packetaddr get packet address lw r2 0r1 get many words lw r3 4r1instruction syntax and descriptionapril 2 2001 netvortex lexra proprietary confidential 54 release 19 45 lx8000 instruction summary and encoding table 21 instruction summarylw r4 8r1 lw r5 12r1 lw r6 16r1 lw r7 20r1 acs2 r2 r2 r3 add them together acs2 r2 r2 r4 acs2 r2 r2 r5 acs2 r2 r2 r6 acs2 r2 r2 r7 srl r3 r2 16 fold over accumulator acs2 r2 r2 r3 r2150 has the answer instruction description context control operations and data transfers mycx rd read my context postcx rs rt post event to context csw rs context switch ltw rt dispbase load twinword lwcsw rt dispbase load word uncached with context switch ltcsw rt dispbase load twinword uncached with context switch lqcsw rt dispbase load quadword uncached with context switch wdcsw rs rt deviceid write descriptor to device with context switch wdlwcsw rd rs rt dev write descriptor to device and load wordtwinword quadword uncached with context switchwdltcsw rd rs rt dev wdlqcsw rd rs rt dev bit field operations seti rt rs width offset set subfield to ones clri rt rs width offset clear subfield to zeroes extiv rd rs rt extract subfield and prepare for insertion variable insv rd rs rt insert extracted subfield variable extii rd rt width offset extract subfield and prepare for insertion immediate insi rd rs rt offset insert extracted subfield variable immediate acs2 rd rs rt dual 16bit ones complement add for checksum hash rd rs keysize hash data to keyapril 2 2001 netvortex lexra proprietary confidential 55 release 19 msb rd rs rt find most significant bit jor rs rt jump to offset register crosscontext access operations mfcxg rd gt move from context gpr mtcxg rt gd move to context gpr mfcxc rd ct move from context control register mtcxc rt cd move to context control registerinstruction descriptionapril 2 2001 netvortex lexra proprietary confidential 56 release 19 451 lx8000 instruction formats the lexra formats are introduced into the mips instruction set by designating single iformat as lexop2 then using the inst50 subop field to permit up to 64 new lexra opcodes thus the new opcodes model the mips special opcodes encoded in rformat the diagrams below illustrate the lexop2 codes using iformat 011_110 which is unused in the mips iv isa the default object code for lexop2 is 011_110 however the location can be changed using static reconfiguration this helps insure compatibility of the extensions with future isa extensions released by mips technologies inc this section also provides detail on the mflxc0mtlxc0 instructions which are variants of the mips standardmfc0mtc0instructionsthesevariantsprovideaccesstoaspaceoflexradefinedcoprocessor0 registersapril 2 2001 netvortex lexra proprietary confidential 57 release 19 452 load formats 453 write descriptor formats31 26 25 21 20 16 15 6 5 0 assembler mnemoniclexop2 011 110 base rt immediatelexra subop lwcsw lexop2 base rt displacement4 lwc ltcsw lexop2 base rteven 0 displacement8 ltc ltw lexop2 base rteven 0 displacement8 ltw lqcsw lexop2 base rtquad 00 displacement16 lqc 655 1 0 6 base rt selects general register r0 r31 rteven selects general register evenodd pair r0r1 r2r3 r30r31 rtquad selects general register quad r0r1r2r3 r28r29r30r31 displacement signed 2scomplement number in bytes 31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 rs rt rd deviceidlexra subop wd lexop2 rs rt 0 deviceid wd wdcsw lexop2 rs rt 0 deviceid wdc wdlwcsw lexop2 rs rt rd deviceid wdlwc wdltcsw lexop2 rs rt rdeven0 deviceid wdltc wdlqcsw lexop2 rs rt rdquad00 deviceid wdlqc 65 555 6 rs rt rd selects general register r0 r31 rdeven selects general register evenodd pair r0r1 r2r3 r30r31 rtquad selects general register quad r0r1r2r3 r28r29r30r31 deviceid indicates bits 73 of system device addressapril 2 2001 netvortex lexra proprietary confidential 58 release 19 454 context checksum and bit field formats 31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 rs rt rd 0lexra subop mycx lexop2 0 0 rd 0 mycx postcx lexop2 rs rt 0 0 postcx csw lexop2 rs 0 0 0 csw extiv lexop2 rs rt rd 0 extiv insv lexop2 rs rt rd 0 insv acs2 lexop2 rs rt rd 0 acs2 msb lexop2 rs rt rd 0 msb jor lexop2 rs rt 0 0 jor 65555 6 31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 rs rt widthkeysize offsetlexra subop seti lexop2 rs rt width offset seti clri lexop2 rs rt width offset clri extii lexop2 width rt rd offset extii insi lexop2 rs rt rd offset insi hash lexop2 rs 0 rd keysize hash 65555 6 rs rt rd selects general register r0 r31 width 5bit encoding of the width parameter modulo 32 ie the value 32 is represented as 0 offset 5bit encoding of the offset parameter in the range 031 keysize 5bit encoding of the keysize parameter in the range 424april 2 2001 netvortex lexra proprietary confidential 59 release 19 455 cross context move format 456 lexracoprocessor0 register access instructions these are notlexop2 instructions they are variants of the standard mtc0 and mfc0 instructions that allowaccesstothelexracoprocessor0registerslistedbelowaswithanycop0instructionacoprocessor unusable exception is taken in user mode if the cu0 bit is 0 in the cp0 status register when these instructions are executed31 26 25 21 20 16 15 11 10 6 5 0 assembler mnemoniclexop2 011 110 0 rtgtct rdgdcd 0lexra subop mfcxg lexop2 0 gt rd 0 mfcxg mtcxg lexop2 0 rt gd 0 mtcxg mfcxc lexop2 0 ct rd 0 mfcxc mtcxc lexop2 0 rt cd 0 mtcxc 65555 6 rt rd selects general register r0 r31 in the current context gt gd selects general register r0 r31 in the context specified by movecx ct cd selects context register in the context specified by movecx 00000 cxstatus 00001 cxpc others reserved 31 26 25 21 20 16 15 11 10 0 assembler mnemoniccop0 010 000 copz rs rt rd 0 mflxc0 cop0 mflx 00011rt rd 000 0000 0000 mtlxc0 cop0 mtlx 00111rt rd 000 0000 0000 6555 1 1 rt selects general register r0 r31 rd selects lexra coprocessor 0 register 00000 estatus 00001 ecause 00010 intvec 00011 cvstag for lexra diagnostic purposes only 00100 movecx 00101 reserved 0011x reserved 01xxx reserved 1xxxx reservedapril 2 2001 netvortex lexra proprietary confidential 60 release 19 457 lexra subop bit encodings table 22 lexra subop bit encoding inst20 inst53 0 1234567 0 hash seti acs2 insv insi 1 jor msb clri extiv extii 2 3 4 mycx mfcxg mtcxg 5 postcx mfcxc mtcxc 6 csw lqc wdc wdlqc ltc lwc wdltc wdlwc 7 wd ltwapril 2 2001 netvortex lexra proprietary confidential 61 release 19 5 lx8000 local memory 51 local memory overview thischapterdescribeshowmemoriesareconfiguredandconnectedtothelx8000usingthelocalmemory interfaces lmis this section provides brief summary of the conventions and supported memories section52 describes the control register that allows software control over certain aspects of the lmis the subsequent sections cover each of the lmis in detail this chapter also discusses configuration options and the ports that customers must access to connect application specific ram devices that are used by the lx8000 lmis all of the signals between the processor core the lmis rams and the system bus controller are automatically configured by lconfig the netvortex configuration tool lconfigalso produces documentation of the exact rams required for the chosen configuration settings and writes ram models used for rtl simulation thelmisconnecttoramsthatservicethelx8000processorslocalinstructionanddatabussesthelmis alsoprovidethepathwaysfromtheprocessortothesystembusthelx8000includesanlmiforeachofthe local memory types the sizes of the rams are customer selectable the lx8000 lmis directly support synchronous rams that register the address write data and control signals at the ram inputs the lmis also supply redundant read enable and chip select lines for each ram which may be required for some ram types lexra supplies an integration layer for the lmis and the memory devices connected to them in this layer memory devices are instanced as generic modules satisfying the depth and width requirements for each specific memory instance the lconfigutility supplies summary of the memory devices required for the chosen configuration in most cases customers simply need to write wrapper that connects the generic module port list to technology specific ram instance inside the ram wrapper the lx8000 is configurable to work with rams with write granularity of 8 bits byte or 32 bits word byte write granularity results in more efficient operation of store byte and store halfword instructions table23 summarizes the lmis that can be integrated on the local busses note that the lx8000 used in netvortex does not include an instruction cache or data cache table 23 local memory interface modules 52 cache control register cctl cctl coprocessor 0 general register address 20 when reading this register the contents of the reserved bits are undefined when writing this register the contents of the reserved bits should be preservedname description imem instruction ram dmem data ram or rom 316 5 4 30 reserved imemoff imemfill reservedapril 2 2001 netvortex lexra proprietary confidential 62 release 19 changes in the contents of the cctl register are observed in the w stage however these changes affect instruction fetches currently in progress in the i stage and data load or store operations in progress in the m stage the imemfill and imemoff bits of the cctl register control the contents and use of any local imem memory configured into the lx8000 when the lx8000 is reset the lmi clears an internal register to indicate that the entire imem lmi contents are invalid transition from 0 to 1 on imemfill causes the lmi to initiate series of line read operations to fill the imemcontentstheaddressesusedforthesereadsaredefinedbytheconfiguredbaseandtopaddresses oftheimemdescribedinsection53theprocessorstallswhiletheentireimemcontentsarefilledbythe lmi thereafter the lmi sets its internal imem valid bit and will service any access to the imem range from the local imem memory the time that an imem fill takes to complete is the number of line reads needed to fill the imem range multiplied by the latency of one line read assuming there is other system bus traffic atransitionfrom0to1onimemoffcausesthelmitoclearitsinternalimemvalidbittousetheimem again an application must reinitialize the imem contents through the imemfill bit of the cctl register 53 instruction memory imem lmi theimemlmisuppliestheinterfaceforanoptionallocalinstructionstoretheimemservesafixedrange of the physical address space determined by configuration settings in lconfig the imem contents are filled and invalidated under the control of the cp0 cctl register described in section52 cache control register cctl the imem module services instruction fetches that falls within its configured range the imemisaconvenientlowcostalternativetoacachethatmakesinstructionmemoryavailabletothecorefor highspeed access the configurations supported by imem and the synchronous rams required for each are summarized in table24 table 24 imem conﬁgurations table25liststheimemsignalsthatareconnectedtoapplicationspecificmodulesthe iw_prefixindicates signalsthataredrivenbytheimemlmimoduleandreceivedbyramsthe iwr_prefixindicatessignals thataredrivenbyramsandreceivedbytheimemlmithe cfg_prefixidentifiesconfigurationportsonconﬁguration imem_inst ram local instruction ram ram required 1k bytes 128 x 64 bits 2k bytes 256 x 64 bits 4k bytes 512 x 64 bits 8k bytes 1024 x 64 bits 16k bytes 2048 x 64 bits 32k bytes 4096 x 64 bits 64k bytes 8192 x 64 bits 128k bytes 16384 x 64 bits 256k bytes 32768 x 64 bitsapril 2 2001 netvortex lexra proprietary confidential 63 release 19 the imem lmi that are typically wired to constant values the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table24 thecfg_wires define where the imem is mapped into the physical address space this configuration information defines the local bus address region of the imem it also determines the address of the external resources which are accessed when an imem miss occurs the lconfigutility supplied by lexra will verify thattheconfiguredaddressrangedoesnotinterferewithotherregionsdefinedfornetvortexthesizeofthe memory region must be power of two and must be naturally aligned table 25 imem ram interfaces the irom lmi supplies the interface for an optional readonly local instruction store the irom serves fixed range of the physical address space determined by configuration settings in lconfig the irom is convenientlowcostalternativetoacachethatmakesreadonlyinstructionmemoryavailabletothecorefor highspeed access 54 scratch pad data memory dmem lmi the dmem lmi supplies the interface for scratch pad data ram attached to the lx8000 local bus the dmem module services in any cacheable or uncacheable data read or write operation that falls within its configured range also because write operation to the dmem is never sent to the lbc writes to dmem will not cause the lbc to stall the processor due to full write buffer condition theconfigurationssupportedbythedmemandthesynchronousramsrequiredforeacharesummarized in the table26 for netvortex 128bit wide dualport rams are used and the second port is connected to the processors block transfer engine bte table 26 dmem conﬁgurationssignal description iw_instindex imem index iwr_instrd instruction read data iw_instwr instruction write data iw_instwen10 instruction ram write enable iw_instren instruction ram read enable iw_instcsn instruction ram chip select cfg_iwbase3110 conﬁgured base address modulo 1k bytes cfg_iwtop1710 conﬁgured top address bits that may differ from base conﬁguration dmem_data ram 64bit dmem_data ram 128bit local data ram ram required ram required 1k bytes 128 x 64 bits 64 x 128 bits 2k bytes 256 x 64 bits 128 x 128 bitsapril 2 2001 netvortex lexra proprietary confidential 64 release 19 table27 lists the dmem signals that are connected to application specific modules the dw_prefix indicates signals that are driven by the dmem lmi module and received by rams the dwr_prefix indicates signals that are driven by rams and received by the dmem lmi the cfg_prefix identifies configurationportsonthedmemlmithataretypicallywiredtoconstantvaluesthewidthoftheindexand data lines depends upon the ram connected to the lmi and can be inferred from table26 thecfg_wires define where the dmem is mapped into the physical address space this configuration informationdefinesthelocalbusaddressregionofthedmemitisnotpossibleforanydmemreferenceto result in an operation on the system bus the lconfigutility supplied by lexra will verify that the configured address range does not interfere with other regions defined for netvortex the size of the memory region must be power of two and must be naturally aligned table 27dmem ram interfaces4k bytes 512 x 64 bits 256 x 128 bits 8k bytes 1024 x 64 bits 512 x 128 bits 16k bytes 2048 x 64 bits 1024 x 128 bits 32k bytes 4096 x 64 bits 2048 x 128 bits 64k bytes 8192 x 64 bits 4096 x 128 bits 128k bytes 16384 x 64 bits 8192 x 128 bits 256k bytes 32768 x 64 bits 16384 x 128 bits signal description dw_dataindex decoded data ram index dwr_datard data ram read data dw_datawr data ram write data dw_datawen data ram write enable dw_dataren data ram read enable dw_datacsn data ram chip select cfg_dwbase3110 conﬁgured base address modulo 1k bytes cfg_dwtop1710 conﬁgured top address bits that may differ from baseconﬁguration dmem_data ram 64bit dmem_data ram 128bitapril 2 2001 netvortex lexra proprietary confidential 65 release 19 6 lx8000 coprocessor interface thelx8000processorprovidescustomeraccesspointsforthecoprocessorinterfacesthissectionprovides description of these access points attachment of memory devices to the lmis the system bus and the ejtag interface are described in separate chapters 61 attaching coprocessor using the coprocessor interface ci acoprocessormaycontainupto32generalregistersandupto32controlregisterseachoftheseregistersis up to 32 bits wide typically programs use the general registers for loading and storing data on which the coprocessor operates data is moved to the coprocessors general registers from the cores general registers with the mtcz instruction data is moved from the coprocessors general registers to the cores general registers with the mfcz instruction main memory data is loaded into or stored from the coprocessors general registers with the lwcz and swcz instructions programs may load and store the coprocessors control registers from the cores general registers with the ctczandcfczinstructionsrespectivelyprogramsmaynotloadorstorethecontrolregistersdirectlyfrom main memory the coprocessor may also provide condition flag to the core the condition flag can be bit of control registeroralogicalfunctionofseveralcontrolregistervaluestheconditionflagistestedwiththebcztand bczfinstructionstheseinstructionsindicatethattheprogramshouldbranchiftheconditionistruebczt or false bczf 62 coprocessor interface ci signals the ci provides the mechanism to attach the custom coprocessor to the core the ci snoops the instruction bus for coprocessor instructions and then gives the coprocessor the signals necessary for reading or writing the general and control registers table 28 coprocessor interface signals signal direction description czcondin input cop branch ﬂag czrd_addr40 output cop read address czrhold output cop hold condition one stalls coprocessor czrd_gen output cop general register read command czrd_con output cop control register read command czrd_data310 input cop read data czwr_addr40 output cop write address czwr_gen output cop general register write command czwr_con output cop control write address command czwr_data310 output cop write data czinvld_m output cop invalid instruction ﬂag one indicates invalid instruction in m stageapril 2 2001 netvortex lexra proprietary confidential 66 release 19 theaddressesoutputdataandcontrolsignalsaresuppliedtotheuserscoprocessorontherisingedgeofthe system clock in the case of read cycle the coprocessor must supply the data from either the control or generalregisteronczrd_databytheendofthesamecyclesimilarlythewriteofdatafromczwr_data to the addressed control or general register must be complete by the end of the cycle the ci incorporates forwarding path so that data which is written in instructionn can be read in instruction n 2 the coprocessor registers should be implemented as positiveedge flipflops using the netvortex system clock 63 coprocessor write operations duringacoprocessorwritethecisendsczwr_addrandczwr_dataandassertseitherczwr_genor czwr_con the coprocessor must ensure that the coprocessor completes the write to the appropriate register on the subsequent rising edge of the clock the target register is decoding of czwr_addr czwr_gen and czwr_con use these instructions to cause coprocessor write lwcz mtcz and ctcz 64 coprocessor read operations during coprocessor read the ci sends czrd_addr and asserts either czrd_gen or czrd_con the coprocessor must return valid data through czrd_data in the following clock cycle if the core asserts czrhold indicating that it is not ready to accept the coprocessor data the coprocessor must hold the previous value of czrd_data the target register for the read is decoding of czrd_addr czrd_gen and czrd_con the instructions causing coprocessor read are swcz mfcz and cfcz the cpu stalls the pipeline so that the program can access data read by coprocessor instruction in the immediatelyfollowinginstructionforexampleifanmfczinstructionreadsdatafromthecoprocessorand stores it in the cores general register 4 the program can get access to that data in the following instruction when the core initiates coprocessor read the coprocessor must return valid data in the following clock cycle the coprocessor cannot stall the cpu applications must ensure that the source code does not access invalid coprocessor data if the coprocessor operations take several clock cycles to complete this is done in one of three ways ensure that code does not access data from the coprocessor until n instructions after the coprocessor operation has stared this is the least desirable method as it depends on the relative execution of the core and coprocessor it can also complicate software debug have the coprocessor send an interrupt to the core and the service routine for that interrupt accesses the appropriate coprocessor registers havethecoprocessorsettheczcondinflagwhenitsoperationiscompletethesourceczxcpn_m output copexceptionﬂagoneindicatesexception in m stage czrd_cntx20 output cop read context number czwr_cntx20 output cop write context number mfc2 4 3 move from cop2 to cpu register 4 subu 5 4 2 subtract r2 from r4 and store in 5signal direction descriptionapril 2 2001 netvortex lexra proprietary confidential 67 release 19 code can poll the flag as shown in the example below 65 coprocessor interface and pipeline stages coprocessorwritesoccurinthewstageoftheinstructionpipelineforcoprocessorreadsthecoregenerates address rd_gen and rd_con signals during the s stage and the coprocessor returns data during the stage whichispassedbythecitothecoreinthemstagethecoreintroducesapipelinebubbleaftercoprocessor instructions to ensure that the result of mtcz instruction can be used by the immediately following instruction in particular if there are backtoback mtcz and mfcz instructions that access the same coprocessor register the pipeline bubble still does not allow cycle between the w stage write and stage read as required in this case special forwarding path within the ci is used that is the true data from the coprocessor is ignored instead the exact data from the mtcz is used mtc2 i d s m w bubble i d mfc2 i d s m w data forwarded by ci from mtc2 wr_gen w x rd_gen s x rd_datae x theforwardingpathcancausesideeffectsifthecoprocessordoesnotimplementallofthebitsofaregister contains readonly bits or updates the register value upon reading the register in such cases the mfc2 instructionreturnsdifferentdatafromwhatitwouldifthecoredidnotactivatetheforwardingpathtoavoid the forwarding path another instruction must be inserted between the mtc2 and mfc2 mtc2 i d s m w bubble i d foo i d s m w mfc2 i d s m w read data from coprocessor wr_gen w x rd_datae x 651 pipeline holds thecoprocessormustregisterthereadaddressandthecontrolsignalsrd_genandrd_conitmustholdthee stage registered values of these signals when cz_rhold is active high and should make the read data output function of the stage registered read address and control signals thewr_addrwr_datawr_genandwr_consignalsneednotberegisteredthecoprocessormaydecodethese w stage signals directly to the appropriate register 652 pipeline invalidation under certain circumstances the instruction pipeline can contain an instruction that must be discarded thismtc2 2 3 store data to cop2 general register 3 ctc2 3 5 set cop2 control register 5 to start nop loop bc2f loop branch back to loop if czcondin bit off nop branch delay slot mfc2 4 7 get results from cop2 general register 7april 2 2001 netvortex lexra proprietary confidential 68 release 19 can be due to mispredicted branches cache misses exceptions inserted pipeline bubbles etc in such cases the ci may decode an instruction that must actually be discarded for the coprocessor writetype instructions the ci will only issue the w stage control signals wr_gen and wr_con for valid instructions the coprocessor does not need to qualify these controls forthecoprocessorreadtypeinstructionsthecimayissuethesstagecontrolsignalsrd_genandrd_confor instructions that must be discarded if the coprocessor can tolerate speculative reads then it need not qualify those signals however if the coprocessor performs destructive reads such as updating fifo pointer upon read then it must use the qualifying signals cz_xcpn_m and cz_invld_m as follows thesignalcz_xcpn_msignalisusedtodiscardanysstagefromcird_genorrd_consignalandanye stage registered in the coprocessor rd_gen or rd_con signal it indicates that preceding instruction in the pipe has taken an exception and that subsequent instructions in the pipe must be discarded the signal cz_invld_m signal is used to invalidate the operation of the current instruction in the m stage this can be for various reasons not limited to an exception on preceding instruction if the coprocessor cannot tolerate speculative reads it must register an m stage version of rd_gen and rd_con the coprocessor must use the cz_rhold signal to hold this m stage version as well as the stage version if cz_invld_m is asserted then any such m stage signals must be discarded to summarize rd_gen or rd_con instruction can retire only if it reaches the m stage and neither cz_rhold nor cz_invld_m is assertedapril 2 2001 netvortex lexra proprietary confidential 69 release 19 7 lx8000 ejtag 71 introduction given the increasing complexity of soc designs the nature of embedded processordesign debug hardware and software and the timetomarket requirements of embedded systems debug solution is needed which allows onchip processor visibility in costeffect io constrained manner lexrasejtagsolutionmeetsallsuchrequirementsitusesexistingieeejtagpins1aswellasfastbring uponnewdesignsitprovidesawayofdebuggingalldevicesaccessibletotheprocessorinthesamewaythe processor would access those devices itself using ejtag debug probe can access all the processor internalregistersandcachesitcanalsoaccessdevicesconnectedtothelexrabusbypassinginternalcaches and memories software debug is enhanced by ejtag features that allow singlestepping through code and halting on breakpoints hardware and software address and data with masking for debugging problems that are artifacts of realtime interactions ejtag gives realtime program counter trace capabilities from which an accurate program execution history is derived for the codesystem perspective pc profiling provides statistical analysis of code usage to aim code optimization 72 overview adebughostcomputercommunicatestotheejtagprobethrougheitheraserialorparallelportorethernet connection the probe in turn communicates to the netvortex ejtag hardware via the included ieee 11491jtaginterfacethroughtheuseofthejtagtapcontrollerprobedataisshiftedintototheejtag data and control registers in the lx8000 to respond to processor requests dma into system memory configure the ejtag control logic enable singlestep mode or configure the ejtag breakpoint registers through the use of the ejtag control registers the user can set hardware breakpoints on the instruction cache address data cache address or data cache data values when ejtag is included in configuration physical address range 0xff20_0000 to 0xff3f_ffff is reserved for ejtag use only and should not be mapped to any other device currentlyembeddedperformanceincepiandgreenhillsincprovideejtagdebuggersandprobesfor the netvortex information on these products is available at the following web sites epi inc httpwwwepitoolscom green hills inc httpwwwghscom lx8000 ejtag implements all required features of version 200 of the ejtag specification and includes support for the following features processor access of host via addressing of probe memory space host probe can dma directly into system memory or io devices hardware breakpoints on internal instruction and data busses singlestep execution mode 1 with the internal pc trace buffers available in netvortex the full ejtag featureset can be accessed through just 4 jtag pins tck tdi tdo and tmsapril 2 2001 netvortex lexra proprietary confidential 70 release 19 realtime program counter trace debug exception and two new debug instructions one for raising debug exception via software and one for returning from debug exception 721 ieee jtagspeciﬁc pinout ieee jtag pins used by ejtag are shown below these are required for all ejtag implementations jtag_trst_n is an optional pin in netvortex with internal pc trace buffers it is not used table 29 ejtag pinout table 30 ejtag ac characteristics1 table 31 ejtag synthesis constraints2signal name direction description jtag_tdo_nr output serial output of ejtag tap scan chain jtag_tdi input serial input to ejtag tap scan chain jtag_tms input test mode select connected to each ejtag tap controller jtag_clock input jtag clock connected to each ejtag tap controller jtag_trst_n input tap controller reset connected to each ejtag tap controllera this pin is optional in multiprocessor conﬁgurations signal parameter condition min max unit jtag_clock frequency 1 40 mhz duty cycle 4060 6040 jtag_tms setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdi setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdo_nr outputdelaytckfallingedgetotdo 18v 0 7 ns 1 based on epi interface speciﬁcations for majictm and majicplus tmsignal name probe budget core budget slack remaining for other logic jtag_tdo_nr 0 to 7ns 115ns 135 to 205ns jtag_tdi 5ns 135ns 65ns jtag_tms 5ns 135ns 65ns 2 based on 25ns jtag clock periodapril 2 2001 netvortex lexra proprietary confidential 71 release 19 73 single processor pc trace the lx8000 ejtag includes support for realtime program counter trace pc trace when in pc trace mode the lx8000 will serially output new value of the program counter whenever change in program control occurs ie context switch branch or jump instruction or an exception when the pc trace option is set to export in lconfig the following signals will be output from the lx8000 dclk pcst and tpc these are described in more detail in the following subsections the dclk output is used to synchronize the probe with the lx8000s sysclk the pcst pc trace status signals are used to indicate the status of program execution example status indications are sequential instruction pipeline stall branch or exception the tpc pins output the value of the pc every time there is change of program control 731 pc trace dclk debug clock the maximum speed allowed for the debug clock dclk output is 100mhz as an epi probe requirement as cores typically run in excess of this speed dclk can be set to divided down value of sysclk this is set by the dclk n parameter in lconfig which indicates the ratio of sysclk frequency to dclk 1 2 3 or 4 732 pc trace pcst program counter status trace theprogramcounterstatuspcstoutputcomprisesnsetsof3bitpcstvalueswherenisconfigurable as123or4via lconfigapcstvalueisgeneratedeverysysclkcyclewhendclkisslowerthanthe lx8000s sysclk up to n pcst values are output simultaneously 733 pc trace tpc target program counter the bus width of the target program counter tpc output is user configured in lconfig via the m parametertobeoneof124or8bitswhenchangeinprogramflowoccursthecurrentpcvalueissentout oftpcasthepcis32bitswidethenumberoftpcpinsaffectshowquicklythepcissentforexample if the tpc is 4 bits wide the pc will take 8 dclk cycles to be sent if another change in flow occurs while thepcofthepreviouschangeisbeingtransmittedthenewpcwillbesentandtheremainderoftheprevious pc will be lost the tpc bus also outputs the exception type when an exception occurs the exception type fieldwidth is either3or4bitsdependingonwhetherornotvectoredinterruptsarepresentthisiscoveredinmoredetail below toreducepinoutthetdooutputisusedfortheleastsignificantbitoftpcortheonlybitifmissetto1april 2 2001 netvortex lexra proprietary confidential 72 release 19 734 singleprocessor pc trace pinout table 32 singleprocessor pc trace pinout table 33 singleprocessor pc trace ac characteristics1 735 vectored interrupts and pc trace the ejtag pc trace facility specifies 3bit code be output on the tpc output when an exception occurs thepcstpinsgivetheexpcodeinordertodistinguishtheeightvectoredinterruptsinthenetvortexfrom all other exceptions 4bit code is used instead for all exceptions otherthan vectored interrupts the most significant bit of the 4bit code is zero and the remaining 3bits are the standard 3bit code note that this includes the standard software and hardware interrupts numbered 0 through 7 for vectored interrupts the most significant bit is always 1 the 4bit code is simply the number of the vectored interrupt from 8 through 15 being taken since the target of the vectored interrupt is determined by the contents of the intvec register the debug softwarewhichmonitorstheejtagpctracecodesmustbeawareofthecontentsofthisregisterinorderto trace the code after the vectored interrupt is taken for probes that do not support 4bit exception code the netvortex can be configured via the ejtag_xv_bits lconfig option to use only the 3bit standard codes in that case if vectored interrupt is taken the 3bit code for reset will be presentedsignal name io description jpt_tpc_dr m bitsopthe pc value is output on these pins when pcdiscontinuity occursa tpc0 is multiplexed with tdo in the singleprocessor pc trace solutionjpt_pcst_dr n3 bitsop pc trace status outputs current instruction type every dclk jpt_dclk op pcst and tpc clock frequency determined as fraction of sysclk via the n parameter maximum frequency of dclk is 100mhz signal parameter min max unit jtag_dclk frequency dc 100 mhz dclk high time 4 ns low time 4 ns tpc setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns pcst setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns 1 based on epi interface speciﬁcations for majictm and majicplus tmapril 2 2001 netvortex lexra proprietary confidential 73 release 19 736 demultiplexing of tdo and tdi during pc trace in normal ejtag pc trace tdi and tdo are multiplexed with the debug interrupt dint and the lsb of the tpc tpc0 when in pc trace mode this reduces the number of pins required by pc trace but has the unfortunate sideaffect of preventing any access to ejtag registers during pc trace in order to allow access to ejtag registers during pc trace and to facilitate pc trace in multiprocessor environments the lconfig option jtag_trst_is_tpcyes causes tdi and tdo to be demultiplexed suchthattrstisusedastpc0anddintisgeneratedviaejtagregistersnotesettingthisoptionmay require changes in ejtag probe hardware check with probe manufacturer for details 74 multiprocessor ejtag in the multiprocessor case lexras ejtag solution enables independent simultaneous control of each processor with the same pinout as the singleprocessor case each processor has its own ejtag block and tapcontrollerthetapcontrollersaredaisychainedtogethersuchthatthetdofromthefirstprocessoris connectedtothetdiofprocessor2andthetdoofprocessor2isconnectedtothetdiofprocessor3the tdo of the last processor on the chain is connected to the ejtag probe 741 connectivity requirements inordertoallowseamlessoperationwithexternalprobeslexrasejtagtapcontrollerchainmusthaveno registerstagesbetweenitandtheexternalprobeanymultiplexingoftheexternalpinsmustbesetsuchthat there is direct connection to and from the netvortex tap controller chain while using ejtag figure 7 construction of chained tap controllers for multiprocessor ejtag 742 multiprocessor pc trace using internal trace buffers in multiprocessor systems traditional pc trace solutions become impractical due to the number of pins neededforeachprocessorandthemismatchbetweenprocessorandprobespeedsbyusinginternalpctrace buffers external pc trace pins are required providing full multiprocessor ejtag and pc trace capability using just 4 pins the buffers allow realtime compressed pc trace information for each processor to be bufferedonchipandscannedoutseriallyusingexistingjtagpinsatprobeclockspeedstheprogramflow canthenbereconstructedexternallytogiveanaccuratehistoryoftheexecutionofprogramsrunningoneach processor lx8000 lx8000 lx8000 lx8000 lx8000 lx8000 lx8000 lx8000 lx8000 lx8000tdotdi tdotditdotdi tdotdi tdotdi tdotdi tdotdi tdotdi tdotdi tdotdinetvortex tdi tdotap controllers probeapril 2 2001 netvortex lexra proprietary confidential 74 release 19 the pc trace buffer keeps history of all nonsequential changes to the pc such as branches jumps and exceptions on each nonsequential pc change buffer entry is written which contains the current pc the current context whether or not trigger point occurred since the previous frame and optionally two characteristic counters the number of sequential instructions and the number of stall cycles since the previous buffer entry the size of the sequential instruction count field is configurable from 2 to 8 bits the stallcyclecountfieldisalsoconfigurableandissplitinto2partsmantissaandexponentbothmantissaand exponent can have widths of 0 to 4 bits if the mantissa width is set to zero the stall cycle count field is removed from the buffer the buffer width ranges from 36 to 58 bits depending on the amount of bits allocated to the characteristic counters and the number of contexts the depth of the buffer is tradeoff between the amount of history requiredandtheamountofdieareavailableitisconfigurableinpowersoftwofrom16framesupwardswith typical value of 64 framesapril 2 2001 netvortex lexra proprietary confidential 75 release 19 8 netvortex crossbar interconnect the crossbar interconnect prevents processordevice communication from becoming system bottleneck the crossbar network supports subset of the full lbus transaction types write processor to device split read request processor to device write with split read request processor to device split read data device to processor thecrossbardoesnotsupportlinereadtransactionswhenusedwiththecrossbarpacketprocessorsmaynot include instruction cache or data cache the processor uses 64bit split reads to fill the instruction ram imem the processor also converts all nonsplit load instructions to split loads context switch is performed for converted transactions and the processor is stalled until the load completes this transparent mode of operation is intended to be used for system initialization and other noncritical tasks split read transactions that are generated by converting nonsplit transactions are referred to as f oreground transactions split read transactions that are generated through the normal mechanisms are sometimes referred to as background transactions the crossbar does not support ejtag dma operations however software running on the probe may still access devices by jamming the appropriate instructions into packet processor theorganizationofthecrossbarnetworkiscenteredarounda16processor6deviceconfigurationaspecial interfaceisalsoincludedtoallowanadditionalpossiblynonnetvortexprocessortoaccessdevicesthatare attached to the crossbar general characteristics of the 16 processor 6 device system are processor and device interfaces support full duplex operation that is transactions can pass simultaneously in both directions aprocessormaypassonewritesplitreadorwritesplitreadrequesttothecrossbarevery two cycles these are converted to single cycle transactions within the crossbar network processors service split data responses at the maximum rate of one every two cycles device may respond to more than one device id for all other purposes multiid device appears to the crossbar as single device devices operate as write descriptor targets or memory storage devices the two modes of operation may not be mixed within single device devices may generate and accept transactions at the rate of one per cycle there is processortoprocessor or devicetodevice traffic in the system transactionsinvolvingagivenprocessorandgivendevicearedeliveredinorderthereare other ordering guaranteesapril 2 2001 netvortex lexra proprietary confidential 76 release 19 81 processortodevice paths figure8 below illustrates the processortodevice crossbar network the numbers just above each queue indicate which devices may be targeted by transactions held in the queue thefirstcolumnofqueuesreceivewritesplitreadandwritesplitreadrequestsfromeach processorandpreventsthreadsfromblockingwhilearequestwaitsforapaththroughthe crossbar interconnect these queues are implemented in the processors lbc theconnectiontothecrossbarusesamodifiedlbcinterfacethatallowstheprocessorto simultaneouslysourceatransactionandreceivesplitdataresultingfromanearlierrequest the 4x6 crossbars sort the requests from the perprocessor queues into perdevice queues asubunitoffourprocessorsone4x6crossbarandassociatedqueuesmakesaconvenient tile used for the design of 16 processor system if each processor attached to the 4x6 crossbar issues request every two cycles and requestsareevenlydistributedamong6devicesthereisan88probabilitythatarequest will be accepted by the crossbar request every four cycles will result in 94 probability of acceptance see below for the source of these figures from the crossbar output queues 51 muxes transfer requests to devices with adequate queue depth at the crossbar outputs the devices can be fully utilized uniform behavior is provided throughout the crossbar network that is if processors are performing similar work they will experience similar delays through the crossbarapril 2 2001 netvortex lexra proprietary confidential 77 release 19 figure 8 crossbar for 16 processors and dmi to 6 devices the probability of request acceptance quoted above is obtained from the formula1p0 p3p2p1 d0 d3d2d14x6 crossbar 6 x 51 muxd05 d05d05d05d0 d3d2d1 d4 d5d0 d3d2d1 p8 p11p10p9 4x6 crossbard05 d05d05d05d0 d3d2d1 d4 d5p4 p7p6p54x6 crossbard05 d05d05d05d0 d3d2d1 d4 d5 p12 p15p14p13 4x6 crossbard05 d05d05d05d0 d3d2d1 d4 d5d5d5d4d4 device management interfaceprocessors xbar layer 1 xbar layer 2 devices lbc bw m 11preq mn april 2 2001 netvortex lexra proprietary confidential 78 release 19 where the equation for bwis accurate to within 8 for mn 075 given the bandwidth the probability that processors request is accepted by the crossbar is 82 devicetoprocessor paths figure9 below illustrates the device to processor crossbar network the numbers just above each queue indicate which processorss may be targeted by transactions held in the queue the topology is compatible with the organization of the processortodevice network the rightmost column of queues are associated with the devices and are fairly shallow simple fanout interconnect layer transfers data from the device queue to the crossbar inputqueuededicatedtothatdevicewithadequatequeueingthedeviceinterfacescanbe fully utilized the blocking effects of the device to processor crossbar are negligible because the utilization is typically low and the ratio of processors to devices is typically 3 to 1 note that the simple formula given in the previous section cannot be used to estimate performance because the mn criteria is not met 1 performance of multiprocessor interconnection networks l bhuyan et ieee computer feb 1989bw aggregate bandwidth of crossbar in transfers per cycle m number of devices preq probability that processor makes request n number of processors paccbw npreqapril 2 2001 netvortex lexra proprietary confidential 79 release 19 figure 9 crossbar for 6 devices to 16 processors and dmi 83 bandwidth and latency the crossbar network can service nfreqrequests per second directed from the processors to the devices wherenis the number of devices and freqis the operating frequency of the crossbar split data return transactions are free with the crossbar because they use full duplex return paths the crossbar operates atp0 p3p2p1 d0 d3d2d14x6 crossbarp0 p3p2p1p03 p03p03p03 p03 p03p016 p016p016p016 p8 p11p10p9 4x6 crossbarp8 p11p10p9p811 p811p811p811 p811 p811p4 p7p6p5 4x6 crossbarp4 p7p6p5p47 p47p47p47 p47 p47 p12 p15p14p134x6 crossbarp12 p15p14p13p1215 p1215p1215p1215 p1215 p1215d5p016d4p016 device management interface6 x 15 fanoutprocessors xbar layer 1 xbar layer 2 devices lbcapril 2 2001 netvortex lexra proprietary confidential 80 release 19 250 mhz in 015 µm technology assuming 1 in 5 transactions is split read request the crossbar delivers about 10 times total processordevice bandwidth of single shared bus with much lower latencies the timing diagram below illustrates the flow of single transaction from processor to device assuming an idle system and synchronous operation figure 10 processor to device transaction flow cycle description 1 local bus request and data are sent from the processor to the cache controller via the local bus 2 cbus request and data are sent from the caches to the lbc via the cbus 3 lbc buf one cycle to go through the transaction queue in the lbc this queue is the lbc write buffer all transactions to the crossbar go through the lbc write buffer 4 lbc addrcrossbar device request ﬁrst cycle on the lbus address is sent to crossbar inter faceaddressisdecodedandrequestissenttocrossbararbitersoneperdevicerequestsare registered in arbiters 5 lbcdatacrossbardevicegrantsecondcycleonthelbusdataissenttothecrossbarinter face device grant is given and merged addressdata is sent across the crossbar to crossbar device queue 6 device queuecrossbar mux request crossbar entry is seen on queue output and request to crossbar mux arbiter is sent request is registered in the arbiterclk local_bus cbus lbc_buf lbus_addr xb_dev_req lbus_data xb_dev_gnt xb_entry xb_dev_q xb_mux_req xb_mux_gnt dev_data dev_loadad ad ad addr data ad ad ad d00131234 5 67april 2 2001 netvortex lexra proprietary confidential 81 release 19 7 muxgrantcrossbarmuxarbitergivesgrantandsendsloadsignaltodevicenewtransaction is loaded into device the timing diagram below illustrates the flow of single transaction from device to processor assuming an idle system synchronous operation figure 11 device to processor transaction flow cycle description 1 device asserts rddatardy to send split data to processor 2 crossbar interface asserts rddequeue to accept the split data split data transferred to read queue in crossbar 3 crossbar read queue asserts request to transfer read data across crossbar to processor inter face 4 read grant is given and data is dequeued from crossbar read queue and sent to lbc 5 data sent from lbc to cache interface via cbus 6 datareturnedtoprocessorvialocalbusnotethelocalbusis32bitswidetwocyclesare needed to return the data for twinword read 84 crossbar port conﬁguration theinterconnectsupportsconfigurationsof12345or6devicesand4812or16processorsplusaport that provides host access to the devices the rtl is optimally reduced to support the configured number of processors and devices 85 address decoding the crossbar interface accepts all requests from processor and decodes the address to determine which device the request is targeting the decode is based on the lconfig options chosen for each device there are two types of devices supported on the crossbar memory mapped and write descriptorclk rddatardy rddequeue data_to_xb xb_rd_q xb_rd_req xb_rd_gnt data_to_lbc cbus local_busdata data data data data d00141234 5 6april 2 2001 netvortex lexra proprietary confidential 82 release 19 851 memory mapped devices when device interface is configured as memory mapped device an address window is specified using lconfig the window is described with base address and mask the upper 12 bits of the address are configurable allowing for minimum window size of 1 mb the address mask is also 12bit value and allows the window size to range between 1 mbytes and 2 gbytes the crossbar uses this base address and masktocomparewiththeupper12bitsoftherequestaddresstodetermineifitiswithintheaddresswindow for that device there is only one address window for each memory mapped device interface 852 write descriptor devices netvortex supports up to 32 write descriptor devices each device port configured to be used as write descriptor interface has an associated 32bit device id mask to indicate which device ids are accepted by the device attached to that port more than one bit in the id mask may be set allowing single device to respond to multiple device ids for write descriptor requests the crossbar uses addr73 of the request and the device masks to determine the target crossbar device port allwritedescriptordevicesarelocatedinasingle1mbytewindowthiswindowisselectablewith lconfig it cannot also be used by memory mapped devices this results in hole in the address space because descriptor devices only use small portion of this window all memory mapped device windows and the 1 mbyte write descriptor memory window must be mutually exclusive 853 address error handling the crossbar detects two error conditions for processor initiated requests if request does not address configured device the crossbar will discard the request and assert the perprocessor error flag if processor issues split read request to writeonly device the crossbar discards the request and asserts the per processorerrorflagthethreadidassociatedwiththerequestisalsocapturedthesetypesoferrorstypically occur during software debug the crossbar module hierarchy gathers the error signals to provide the outputs listed below each processor has its own set of outputs in the signal name n represents the processor number from 0 through 15 customers may use these output signals as appropriate for their system level error detection and recovery strategy for example the error signals may be captured by custom coprocessor that interrupts the affected processor or the signals may be passed to centralized error reporting and handling hardware table 34 crossbar error reporting signals direction signal description output xb_errbadaddrn pulsed high for one cycle when the pro cessor issues request with an address that does not decode to valid device output xb_errinvldrdn onebitperprocessorpulsedhighforone cycle when the processor issues read request to device that does not have read return path output xb_errthreadn30 identiﬁes the local thread id that caused anerrorsignalledthroughxb_errbadaddr or xb_errinvldrd for given processorapril 2 2001 netvortex lexra proprietary confidential 83 release 19 86 arbitration arbitration in the 4x6 crossbar unit is performed with independent perqueue arbiters each arbiter implements windowed roundrobin selection among the processors that compete for given output queue atthenextlevelintheinterconnecteachdevicehasthesametypeofindependentdedicatedarbitertoselect one of four requests in the crossbars perdevice queues the same approach is used for the split data return pathways through the crossbars back to the processors 87 asynchronous interface anoptionalasynchronousboundaryisimplementedatthe4x6crossbarsqueueswithinthecrossbarlayer1 column shown in figure8 and figure9 allowing the processor and 4x6 crossbar speed to be decoupled from chip level interconnect implementing the async interface at this point preserves as much bandwidth as possiblefromtheprocessorandthroughthe4x6crossbarcomparedtousingthelessefficientasyncinterface in the lbc however this does require most of the 4x6 crossbars logic and local interconnect to run at full processor speed 88 queue depths the queues in the lbc may be sized appropriately to prevent local blocking between the processor and crossbar the lbcs output queues should not be used as extra overflow queuing for the crossbar when any particulardevicequeueisfullthedepthoftheprocessorsoutgoingcommandqueueisrtlconfigurablein the range of 2 to 16 command entries the depth of the processors incoming split data queue is rtl configurable in the range of 2 to 16 twinword entries thelbcwillstalltheprocessoriftheprocessorexecutesawritesplitreadorwritesplitreadwhilethelbc output queue is full because the behavior of and demand for devices may differ each devicededicated queue in the crossbar layer 1 see figure8 and figure9 may be sized specifically for its device generally the depth of these queues should be determined by device access patterns and crossbar performance the depth should not be related to performance characteristics of the actual device the fifo depths in the first level crossbar modules are rtlconfigurable for 4 8 or 16 entries the devices include dedicated queues with depths that are related to overall access rates and device latency 89 instruction ram fill instruction rams of the packet processors are filled under the control of hardware state machine in the processor using split reads over the crossbar network the state machine sequence is initiated by software with write to the cop0 cctl register it is assumed that iram fill performance is not critical 810device management interface the crossbars optional device management interface dmi provides port for accessing the crossbar devices with management processor or other hardware the dmi provides support for all crossbar operations to the devices for memory devices this includes writes and split reads for write descriptor devices this includes writes and write split reads 8101 dmi read and write request interface the table below lists the dmi signals that are used by management processor or similar subsystem toapril 2 2001 netvortex lexra proprietary confidential 84 release 19 transfer write or read request to the dmi table 35 dmi request signals to send new request to device the request line dmi_devreqs associated with that device is asserted onlyonerequestlinemaybeassertedatanytimedmi_cmddmi_sizedmi_dataanddmi_gtidmust supplyvalidrequestinformationformemorymappeddevicesdmi_addrmusthaveavalidaddressforthat device for write descriptor devices dmi_devid must have valid device id for that device the crossbar asserts dmi_gnt when it accepts the request which will be earlier than one cycle after the requestwasinitiatedthecrossbarusestherequestinformationthatissampledinthecyclepriortoasserting dmi_gnt the crossbar ignores new requests until the it has granted the current request the interface is pipelinedallowingthecrossbartocaptureinformationforthenextrequestifanywhileitgrantsthecurrent request dmi_procnum processor number this 8bit value is used when split read data is being returned from the devices to identify that the data is for the dmi it must not match any of the gtid114 values that are assigned to packet processors attached to the crossbar dmi_cmd request command 0000 reserved 0001 write 0010 background split read request 0011 write split read 001x reserved 0110 foreground split read request 0111 reserved 1xxx reserved dmi_size request size 000 1 byte 001 2 bytes 010 1 word 011 2 words 100 4 worddirection signal description mpxb dmi_devreqs50 request to individual devices xbmp dmi_gnt grant from crossbar request has been taken mpxb dmi_procnum70 processor number mpxb dmi_cmd30 request command mpxb dmi_size20 request size mpxb dmi_threadid30 request thread id mpxb dmi_addr310 request address for memory mapped devices mpxb dmi_devid40 request device id for wd devices mpxb dmi_data630 request write dataapril 2 2001 netvortex lexra proprietary confidential 85 release 19 101 reserved 110 reserved 111 reserved noteforwritesplitreadcommandsthesizeisforthereadrequesteither1or2wordssincethewritemust be 2 words dmi_threadid request thread id this value must be used to differentiate read requests when the hardware attached to the dmi can have multiple outstanding read requests for split read requests the value will be returned with the split read data dmi_addr request address theaddressisneededforallmemorymappeddevicesthefull32bitphysicaladdressissent to the device dmi_devid request device id the device id is used for write descriptor devices it should be valid for any write descriptor operations reqdata write data size is either 32 bits for memory mapped devices or 64 bits for write descriptor devices 8102 dmi request waveforms in these waveforms device 0 value of 1 in the dmi_devreqs is used but the logic is the same for any device request figure 12 single dmi request without grant delay for all transactions the timings for dmi_addr dmi_cmd dmi_size dmi_threadid and dmi_data areclk dmi_devreqs dmi_gnt dmi_addr310 dmi_cmd30 dmi_size20 dmi_threadid30 dmi_data630a d0015april 2 2001 netvortex lexra proprietary confidential 86 release 19 all the same for the waveforms below only dmi_addr is shown figure 13 single dmi request with grant delay figure 14 back to back dmi requests without delay figure 15 multiple back to back dmi requests with grant delay 8103 dmi split read data interface the table below lists the signals that are used by management processor or similar subsystem to receive split read data from the dmi table 36 dmi split read data signals direction signal description xbmp dmi_rdvalid split read data valid xbmp dmi_rdcmd10 split read data command xbmp dmi_rddata630 split read data xbmp dmi_rdthreadid30 split read thread id xbmp dmi_rdsize10 split read size mpxb dmi_rdbusy busy signal from management processorclk dmi_devreqs dmi_gnt dmi_addr310a d0016 clk dmi_devreqs dmi_gnt dmi_addr310a b b d0017 clk dmi_devreqs dmi_gnt dmi_addr310a b c b c d0018april 2 2001 netvortex lexra proprietary confidential 87 release 19 whenasplitreadresponsefromadevicehasaprocessornumberthatmatchesdmi_procnumthecrossbar forwards split read the dmi interface dmi_rdvalid indicates that split read data is being sent dmi_rddata dmi_rdthreadid and dmi_rdsize will all have the valid split read information if the hardware connected to the dmi cannot accept split read data it should assert dmi_rdbusy dmi_rdcmd split read data command 00 background split read data 01 foreground split read data 1x reserved dmi_rdsize split read data size 00 1 byte 01 2 bytes 10 1 word 11 2 words 8104 dmi read data waveforms figure 16 single dmi read data response without delayclk dmi_rdvalid dmi_rddata630 dmi_threadid30 dmi_cmd10 dmi_size10 dmi_rdbusya d0019april 2 2001 netvortex lexra proprietary confidential 88 release 19 figure 17 single dmi read data response with busy delay figure 18 back to back dmi read data response without delay figure 19 back to back dmi read data response with busy delay 811direct fifo interface for devices the devices enqueue and dequeue information directly to and from the crossbar interconnects queues the devices do not implement any aspects of the lbus protocolclk dmi_rdvalid dmi_rddata630 dmi_threadid30 dmi_cmd10 dmi_size10 dmi_rdbusya d0020 clk dmi_rdvalid dmi_rddata630 dmi_threadid30 dmi_cmd10 dmi_size10 dmi_rdbusya b b b b d0021 clk dmi_rdvalid dmi_rddata630 dmi_threadid30 dmi_cmd10 dmi_size10 dmi_rdbusya b b b b d0022april 2 2001 netvortex lexra proprietary confidential 89 release 19 8111 device request interface thecrossbarinterfaceforsendingrequestsforeachdeviceisoptimizedviartlconfigurationadevicecan either be memory mapped device which requires an address but supports only 32bit writes or write descriptor device which does not need an address but supports 64bit writes for write descriptors each interface is configured for either memory mapped or write descriptor using lconfig table 37 device request signals when the crossbar is ready to enqueue new request it asserts devreqrdy reqcmd reqsize regtid reqaddr and reqdata are valid when devreqrdy is asserted if devbusy is asserted the crossbar cannot send new request reqcmd request command 0000 reserved 0001 write 0010 background split read request 0011 write split read 010x reserved 0110 foreground split read 0111 reserved 1xxx reserved reqsize request size 000 1 byte 001 2 bytes 010 1 word 011 2 words 100 4 word 101 reserved 110 reserved 111 reserved note for write split read commands the size is for the read request either 12 or 4 words since the write must be 2 wordsdirection signal description xbdev devreqrdy load new request xbdev reqcmd30 request command xbdev reqsize20 request size xbdev reqgtid150 request global thread id devxb devbusy device cannot accept any more trans actions xbdev reqaddr310 request address memory mapped devices xbdev reqdata310 write data memory mapped devices xbdev reqdevid40 write descriptor device id wd devices xbdev reqdata630 write descriptor data wd devicesapril 2 2001 netvortex lexra proprietary confidential 90 release 19 reqgtid request global thread id same as lbus global thread id for split read requests the device should return this value with the split read data reqaddress request address theaddressisneededforallmemorymappeddevicesthefull32bitphysicaladdressissent reqdevid request write descriptor device id the device id is provided if more than one write descriptor device is connected to device interface only available for write descriptor interfaces reqdata write data size is either 32 bits for memory mapped devices or 64 bits for write descriptor devices 8112 device request waveforms notewaveformsareformemorymappeddeviceswritedescriptordevicesareidenticalexceptreqaddr is replaced with reqdevid figure 20 single request enqueue the crossbar can also issue backtoback requests with delay if devbusy is not asserted figure 21 back to back request enqueueclk devreqrdy reqcmd30 reqsize20 reqgtid150 reqaddr310 reqdata310 devbusya d0041 clk devreqrdy reqcmd30 reqsize20 reqgtid150 reqaddr310 reqdata310 devbusya b b b b b d0042april 2 2001 netvortex lexra proprietary confidential 91 release 19 devbusy is used by the device to indicate it is not ready to receive new request if devreqrdy is asserted concurrent with the assertion devbusy the request is ignored and must be regenerated in the next cycle figure 22 devbusy asserted between two requests 8113 device read data interface the crossbar also accepts split read data to be returned to the processor not all devices need this interface and each crossbar device interface can be configured using lconfig table 38 device read data signals when device is ready to return split read data it asserts rddatardy for one cycle and drives rdgtid with thegtidassociatedwiththereturndatathecrossbarcapturesandretainsrdgtiduntilithasdequeuedthe data splitrddata rdcmd and rdsize are valid the cycle after rddatardy is asserted until the crossbar accepts the data rdgtid and rdsize should have the same value as the split request sent on reqgtid and reqsize the crossbar asserts rddequeue when it accepts the data and the device dequeues the entry rdcmd split read command 00 background split read data 01 foreground split read data 1x reserved dmi_rdsize split read data size 00 1 byte 01 2 bytes 10 1 worddirection signal description devxb rddatardy read data ready devxb rdcmd10 read data command devxb splitrddata630 read data devxb rdgtid150 read global thread id devxb rdsize10 read data size xbdev rddequeue crossbar accepts read dataclk devreqrdy reqcmd30 reqsize20 reqgtid150 reqaddr310 reqdata310 devbusya b b b b b d0043april 2 2001 netvortex lexra proprietary confidential 92 release 19 11 2 words acrossbardevicemayneedtoreturn4wordsofdataforasinglerequestquadwordsplitreadthecrossbar acceptsamaximumof2wordsofdatapertransactionsotwoseparatetwinwordoperationsshouldbeused for memory devices the data in addr2 0 should be returned first the gtid for both halves of the quadword data should use the same value as the quadword split read request 8114 device read data waveforms figure 23 single split read return notespltrddatarddatacmdandrdsizecanbedrivenwithrddatardyandrdgtidinthefirstcyclebut the crossbar will not use them if the crossbar interface is not ready to accept the split read data it will not assert rddequeue to avoid timing problems the device must not use rddequeue to gate spltrddata rddatacmd and rdsize at the device outputs instead these outputs are controlled by registered next cycle versions of rddatardy and rddequeue figure 24 rddequeue delay adevicecanissuebacktobacksplitreadresponseseachrddatardyassertionbyadeviceindicatesanew requestifthedeviceissuesanewrequestwhileapriorrequestispendingieissuedbutnotacceptedbythe crossbar the device must reissue the new request to do so the device leaves rddatardy asserted for the second request until the cycle after rddequeue isclk rddatardy rdgtid150 rddequeue spltrddata630 rddatacmd10 rdsize10a d0044 clk rddatardy rdgtid150 rddequeue spltrddata630 rddatacmd10 rdsize10a d0045april 2 2001 netvortex lexra proprietary confidential 93 release 19 asserted by the crossbar ie the crossbar accepts the first request figure 25 back to back split read responses without rddequeue delay figure 26 back to back split read responses with rddequeue delayclk rddatardy rdgtid150 rddequeue spltrddata630 rddatacmd10 rdsize10a b b b b d0046 clk rddatardy rdgtid150 rddequeue spltrddata630 rddatacmd10 rdsize10a b c b c b c b c d0047april 2 2001 netvortex lexra proprietary confidential 94 release 19 april 2 2001 netvortex lexra proprietary confidential 95 release 19 9 netvortex test and set engine netvortex includes an optional test and set engine this module implements an lbus target that supplies up to 32 unique semaphores these semaphores can be used to control access to resources that are shared among any of the processors and contexts that have access to the lbus theremainderofthischapterdescribesthelbuscommandsthataresupportedbythetestandsetengineas well as the resources required to implement various numbers of contexts processors and semaphores the test and set engine responds to the following lbus commands single word read lw instruction basic test and set single word splitread lwcsw enqueue and wait for semaphore free single word write sw instruction dequeue wait or clear semaphore 91 semaphore addressing thetestandsetenginerespondstoarangeofaddressesonthelbusthatisprogrammableusingthelexra lconfigutility each semaphore occupies the even word of doubleword in the address range up to 32 semaphores are implemented the base address of the engine must be aligned on 1mbyte boundary since the test and set engines configurable decoder only compares bits 3120 of the lbus address address bits 73 identify the semaphore to be accessed and address bits 20 must be zero for double word addressing address bits 198 are ignored but should be zero for compatibility with future expansion 92 single word read basic test and set anlbussinglewordreadrequesttoasemaphoreaddresswithinthetestandsetengineprovidesthebasic functionality if the semaphore is free it is atomically marked as held and value of zero is returned for the wordreadifthesemaphoreisalreadyheldwhentherequestarrivesitremainsheldandavalueofoneinthe least significant bit of the word is returned for the word read 93 single word splitread enqueue and wait for semaphore free anlbussingle word split read request to asemaphoreaddresswithin thetest andset engine enqueues the processorandcontextoftherequestortowaitforthesemaphoretobefreeifthesemaphoreisalreadyfree itismarkedheldandthereturnresponsewithavalueofzeroismadeassoonastheenginecangainaccessto thelbusifthesemaphoreisnotfreewhentherequestarrivestheprocessorandcontextoftherequestoris enqueued behind all others waiting for this particular semaphore if any eventually when this requestor is the oldest one waiting and the semaphore is dequeued the return response with value of zero is made as soon as the engine can gain access to the lbus note that the return response for split read always has value of zero and always leaves the semaphore in the held state 94 single word write dequeue wait or clear semaphore anlbussinglewordwriterequesttoasemaphoreaddresswithinthetestandsetengineisusedtodequeue orclearthesemaphorethedataassociatedwiththewriteisignoredtherequestorisalsoignoredseethe examples of semaphore usage below if the queue for that semaphore is empty waiting requestors the semaphore is marked free regardless of itspreviousstatefreeorheldifthequeueofwaitingrequestorsisnotemptythesemaphoreisnecessarilyapril 2 2001 netvortex lexra proprietary confidential 96 release 19 heldtheoldestrequestorinthequeueisremovedfromthequeuethatrequestorsreturnresponseismadeas described above in section 73 and the semaphore remains in the held state 95 ram requirements for semaphore queues in order to provide robust implementation that can withstand the worst case scenario of waiting requestors withoutresortingtoretrymechanismsthequeuesofrequestorsthatarewaitingforanyofthesemaphoresare implemented in ram the size of this ram depends on these three variables number of semaphores supported number of processors in the system number of contexts per processor an expression for how the number of words in the ram is calculated s of semaphores p of processors in the system c of contexts per processor table 39 semaphore engine ram requirements 96 semaphore usage for critical code section thefollowingprogrammingexampleshowstypicalusageofasemaphoretoprotectacriticalsectionofcode that should only be executed while the semaphore is held by the executing threadnumber of semaphoresnumber of processorscontexts per processorram required 4 4 4 64 x 16 bits 4 16 4 256 x 16 bits 8 4 4 128 x 16 bits 8 16 8 1k x 16 bits 16 4 4 256 x 16 bits 16 16 8 2k x 16 bits 24 4 4 512 x 16 bits 24 16 8 4k x 16 bits 32 4 4 512 x 16 bits 32 8 4 1k x 16 bits 32 16 4 2k x 16 bits 32 16 8 4k x 16 bits r1semaphore getsemaphoreaddress 16bit words 2log2spcapril 2 2001 netvortex lexra proprietary confidential 97 release 19 thisexampleassumesthatthesemaphorewillusuallybefreewhenitisneededthereforethefirstcheckof the semaphore uses an ordinary read lw instruction if the semaphore is free the critical section is entered immediately branch around the lwcsw if the semaphore is not free rather than using spin loop which would consume both processor cycles and lbus cycles split read is used lwcsw instruction which enqueues the context in the semaphores wait queue and allows another thread to execute when the semaphore is later acquired this thread becomes ready when this thread resumes execution it immediately enters the critical section since it is guaranteed to hold the semaphore at that point at the conclusion of the critical section during which the resources protected by the semaphore may be accessed the semaphore is released with simple write sw instruction it was noted above that write operation to semaphore address always dequeues or clears the semaphore regardless of the requestor or the write data in the above coding example only the holder of the semaphore would actually clear the semaphore maintaining that requirement is actually different than any other operation performed within the critical section 97 semaphore usage for cross processor wait and post within one netvortex processor pair of threads can use the csw and postcx instructions to implement wait and post semantics for communication between producer thread and consumer thread since the postcx instruction only updates the cxstatus register of another context within the same processor these instructions cannot be used for communication across processors the semaphore facility in the test and set engine can be used to implement this functionality as follows let gtid1 be the global thread id of the consumer thread that is ready to wait for the producer thread which has global thread id of gtid2 the following code sequences allow for cross processor wait and post semantics assuming that both semaphore1 and semaphore2 have both been placed in the held state by initialization code using simple lw instructions in gtid the consumer executes in gtid2 the producer executeslw r20r1 atomic test and set beqz r2critical_section if got it go do it nop delay slot lwcsw r20r1 else wait to get it nop delay slot critical_section do critical section sw r00r1 release semaphore end_crit_section ready to wait r1semaphore1 get semaphore address r3semaphore2 clear semaphore2 to sw r00r3 indicate wait to gtid2 lwcsw r00r1 wait for semaphore1 to be cleared nop delay slot consume after context switch produce ready to post r3semaphore2 lw r20r3 ensure gtid1 waitingapril 2 2001 netvortex lexra proprietary confidential 98 release 19 in this example the consumer waits for semaphore1 before consuming the producer clears semaphore1 to post that it has produced note that the producers clearing operation can take place any time after the consumer is ready to wait for the semaphore usually this will be after the wait begins in the rare event that the clear occurs before the lwcsw the operation will still be correct even though the consumer is never enqueued for the semaphore also note that the lwcsw always leaves semaphore1 in the held state for the next wait in case the producer is ready before the consumer semaphore1 must not be cleared the purpose of semaphore2istopreventthisfromhappeningtheconsumerclearsittoindicatetotheproducerthatthe consumerisabouttobeginwaitingiftheproducerfindsithelditcandosomeotherworkorswitchcontext notshownwhetherthetestofsemaphore2succeedsorfailsthelwinstructionleavesitintheheld state for the next attempted post 98 initialization atresettimeallofthesemaphoresaremarkedfreeandallofthequeuesaremarkedasemptythisdoesnot requireanyramaccesssincethefreebitandqueuepointersaremaintainedinregistersinthetestandset engine rather than in the ram itselfbnez r2otherwork do something else if not r1semaphore1 clear semaphore1 to sw r00r1 indicate post to gtid1april 2 2001 netvortex lexra proprietary confidential 99 release 19 10 netvortex block transfer subsystem thischapterdescribestheoptionalnetvortexblocktransfersubsystemwhichconsistsoftheblocktransfer controllers btc and the bock transfer engines bte section101 overview briefly introduces the netvortex block transfer capabilities and structure section102 block transfer buffers and transfer descriptors defines the data structures that are used in conjunction with block transfers section103 example transaction flow provides brief description of how block transfer transactions flow through the netvortexsystemsection104 detaileddescriptionofblocktransfermodulesdescribestheelementsof the block transfer subsystem summary of block transfer subsystem operates at core processor speed peak transfer bandwidth of 256 bits per cycle transfer engines dedicated to each processor one or two receivetransmit port pairs for external connection ram interfaces can sustain simultaneous inputoutput transfers perthread transfer descriptor queues maintained by each transfer engine centralized scheduler maintains optimal packet flow and packet order 101overview theblocktransfersubsystemmovesblocksofdatabetweenexternalreceiveandtransmitportsandthelocal data rams that are attached to one or more netvortex processors threads set up transfer operations using the write descriptor wd instruction that indicates the transfer details the block transfer subsystem is composed of the modules listed below refer to figure27 organization of the block transfer controller block transfer engines btes are attached to each processors dualport data rams perthread descriptor queues within each bte provide storage for receive and transmit requests that are made by processor receive dma rxdma and transmit dma txdma controllers within each bte support concurrent receive and transmit transfers for each processor block transfer controllers btcs coordinate receive and transmit traffic for receive transmit port pair utopia4 receive and transmit ports are connected to the rx btc and tx btc modules support for spi level 4 phase 2 is planned for future releases internal busses rxbus and txbus provide pathways between the btes and the btcs the block transfer engine bte is controlled with the write descriptor instructions wd and wdcsw that pass 64bit descriptor from the cpu to the bte the bte saves the descriptors in queues that may holdmultipleentriesperthreadthereisonerxqueueandonetxqueueperthreadwritingadescriptorto the bte does not in itself cause the transfer to start rather each bte uses information in the descriptor inapril 2 2001 netvortex lexra proprietary confidential 100 release 19 conjunction with information provided by the block transfer controllers btcs to determine when the transfer will take place the rx btc and tx btc modules pass data and control information between the utopia4 interfaces and internalbussestheyalsocoordinatetransferstooptimizepacketflowandmaintainpacketorderingtherx btc assigns receive traffic to threads with either strict roundrobin selection or to the next available thread packet transmission follows the strict order of the original packet receive sequence theinternalrxandtxbussesprovidepathwaysbetweenthebtcsandbteseachbuscantransfer64bits of data every cycle when two port pairs are configured each bte is allocated to specific port via the first write descriptor sent to the bte for example if the first descriptor sent to the bte in processor 0 specified port 1 processor 0s bte would be allocated to port 1 for the remaining descriptors figure 27 organization of the block transfer controller 102block transfer buffers and transfer descriptors this section describes the format of the block transfer descriptors and block transfer buffers table40 block transfer descriptor below shows the format of the descriptors software passes the the bte using the wd and wdcsw instructionsdevice m device 0 crossbar cpu 0 cpu ndmem dmem block transfer engine bte rx dmatx dmadescriptor queuesblock transfer engine bte rx dmatx dmadescriptor queues rx block transfer controllertx block transfer controller tx block transfer controllerrx block transfer controller block transfer subsystemrx tbus 0 tx tbus 0 rx tbus 1 tx tbus 1scheduling 0 scheduling 1utopia l4 inter faces utopia l4 interfaces tx btc0 rx btc1rx btc0 tx btc1april 2 2001 netvortex lexra proprietary confidential 101 release 19 table 40 block transfer descriptor blocktransferbuffersareregionsinaprocessorslocaldmemthatprovidestorageforreceiveandtransmit packetsthebterequiresthebaseofeachbuffertobealignedtoa16byteboundaryandthefirst8bytesof thebufferarereservedforusebythebteasidefromtheserestrictionssoftwarehasflexibilitywithregards tothenumberandsizeofbufferssoftwaremaymaintainanarbitrarilylargepoolofbufferswithinthelimits of available local dmem the figure below illustrates the structure of transfer bufferfieldwidth bitsdescription waitevent 8 waitevent bits to be set in cxstatus when writedescriptor includes context switch rs241 causes the thread to wait for receivecompleteeventrs25causesthethreadtowaitforatrans mit complete event this ﬁeld is valud only with wdcsw instruc tion for wd instruction this ﬁeld must contain zeroes notify 8 thesebitsareusedtorequestthebtetonotifythethreadofatrans fer completion by pulsing the appropriate waitevent input to the processor rs161 indicates that the thread wants to be notiﬁed after the receive transfer speciﬁed by this descriptor is completed rs171 indicates that the thread wants to be notiﬁed after the trans mit transfer speciﬁed by this descriptor is completed sequence 16 sequencing code used for packet ordering the btc inserts 16bit sequencecodeinthereservedﬁeldofeveryreceivedpackettransfer bufferforsomemodesofoperationsoftwaremustcopythiscodeto the transmit descriptor to allow the block transfer subsystem to main tain packet ordering the interpretation of this code is private to the bte and btc dir 1 direction of the transfer 0 receive 1 transmit port 1 id number of the transmit or receive port to transfer data all of the threadsonagivenprocessormustaccessasinglerxtxportpairat all times offset 12 offset of the buffer in local dmem addressed in 16byte multiples the starting location of buffer must be aligned to 16byte bound ary the low order 4 bits of the byte offset are omitted from the field xfercount 14 this value indicates the maximum number of bytes which may be receivedorthenumberofbytestotransmititneednotbeamultiple of 16 bytes the count does not include the 8 bytes at the beginning ofthebufferthatarereservedforusebytheblocktransfersubsystemxfercount offset dir0000 1314 252629 14 12 1sequence0 1516 1631 330notify 031 18 8waitevent2324 rs rt29 port 1april 2 2001 netvortex lexra proprietary confidential 102 release 19 btc reserved fields table 41 btc reserved fields in transfer buffer tomakeabufferavailableforareceiveortransmitoperationsoftwareieathreadcreatesadescriptorthat specifies the buffer location size and other aspects of the transfer the thread executes the wdcsw instruction to enqueue the transfer descriptor in the threads receive or transmit descriptor queue within the bte the descriptor is contained in the general registers specified by the wd instruction 103example transaction flow here is the flow of an example receive block transfer operation through netvortex system 1enable the transfer processor initiates receive block transfer with the wdcsw instruc tionwritedescriptorwithcontextswitchsoftwaresetsthereceivewaiteventbitrs24 and and the receive notify bit rs16 to indicate that the thread is waiting for the receive operationtocompleteandthethreadwantstobenotiﬁedofthecompletiontheprocessorper forms context switch to allow the processor to perform work for another thread 2enqueue the descriptor the processor passes the descriptor to its bte in turn the bte enqueues the descriptor into the receive descriptor queue that serves the thread the bte also informs the rx btc that new buffer is available6448 47 46 45 440 sequence reserved abort trunc reserved field use sequence sequencenumberinsertedinreceivepacketsby bte ignored for transmit packets abort received packet was aborted by the sender trunc received packet was truncated by bte to ﬁt available buffer space reserved reservedforfuturebteusecontentsundeﬁned for receive packets ignored for transmit packets octn octet n of the receive or transmitted packetoct1btc reserved fields see table below address 0 8 16oct2 oct3 oct4 oct5 oct6 oct7 oct8 oct9 oct10 oct11 oct12 oct13 oct14 oct15 oct16 april 2 2001 netvortex lexra proprietary confidential 103 release 19 3select the descriptor the bte analyzes the entries at the heads of its descriptor queues and selects descriptor for this transfer the bte then passes the descriptor to its receive dma rxdma controller for the next transfer 4schedule the transfer the rx btc observes that the bte is ready to accept data this is determined in the background of the current data transfer 5transferthedata whenthebtesturnarisestherxbtcdirectsdatabeatstothebteand the btes rxdma controller stores the data into the local dmem 6signal the processor after the last beat is transferred the bte signals the processor to clear waitevent bit 0 of the initiating threads cxstatus register 7markthreadready theprocessorsthreadschedulermarkstheapplicablethreadasreadyfor executionifnoothereventsarependingifanotherthreadiscurrentlyexecutingafuturecon text switch will activate the thread for which this transfer was completed if thread is cur rently active the thread is resumed immediately 8processpacketdata thethreadischosenbythethreadschedulerandresumesexecutionthe thread processes the data in the packet and issues transmit block transfer with the wdcsw instruction software inserts the sequence number from the reserved ﬁeld of the packet buffer intors150bitsrs25andrs17aresettoindicatethatthethreadiswaitingforthetrans mitoperationtocompleteandthethreadwantstobenotiﬁedofthecompletiontheprocessor performs context switch to allow the processor to perform work for another thread 9enqueue the descriptor the processor passes the descriptor to its bte which enqueues the descriptor in the transmit descriptor queue that serves the thread that initiated the request 10descriptor next to transmit the bte has local copy of the currently transmitting sequence number and determines that it has the descriptor for the next transmission the bte then passes the descriptor to its transmit dma txdma controller 11transferthedata whenthebtenoticesthecompletionofthecurrenttransferitwillbeginto transmit data from dmem to the tx btc 12signal the processor after the last beat is transferred the bte signals the processor to clear waitevent bit 1 of the initiating threads cxstatus register 104detailed description of block transfer modules this section provides more detailed description of the block transfer components 1041 block transfer engine block transfer engine bte is connected directly to each processor with dedicated control port to receive descriptors from the processor dedicated data port connected to the processorss data ram and data port connected to the shared rxbus and txbus interconnect the processor connection provides private pathway from the processor to the engine for writing transfer descriptors with the wd instruction without using shared system bus bandwidth internally the bte includes perthread descriptor queues to manage receive and transmit operations and dedicated receive and transmit dma controllers rxdma and txdma to pass data between the processors dmem and the tbus eachthreadissupportedbydedicatedreceiveandtransmitdescriptorqueuesthebtehasparallelaccessto the head entry of each queue to determine which descriptor to select for the next receive and transmitapril 2 2001 netvortex lexra proprietary confidential 104 release 19 operations thenumberofdescriptorqueueentriesisrtlconfigurabletheminimumisoneentryperdescriptorqueue thatisonerxdescriptorandonetxdescriptorintypicalapplicationstworeceivedescriptorentriesandone transmit descriptor entry are dedicated per thread because the bte allows software to assign the buffer addresses in descriptors the number of actual packet buffers held in dmem may be larger than the number of descriptor queue entries with just three packet buffers thread may perform packet computation concurrently with packet receive and transmit operations that take place in the background the btes dma controllers can sustain simultaneous receive and transmit operations the processors dmem is 128bit wide dual port sram shared by the processor and the bte the processor loads or storesonly32bitsofdatainanycycleoveritsportthe64bitreceiveandtransmitdmacontrollersaccess theraminalternatecyclesovertheirportwriting128bitsinonecycleandreading128bitsthenextcycle this allows the ram to sustain the simultaneous read and write operations that may be presented on 64bit rxbus and txbus pathways the dma controllers include register stage to match actual receive and transmit data widths to the 128bit ram interfaces 1042 rx and tx block transfer controllers the rx and tx block transfer controllers rx btc and tx btc provide data pathways between the external utopia4 rxtx and the internal rxbus and txbus the main functions of scheduling are to distributereceivepacketsamongtheavailablepoolofreceivebuffersandtoensurepacketsaretransmittedin the original receive order the scheduler enforces the ordering policy by providing sequencing information that is used by the btes there are two modes of scheduling that may be employed strict roundrobin scheduling next available receive buffer scheduling strict roundrobin scheduling strict roundrobin scheduling of incoming packets assigns the first packet to the first processor the second packet to the second processor etc assignment then wraps around to the first processor the second processoretctransmitpacketsareselectedinthesameorderiftheprocessorthatisdesignatedforareceive or transmit operation does not have receive or transmit buffer available when required data transfer can take place strict round robin scheduling is useful for its simplicity in distributing the packet workload among the processors it should only be used when worst case analysis of the traffic flow indicates that receive and transmit operations will not be stalled to wait for buffer from the next required processor next available receive buffer scheduling next available receive buffer scheduling assigns an incoming packet using windowed rotating priority to processorthatindicatesareceivebufferisavailabletherxbtcinsertsasequencecodeinthereservedfield atthestartofeachreceivedpacketwhensoftwareisreadytotransmitthepacketitinsertsthesequencecode it obtained from the receive packet into the sequence field of the transmit descriptor each bte has local copy of the next sequence code to be transmitted and the tx btc informs the btes when to increment that code each bte ensures that transmit descriptor that contains this sequence code is made ready in the btes txdma controller when the controller is able to accept new descriptor the interpretation of the sequence code is hardware implementation specific software only needs to copy the sequence code from each receive operation to each transmit operationapril 2 2001 netvortex lexra proprietary confidential 105 release 19 1043 utopia level 4 rx and tx interfaces therxbtcandtxbtcinterfacesprovideutopialevel4connectionstoexternaldatapathsanetvortex systemmayincludeoneortworxtxinterfacepairstheinterfacessupportthefollowingfeaturesofutopia level 4 415 mhz operation 32bit wide data path channel 0 provisioning concatenated nonchannelized data streams packet and atm cell transfer modes flow control signalling all of rxtx interface signals are differential so each port requires total of 68 device pins they are summarized in the tables below table 42 receive port signals table 43 transmit port signalssignal direction description rxu4_clki input receive reference clock rxu4_ctli input receive control ﬂag rxu4_datai310 input receive data signal direction description txu4_clko output transmit reference clock txu4_ctlo output transmit control ﬂag txu4_datao310 output transmit dataapril 2 2001 netvortex lexra proprietary confidential 106 release 19 april 2 2001 netvortex lexra proprietary confidential 107 release 19 appendix netvortex lconﬁg forms a1 introduction the general construct of the multiprocessor form is block the block can refer to configuration for use later in the form or it can be used as declaration inside another block the structure of block block_type block_name theblock_type parameter is one of handful of lconfig keywords it can describe processor crossbar device or system here is list of valid block types and their descriptions table 44 lconﬁg block types theblock_name isuserdefinedandmaybeusedbylconfigtohelpgeneratefilesforthatconfiguration for instance the block_name parameter in the ppu block is used as prefix for the processor rtl files the block itself contains form options verilog symbol declarations and declarations of other blocks the multiprocessor netvortex form is intended to model the actual system hierarchy as closely as possible a2 packet processor unit ppuppu_config_name form_option value symbol define verilog_symbol value the ppu block does not contain subblock instances or declarations and it uses the same processor form options as lx8000 configurations a3 four processor tile with level 1 crossbar nvx_4proc nvx_4proc_config_name ppuppu_decl_name1 ppu_config_name block types description section ppu packet processing unit sectiona2 packet processor unit nvx_4proc netvortex 4 processor tile with level 1 crossbarsectiona3 four processor tile with level 1 crossbar memory_map memorymapped crossbar devicesectiona4 memorymapped cross bar device write_desc writedescriptor crossbar devicesectiona5 writedescriptor cross bar device taser test and set engine crossbar devicesectiona6 test and set engine crossbar device crossbar netvortexsystemincludingthe level 2 crossbarsectiona7 netvortex system with level 2 crossbarapril 2 2001 netvortex lexra proprietary confidential 108 release 19 the nvx_4proc block contains the instances of the packet processors if ppu configuration is declared above this block it may be referencedinside four processors are required in the block a4 memorymapped crossbar device memory_map block_name form_option value the memory_map block describes memorymapped device this block specifies base address and an address mask that declares the range of addresses defining memory device if the device specifies 128 mb range for instance then the base address must be on 128 mb boundary memorymaps must not overlap with each other including the writedescriptor memorymap here is summary of address masks and the memory window size created table 45 memory mapped device address masks a5 writedescriptor crossbar device write_desc block_name form_option value the write_desc block describes writedescriptor device and will respond to writedescriptoraddr_mask size 12h000 4 gb 12h800 2 gb 12hc00 1 gb 12he00 512 mb 12hf00 256 mb 12hf80 128 mb 12hfc0 64 mb 12hfe0 32 mb 12hff0 16 mb 12hff8 8 mb 12hffc 4 mb 12hffe 2 mb 12hfff 1 mbapril 2 2001 netvortex lexra proprietary confidential 109 release 19 instructions each writedescriptor device responds to one or more device_id bits however any given device_id bit must map to one and only one writedescriptor device a6 test and set engine crossbar device taser block_name form_option value thetaserblockdescribesatestandsetenginedevicethisdeviceisaspecialmemorymappeddevicein thatitallowsaccesstosemaphoresithasthesamebasicformoptionsasamemorymappeddevicewithone additional option used to configure the number of semaphores in the test and set engine only one taser device may be used in netvortex system a7 netvortex system with level 2 crossbar crossbar form_option value nvx_4proc nvx_4proc_decl_name1 nvx_4proc_config_name memory_map mm_decl_name form_option value write_desc wd_decl_name form_option value taser taser_decl_name form_option value the crossbar block instances an entire netvortex system the processor tiles are declared the device ports are configured and the related crossbar form options are set this block does not need block_name sinceitmaybeinstancedonlyoncetheorderinwhichcrossbardevicesaredeclaredisthe ordertheywillbeinsertedintothecrossbarportsthefirstdevicewillbeconnectedtoport0thenextdevice to port 1 etc there must be at least one crossbar device up to maximum of six only one taser device may be used in the system memorymapped devices may not have overlapped ranges and writedescriptor devices may not share the same writedescriptor bits a8 general form notes whenusingaparticularconfigurationmorethanonceforexamplewhendeclaringa4processortileifall4 processors are identical instance each processor with the same configurationapril 2 2001 netvortex lexra proprietary confidential 110 release 19 nvx_4proc ppu4tile ppu pa packetpu ppu pb packetpu ppu pc packetpu ppu pd packetpu this guarantees that lconfig will use one type of packet processor packetpu in this case for all processorsinthe4processortileiftheprocessorsareexplicitlydeclaredinsidetheblocklconfigwillparse each processor independently even if they are exactly the same and each configuration will be synthesized separatelythereforewhenusingaconfigurationmorethanoncedescribetheprocessorwithaconfiguration block and instance it in the processor tile as shown above all crossbar devices must be uniquely addressable to avoid accidently instancing crossbar device configuration twice inside the crossbar block explicitly declare each crossbar device crossbar memory_map device0 form_option value a9 example netvortex form belowisanexamplenetvortexformthisformdefinesafourprocessorsystemasynchronouscrossbarand three devices memorymapped device writedescriptor device and test and set engine the four processors are identical ppu nvp product lx8000 product_type rtl technology custom custom_files yes testbed_env chip reset_type asynchronous reset_dist global sleep reset_buffers lx2 clock_buffers lx2 ram_clock_buffers cop1 none cop2 export cop3 none ce0 ce_hl ce1 none mem_line_order sequential mem_first_word zero mem_granularity byte system_interface lbus wdesc_addr 12hff6 lbc_wbuf 4april 2 2001 netvortex lexra proprietary confidential 111 release 19 lbc_rbuf 4 lbc_rdbypass yes lbc_sync_mode synchronous line_size 4 icache none dcache none imem range0x4040_00000x4040_1fff dmem range0x4051_00000x4051_1fff dmem_width 128 lmi_range_source hardwired lmi_ram_arb jtag export_extended ejtag yes ejtag_inst_break 2 ejtag_data_break 2 pc_trace ejtag_dclk_n 3 ejtag_tpc_m 8 ejtag_xv_bits 4 ejtag_pc_isabit scan_insert scan_mix_clocks scan_num_chains 4 scan_scl ram_bist_mux lexop2_opcode lx2op lexop2_disable thread_scheduler internal contexts 8 jtag_trst_is_tpc nvx_4proc ppu4 ppu pa nvp ppu pb nvp ppu pc nvp ppu pd nvp crossbar crossbar_sync_mode synchronous nvx_4proc xb0 ppu4 uncomment this line to make it 8 processors nvx_4proc xb1 ppu4 memory_map memory this device is on port 0 read_device yes addr_base 12h000 addr_mask 12h800 req_qsize 8 read_qsize 8 april 2 2001 netvortex lexra proprietary confidential 112 release 19 write_desc cam this device is on port 1 read_device yes device_id 32hffffffff req_qsize 8 read_qsize 8 taser testandset this device is on port 2 read_device yes addr_base 12hff8 addr_mask 12hfff req_qsize 8 read_qsize 8 semaphores 32 this form describes 4 processor system synchronous crossbar interface with 2gb memory mapped deviceawritedescriptordeviceandatestandsetenginedevicethedeviceportforthememorymapped device has an 8 entry queue for the device request path and an 8 entry queue for the read return path any device_id will select the writedescriptor device on port 1 of the crossbar this port also has an 8 entry queue for the device request path and an 8 entry queue for the read return path the test and set engine device is on crossbar port 2 and has 1 mb memorymapped window starting at ff80_0000h it is configuredfor32addressablesemaphoresandthecrossbarhas8entriesfortherequestandreadreturnpaths for the test and set engines port by declaring the ppu4 construct it is easy to reuse the tile description for 8 12 or 16 processor configurations a10 conﬁguration options for the lx8000 packet processor this section provides summary of the configuration options available with lconfig refer to lconfigforms for detailed description of these form options product lexra processor name product_type indicates product type technology identifies target technology testbed_env identifies simulation testbed environment type reset_type flipflop reset method reset_dist reset distribution method sleep include clock sleep support reset_buffers reset buffers at toplevel module clock_buffers clock buffers at toplevel module ram_clock_buffers lmi ram clock distribution method cop1 coprocessor interface 1 cop2 coprocessor interface 2 cop3 coprocessor interface 3 ce0 custom engine 0 ce1 custom engine 1 m16_support 16bit opcode support mem_line_order cache line fill beat ordering mem_first_word cache line fill first word mem_granularity main memory system partial word write supportapril 2 2001 netvortex lexra proprietary confidential 113 release 19 system_interface system bus interface type wdesc_addr write descriptor upper address bits lbc_wbuf lexra bus controller write buffer depth lbc_rbuf lexra bus controller read buffer depth lbc_rdbypass lexra bus controller read bypass enable lbc_sync_mode lbc synchronousasynchronous selection line_size cache line size in words icache instruction cache size dcache data cache size imem local instruction ram with line valid bits irom local instruction rom dmem_width local scratch pad data memory width dmem local scratch pad data ram lmi_data_granularity dcache and dmem write granularity lmi_range_source source of lmi address ranges lmi_ram_arb allow external agents to arbitrate for lmi rams jtag internal jtag tap controller with ejtag support ejtag ejtag debug support ejtag_inst_break number of instruction breaks to be compiled ejtag_data_break number of data breaks to be compiled jtag_trst_is_tpc trst pin is tpc out instead of tdotpc mux pc_trace ejtag pc trace pins ejtag_dclk_n ejtag pctrace dclk n parameter ejtag_tpc_m ejtag pctrace tpc m parameter ejtag_xv_bits ejtag pctrace number of exception vector bits ejtag_pc_isabit ejtag pctrace include isa as pc bit0 scan_insert controls scan insertion and synthesis scan_mix_clocks scan chains can cross clock boundaries with lockup latches scan_num_chains number of scan chains scan_scl scan collar insertion on ram interfaces sen_dist scan enable distribution method sen_buffers scan enable buffering ram_bist_mux include test ram mux and ports thread_scheduler location of thread scheduler contexts number of contexts threads in the processor a11 conﬁguration options for memorymapped devices read_device does the device return read data addr_base base address for memory mapped range 3120 addr_mask address mask used to specify the size of the map 3120 req_qsize xbar queue size for device request path read_qsize xbar queue size for device read path a12 conﬁguration options for the test set engine read_device does the device return read data addr_base base address for memory mapped range 3120 addr_mask address mask used to specify the size of the map 3120 req_qsize xbar queue size for device request path read_qsize xbar queue size for device read path semaphores of semaphores for the test and set engineapril 2 2001 netvortex lexra proprietary confidential 114 release 19 a13 conﬁguration options for writedescriptor devices read_device does the device return read data device_id 32bit write descriptor device id req_qsize xbar queue size for device request path read_qsize xbar queue size for device read path a14 conﬁguration options for the crossbar crossbar_sync_mode syncasync crossbar interconnectapril 2 2001 netvortex lexra proprietary confidential 115 release 19 appendix b netvortex port descriptions thetablebelowshowstheportconnectionsforthenetvortextoplevelmoduleknownasnvx3portsthatare replicatedformultipleprocessorsincludeninthenamewheren01upto15likewisedeviceports include m in the port name where m 0 1 up to 5 all ports must be connected to valid logiclevel sources the timing information indicates the point within cycle when the signal is stable in terms of percent the timing information also includes parenthetical references to these notes 1 clocked in the jtag_clock domain 2 clocked in the busclk domain if crossbar or lbc are asynchronous otherwise clocked in the sysclk domain 3 does not require constraint eg clock 4 false path eg conﬁguration input tied to constant 5 timing is speciﬁed with symbol in techvarsscr script eg ram timing table 46 netvortex top level port summary port name io timing description clocking reset interrupts and control sysclk input 3 processor clock busclk input 3 asynchronous crossbar clock resetn input 4 warm reset eg from button or higher level controller cresetn input 4 cold reset from power on condition pn_reset_d1_r_n_o output 30 sysclk domain reset combination of resetn cresetn ejtag xb_reset_d1_r_n input 4 sysclk domain reset input for cross bar connect to p0_reset_d1_r_n_o output xb_reset_d1_br_n input 4 busclk domain reset input for cross bar connect to p0_reset_d1_r_n_o output syn chronized into busclk domain pn_intreq_n152 input 4 interrupt requests active low ext_halt_p input 50 drive to one stalls processor next cycle conﬁguration cfg_memsequential input 4 strap to one if line reads return words in sequential order zero if interleave order tie to 1april 2 2001 netvortex lexra proprietary confidential 116 release 19 cfg_memzerofirst input 4 strap to one if line reads return word zero ﬁrst zero if desired word ﬁrst tie to 1 cfg_lbcwbdisable input 4 strap to one to disable read bypass of lbc write buffer zero to allow read bypass tie to 1 cfg_ejtnminus110 input 4 strap with ejtag dclk n minus 1 conﬁguration 0314 cfg_ejtmlog210 input 4 strap with ejtag m log2 031248 conﬁguration cfg_ejt3bitxvtpc input 4 strap with etjag 3bit tpc conﬁgura tion cfg_ejtbit0m16 input 4 strap with ejtag pc bit 0 in tpc ﬁguration cfg_ejdis input 4 must be strapped to zero cfg_dwdisw input 4 strap to one to disable processor dmem writes must be zero for netvor tex test and debug jtag_tdo_nr output 50 1 test data out jtag_tdi input 50 1 test data in jtag_tms input 60 1 test mode select jtag_clock input 3 test mode select jtag_trst_n input 4 tap controller reset pn_ejc_ecrprobeen_r output 30 one indicates ejtag probe is active pn_rbc_sel70 input 4 ram bist ram select code 10000000 instruction mem 01000000 not used 00100000 dcache data store 00010000 dcache tag store 00001000 icache tag store set 1 00000100 icache inst store set 1 00000010 icache tag store set 0 00000001 icache inst store set 0 note for netvortex the dmem is not accessible via the ram bist path pn_rbc_wek0 input 4 rambistwriteenablewherekis1 for word write granularity 7 for byte write granularity pn_rbc_re input 4 ram bist read enable pn_rbc_cs input 4 ram bist select pn_rbc_addr150 input 4 ram bist address pn_rbc_datawr630 input 4 ram bist write dataport name io timing descriptionapril 2 2001 netvortex lexra proprietary confidential 117 release 19 pn_rbm_datard630 output 4 ram bist read data data ram dma access pn_dmadw_rclk input 3 data ram dma clock optional pn_dmadw_dataindex174 input 5 data ram dma address pn_dmadw_datard1270 output 5 data ram dma read data pn_dmadw_datawr1270 input 5 data ram dma write data pn_dmadw_datacs input 5 data ram dma chip select pn_dmadw_datacsn input 5 data ram dma chip select active low pn_dmadw_datare input 5 data ram dma read enable pn_dmadw_dataren input 5 data ram dma read enable active low pn_dmadw_datawek0 input 5 data ram dma write enable where k is 3 for word write granularity 15 for byte write granularity pn_dmadw_datawenk0 input 5 data ram dma write enable active low where k is 3 for word write gran ularity 15 for byte write granularity coprocessor interface pn_c2condin input 80 cop branch ﬂag pn_c2rd_addr40 output 50 cop read address pn_c2rhold output 45 cop hold condition one stalls copro cessor pn_c2rd_gen output 50 cop general register read command pn_c2rd_con output 50 cop control register read command pn_c2rd_data310 input 80 cop read data pn_c2wr_addr40 output 20 cop write address pn_c2wr_gen output 20 cop general register write command pn_c2wr_con output 20 cop control write address command pn_c2wr_data310 output 30 cop write data pn_c2invld_m output 60 cop invalid instruction ﬂag one indi cates invalid instruction in m stage pn_c2xcpn_m output 60 cop exception ﬂag one indicates exception in m stage pn_c2rd_cntx20 output 40 cop read context number pn_c2wr_cntx20 output 30 cop write context number event control and thread observationport name io timing descriptionapril 2 2001 netvortex lexra proprietary confidential 118 release 19 pn_ext_clearwtevnt_r n810input 30 external hardware clear wait event ﬂags n is the number of contents pn_cx_stusthwait_r n10output 30 bits set to one indicate which contexts arewaitingforeventswherenisthe number of contexts pn_cx_threadactv_r n10output 30 abitsetoneindicateswhichcontextif anyisactivewherenisthenumber of contexts pn_ext_nxtcntx_p_r20 input 30 external scheduler next context pn_ext_nextcntxrdy_p_r input 30 external scheduler next context is ready pn_cx_stusthprio_rn3 10output 30 thread priority status error signalling xb_errbadaddrn output 2 20 abitpulsedhighidentiﬁesaprocessor thatpassedabadaddresstocrossbar where n is the processor xb_errinvldrdn output 2 20 abitpulsedhighidentiﬁesaprocessor that passed bad read request to crossbar where n is the processor xb_errthreadn30 output 2 20 identiﬁes error causing thread that sig nals an error via xb_errbadaddr or xb_errinvldrd n is the processor crossbar device interface devreqrdym output 2 20 asserted when new request is present reqaddrm310 output 2 20 request address reqcmdm30 output 2 20 request command reqsizem20 output 2 20 request size reqgtidm150 output 2 20 request global thread id reqdatam310 output 2 20 write data for memory mapped devices reqdevidm40 output 2 20 write descriptor device id for write descriptor devices reqdatam630 output 2 20 write descriptor write data for write descriptor devices devbusym input 2 30 device will not accept current request when asserted rddequeuem output 2 40 asserted by crossbar when it accepts read data rddatardym input 2 30 devices split read data is readyport name io timing descriptionapril 2 2001 netvortex lexra proprietary confidential 119 release 19 thetablebelowshowstheportconnectionsforthetoplevelmoduleofthelx8000processorknownaslx2 the timing information and notes have the same meaning as for the previous table table 47 lx8000 singleprocessor port summarysplitrddatam630 input 2 30 split read data rdgtidm150 input 2 30 global thread id associated with split read data rdcmdm10 input 2 30 read data command rdsizem10 input 2 30 read data size device management interface dmi_procnum70 input 2 20 processor number assigned to dmi dmi_devreqsm10 input 2 20 dmi request lines to devices m is the number of devices dmi_gnt output 2 20 dmi grant lines from devices dmi_cmd30 input 2 20 dmi command to device dmi_size20 input 2 20 dmi data size to device dmi_addr310 input 2 20 dmi address to device dmi_data630 input 2 20 dmi write data to device dmi_threadid30 input 2 20 dmi thread id to device dmi_devid40 input 2 20 dmi device address to device dmi_rdvalid output 2 20 dmi split read data valid from device dmi_rdbusy input 2 30 dmi read path busy to device dmi_rddata630 output 2 20 dmi split read data from device dmi_rdthreadid30 output 2 20 dmi split read thread id from device dmi_rdsize10 output 2 20 dmi split read data size from device dmi_rdcmd10 output 2 20 dmi split read data command from device port name io timing description clocking reset interrupts and control sysclk input 3 processor clock resetn input 4 warm reset or reset button cresetn input 4 cold reset or power on reset_d1_r_n input 4 sysclk domain reset combination of resetn cresetn ejtagport name io timing descriptionapril 2 2001 netvortex lexra proprietary confidential 120 release 19 reset_d1_br_n input 4 busclk domain reset combination of resetn cresetn ejtag reset_pwron_c1_n input 4 power on reset copy for jtag reset_pwron_d1_lr_n input 4 sysclk domain power on reset for ejtag reset_d1_r_n_o output 30 sysclk domain reset combination of resetn cresetn ejtag reset_d1_br_n_o output 30 2busclk domain reset combination of resetn cresetn ejtag reset_pwron_c1_n_o output 30 power on reset copy for jtag reset_pwron_d1_lr_n_o output 30 sysclk domain power on reset for ejtag intreq_n152 input 4 interrupt requests ext_halt_p input 50 external stall line conﬁguration cfg_tlb_disable input 4 disable tlb mappings even if pop_tlb cfg_sleepenable input 4 sleep enable conﬁguration cfg_rad_lexop50 input 4 lexop encoding must be 011111 for lx8000 cfg_rad_disable input 4 lexop disable conﬁguration must be zero for lx8000 cfg_singleissue input 4 single issue mode conﬁguration must be zero for lx8000 cfg_hlenable input 4 strap to one to enable internal hilo registers cfg_macenable input 4 strap to one to enable internal mac if present cfg_memsequential input 4 strap to one if line reads return words in sequential order zero if interleave order cfg_memzerofirst input 4 strap to one if line reads return word zero ﬁrst zero if desired word ﬁrst cfg_memfullword input 4 strap to one if main memory must be written with 32bit words zero if byte and halfword writes are allowed cfg_lbcwbdisable input 4 strap to one to disable read bypass of lbc write buffer zero to allow read bypass cfg_procnum70 input 4 strapped with processor number cfg_ejtnminus110 input 4 strap with ejtag dclk n minus 1 conﬁguration 0314port name io timing descriptionapril 2 2001 netvortex lexra proprietary confidential 121 release 19 cfg_ejtmlog210 input 4 strap with ejtag m log2 031248 conﬁguration cfg_ejt3bitxvtpc input 4 strap with etjag 3bit tpc conﬁgura tion cfg_ejtbit0m16 input 4 strap with ejtag pc bit0 in tpc ﬁguration cfg_dwbase3110 input 4 strapped with dmem base address conﬁguration value cfg_dwtop2310 input 4 strapped with dmem top address ﬁguration value cfg_iwbase3110 input 4 strappedwithimembaseaddresscon ﬁguration value cfg_iwtop2310 input 4 strapped with imem top address ﬁguration value cfg_iwrom input 4 straptoonetotreatimemlikearom note new applications should use irom instead of romlike imem cfg_iroff input 4 strap to one to disable irom cfg_dwdisw input 4 strap to one to disable processor dmem writes must be zero for lx8000 cfg_ejdis input 4 must be strapped to zero test and debug jtag_reset_o output 20 1 jtag is in testlogicreset state jtag_reset input 4 jtag is in testlogicreset state tap_reset_n_o output 20 1 tap controller reset tap_reset_n input 4 tap controller reset jtag_tdo_nr output 50 1 test data out jtag_tdi input 60 1 test data in jtag_tms input 60 1 test mode select jtag_clock input 3 test clock jtag_trst_n input 4 test reset ejc_ecrprobeen_r output 30 one indicates ejtag probe is active jtag_capture output 201 jtag is in data register cap ture state jtag_scanin output 501 scan input to chain jtag_scanout input 501 scan output from chain jtag_ir40 output 201 contents of instruction regis terport name io timing descriptionapril 2 2001 netvortex lexra proprietary confidential 122 release 19 jtag_shift_ir output 201 jtagisinshiftinstructionreg ister state jtag_shift_dr output 201 jtag is in shift data register state jtag_runtest output 201 jtag is in runtest state jtag_update output 201 jtag is in data register update state sen input 4 scan enable tmode input 4 test mode pins sink0 input 4 scan input k can range from 7 to 0 soutk0 output 4 scan output k can range from 7 to 0 rbc_sel70 input 4 ram bist ram select code 10000000 instruction mem 01000000 data mem 00100000 dcache data store 00010000 dcache tag store 00001000 icache tag store set 1 00000100 icache inst store set 1 00000010 icache tag store set 0 00000001 icache inst store set 0 rbc_wek0 input 4 rambistwriteenablewherekis1 for word write granularity 7 for byte write granularity rbc_re input 4 ram bist read enable rbc_cs input 4 ram bist select rbc_addr150 input 4 ram bist address rbc_datawr630 input 4 ram bist write data rbm_datard630 output 4 ram bist read data data ram dma access dmadw_rclk input 3 data ram dma clock dmadw_dataindex174 max input 5 data ram dma address dmadw_datard630 output 5 data ram dma read data 128bit interface is optional dmadw_datawr630 input 5 data ram dma write data 128bit interface is optional dmadw_datacs input 5 data ram dma chip select dmadw_datacsn input 5 data ram dma chip select active low dmadw_datare input 5 data ram dma read enable dmadw_dataren input 5 data ram dma read enable active lowport name io timing descriptionapril 2 2001 netvortex lexra proprietary confidential 123 release 19 dmadw_datawek0 input 5 data ram dma write enable where k is 3 for word write granularity 15 for byte write granularity dmadw_datawenk0 input 5 data ram dma write enable active low where k is 3 for word write gran ularity 15 for byte write granularity lbc interface to lbus or crossbar laddro310 output 2 20 address lcmdo80 output 2 20 output command ldatao630 output 2 20 output data ldatai630 input 2 50 input data lirdyo output 2 20 initiator ready lirdyi input 2 30 other initiators ready lframeo output 2 20 transaction frame lframei input 2 30 frame from other initiators lseli input 2 30 slave select ltrdyi input 2 30 target ready lgtido150 output 2 20 lbc global thread id lgtidi150 input 2 30 lbus global thread id xbrdvld input 2 30 crossbar read data valid xbrdsize input 2 30 split read data size spltrdfull output 2 30 read data queue full lid output 2 20 instructiondata luc output 2 20 bus request lcoe90 output 2 20 command output enable ltoe output 2 20 transaction output enable ldoe70 output 2 20 data output enable lreq output 2 50 bus request lgnt input 2 30 bus grant shared ram requestgrant interface ext_iwreqram_r input 30 external hardware drives to one to request access to imem iw_gntram_r output 30 cpu drives to one to grant external imem access request ext_dwreqram_r input 30 external hardware drives to one to request access to dmemport name io timing descriptionapril 2 2001 netvortex lexra proprietary confidential 124 release 19 dw_gntram_r output 30 cpu drives to one to grant external dmem access request ext_icreqram_r input 30 external hardware drives to one to request access to icache ic_gntram_r output 30 cpu drives to one to grant external icache access request ext_dcreqram_r input 30 external hardware drive to one to request access to dcache dc_gntram_r output 30 cpu drives to one to grant external dcache access request coprocessor interface czcondin input 80 cop branch ﬂag czrd_addr40 output 50 cop read address czrhold output 45 cop hold condition one stalls copro cessor czrd_gen output 50 cop general register read command czrd_con output 50 cop control register read command czrd_data310 input 80 cop read data czwr_addr40 output 20 cop write address czwr_gen output 20 cop general register write command czwr_con output 20 cop control write address command czwr_data310 output 30 cop write data czinvld_m output 60 cop invalid instruction ﬂag one indi cates invalid instruction in m stage czxcpn_m output 60 cop exception ﬂag one indicates exception in m stage czrd_cntx20 output 40 cop read context number czwr_cntx20 output 30 cop write context number c3cnt_iparet output 20 count instructions retired pipe c3cnt_ipbret output 20 count instructions retired pipe b c3cnt_ifetch output 20 count instruction fetches c3cnt_imiss output 20 count icache misses c3cnt_istall output 20 count icache stalls c3cnt_dmiss output 20 count dcache misses c3cnt_dstall output 20 count dcache stalls c3cnt_dload output 20 count data load operations c3cnt_dstore output 20 count data store operationsport name io timing descriptionapril 2 2001 netvortex lexra proprietary confidential 125 release 19 event control and thread observation ext_clearwtevnt_rn8 10input 30 clear status wait event bits where n is the number of contexts cx_stusthwait_rn10 output 30 bits set to one indicate which contexts arewaitingforeventswherenisthe number of contexts cx_threadactv_rn10 output 30 abitsetoneindicateswhichcontextif anyisactivewherenisthenumber of contexts ext_nxtcntx_p_r20 input 30 external scheduler next context ext_nextcntxrdy_p_r input 30 external scheduler next context is ready cx_stusthprio_rn310 output 30 thread priority status block transfer engine rxtz_ctl_r input 30 receive tbus control 1control beat 0data beat rxtz_data_r630 input 30 receive tbus data rxtz_rdy_r output 30 asserted when new receive descriptor is available txtz_rdy_r input 30 asserted when transmit scheduler is ready to accept transmit data txtz_incseq_r input 30 asserted when transmit scheduler wants btes to increment their sequence number txtz_done_r input 30 asserted when tbus will be idle in the next cycle txtz_busy_r output 30 asserted when the bte is transmitting data deasserted 2 cycles before ﬁn ishing txtz_ctl_r output 30 transmit tbus control 1control beat 0data beat txtz_data_r630 output 30 transmit tbus dataport name io timing descriptionapril 2 2001 netvortex lexra proprietary confidential 126 release 19 april 2 2001 netvortex lexra proprietary confidential 127 release 19 appendix c lx8000 pipeline stalls this section documents stall conditions that may arise in the lx8000 c1 stall deﬁnitions issue stall an invalid instruction enters the pipe while any other valid instructions in the pipe advance pipeline stall all instructions in either pipe stay in the same stage and do not advance stall if not otherwise qualified means pipeline stall c2 instruction groupings these instruction groupings are used to describe stall conditions that are based on the type of instructions in the pipeline table 48 instruction groupings for stall deﬁnition c3 nonsequential program flow issue stall jr jalr two issue stalls after the delay slot instruction j jal and taken branches stall cycles after the delay slot instruction nottaken branches two issue stalls after the delay slot instruction the branch rules are consequence of the fact that all branches are predicted to be takengroup name instructions in group miloadstore lb lh lw lbu lhu lwc1 lwc2 lwc3 sb sh sw swc1 swc2 swc3 micontrol j jalx jr jalr bltzal bgezal linked branches syscall break all copz mfcz cfcz mtcz ctcz bcfz bctz rfe lwcz swcz also in loadstore group miunlinkedbranch beq bne blez bgtz bltz bgez migeneral all remaining instructions mivcmove movz movn ejtagcontrol deret sdbbp m16sdbbpapril 2 2001 netvortex lexra proprietary confidential 128 release 19 c4 load subword stall load instructions which have byte or halfword operands always cause onecycle stall c5 storeload stall load instruction which follows store instruction by one cycle causes onecycle stall if the store instruction hits in the dcache or has byte or halfword operand c6 storeany storesubword stall if the lx8000 is configured to work with rams that have word write granularity store instruction which has byte or halfword operand and which follows any store instruction by one cycle always causes onecycle stall alternatively the lx8000 can be configured to work with rams support byte write granularity which eliminates the stall c7 loadstore ops stall matrix thefollowingtablesummarizesthestallrulesrelatedtoloadandstoreinstructionsdescribedaboveinthis table the 2nd op refers to an instruction which issues in the cycle after the 1st op table 49 loadstore ops stall matrix notes means stalls xu indicates unconditional stall for the indicated number of cycles xs indicates stall only if 2ndop source 1stop loadtarget xw indicates stall if data rams have wordwrite granularity c8 mvcz stall the coprocessor move instructions lwcz mtcz mfcz and mtlxc0 mflxc0 are always followed by single cycle issue stall c9 immu stall whentheprogramjumpsbranchesorincrementsbetweenthetwomostrecentlyusedpagesasinglecycle stall is incurred when the program jumps branches or increments to third page twocycle stall is incurred1st op 2nd op lw lt milbulhu sb sh sw non loadstore 1u lw lbu lhu 1u 1w 1u sb sh 1u 1w 1u sw 1u april 2 2001 netvortex lexra proprietary confidential 129 release 19 c10 immu issue stall whenanimmustalloccursduetoincrementingacrossapageboundaryandthereisanyofthefollowing instructionsfoundanywhereinthelastdoublewordofthepagethenthereisoneissuestallinadditiontothe immu stalls branch of any kind j jal ejtag dret c11 icache miss stall when an instruction cache miss occurs the processor is stalled for the duration of the cache line fill operation the number of cycles required to complete the line fill is system dependent c12 dcache miss stall when data cache miss occurs as the result of load instruction the processor stalls while it waits for the data the data cache releases the stall condition after the required word is supplied to the processor even if additionalwordsmuststillbefilledintothedatacachehoweveriftheprocessorissuesanotherloadorstore operation to the data cache while the remainder of the line fill is in progress the cache will again stall the processor until the line fill operation is completed whenadatacachemissoccursasaresultofaloadbyteorloadhalfwordtheprocessorstallsfortheduration of the cache line fill operation the number of cycles required to complete the line fill is system dependent c13 pipeline timing diagrams for stalls c131 nonsequential program flow issue stalls jrjalr jr i d s m w delayslot i d s m w notvld i notvld i target i d s j jal and taken branches j i d s m w delayslot i d s m w target i d s mapril 2 2001 netvortex lexra proprietary confidential 130 release 19 nottaken branches bntkn i d s m w delayslot i d s m w notvld i notvld i delay4 i d s c132 load subword stall lb i d s m m w foo2 i d s m w foo4 i d s s m w rhold x c133 storeload stall sw s04a0 i d s m w lw s20a0 i d s m m w foo3 i d s m w rhold x c134 storeany store subword stall sw s04a0 i d s m w sb s20a0 i d s m m w foo3 i d s m w rhold x sh s04a0 i d s m m w sb s20a0 i d s m m w foo2 i d s s m w rhold x x c135 mvcz stall mtc0 i d s m w foo i d d s m w foo1 i d s m w c136 lwcz stall lwc0 i d s m w foo i d d s m w foo1 i d s m wapril 2 2001 netvortex lexra proprietary confidential 131 release 19 c137 icache miss stall foo0 i d s m m m m m m w foo2 i d s m w foo4 i d i d s m w rhold x x x x x c138 dcache miss stall lw i d s m w foo2 i d s m m m m m w foo4 i d s m w rhold x x x xapril 2 2001 netvortex lexra proprietary confidential 132 release 19