lx5180 data sheet lexra inc release 19 april 19 2001 lexra proprietary and conﬁdentialapril 19 2001 lx5180 lexra proprietary confidential release 19 lx5180 data sheet revision 10 for rtl release 19 this document is proprietary and confidential to lexra inc copyright 2001 lexra inc all rights reserved mips mips16 mips abi mipsii mipsiv mipsv mips32 r3000 r4000 and other mips common law marks are trademarks andor registered trademarks of mips technologies inc lexra inc is not associated with mips technologies inc in any way smoothcore radiax and netvortex are trademarks of lexra incapril 19 2001 lx5180 lexra proprietary confidential i release 19 table of contents 1 lx5180 product overview 1 11 introduction 1 12 lx5180 processor overview 2 13 system level building blocks 4 131 smmu 4 132 local memory interface 4 133 coprocessor interface 4 134 custom engine interface 5 135 lexra bus controller 5 136 building block integration 5 14 rtl core smoothcore 5 15 eda tool support 5 2 lx5180 architecture 7 21 motivation 7 22 hardware architecture 7 221 module partitioning 7 222 six stage pipeline 8 23 ralu data path 9 24 system control coprocessor cp0 9 25 dual multiliplyaccumulate mac 10 251 dual mac operations 10 252 mac mode mmd register 11 253 architecture 12 254 vector addressing 15 255 circular buffers 16 26 radiax alu operations 17 261 extensions to mips alu operations 17 262 new alu instructions 18 263 conditional move operations 18 27 zero overhead loop facility 18 28 lowoverhead prioritized interrupts 20 3 lx5180 risc programming model 23 31 summary of mipsi instructions 23 311 alu instructions 24 312 load and store instructions 25 313 conditional move instructions 25 314 branch and jump instructions 26 315 control instructions 27 316 coprocessor instructions 27 32 opcode extension using the custom engine interface cei 28 321 cei operations 28 322 interface signals 28 33 memory management 29 34 exception processing 29 341 exception processing registers 31 342 exception processing entry and exit 32 35 the coprocessor interface ci 32april 19 2001 lx5180 lexra proprietary confidential ii release 19 36 power savings mode 32 4 mips16 35 41 mips16 instructions 35 42 mode switching 38 43 exceptions 38 44 delay slots 38 5 lx5180 dsp programming model 39 51 radiax instructions 39 511 radiax dualmac instructions 39 512 cyclebycycle usage for dual mac instructions 42 513 vector addressing instructions 45 514 radiax alu operations 47 515 conditional operations 49 52 instruction encoding 50 521 lexra formats 50 522 loadstore formats 51 523 arithmetic format 52 524 mac format 53 525 mac format b 54 526 mac format c 55 527 radiax move format and lexracop0 mtlxc0mflxc0 55 528 cmove format 57 529 lexra subop bit encodings 57 6 lx5180 local memory 59 61 local memory overview 59 62 cache control register cctl 60 63 instruction cache icache lmi 61 64 instruction memory imem lmi 62 65 instruction rom irom lmi 64 66 direct mapped write through data cache dcache lmi 65 67 scratch pad data memory dmem lmi 66 7 lx5180 system bus 69 71 connecting the lx5180 to internal devices 69 72 terminology 69 73 bus operations 70 731 singlecycle read 70 732 read line 70 733 burst read 71 734 singlecycle write 71 735 line write 71 736 burst write 71 74 signal descriptions 72 75 lbus commands 72 76 byte alignment 73 77 lexra bus controller 73 771 lbc commands 73 772 lbc write buffer and outoforder processing 74 773 lbc read buffer 74 774 transfer descriptions 75april 19 2001 lx5180 lexra proprietary confidential iii release 19 775 single cycle read with waits 76 776 single cycle read with target wait 77 777 line read with waits 77 778 line read with target waits 78 779 line read with initiator waits 78 7710 burst read 79 7711 singlecycle write with waits 79 7712 singlecycle write with waits 80 7713 burst write with waits 80 7714 burst write with target waits 81 7715 burst write with initiator waits 81 78 lbc signals 82 79 arbitration 83 791 rules 83 792 lbc behavior 83 710 connecting devices to the bus 83 8 lx5180 coprocessor interface 85 81 attaching coprocessor using the coprocessor interface ci 85 82 coprocessor interface ci signals 85 83 coprocessor write operations 86 84 coprocessor read operations 86 85 coprocessor interface and pipeline stages 87 851 pipeline holds 87 852 pipeline invalidation 87 9 lx5180 ejtag 89 91 introduction 89 92 overview 89 921 ieee jtagspecific pinout 90 93 single processor pc trace 90 931 pc trace dclk debug clock 91 932 pc trace pcst program counter status trace 91 933 pc trace tpc target program counter 91 934 singleprocessor pc trace pinout 91 935 vectored interrupts and pc trace 92 936 demultiplexing of tdo and tdi during pc trace 92 appendix alx5180 lconfig forms 93 a1 configuration options for the lx5180 processor 93 appendix blx5180 port descriptions 95 appendix c lx5180 pipeline stalls 103 c1 stall definitions 103 c2 instruction groupings 103 c3 nonsequential program flow issue stall 103 94 loaduse single cycle issue stall 104 c4 load subword stall 104 c5 storeload stall 104 c6 storeany storesubword stall 104 c7 loadstore ops stall matrix 104 c8 mvcz stall 104 c9 immu stall 105april 19 2001 lx5180 lexra proprietary confidential iv release 19 c10 immu issue stall 105 c11 icache miss stall 105 c12 dcache miss stall 105 c13 pipeline timing diagrams for stalls 105 c131 nonsequential program flow issue stalls 105 c132 load subword stall 106 c133 storeload stall 106 c134 storeany store subword stall 106 c135 mvcz stall 106 c136 lwcz stall 107 c137 icache miss stall 107 c138 dcache miss stall 107april 19 2001 lx5180 lexra proprietary confidential v release 19 list of tables table 1 eda tool support6 table 2 cp0 registers10 table 3 mmd fields radiax user register 2412 table 4 prioritized interrupt exception vectors21 table 5 alu instructions24 table 6 load and store instructions25 table 7 conditional move instructions25 table 8 branch and jump instructions26 table 9 control instructions27 table 10 coprocessor instructions27 table 11 custom engine interface operations28 table 12 custom engine interface signals28 table 13 smmu address mapping29 table 14 list of exceptions30 table 15 mips i instructions not supported by mips1636 table 16 mips16 instructions that support mips i36 table 17 new mips16 instructions37 table 18 pcrelative addressing37 table 19 radiax dualmac instructions39 table 20 cycles required between dual mac instructions43 table 21 vector addressing instructions45 table 22 radiax alu operations47 table 23 conditional operations49 table 24 local memory interface modules59 table 25 icache configurations61 table 26 icache ram interfaces62 table 27 imem configurations63 table 28 imem ram interfaces63 table 29 irom configurations64 table 30 irom rom interfaces65 table 31 dcache configurations65 table 32 dcache ram interfaces66 table 33 dmem configurations67 table 34 dmem ram interfaces67 table 35 line read interleave order71 table 36 lbus signal description72 table 37 lbus byte lane assignment73 table 38 lbus commands issued by the lbc74 table 39 lbc interface signals82 table 40 coprocessor interface signals85 table 41 ejtag pinout90 table 42 ejtag ac characteristics90 table 43 ejtag synthesis constraints90 table 44 singleprocessor pc trace pinout91 table 45 singleprocessor pc trace ac characteristics92 table 46 lx5180 processor port summary95 table 47 instruction groupings for stall definition103 table 48 loadstore ops stall matrix104april 19 2001 lx5180 lexra proprietary confidential vi release 19 april 19 2001 lx5180 lexra proprietary confidential vii release 19 list of figures figure 1 lx5180 processor overview3 figure 2 processor core module partitioning8 figure 3 dual mac data path13 figure 4 postmodified pointers with circular buffer support16 figure 5 lexra system bus diagram69april 19 2001 lx5180 lexra proprietary confidential viii release 19 april 19 2001 lx5180 lexra proprietary confidential 1 release 19 1 lx5180 product overview 11 introduction this data sheet describes the lx5180 new lowpower riscdsp developed for intellectual property ip licensing the lx5180 can perform multiply accumulate mac operations at the same rate as its clock frequency the lx5180 is not just highly specialized dsp architecture but also carefully engineered extensiontothemipsisaasaresultsystemfunctionsandcomputationallyintensivedspalgorithmscan be integrated on single lowcost subsystem key applications include powersensitive products which requirehighdspperformancesuchasdigitalstillcameraspdaswithaudiocapabilitiesorconsumeraudio products asdspintensiveapplicationshavegainedcommercialimportancetherehasbeenanincreasingrecognition of the benefit of implementing dsp functions on the cpu cpu is usually required for memory managementuserinterfaceandcontrolsoftwarecpusalsohaveexcellentthirdpartysoftwaretoolsupport however software implementations of dsp algorithms such as the fir filter or discrete cosine transform dcttypicallysufferbyanorderofmagnitudeinperformancecomparedtospecializeddspstheproblem iscompoundedbythedifficultyofdeterministicallyallocatingrealtimeinsophisticatedcpusvendorshave addressed these problems by offering dsp coprocessors which have separate instruction sets separate instruction stores and execution units and dsp accelerators which share the same istream with the cpu buthaveseparatedspexecutionunitseachoftheseapproachesimposesasubstantialburdenonthecpuin managing the dsp functions the lx5180 on the other hand tightly integrates its dsp extensions into the mips isa as result wide variety of thirdparty tools are available and the lx5280 programmer can switch seamlessly from risc code to dsp code thelx5180addstothemipsiinstructionsetacollectionofdsporientedinstructionscalledtheradiaxtm instruction set the radiax instruction set adds dual 16bit multiply and multiplyaccumulate operations including dsp modes such as saturation rounding and fractional arithmetic it includes dsp addressing modessuchaspostmodifiedaddresspointerscircularbuffersandzerooverheadloopsitalsoincludesdual 16bit simd alu operations and data alignment operations for applications where 16 bits of data is sufficient features introduced in lexras risc product line to support systemonchip soc design including customerdefined coprocessors and customer extensions to the mips isa are standard in the lx5180 configuration options include extendedjtag ejtag support for debug and incircuit emulation ice lexras products include the same memory management stub smmu as the lx4189 because the lx5180 executes the mips instruction set wide variety of thirdparty software tools are immediately available including compilers operating systems debuggers and incircuit emulators the assembler extensions and cycle accurate instruction set simulator iss are developed by lexra programmers can use offtheshelf c compilers for initial coding then replace performancecritical loops with optimized assembler code third parties provide c compiler support for the new dsp instructions and will supply dsp macro libraries and application packages compiler support is provided by the greenhills multi ide package dsp library of functions such as filters and transforms will be available from lexraapril 19 2001 lx5180 lexra proprietary confidential 2 release 19 key features complete processor subsystem executes mips i isa except unaligned loads stores extensive thirdparty tool support highperformance 6stage pipeline local instruction memory andor cache configurable sizes local data memory andor cache configurable sizes memory interface logic included system bus controller optional customerdefined coprocessors optional customerdefined instruction extensions supports ejtag draft 20 for debugging portable rtl model available as synthesizable rtl portable to any 025 µm 018µmor 015µm logic and sram process foundry partners include ibm tsmc and umc easy asic design single phase clocking fully synchronous design easy to interface system bus protocol supports popular eda tools executes lexras radiaxtm instruction set simd operations zerooverhead loop multiplyaccumulate instructions vector and circular buffer addressing modes easy rtl customization userconfigurable local memory reset method clock distribution userconfigurable ejtag breakpoints over 30 other configuration options interfaces for adding applicationspecific instructions 12 lx5180 processor overview the lx5180 is riscdsp processor that executes the mipsi instruction set1along with lexras radiaxtmdsp extensions however the clocking pipeline structure pinout and memory interfaces have allbeendesignedbylexratoreflectsystemonsilicondesignneedsdeepsubmicronprocesstechnologyas well as design methodology advances 1 the mips unaligned load and store instructions lwl lwr swl swr are not supportedapril 19 2001 lx5180 lexra proprietary confidential 3 release 19 the figure below shows the structure of the lx5180 processor figure 1 lx5180 processor overview mipsisaexecution thelx5180supportsthemipsiprogrammingmodeltwosourceoperandscanbe supplied and one destination update performed per cycle the second operand is either register or 16bit immediatetheinstructionsetincludesawideselectionofaluoperationsexecutedbytheralulexras proprietary register based alu the ralu also generates memory addresses for 8bit 16bit and 32bit register loads from stores to memory by adding register base to an immediate offset branches are based on comparisons between registers rather than flags and are therefore easy to relocate optional links following jump or branch instructions assist with subroutine programming the mips unaligned load and store instructions are not supported because they represent poor priceperformance tradeoff for embedded applications pipeline lx5180 instructions are executed by sixstage pipeline that has been designed so that all transactions internal to the lx5180 as well as at the interfaces occur on the positive edge of the processor clock twophase clocks are not used exception handling the mips r3000 exception handling model is supported exceptions include both instructionsynchronous trapsaswellashardwareandsoftware interruptsthestatusregistercontrolsthe interrupt mask and operating mode exceptions are prioritized when an exception is taken control is transferred to the exception vector the current instruction address is saved in the epc register and the exceptionsourceisidentifiedinthecauseregisterauserprogramlocatedattheexceptionvectoridentifies thecauseoftheexceptionandtransferscontroltotheapplicationspecifichandlerintheeventofanaddress error exception the badvaddr holds the failing address coprocessoroperations thelx5180supports32bitcoprocessoroperationstheseincludemovestoand from the coprocessor general registers and control registers mtcz mfcz ctcz cfcz coprocessor loads and stores lwcz swcz and branches based on coprocessor condition flags bczt bczf the lexrasuppliedcoprocessorinterfacecansupportcoprocessoroperationsinasinglecyclewithoutpipeline stalls lx5180 provides excellent priceperformance and timetomarket there are two main approaches which lexra has taken to achieve this deliver simple building blocks outside the processor core to enable system level customizations such as coprocessors application specific instructions memories and busses deliver either fully synthesizable verilog source model or fully implemented hardcore called smoothcore for popular pureplay foundriesinst ramicache ram inst lmi data lmi data ramdcache ramlx5180 cpu corecustom engine ci 13ceiinstruction bus addr data ctl data bus addr data ctl coprocessorslbcsystem bus denotes customer logicinst romapril 19 2001 lx5180 lexra proprietary confidential 4 release 19 section13 describes the building blocks and section14 describes the deliverable models 13 system level building blocks the lx5180 processor is designed to easily fit into different target applications it provides the following building blocks simple memory management unit smmu an optimized custom engine interface cei up to three coprocessor interfaces ci flexible local memory interface lmi that supports instruction cache instruction ram instruction rom data cache and data ram lexra bus controller lbc to connect peripheral devices and secondary memories to the processors own local buses the following sections discuss each of these system building block interfaces 131 smmu the lx5180 smmu is designed for embedded applications using single address space its primary function is to provide memory protection between user space and kernel space the smmu is consistent with the mips address space scheme for userkernel modes mapping and cacheduncached regions 132 local memory interface the lx5180s harvard architecture provides local memory interfaces lmis that support instruction memory and data memory synchronous memory interfaces are employed for all memory blocks the lmi block is designed to easily interface with standard memory blocks provided by asic vendors or by third party library vendors the lmis provide twoway set associative instruction cache interface and directmapped writethrough datacacheinterfacethetagcomparelogicaswellasacachereplacementalgorithmareprovidedaspartof the lmi one of the instruction cache sets may be locked down as unswappable local memory local instructionanddatamemoriescanalsobemappedtofixedregionsofthephysicaladdressspaceandinclude nonvolatile memory such as rom flash or eprom 133 coprocessor interface lexrasuppliesanoptionalcoprocessorinterfaceciforapplicationsrequiringthisfunctionalityuptothree cis may be implemented in one design the coprocessor interface eavesdrops on the instruction bus if coprocessor load lwcz or move to mtcz ctcz is decoded data is passed over the data bus into ci register then supplied to the designerdefined coprocessor similarly if coprocessor store swcz or movefrommfczcfczisdecodeddataisobtainedfromthecoprocessorandloadedintoaciregister then transferred onto the data bus in the following cycle the design interface includes data bus fivebit addressandindependentreadandwriteselectsforcoprocessorregistersandcontrolregistersthelx5180 pipeline and harvard architecture permit single cycle coprocessor access and transfer an application defined coprocessor condition flag is synchronized by the ci then passed to the sequencer for testing in branch instructionsapril 19 2001 lx5180 lexra proprietary confidential 5 release 19 134 custom engine interface the lx5180 includes custom engine interface cei that the application may use to extend the mips i alu opcodes with applicationspecific or proprietary operations similar to the standard alu the cei supplies the custom engine two input 32bit operands src1 and src2 one operand is selected from the register file depending on the most significant 6 bits of the opcode the second operand is either selected from the register file or is 16bit signextended immediate the opcode is locally decoded by the custom engine and following execution by the custom engine the result is returned on the 32bit result bus to the lx5180 to support multicycle operations stall input is included in the interface 135 lexra bus controller thelexrabuscontrollerlbcistheinterfacebetweenthelx5180andtheoutsideworldwhichincludes dram and various peripherals it is nonmultiplexed nonpipelined and nonparity checked bus to providetheeasiestbusprotocolfordesignintegrationontheprocessorsidethelbcprovidesawritebuffer of configurable depth to support the writethrough cache as well as the control for byte and halfword transfers on the peripheral side the lbc is designed to easily interface to industry standard bus protocols such as pci usb and firewire thelbccanrunatanyspeedfrom33mhzuptothespeedofthelx5180processorcoreinboththertl core and smoothcore 136 building block integration the lx5180 configuration script lconfig provides menu of selections for designers to specify building blocks needed number of different memory blocks target speed and target standard cell library next the configuration software automatically generates top level verilog model makefiles and scripts for all steps of the design flow for testability purposes all building blocks contain scan control signals the lexra synthesis scripts include scan insertion which allows atpg testing of the entire lx5180 core 14 rtl core smoothcore lexra delivers lx5180 as rtl core and smoothcore rtlcore forfullasicdesignsthertlisfullysynthesizableandscantestableverilogsourcecodeand maybetargetedtoanyasicvendorsstandardcelllibrariesinthiscasethedesignermaysimplyfollowthe asicvendorsdesignflowtoensurepropersignoffinadditiontotheverilogsourcecodeandsystemlevel test bench lexra provides synthesis scripts as well as floor plan guidelines to maximize the performance of the lx5180 smoothcore forcotdesignsthataremanufacturedatpopularfoundriessuchasibmtsmcandumc smoothcore port is the quickest lowest cost and best performance choice in this case the lx5180 has been fully implemented and verified as hard macro all data path register file and interface optimizations havebeenperformedtoensurethesmallestdiesizeandfastestperformancepossiblefurthermorethereisa scan based test pattern that provides excellent fault coverage during manufacturing tests 15 eda tool support lexra supports mainstream eda software so designers do not have to alter their design methodology the following is snapshot of eda tools currently supportedapril 19 2001 lx5180 lexra proprietary confidential 6 release 19 table 1 eda tool support design flow tools supported simulation synopsys vcs cadence verilog xl cadence ncverilog synthesis synopsys design compiler static timing synopsys primetime dft synopsys tetramax pr avant apollo iiapril 19 2001 lx5180 lexra proprietary confidential 7 release 19 2 lx5180 architecture 21 motivation thelx5180isasingleissueriscdspprocessorwhichaddsdspfeaturestoariscpipelineitistargeted ataddingdspaudioor communications functionality to adeviceperformingonly system control functions or for ics requiring dsp functionality in battery operated devices the lx5180 uses sixstage singleissue pipeline and 32bit memory interfaces similar to risc controller product however it adds dual 16 bit operations to support simd arithmetic new vector addressingmodesforenhanceddspperformanceandadualmacwhichsupportstwo16bitmultipliesper cycle 22 hardware architecture 221 module partitioning the lx5180 processor core includes two major blocks the ralu register file and alu and the cp0 controlprocessortheraluperformsaluoperationsandgeneratesdataaddresseswhilecp0includes instruction address sequencing exception processing and product specific mode control the ralu and cp0 are looselycoupled and include their own independent instruction decodersapril 19 2001 lx5180 lexra proprietary confidential 8 release 19 figure 2 processor core module partitioning 222 six stage pipeline the lx5180 has six stage pipeline thesixstagepipelineprovidesacompleteprocessorcyclefortheinstructionmemoryprovidingeaseofuse integrating for allowing use of larger and setassociative memories without degrading cycle time the six pipeline stages allow the processor clock speed to scale with current silicon processes as result of the dstage two cycle penalty is incurred on branch prediction failure vs the onecycle penalty in the lx4180 five stage pipeline however the lx5180s zerooverhead loop hardware and conditionalmoveinstructionscanbeusedtoavoidanywastedcyclesinthecontrolofrealtimecriticalloopsstage 1 i instruction fetch stage 2 d decode stage 3 s source fetch register file read stage 4 execution and address generation stage 5 m memory data select read data cache store and tags stage 6 w write back to register fileregister file 32 x 32b r0 0 4p 2r2w alu cei1cbs0cbs2 cbe0cbe2 res0opaopbres1opaopb dual mac dmaccustom engine optional m0m3n z ov_adbus1 data addrjump addresslink addressaddr_ra2addr_wa1 addr_ra1 addr_rb2addr_wb1 addr_rb1addr_wb2 addr_wa2 ra2wa1 wa2 ra1 pridexception processing logicpc and sequencercp0 and controlralufsinstruction address and control instructionsapril 19 2001 lx5180 lexra proprietary confidential 9 release 19 23 ralu data path the lx5180 ralu incorporates 32x32b fourport register file one write port is dedicated to 32bit registerfileloadsfromthedatabusloadsmfczcfczmovesfromcoprocessortheremainingthree ports 2r1w are used for the other operations such as alu operations theinstructionsetincludesawideselectionofaluoperationsexecutedbytheraluinthecaseofalu operations one operand is register and the second operand is either register or 16bit immediate value the immediate value is signextended or zeroextended depending on the operation signed adds and subtracts can generate the arithmetic overflow trap ov which is sampled by cp0 theralualsogeneratesthevirtualmemoryaddressesforregisterloadsfromstorestomemorybyadding aregisterbasetoasignextended16bitimmediateoffsetdataaddresserrorsgeneratethe adelades trap flags which are sampled by cp0 the lx5180 employs bigendian memory addressing branches are based on comparisons between registers rather than implicit flags permitting the programmer moreflexibilityfromthesecomparisonstheralugenerates nandzflagsforsamplingincp0branchor jump instructions may optionally store in general purpose register the address of the instruction at the memory location following the branch delay slot of jump or branch which is taken this register called thelink holds the return address following subroutine call coprocessor operations permit moves of the general purpose registers to one of three optional application specific coprocessors the general purpose registers may also be loaded from the coprocessor registers these transfers occur over the data bus similar to data memory loads and stores in addition the ralu interfaces with the dualmac as custom engine this interface can supply two 32 bitoperandspercycleandreturnasingle32bitoperandpercycleinthecaseofthedualmaceachofthe 32bit operands can be interpreted as two independent 16bit operands 24system control copr ocessor cp0 the system control coprocessor cp0 is responsible for instruction address sequencing and exception processing fornormalexecutionthenextinstructionaddresshasseveralpotentialsourcestheincrementoftheprevious address branch address computed using pcrelative offset or jump target address for jump addresses the absolute target can be included in the instruction or it can be the contents of generalpurpose register transferred from the ralu branches are assumed or predicted to be taken in the event of prediction failure two stall cycles are incurred and the correct address is selected from special backup register statistics from several large programssuggestthatthesestallswilldegradeaveragelx5180throughputbyseveralpercenthoweverthe net effect of the lx5180s branch prediction on performance is positive because this technique eliminates certain critical paths and therefore permits higher speed system clock if anexception occurs cp0 selects one of several hardwired vectors for the next instruction address the exception vector depends on the mode and specific trap which occurred this is described further in section34 exception processing the following registers which are visible to the programming model are located in cp0april 19 2001 lx5180 lexra proprietary confidential 10 release 19 table 2 cp0 registers epc status cause and badvaddr are described further in the section34 prid is readonly register that allows the customers software to identify the specific version of the lx5180 that has been implemented in their product the cctl register is lexra defined cp0 register used to control the instruction and data memories as described in section62 cache control register cctl the contents of the above registers can be transferred to and from the ralus generalpurpose register file usingcp0operationsunlikeregisterslocatedincoprocessors13theycannotbeloadedorstoreddirectly to data memory 25 dual multiliplyaccumulate mac 251 dual mac operations the dual mac data path is illustrated in figure3 on page13 the major subsystems are two 16bit multiplyaccumulate data paths each with 16bit x 16bit multiplier 32bit product register four 40bit accumulator registers with optional saturate output scalers 40bit addsubtractdual round unit with optional saturate one or two 16bit x 16bit multiply or multiplyaccumulate operations can be initiated every cycle with three cycle latency 32bit x 32bit multiply executes on single multiplyaccumulate data path with five cycle latency by using both data paths 32bit x 32bit multiplyaccumulate can be initiated every other cycle 32bit x 32bit multiplyaccumulate executes using combination of single multiply accumulate data path followed by the addround the total latency is six cycles by using both data paths 32bit x 32bit multiplyaccumulate can be initiated every other cycle complex multiply 16bit real 16bit imaginary perproduct uses both multiply accumulatedatapathswiththreecyclelatencyanewcomplexmultiplycanbeinitiated every two cyclescp0 register number function badvaddr 8 holds bad virtual address if address exception error occurs status 12 interrupt masks mode selects cause 13 exception cause epc 14 holds address for return after exception handler prid 15 processor id readonly 0x0000c501 for lx5180 cctl 20 instruction and data memory controlapril 19 2001 lx5180 lexra proprietary confidential 11 release 19 one divide unit 252 mac mode mmd register several new dsp features are controlled using the mmd mac mode register mmd is new radiax user register 24 which is accessed using radiax user move instructions mtru and mfru if mmd is updated between mac instruction and the mfa instruction that retrieves the result of that instruction the resulting operation is undefined the fields in mmd are as follows note that mmd is reset to all zeroes mmd radiax user register 24 new radiax user register 24 accessed with mtru mfru operationsmf selects arithmetic mode for multiplies in the dual mac 0 use integer arithmetic mode 1 use fractional arithmetic mode ms selects saturation boundary in the dual mac accumulators 0 saturate at 40 bits 1 saturate at 32 bits mt selects truncation of 32x32 multiplies in the dual mac 0 perform full 32x32 multiply sum all four partial products 1 omit partial product rs1500 x rt1500 when performing 32x32 multiply rnd selects the rounding mode used in the rnda2 instruction 00 convergent rounding sometimes called roundtonearesteven round to nearest number when the number to be rounded is midway betweentwonumbersrepresentableinthesmallerformatroundtothe even number the rounded result will always have 0 in the lsb assuming that the lsb left of the roundoff point is random convergent rounding is unbiased 01 roundtonearest round to nearest number when the number to be rounded is midway betweentwonumbersrepresentableinthesmallerformatroundtothe more positive number this rounding mode is common because it is easily implementedbyalwaysadding00100tothenumbertobe rounded digits to the right of are dropped after rounding 1x reservedapril 19 2001 lx5180 lexra proprietary confidential 12 release 19 reset to 0 table 3 mmd fields radiax user register 24 253 architecture the multiplyaccumulate data paths can operate on 16bit input data either individually or in parallel the same assembler mnemonic is used for individual or parallel operation the output register specified determines whether mac0 or mac1 or both operate for example eachmultipliercaninitiateanew16bitx16bitproducteverycycle singlecyclethroughput each16bitx 16bit multiplyaccumulate completes in three cycles figure3 illustrates the intermediate pipeline registers temp0 temp1 product 0 product 1 to help the reader remember that the multipliers require two cycles but have single cycle throughput temp0 temp1 product 0 product 1 are not accessible by the programmer thus there are two delay slots for multiplication or multiplyaccumulate for examplefieldwidth bitsdescription rnd 2 rounding mode 00 convergent 01 roundtonearest 10 reserved 11 reserved mf 1 mac fractional mode ms 1 mac 32bit saturate mode mt 1 mac 32x32 truncate mode madda2 m0l r2 r3 mac0 m0l m0l r21500 r31500 mac1 idle madda2 m0h r2 r3 mac0 idle mac1 m0h m0h r23116 r33116 madda2 m0 r2 r3 mac0 m0l m0l r21500 r31500 mac1 m0h m0h r23116 r33116 cycle 1 madda2 m1h r2 r3 cycle 2 delay slot 1 new m1h is not available cycle 3 delay slot 2 new m1h is not available cycle 4 mfa r3 m1h new m1h is available2 2731 534 0 rnd2 mf1 ms 10 mt 11april 19 2001 lx5180 lexra proprietary confidential 13 release 19 figure 3 dual mac data path the accumulator m1h can be referenced by mfa in inst2inst3 however two one stall cycles will be incurred it is expected that the number of stall cycles in dsp algorithms will be minimal because typically many products are accumulated before the accumulator must be stored in 64tap fir for example 64 termsareaccumulatedbeforethefiltersampleisupdatedin memoryalsothefouraccumulatorpairsallow loops to be unrolled so that up to three additional independent mac operations can be initiated before the result of the first is available compared to typical risc multiplyaccumulate unit the lx5180 mac includes number of features criticaltohighfidelitydsparithmeticthesefeaturesareoptionallyselectedbyopcodesandormodebitsin the mmd register and are compatible with conventional integer arithmetic also supported by the lx5180x divider div divuy 32 32 multiplier 0 16b x 16b temp0 32 32 product 0 32 40 accumulator 0 mlp mlsatml pax ml satml paxmultiplier 1 16b x 16b temp1 32 32 product 1 32 40 accumulator 1 mhp mh satmh pax mh satmh pax acc m0l4040 acc m1l40 acc m2l40 acc m3l4040 40 scaler 08 16 32acc m0h40 acc m1h40 acc m2h40 acc m3h40 40 scaler 08 16 32 32add subtract dual round w saturateapril 19 2001 lx5180 lexra proprietary confidential 14 release 19 accumulator guard bits fractional arithmetic saturation rounding output scaling accumulationisperformedat40bitprecisionusingeight guardbits foroverflowprotectionthealternative is to require the programmer to rightshift scale products prior to accumulation which complicates programming and causes loss of precision prior to accumulation the product is signextended to 40bits withguardbitstypicallytheonlylossofprecisionwilloccurattheendofalengthycalculationwhenthe40 bit result must be stored to the general register file or to memory in 32bit or 16bit format fractional arithmetic is implemented by the programs interpretation of the 16 32 or 40bit quantities and iscontrolledbyabitinthemmdregisterwhenfractionalmodeisselectedthedualmacshiftstheresults of any radiax multiply operation left by one bit to maintain the alignment of the implied radix point furthermore since 1 can be represented in fractional format but 1 cannot be represented in fractional mode the dual mac detects when both operands of multiply are equal to 1 if so it generates the approximate product consisting of 0 for the sign bit representing positive result and all ones for the remaining bits this is true for both 16x16 bit and 32x32 bit radiax multiplications the least significant bit of product is always zero in fractional mode due to the left shift the accumulation units can add the product to or subtract it from one of the four accumulator registers this operation can be performed with optional saturation that is if result overflows underflows the accumulator is updated with the largest smallest positive negative number rather than the wraparound result with incorrect sign the lx5180 instructions include multiplyadd and multiplysub each with and without saturation there are also instructions for adding or subtracting any pair of 40bit accumulator registers together with and without saturation bit in the mmd register determines whether the saturation isperformedonthefull40bitsorwhethersaturationisperformedat32bitsthelattercapabilityisusefulfor emulatingtheresultsofotherarchitecturesthatdonothaveguardbitsin32bitsaturationmodeafull40bit compareisusedtodetermineiftheresultisgreaterlessthanthemaximumminimumvaluewhichcanbe stored in 32bit quantity this provides the most robust solution inthecasethattheinstructionrequiresmultiplicationbutnoaccumulationtheproductispassedthroughthe accumulationunitunchangedthusboth16bitmultiplicationandmultiplyaccumulaterequirethreemac cycles round instruction can also be executed on one or pair of the accumulator registers to reduce precision prior to storage the rounding mode is selectable in the mmd register the output scaler is used to right shift scale the accumulator register when it is transferred to the general register file the dual mac is also used to execute the 32bit multu and divu instructions specified in the mips isainthecaseofmultuoneofthe16bitmultiplyaccumulatedatapathsworksiterativelytoproduce the 64bit product in five cycles the least significant 32 bits are available one cycle earlier than the most significant 32 bits note the mmd mode bits have effect on the operation of the standard mips isa instructions by contrast the lx5180 multa instruction is subject to the mmd mode bits for fractional arithmetic and truncated 32x32 multiplication 32bitx32bitmultiplyaccumulateinstructionsmaddamsubaareimplementedusingoneofthe16april 19 2001 lx5180 lexra proprietary confidential 15 release 19 bit multiplyaccumulate data paths and the addround unit it provides 64bit multiply result which is signextended and accumulated at 72bits the result is available in six cycles the least significant 32 bits areavailableonecycleearlierthanthemostsignificant40bitsthemaduandmsubuinstructionsof the mips32 isa are also supported forthelx5180multaanaccumulatorpairm0h390m0l310m1h390m1l310etcisthetarget m0h390 is aliased to hi m0l310 is aliased to the most significant 8bits of the 40bit hi accumulatorareusedastheguardbitswhiletheloaccumulatorissimplyzeroextendedto40bitsunlike the dual 16bit operations singlecycle throughput is not available for 32bit data however since there are twoavailabledatapathstwo32bitx32bitmultiplyoperationscanbeinitiatedeveryfourcyclesthedual mac hardware automatically allocates the second operation to the available data path if third 32bit multiplication is programmed too soon stall cycles are inserted until one of the data paths is free thedualmacalsosupportsacomplexmultiplyinstructioncmultaforthisinstructioneachofthe32 bitgeneralregisteroperandsisconsideredtorepresenta16bitrealpartinbits3116anda16bitimaginary part in bits 1500 one of the multiplyaccumulate engines calculates the real part 33 bits of the complex product namely xryr xiyi and stores it in the h half of the target accumulator pair the other mac engine calculates the imaginary part 32 bits of the complex product namely xryi xiyr and stores it in the l half of the target accumulator pair this instruction can be initiated every two cycles 2cycle throughput and takes four cycles to complete as in the other dual mac operations programming cmulta instructions too close together causes stall cycles but the correct results are always obtained the dual mac includes separate divide unit for executing the 32bit divu operations specified by the mips isa the divide requires 19 cycles to complete the quotient is loaded into m0l310 m1l310 m2l310 or m3l310 and the remainder is loaded into the lower 32bits of the other accumulator in the target pair there is special support for fractional arithmetic for the divide operations 254 vector addressing dsp algorithms usually operate on vectors or matrices of data for example discrete cosine transforms operateon8x8pixelblocksasaresultdatamemorypointersareincrementedfromoneoperandtothenext the extra instruction cycle required to increment risc memory pointers is eliminated in dsps with auto increment this capability is provided in the lx5180 memory pointers are used unmodified to create the address then updated in the general register file before the next use in the lx5180 the 8bit immediate field containing the stride is signextended to 32bits before being added tothepointerforthelattersupdatethenomenclaturepointerisusedtodistinguishtheupdateperformed aftermemory addressing from the offset in which the base register in the mips isa which is augmented by the offset beforeaddressing memory in the standard instructions the nomenclature stride which is dependent on the granularity of the access is used to distinguish it from the invariant byte offset usedinthestandardloadandstoreinstructionsfortwinwordwordhalfwordaddressingthe8bitfieldisfirst leftshiftedbythreetwooneplacesandzerofilledbeforesignextensionto32bitsthisuseofleftshiftsfor the word and halfword word and halfword strides is similar to mips16 and is used to extend the effective address range thus increments of between 128 and 127 twinwords1 words halfwords or bytes are available for each data type in the case of loads but not stores pointer update requires second general register file write port the lx5180 includes an 4p2r2w register file with one of the two write ports dedicated to pointer updates forsomedspalgorithmsnotablyfiltersdspdataisorganizedintocircularbuffersinthiscaseattheaddress pointer pointer pointer stride 1 twinwords are supported only on the lx5280 and not the lx5180april 19 2001 lx5180 lexra proprietary confidential 16 release 19 end of the buffer the next reference is to the beginning of the buffer implementing this structure in risc requires note that the above example is written so that branch prediction failure will only be incurred at the end of the buffer nevertheless the combination of postmodified pointers together with hardware support for circularbuffersinthelx5180allowsthistypicaldspaddressingoperationtobereducedfromfourcyclesto one figure 4 postmodified pointers with circular buffer support 255 circular buffers thelx5180supportsthreecircularbufferstoinitializethecircularbuffersthemtruinstructionsareused to set the twinword start addresses cbs0cbs2313 and twinword end addresses cbe0cbe2313 circularbuffersareonlyusedwhenmemorypointersarepostmodifiedandconsistofanintegralnumberof twinwords when circular buffer pointer is used in postmodified address calculation the pointer is compared to theinst 1 lw reg addressreg inst 2 bnel addressreg bufferend continue inst 3 addiu addressreg addressreg 4 inst 4 move addressreg bufferstart continue alu regfor pointer update reg bi reg br reg temp dbus_malu reg bi comparedaddr_em u x select enable cb203 enable cb203cbe1 cbe2cbe0 cbs1 cbs2cbs0april 19 2001 lx5180 lexra proprietary confidential 17 release 19 associatedcbeaddressiftheymatchandthestrideisnonnegativethecbsaddressratherthanthepost modified address is restored to the register file similarly to allow for traversing the circular buffer in the reverse direction the pointer is compared to the cbs address if they match and the stride is negative the cbe address rather than the postmodified address is restored to the register file it is worth noting that circular buffers can also be accessed with byte halfword or word loadstore with pointer increment instructions in those cases the several least significant bits of the pointer register are examinedtodetermineifthestartorendofthebufferhasbeenreachedtakingintoaccountthegranularityof the access before replacing the pointer with the cbs or cbe as appropriate anygeneralregistermemorypointercanbeusedwith circularbuffers usingthecnoptiontousegeneral register rp as circular buffer pointer for example the instruction associatesther4memorypointerwithcircularbufferc2whichisdefinedbythestartaddresscbs2andend address cbe2 26 radiax alu operations the lx5180 introduces extensions to the mips instructions to support dual 16bit operations the lx5180 also introduces number of new alu instructions which improve performance on dsp algorithms these instructions will also be described in this section 261 extensions to mips alu operations tosupporthighperformancedual16bitoperationsintheriscdspitisnecessarytosupportnotonlydual mac instructions but also dual 16bit versions of other arithmetic operations that the programmer may require to maintain simple orthogonal instruction set the following criteria were used to determine the mips alu extensions dual 16bit versions of all mips alu operations without immediate data optional saturation for every alu instruction without immediate data that can produce signed overflow or underflow it is expected that the above organizing principles will simplify the lx5180 isa for both programmers and tool developers obviously dual 16bit versions of logical operations such as and are not required howeverdual16bitversionshavebeenprovidedforall3registeroperandshiftsandaddsubtractsincluded in the mips rformat the character 2 in the assembler mnemonic indicates an operation on dual 16bit data dsp algorithms are often somewhat tolerant of data errors for example bad audio sample may cause brief distortion but lasting effect as new audio samples arrive and the bad sample is cleared out of the buffer accordinglythesaturatedresultofsignedarithmeticisaclosermoredesirableapproximationthan the wraparound result therefore all lx5180 arithmetic operations which may potentially produce arithmetic overflow or underflow and do not have immediate operands support optional saturation for examplenotonlythedual16bitaddaddr2butalsothe32bitaddaddrhaveoptionalsaturateinthe lx5180 saturation options are not provided for mips iformat 32bit instructions for example addiu howeverinthiscasetheprogrammerselectstheimmediateoperandandasaresultsaturationislesslikely or at least more predictable neither the dual 16bit instructions nor the new 32bit saturating adds and subtracts cause exceptionslwpc2 r3 r4strideapril 19 2001 lx5180 lexra proprietary confidential 18 release 19 262 new alu instructions the lx5180 adds several new alu instructions which have proven useful in dsp performance analysis consistent with the approach described above each new instruction has both 32bit and dual 16bit version if signed overflowunderflow is possible saturation option is provided 263 conditional move operations the lx5180 includes new instructions movz and movn to support conditional operations these instructions are described in this section number of dsps and risc processors have deployed extensive conditional execution in these processorsthebranchpredictionpenaltyisthreecyclesormoreconditionalexecutioncanmitigatetheeffect of the branch prediction penalty by allowing the branch to be avoided in some cases however conditional executionisacostlyalternativeitusesinstructionopcodebitsandconsequentlylimitsthesizeofimmediate data andor limits the number of general purpose registers visible to the program the lx5180 branch prediction penalty is only two cycles therefore the need for conditional execution is minimized and only restricted set of conditional move instructions is needed it is notable however that the effect of any conditional execution can be emulated in the lx5180 with sequence of two instructions by using the conditional move for example processor with conditional execution lx5180 if rb satisfies the cond rd is updated with ra ie the 2nd alu operation is executed to completion note that this sequence is interruptible another use of the conditional move instructions is to code ifthenelse constructs as follows can be coded if the previous example is prefaced with one reason lexra has provided conditional move is to facilitate initial porting of assembler code from processors with conditional execution to the lx5180 27 zero overhead loop facility because dsp algorithms spend much of their time in short realtime critical code loops dsps often include hardwaresupportforzerooverheadloopingthegoalofzerooverheadloopingisthatbranchingfromthe endtobeginning of the loop can be accomplished without explicit program overhead if the loop is to beinst 1 alu operation sets condition flags inst 2 cond alu operation inst 1 alu operation updates register rb condition setting operation inst 2 alu operation with result directed to temp register ra inst 3 movcond rd ra rb if rb cond rd ra else rd rc move rd rc move rc to rdapril 19 2001 lx5180 lexra proprietary confidential 19 release 19 executed fixed number of times known at compile time the lx5180 supplies such facility but allows the loop count to be determined at run time as well the facilityconsistsofthreenewradiaxregisterswhichareaccessiblebyaprogramrunninginusermodeusing the radiax instructions mfru and mtru the operating system should consider these registers as part of the context of the executing process and must save and restore them in the case of an interrupt lpe0312 virtual address of the ending instruction of the loop lps0282 low order bits of the virtual address of the starting instruction of the loop lpc0150 the loop count although the facility is intended for use in loops the algorithm executed by the hardware can be described moresimplyinparticularitshouldbenotedthatthereisnoknowledgeofbeinginsidetheloopallthat mattersisthecontentsofthethreeregisterswhenanattemptismadetoexecutetheinstructionattheaddress specified by lpe0 if m32mode and currentinstructaddr312 lpe0 and lpc0 0 then execute current instruction at lpe0312 00 decrement lpc0150 by one execute instruction at lpe03129 lps0282 00 continue lps0 could be jumpbranch else execute current instruction continue current instruction could be jumpbranch the following restrictions apply to the usage of the zero overhead loop facility it is only active in 32bit isa mode it is disabled in mips16 mode lpsmaynotbeexactlyequaltolpeiflpcisnonzerothereforetheloopmustcontain at least two instructions otherwise operation is undefined lpe may not be in the delay slot of branch nor may it be branch or jump instruction itself if lpc is nonzero otherwise operation is undefined forcorrectoperationtheorderofloadingtheregistersmustbefirstlpsthenlpethen lpc with nonzero value for correct operation there must be at least two 2 instructions between the instruction which loads lpc with nonzero value and the instruction at the lpe address to guarantee that stall cycles are incurred there must be at least three 3 cycles between the instruction which loads lpc with nonzero value and the instruction at the lpe address1 1 the following discussion is only relevant if lpc will be updated in an instruction that is close to lpe that case can have per formance impact although correct operation will still be obtained the programming guideline is keep the lpc update in an outer loop as far as possible from the end of the inner loop the updates of lps lpe and lpc use the mtru instruction therefore the new lps lpe and lpc values are only known after the estage of the pipeline but in order to perform the pseudobranch they must be used in the istage of the pipeline because of therestrictionontheorderofsettingtheseregistersthehardwareintroducesaminimumnumberofstallsaftersettinglpsandlpe to test for an lpe match against the current instruction address however if the lpc update is still in the pipeline when the lpe match is detected the hardware stalls to check and update the new value of lpc to avoid these stalls lpc should not be updated within 3 cycles which could be as many as 6 instruction issue slots of an expected lpematching instruction as noted above for correct operation there must be at least 2 instructions between the lpc update and any expected lpematching instructionapril 19 2001 lx5180 lexra proprietary confidential 20 release 19 if the instruction at lpe is load type instruction then the immediately executed instruction at lps is considered to be in the load delay slot and cannot rely on seeing the result of the load the following items are notrestrictions that apply to the usage of the zero overhead loop facility but are features to be aware of the loop count lpc may be reloaded multiple times after lps and lpe are loaded typically this would be done in an outer loop theinstructionatlpemaybethetargetofajumporbranchincludingachangeinmode from 16bit to 32bit isa any of the instructions before or at lpe may be subject to exceptions or interrupts and processingwillconformtothenormalexceptionhandlingrulesnotethatthebdbitwill always be off since lpe must not be in the delay slot of branch the return from the exception handler to lpe will also be handled normally since it is just special case of lpe being the target of jump if the instruction at lpe causes reserved instruction trap it is necessary for the exception handler to decrement lpc prior to return after emulating the instruction at lpe and before returning to the instruction at lps similar restrictions apply if the instruction at lpe is not to be reexecuted for any other reason such as break or syscall execution 28 lowoverhead prioritized interrupts thelx5180includeseightnewlowoverheadhardwareinterruptsignalsthesesignalsarecompatiblewith the r3000 exception processing model and are useful for realtime applications these interrupts are supported with three new lexra cp0 registers estatus ecause and intvec accessed with the new mtlxc0 and mflxc0 variants of the mtc0 and mfc0 instructions as with any cop0instructionacoprocessorunusableexceptionistakeniftheseinstructionsareexecutedwhileinuser mode and the cu0 bit is 0 in the cp0 status register the three new lexra cp0 registers are estatus 0 ecause 1 and intvec 2 and are defined as follows estatus lx cop0 reg 0 readwrite ecause lx cop0 reg 1 readonly intvec lx cop0 reg 2 readwrite31 24 23 16 15 0 0 im158 0 31 24 23 16 15 0 0 ip158 0 31 6 5 0 base 0april 19 2001 lx5180 lexra proprietary confidential 21 release 19 estatus contains the new interrupt mask bits im158 which are reset to 0 so that none of the new interruptswillbeactivatedregardlessoftheglobalinterruptsignaliecip158forthenewinterruptsignals islocatedinecauseandisreadonlythesefieldsaresimilartotheimandipfieldsdefinedinther3000 exception processing model except that the new interrupts are prioritized in hardware and each have dedicated exception vector ip15 has the highest priority while ip8 has the lowest priority however all new interrupts are higher priority than ip70 the processor concatenates the program defined base address for the exception vectorswiththeinterruptnumberforformtheinterruptvectorasshowninthetablebelowtwoinstructions can be executed in each vector typically these will consist of jump instruction and its delay slot with the target of the jump being either shared interrupt handler or one that is unique to that particular interrupt table 4 prioritized interrupt exception vectors when vectored interrupt causes an exception all of the standard actions for an exception occur these include updating the epc register and certain subfields of the standard status and cause registers in particulartheexceptioncodeofthecauseregisterindicatesinterruptandthecurrentandprevious mode bits of the status register are updated in the usual mannerinterrupt number exception vector 15 base 6b111000 14 base 6b110000 13 base 6b101000 12 base 6b100000 11 base 6b011000 10 base 6b010000 9 base 6b001000 8 base 6b000000 april 19 2001 lx5180 lexra proprietary confidential 22 release 19 april 19 2001 lx5180 lexra proprietary confidential 23 release 19 3 lx5180 risc programming model this section describes the lx5180 programming model section31 summary of mipsi instructions containsalistsummarizingallmipsioperationssupportedbythelx5180theseopcodesmaybeextended by the customer using lexras custom engine interface cei this capability is described in section32 opcode extension using the custom engine interface cei section33 memory management describes the simplified memory management unit smmu which is physically incorporated in the lx5180 lmi the smmu provides sufficient memory management capabilities for most embedded applications while ensuring execution of thirdparty mips software development tools thelx5180supportsthemipsr3000exceptionprocessingmodelasdescribedinsection34 exception processing thelx5180supportsallmipsicoprocessoroperationsthecustomercanincludeonetothreeapplication specific coprocessors lexra provides functional block called the coprocessor interface ci which allows thecustomerasimplifiedconnectionbetweentheircoprocessorandtheinternalsignalsofthelx5180the ci is described in section35 the coprocessor interface ci 31 summary of mipsi instructions the lx5180 executes mipsi instructions as detailed in the tables below to summarize the lx5180 executes mipsi instructions with the following exclusions the unaligned loads and stores lwl swl lwrswrarenotsupportedbecausetheyaddsignificantsiliconareaforlittlebenefitinmostapplications the following conventions are employed in the instruction descriptions encloses list of syntax choices from which one must be chosen encloses list of values that are concatented to form larger value n value replicates concatenates value n times value3 bits selected from value ra offset memory address computation and corresponding memory contents 4b0000 sized constant binary value 32h1234_5678 sized constant hexadecimal value expr b select if expr is true otherwise select bapril 19 2001 lx5180 lexra proprietary confidential 24 release 19 311 alu instructions table 5 alu instructions instruction description add rd ra rb addu rd ra rb addi rd ra immediate addiu rd ra immediaterd ra rb immediate add reg ra to either reg rb or 16bit immediate sign extendedto32bitsresultisstoredinregrdaddandaddi can generate overflow trap addu and addiu do not sub rd ra rb subu rd ra rbrd ra rb subtract reg rb from reg ra result is stored in register rd sub can generate overflow trap subu does not and rd ra rb andi rd ra immediaterd ra rb immediate logicaland of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rd or rd ra rb ori rd ra immediaterd ra rb immediate logicalor of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rd xor rd ra rb xori rd ra immediaterd ra rb immediate logicalxor of reg ra with either reg rb or 16bit immediate zeroextended to 32 bits result is stored in reg rd nor rd ra rb rd ra rb logicalnor of reg ra with either reg rb or zeroextended 16 bit immediate result is stored in reg rd lui rd immediate rd immediate 16b0 the 16bit immediate is stored into the upper half of reg rd the lower half is loaded with zeroes sll rd rb immediate sllv rd rb rard rb ra immediate regrbisleftshiftedby031theshiftamountiseitherthe5b immediate of the 5 lsb of ra result is store in reg rd srl rd rb immediate srlv rd rb rard rb ra immediate reg rb is rightshifted by 031 the unsigned shift amount is either the 5b immediate or the 5 lsb of ra result is stored in reg rd sra rd rb immediate srav rd rb rard rb ra immediate reg rb is arithmetic rightshifted by 031 the unsigned shift amount is either the 5b immediate or the 5 lsb of ra result is stored in reg rd slt rd ra rb sltu rd ra rb slti rd ra immediate sltiu rd ra immediaterd ra rb immediate 1 0 if reg ra is less than rb immediate set rd to 1 else 0 the 16bitimmediateissignextendedforsltsltithecompari is signed for slu sltiu the comparison is unsignedapril 19 2001 lx5180 lexra proprietary confidential 25 release 19 312 load and store instructions table 6 load and store instructions 313 conditional move instructions table 7 conditional move instructionsinstruction description lb rd offsetra lbu rd offsetra lh rd offsetra lhu rd offsetra lw rd offsetrard memoryra offset reg rd is loaded from data memory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits lb lbu addresses are interpreted as byte addresses to data memorylhlhuashalfword16bitaddresseslwasword 32bit addresses thedatafetchedinlblhlbulhuissignextendedzero extended to 32bits for storage to reg rd rd cannot be referenced in the instruction following load instruction sb rb offsetra sh rb offsetra sw rb offsetrarb memoryra offset reg rb is stored to data memory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits sbaddressesareinterpretedasbyteaddressestodatamem ory the 8 lsb of rb are stored sh addresses are interpreted as halfword addresses to data memory the 16 lsb of rb are stored instruction description movz rd rs rt rd rt 0 rs rd if the contents of general register rt are equal to 0 the general register rd is updated with rs otherwise rd is unchanged movn rd rs rt rd rt 0 rs rd if the contents of general register rt are not equal to 0 the gen eral register rd is updated with rs otherwise rd is unchangedapril 19 2001 lx5180 lexra proprietary confidential 26 release 19 314 branch and jump instructions table 8 branch and jump instructions instruction description beq ra rb destination bne ra rb destinationif cond pc pc 4 14 destination15 destination 2b00 else pc pc 8 where cond ra rb for eq ra ne rb for ne and desti nation is 16bit value for beq bne the instruction after the branch delay slot is always executed blez ra destination bgtz ra destinationif cond pc pc 4 14 destination15 destination 2b00 else pc pc 8 where cond ra 0 for ra 0 for gt and destina tion is 16bit value forblezbgtztheinstructionafterthebranch delayslotis always executed bltz ra destination bgez ra destinationif cond pc pc 4 14 destination15 destination 2b00 else pc pc 8 where cond ra 0 for lt ra 0 for ge and destina tion is 16bit value forbltzbgeztheinstructionafterthebranch delayslotis always executed bltzal ra destination bgezal ra destinationsimilar to the bltz and bgez except that the address of the instruction following the delay slot is saved in r31 regardless of whether the branch is taken j target pc pc3128 target 2b00 target is 26bit absolute the instruction following j delay slot is always executed jal target same as above except that the address of the instruction fol lowing the delay slot is saved in r31 jr ra pc ra the instruction following jr delay slot is always executed jalr ra rd same as above except that the address of the instruction fol lowing the delay slot is saved in rdapril 19 2001 lx5180 lexra proprietary confidential 27 release 19 315 control instructions table 9 control instructions 316 coprocessor instructions table 10 coprocessor instructionsinstruction description syscall the sys trap occurs when syscall is executed break the bp trap occurs when break is executed rfe causes the kuie stack to be popped used when returning from the exception handler see exception processing below sleep initiates lowpower standby mode this is lexra specific operation lexop see section36 power savings mode instruction description lwcz rcgen offsetra rcgen memoryra offset coprocessor z general reg rcgen is loaded from data mem ory the memory address is computed as base offset where the base is reg ra and the offset is the 16bit offset signextended to 32 bits rcgen cannot be referenced in the following instruction one cycle delay swcz rcgen offsetra rcgen memoryra offset coprocessor z general reg rcgen is stored to data memory the memory address is computed as base offset where the base is reg ra and the offset is the16bit offset sign extended to 32 bits mtcz rb rcgen ctcz rb rcconin mtczctcz the general register rb is moved to copro cessor z general control reg rcgenrccon rcgen and rccon cannot be referenced in the following instruction mfcz rb rcgen cfcz rb rcconin mfczcfcz the coprocessor z general control reg rcgenrccon is moved to the general register rb rb cannot be referenced in the following instruction bczt destination bczf destinationif cond pc pc 4 14 destination15 destination 2b00 else pc pc 8 where cond cpcondz true for bczt cpcondz false for bczf forbcztbczftheinstructionafterthebranch delayslotis always executedapril 19 2001 lx5180 lexra proprietary confidential 28 release 19 32 opcode extension using the custom engine interface cei 321 cei operations customers may add proprietary or applicationspecific opcodes to their lx5180 based products using the custom engine interface cei the new instructions take one of the following forms illustrated below and use reserved opcodes table 11 custom engine interface operations lexra permits customer operations to be added using the four 4 iformat opcodes and six 6 rformat opcodes listed in the table above other opcode extensions in future lexra products will notutilize the opcodes reserved above when the cei decodes newopi or newopr it must signal the core that custom operation has been executed so that the reserved instruction trap will not be taken multicycle custom operations may be executed by asserting cesel note the custom operation may choose to ignore the src1 and src2 operands supplied by the cei and reference customer registers instead results can also be written to an implicit customer register however unless d 0 is coded register in the core will also be written 322 interface signals table 12 custom engine interface signalsnew instruction description available opcodes newopi rd ra immed rd ra newopi immed reg ra is supplied to the src1 port of cei and the 16bit immediate sign extended to 32bits is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 24 27 newopr rd ra rb rd ra newopr rb reg ra is supplied to the src1 port of cei and reg rb is supplied to src2 the result of the customers newopi is placed on the cei input port res and stored in reg rdinst3126 0 and inst50 5658 606263 signal io description src1310 output operand supplied to customer logic src2310 output operand supplied to customer logic res310 input result of customer logic supplied to core ceiop110 output instruction op and subop fields to be decoded by customer logicapril 19 2001 lx5180 lexra proprietary confidential 29 release 19 33 memory management thelx5180includesasimplifiedmemorymanagementunitsmmufortheinstructionmemoryaddress and the data memory address these units are physically located in the local memory interface lmi modulesthehardwiredvirtualtophysicaladdressmappingperformedbythesmmuissufficienttoensure execution of thirdparty software development tools table 13 smmu address mapping 34 exception processing thelx5180implementsthemipsr3000exceptionprocessingmodelasdescribedbelowfeaturesspecific to onchip tlb support are not included in the discussion below the term exception refers to both traps which are nonmaskable program synchronous events and interrupts which result from unmasked asynchronous events thelistbelowisnumberedfromhighesttolowestpriorityexccodeisstoredincausewhenanexception is taken note that sys bp ri cpu can share the same priority level because only one can occur in particular time slotcehalt input indicates that multicycle custom operation is in progress cesel input indicates that cei operation has been decoded virtual address space description mapped to physical address 0xff00_0000 to 0xffff_ffffejtag address space 16 mbyte uncached this address range is reserved for ejtag use only0xff00_0000 to 0xffff_ffff 0xc000_0000 to 0xfeff_ffffkseg2 1gbyte minus 16 mbyte addressable only in kernel mode cached0xc000_0000 to 0xfeff_ffff 0xa000_0000 to 0xbfff_ffffkseg1 05 gbyte addressable only in ker nel mode uncached used for io devices0x0000_0000 to 0x1fff_ffff 0x8000_0000 to 0x9fff_ffffkseg0 05 gbyte addressable only in ker nel mode cached0x0000_0000 to 0x1fff_ffff differentiated from kseg1 addresses with an internal signal 0x0000_0000 to 0x7fff_ffffkuseg 2gbyte addressableinkernelor user mode cached0x4000_0000 to 0xbfff_ffffsignal io descriptionapril 19 2001 lx5180 lexra proprietary confidential 30 release 19 table 14 list of exceptions exception priority exccode description reset 1 reset trap adel instruction2 4 address exception trap instruction fetch occurs if the instruction address is not wordaligned or if kernel address is referenced in user mode ov 3 12 arithmeticoverflowtrapcanoccurasa result of signed add or subtract opera tions sys 4 8 syscall instruction trap occurs whensyscallinstructionisexecuted bp 4 9 break instruction trap occurs when break instruction is executed ri 4 10 reservedinstructiontrapoccurswhen areservedopcodeisfetchedreserved opcodes are listed below cpu 4 11 coprocessor usability trap occurs when an attempt is made to execute coprocessor n operation and copro cessor n is not enabled adel data 5 4 address exception trap data fetch occurs if the data address is not prop erly aligned or if kernel address is generated in user mode ades 6 5 address exception trap data store occurs if the data address is not prop erly aligned or if kernel address is generated in user mode int 7 0 unmasked interrupt there are six 6 levelsensitive hardware interrupt request signals into the lx5180 core eachissynchronizedbythecoretothe lx5180 system clock in addition pro gram writes to cause98 are soft wareinitiated interrupt requests each of the eight 8 requests has an associ ated mask bit in status int is gener ated by any unmasked request when interrupts are globally enabledapril 19 2001 lx5180 lexra proprietary confidential 31 release 19 341 exception processing registers status coprocessor 0 general register address 12 cu cun 10 indicates that coprocessor n is usableunusable in coprocessor instructions bev bootstrap exception vector selects between two trap vectors see below im interrupt masks for the six hardware interrupts and two software interrupts kuie ku01indicateskernelusermodeinthelx5180usermodevirtualaddressesmusthave msb 0 in kernel mode the full address space is addressable ie 10 indicates that interrupts are enabled disabled the kuo ieo kup iep kuc and iec fields form threelevel stack hardware stack kuie signals the currentvalues are kuciec the previousvalues are kupiep and the oldvalues those before previous are kuoieo see section342 statusisreadorwrittenusingmtc0andmtf0operationsonresetbev1kuciec0theother bitsinstatusareundefinedthe0fieldsareignoredonwriteandare0onreaditisrecommendedthatthe user explicitly write them to 0 to insure compatibility with future versions of the lx5180 cause coprocessor 0 general register address 13 bd branch delay indicates that the exception was taken in branch or jump delay slot ce coprocessorexceptioninthecaseofacoprocessorusabilityexceptionindicatesthenumber of the responsible coprocessor ip interrupt pending each bit in ip70 indicated an associated unmasked interrupt request exccode the exccode listed above for the different exceptions are stored here when as exception occurs causeisreadorwrittenusingmtc0andmtf0operationstheonlyprogramwritablebitsincauseare ip10 which are called softwareinterrupts cause isundefinedatreset the 0 fieldsare ignored on write and are 0 on read epc coprocessor 0 general register address 14 epc is 32bit readonly register which contains the virtual address of the next instruction to be executed following return from the exception handler if the exception occurs in the delay slot of branch epc will hold the address of the branch instruction and bd will be set in cause the branch will typically be re executed following the exception handler badvaddr coprocessor 0 general register address 8 badvaddr is 32bit readonly register containing the virtual address instruction or data which3128 2723 22 2116 158 76 5 4 3 2 1 0 cu30 0 bev 0 im70 0 kuo ieo kup iep kuc iec 31 30 2928 2716 158 7 62 10 bd 0 ce10 0 ip70 0 exccode40 0april 19 2001 lx5180 lexra proprietary confidential 32 release 19 generated an adel or ades exception error 342 exception processing entry and exit when an exception occurs the instruction address changes to one of the following locations the kuie stack is pushed kuo ieo kup iep kuc iec before push kup iep kuc iec 0 0 after push whichdisablesinterruptsandputstheprograminkernelmodethecodeexccodefortheexceptionsource isloadedintocausesothattheapplicationspecificexceptionhandlercandeterminetheappropriateaction the exception handler should not reenable interrupts until necessary context has been saved to return from the exception the exception handler first moves epc to general register using mfc0 followed by jr operation rfe only pops the kuie stack kup iep kuc iec 0 0 before pop kup iep kup iep kuc iec after pop this example assumes that kuie were not modified by the exception handler therefore typical sequence of operations to return from the exception handler would be 35 the coprocessor interface ci designers may implement up to three coprocessors to interface with the lx5180 the contents of these coprocessors may include up to thirtytwo 32 32bit general registers and up to thirtytwo 32 32bit controlregisters thegeneralregistersmaybemovedtoandfromtheralusregistersusingmtczmfcz operationsorbeloadedandstoredfromdatamemoryusinglwczswczoperationsthecontrolregisters may only be moved to and from the ralus registers using ctcz cfcz operations lexra supplies simple coprocessor interface ci model allowing the customer to easily interface coprocessor to the lx5180 the ci supplies set of control address and data busses that may be tied directly to the coprocessor general and special registers the ci is described in more detail in section8 lx5180 coprocessor interface 36 power savings mode the operating system kernel can initiate power savings standby mode using the lexra specific sleepreset 0xbfc0_0000 other exceptions bev 0 0x8000_0080 other exceptions bev 1 0xbfc0_0180 mfc0 epc r26 r26 is temporary storage register in the ralu jr r26 rfeapril 19 2001 lx5180 lexra proprietary confidential 33 release 19 instruction this holds the lx5180s internal clocks in the high state until an external hardware interrupt is received before executing the sleep instruction the kernel must ensure that the interrupt condition that will ultimately terminate standby mode has been enabled via the im field of the coprocessor 0 status register whenthesleepinstructionentersthewstagethestandbylogicstallstheprocessorandwaitsforthelbc to complete any outstanding processor initiated system bus operations after these are completed the standby logic holds the system and bus clocks high these are held high until an enabled interrupt is received when standby mode is terminated by an interrupt the standby logic allows the clocks to toggle the processor honors the interrupt by branching to the exception handler as is normally done for interrupt servicing because several instructions are held in the pipeline while the clocks are frozen prior to the interrupt the exception pc will not point to the sleep instruction but rather some later instruction typicallyakernelwouldenteranidleloopjustafterexecutingthesleepinstructionsotheinterruptwillbe serviced from the kernels normal idle interrupt service level the lx5180 takes minimum of 6 cycles after the sleep instruction enters the w stage to safely synchronize the initiation of standby mode ie hold the clocks in the high state two cycles are required terminate standby mode the processor is stalled during these periods thestandbylogicreceivesthefreerunningsystemandbusclocksandgeneratesgatedclocksfordistribution to the lx5180 the standby logic must use flipflops tied to free running clocks which results in about dozen loads on the free running clocks twopinssl_sleeping_randsl_sleeping_brareavailablefromthestandbylogicandareasserted highwhentheprocessorisinstandbymodethe_rpinisforuseinthesystemclockdomainandthe_br pin is for use in the bus clock domainapril 19 2001 lx5180 lexra proprietary confidential 34 release 19 april 19 2001 lx5180 lexra proprietary confidential 35 release 19 4 mips16 mips16 is an extension to the mips instruction set architecture isa that was developed to improve code densityespeciallyforsystemonchipsocdesignsinthesedesignsonchipinstructionstorageisoftena significant even dominant portion of the silicon component cost this is especially true for realtime applications because in order to meet realtime requirements instruction cache miss penalties cannot be tolerated and thus large portion of the instruction storage must be resident onchip mips16 provides set of 16bit instruction formats to encode the most common operations the key compromisesrequiredtoachieve16bitencodingincludeisomemipsiinstructionsarenotavailableii immediate widths are reduced iii only 8 of the 32 general registers may be directly addressed as result some operations cannot be executed in mips16 or require multiple mips16 instructions thus realistic programs need to include both mips16 and mips i instructions using mips16 where possible to save storageatsomecosttoperformance1modeswitchingbetweenmips16andmipsiisdiscussedbelowto permit occasional access to all 32 general registers without the overhead of mode switching mips16 providesmoveinstructions to move data between the mips16visible registers and the full general register set also to permit occasional use of 16bit immediates without mode switching mips16 provides the extend instructiontoallowafullwidthimmediateintwomips16instructioncyclesprogramsrequiring large register set or frequent fullwidth immediates should be compiled in mips i mips16 is difficult to program effectively at the assembler level this is because of the limited register set and the restricted size immediates in fact according to sweetman2 mips16 is not suitable language for assembly coding rather mips16 is viewed as compiler option which can be effectively applied to achieve significant code size reduction where performance is not critical 41 mips16 instructions this section describes the mips16 instructions with emphasis on the differences between mips16 and the 32bit mips isa the first table lists mips i instructions that are notsupported in mips16 the second table lists mips i instructions which are supported in mips16 in most cases these are specialized versions of the mips i instruction mips16 is compatible with mips i ii and iii iv or v the lx5180implements allmips16for32bitdataoperations3thetablelistsallmips16instructionstogether withthecorrespondingmipsiinstructionandthespecializationrequiredtoproducethemips16instruction other than smaller register set and smaller immediates the third table lists the several new instructions introduced by mips16 itisnotablethatmultudivuaresupportedinmips16mfhiandmfloarealsosupportedandare necessarytoaccesstheresultofmultuordivuhowevermthiandmtloarenotsupportedthese are used primarily to restore the state after exception handling and are used within the kernel typically in mips i 1 the mips16 performance penalty results from occasionally using two instructions where one mips i instruction would sufﬁce some of this penalty is recovered in applications where larger number of instructions per cache line reduces cache miss rate 2 see mips run dominic sweetman appendix d p 425 3 mips16 includes 16bit formats for number of mips iii 64bit doubleword operations which are not supported in the mips i isathey are also not supported in radiaxapril 19 2001 lx5180 lexra proprietary confidential 36 release 19 table 15 mips i instructions not supported by mips16 table 16 mips16 instructions that support mips imips i not supported by mips16 assembler mnemonics coprocessor operations ctcz cfcz mtcz mfcz lwcz swcz bczt bczf copz unaligned loads stores lwl lwr swl swr arithmetic operations add addi sub conditional branches blez bgtz bltz bgez bltzal bgezal logical operations with immediates andi ori xori lui jump j miscellaneous syscall rfe mthi mtlo mips16 instruction mips i equivalent instructiona lbu ry offsetrx lhu ry offsetrx lw ry offsetrx lw rx offsetsp r29 base sb ry offsetrx sh ry offsetrx sw ry offsetrx sw rx offsetsp r29 baselw rx offsetbase base r29 sw rx offsetbase base r29 addiu ry rx immediate addiu rx immediate addiu sp immediate 1operand addiu rx sp immediate 2operand addu rz rx ry subu rz rx ry neg rx ry 2operandaddiu rt rs immediate rtrs addiu rt rs immediate rtrsr29 addiu rt rs immediate rsr29 subu rd rs rt rsr0 sltu rx ry r24 dest implied sltiu rx immediate 2op r24 destsltu rd rs rt rdr24 sltiu rt rs immediate rtrs cmpi rx immediate r24 dest implied cmp rx ry r24 dest impliedxori rt rs immediate rtr24 xor rd rs rt rdr24 and rx ry 2operand or rx ry 2operand xor rx ry 2operand not rx ry 2operand move ry r32 2operand move r32 ry 2operand li rx immediateand rd rs rt rdrs or rd rs rt rdrs xor rd rs rt rdrs nor rt rs rt rsr0 or rd rs rt rsr0 or rd rs rt rsr0 ori rd rs immediate rsr0 sll rx ry immediate srl rx ry immediate sra rx ry immediate sllv ry rx 2operand srlv ry rx 2operand srav ry rx 2operandsllv rd rt rs rdrs srlv rd rt rs rdrs srav rd rt rs rdrs multu rx ry divu rx ry mfhi rx mflo rxapril 19 2001 lx5180 lexra proprietary confidential 37 release 19 as noted earlier mips16 restricts the mips i directly addressable register set and immediate field another commonmips16restrictionisthattworatherthanthreeregisteroperandsarepermittedmips16provides number of instructions that are not found mips i as shown in table17 table 17 new mips16 instructions the pcrelative load lw is important to overcoming the drawback of smaller immediates in mips16 it allowsfull32bitimmediatestobeembeddedintheprogramandloadedintoregistersinasingleinstruction the addiu with pc operand is useful to support immediates embedded in the program the pc value referenced in lw or addiu depends on the context of the pcrelative instruction as shown in table18 table 18 pcrelative addressing extend is used to supply an extra 11bits of immediate it is used together with the restricted size immediatefieldofthenextinstructiontosupplyafullwidthimmediateextendcannotoccurinthedelay slot of jump it is not necessary for the assembly programmer to code extend instructions it will automatically be assembled by mips16 assemblers wherever the immediate is too large to be encoded in single mips16 instructionjal target jr rx jr ra jalr ra rx 2operand link r31jr rs rsr31 jalr rs rd rsr31 beqz rx offset 1operand bnez rx offset 1operand bteq offset implied operands btne offset implied operands b offset implied operandsbeq rs rt offset rtr0 bne rs rt offset rtr0 beq rs rt offset rsr24 rtr0 bne rs rt offset rsr24 rtr0 beq rs rt offset rsr0 rtr0 break if 32bit mips instruction is listed specialization beyond limited size register set and limited size immediates is required new mips16 instruction comment lw rx offsetpc load word with pcrelative address addiu rx pc immediate addiu with pc operand extend immediate supplies 11bit immediate for use in the following mips16 instruction jalx target jump to target store return in r31 and toggle the isa mode between mips16 and mips i context for pcrelative instruction pc value normal case nonextended pcrelative instruction not in jump delay slotpc of the pcrelative instruction pcrelative instruction with extended immediate pc of the extend instruction nonextended pcrelative in the delay slot of jumpjrjalrjalxextendedinstructions are not permitted in the delay slot of the jumppc of the jump instructionmips16 instruction mips i equivalent instructionaapril 19 2001 lx5180 lexra proprietary confidential 38 release 19 another new instruction jalx is available in both mips16 and also in mips i on machines implementing mips16andisdiscussedbelowinmipsimachinesnotimplementingmips16thejalxopcode000111 causes an ri trap 42 mode switching mode is switched between mips16 and mips i in one of two ways 1 the instruction jalx target toggles the mode 2 the lsb of the general register rx in jr rx jalr rs rx in mips16 rsra causes the mode to be set to mips16 if rx0 1 to mips i if rx0 0 however the lsb of the instruction memory address from jrjalr is forced to 0 as consequence machines that implement mips16 never take adel exceptions on the lsb of the instruction address this is true regardless of whether the machine is operating in mips16 or mips i mode the mode bit is saved in the lsb of the link register in jal jalx jalr 43 exceptions upon exception the mode is automatically switched to mips i the mode is saved in the lsb of the exception pc epc epc0 0 indicates that the exception occurred while executing code in mips i modeepc01indicatesthattheexceptionoccurredinmips16modethetypicalprogramwillsavethe epc to general register and later return to the main program with jr instruction causing the proper isa mode to be restored 44 delay slots consistent with the mip16 emphasis on code density there are load delay or branch delay slots in other wordstheinstructionfollowingthebranchisexecutedonlyifthebranchisnottakenmips16 jumpsjal jalx jr jalr have single delay slot the same as in mips i for jumps the target address is always taken thus there is risk that the delay slot cannot be used to do useful work the instruction from the target can be moved to the delay slot if necessary for mips16 loads the instruction following the load can reference the loaded register as in mips ii this feature is present because the mips i compiler is not always successful in scheduling useful instruction in the delay slot and must occasionally resort to nop reducing code density this possibility is eliminated in mips16april 19 2001 lx5180 lexra proprietary confidential 39 release 19 5 lx5180 dsp programming model the lx5180 supports lexras radiax dsp extensions to the mips1 instruction set this chapter describes the radiax extensions in detail section51 describes each of the radiax instructions section52 describes the instruction encoding the following conventions are employed in the instruction descriptions 51 radiax instructions the radiax instruction extensions include mac operations vectoraddressing and enhanced extensions to the mips1 alu instructions 511 radiax dualmac instructions table 19 radiax dualmac instructions encloses list of syntax choices from which one must be chosen value3 bits selected from value mnemopt indicates an optional form of instruction an mnemonic instruction syntax and description dual move to accumulatormta2g rs md mdh mdl ifmta2andmdhmdlisselectedsignextendthecontentsofgeneralregisterrsto 40bits and move to accumulator register mdhmdl if mta2 and md is selected update both mdh and mdl with the 40bit signextended contents of the same rs if mta2gisselectedtheaccumulatorregisterbits3932areupdatedwithrs3124 bits 3100 of the accumulator are unchanged the g option is used to restore the upperbits of the accumulator from the general register file typically following an exception move from accumulatormfa rd mth mtl n move the contents of accumulator register mth or accumulator register mtl to register rd with optional right shift bits 31n n from the accumulator register are transferredtord3100therangen 08isper mittedfortheoutputalignmentshift amount in the case of n 0 the field may be omitted dual move from accumulatormfa2 rd mt n movethecontentsoftheupperhalvesofaccumulatorregisterpairmttoregisterrd with optional right shift the rd3116 are taken from mth and rd1500 from the corresponding mtl mth31n 16n mtl31n 16n from the accumulator register pair are transferred to rd3100 the range n 0 8 is permitted for the output alignment shift amount in the case of n 0 the field may be omitted divide diva md rs rt the contents of register rs is divided by rt treating the operands as signed 2s complement values the remainder is signextended to 40bits and stored in mdh and the quotient is signextended to 40bits and stored in mdl m0h3100 is also called hi m0l3100 is also called divide unsigned divau md rs rt thecontentsofregisterrsisdividedbyrttreatingtheoperandsasunsignedvalues the remainder is zeroextended to 40bits and stored in mdh and the quotient is zeroextended to 40bits and stored in mdl m0h3100 is also called hi m0l3100 is also called loapril 19 2001 lx5180 lexra proprietary confidential 40 release 19 multiply 32bitmulta md rs rt the contents of register rs is multiplied by rt treating the operands as signed 2s complement values the upper 32bits of the 64bit product is signextended to 40 bitsandstoredinmdhandthelower32bitsiszeroextendedto40bitsandstoredin the corresponding mdl m0h3100 is also called hi m0l3100 is also called if mmdmt is 1 then the partial product rs1500 x rt1500 is not included in the total product if mmdmf is 1 then the product is left shifted by one bit and furthermore if both operands are 1 then the product is set to positive signed all ones fraction prior to the shift if both mmdmt and mmdmf are 1 the result is undefined multiply unsigned 32bitmultau md rs rt the contents of register rs is multiplied by rt treating the operands as unsigned valuestheupper32bitsofthe64bitproductiszeroextendedto40bitsandstored in mdh and the lower 32bits is zeroextended to 40bits and stored in the corresponding mdl m0h3100 is also called hi m0l3100 is also called if mmdmt is 1 then the partial product rs1500 x rt1500 is not included in the total product if mmdmf is 1 then the result is undefined dual multiply 16bitmulta2 md mdh mdl rs rt the contents of register rs is multiplied by rt treating the operands as signed 2s complement values if the destination register is mdh rs3116 is multiplied by rt3116 and the product is signextended to 40bits and stored in mdh if the destination register is mdl rs1500 is multiplied by rt1500 and the product is signextended to 40bits and stored in mdl if the destination is md both operations areperformedandthetwoproductsarestoredintheaccumulatorregisterpairmdif mmdmfis1theneachproductisleftshiftedbyonebitandfurthermoreforeach multiply if both operands are 1 then the product is set to positive signed all ones fraction dual multiply and negate 16bitmulna2 md mdh mdl rs rt the contents of register rs is multiplied by rt treating the operands as signed 2s complement values if the destination register is mdh rs3116 is multiplied by rt3116 and the product is signextended to 40bits negated ie subtracted from zero and stored in mdh if the destination register is mdl rs1500 is multiplied by rt1500 and the product is signextended to 40bits negated ie subtracted from zero and stored in mdl if the destination is md both operations are performed and the two products are stored in the accumulator register pair md if mmdmf is 1 then each product is left shifted by one bit prior to signextension and negation and furthermore for each multiply if both operands are 1 then the product is set to positive signed all ones fraction prior to signextension and negation complex multiplycmulta md rs rt rs3116isinterpretedastherealpartofacomplexnumberrs1500isinterpreted as the imaginary part of the same complex number similarly for the contents of generalregisterrtastheresultofcmultamdhisupdatedwiththerealpartofthe product signextended to 40bits and mdl is updated with the imaginary part of the product signextended to 40bits if mmdmf is 1 then each product is left shifted by one bit and furthermore for each multiply if both operands are 1 then the product is set to positive signed all ones fraction prior to the addition of terms 32bit multiplyadd with 72bit accumulatemadda md rs rt the contents of register rs is multiplied by rt treating the operands as signed 2s complementvaluesifmmdmtis1thenthepartialproductrs1500xrt1500is not included in the total product if mmdmf is 1 then the product is left shifted by one bit and furthermore if both operands are 1 then the product is set to positive signedallonesfractionifbothmmdmtandmmdmfare1thentheresultofthe multiply is undefined the 64bit product is signextended to 72bits and added to the concatenation mdh390 mdl310 ignoring mdl3932 the lower 32 bits of the result are zero extended to 40bits and stored into mdl the upper 40bits of the result are stored into mdhinstruction syntax and descriptionapril 19 2001 lx5180 lexra proprietary confidential 41 release 19 32bit unsigned multiply add with 72bit accumulatemaddau md rs rt the contents of register rs is multiplied by rt treating the operands as unsigned valuesifmmdmtis1thenthepartialproductrs1500xrt1500isnotincluded in the total product if mmdmf is 1 then the result of the multiply is undefined the 64bit product is zeroextended to 72bits and added to the concatenation mdh390 mdl310 ignoring mdl3932 the lower 32 bits of the result are zero extended to 40bits and stored into mdl the upper 40bits of the result are stored into mdh dual multiplyadd optional saturationmadda2smd mdh mdl rs rt the contents of register rs is multiplied by rt and added to an accumulator register treating the operands as signed 2s complement values if the destination register is mdh rs3116 is multiplied by rt3116 then signextended and added to mdh3900ifthedestinationregisterismdlrs1500ismultipliedbyrt1500then signextended and added to mdl3900 if the destination is md both operations are performed and the two results are stored in the accumulator register pair md if madda2stheresultofeachadditionissaturatedbeforestorageintheaccumulator register the multiplies are subject to mmdmf as in multa2 the saturation point is selected as either 40 or 32 bits by mmdms 32bit multiplysubtract with 72bit accumulatemsuba md rs rt the contents of register rs is multiplied by rt treating the operands as signed 2s complementvaluesifmmdmtis1thenthepartialproductrs1500xrt1500is not included in the total product if mmdmf is 1 then the product is left shifted by one bit and furthermore if both operands are 1 then the product is set to positive signedallonesfractionifbothmmdmtandmmdmfare1thentheresultofthe multiply is undefined the64bitproductissignextendedto72bitsandsubtractedfromtheconcatenation mdh390 mdl310 ignoring mdl3932 the lower 32 bits of the result are zero extended to 40bits and stored into mdl the upper 40bits of the result are stored into mdh 32bit unsigned multiply subtract with 72bit accumulatemsubau md rs rt the contents of register rs is multiplied by rt treating the operands as unsigned valuesifmmdmtis1thenthepartialproductrs1500xrt1500isnotincluded in the total product if mmdmf is 1 then the result of the multiply is undefined the64bitproductiszeroextendedto72bitsandsubtractedfromtheconcatenation mdh390 mdl310 ignoring mdl3932 the lower 32 bits of the result are zero extended to 40bits and stored into mdl the upper 40bits of the result are stored into mdh dual multiplysub optional saturationmsuba2s md mdh mdl rs rt the contents of register rs is multiplied by rt and subtracted from an accumulator register treating the operands as signed 2s complement values if the destination register is mdh rs3116 is multiplied by rt3116 then signextended and subtracted from mdh3900 if the destination register is mdl rs1500 is multiplied by rt1500 then signextended and subtracted from mdl3900 if the destination ismdbothoperationsareperformedandbothresultsarestoredintheaccumulator register pair md if msuba2s the result of each subtraction is saturated before storage in the accumulator register add accumulatorsaddmasmdhl mshl mthl the contents of accumulator mth or mtl is added to the contents of accumulator msh or msl treating both registers as signed 40bit values mdh or mdl is updated with the result if addmas the result is saturated before storage the saturation point is selected as either 40 or 32 bits by mmdms subtract accumulatorssubmas md hl mshl mthl the contents of accumulator mth or mtl is subtracted from the contents of accumulatormshormsltreatingbothregistersassigned40bitvaluesmdhormdl is updated with the result if submas the result is saturated before storagethe saturation point is selected as either 40 or 32 bits by mmdmsinstruction syntax and descriptionapril 19 2001 lx5180 lexra proprietary confidential 42 release 19 nomenclature 512 cyclebycycle usage for dual mac instructions the dual mac eliminates all programming hazards for its instructions by stalling the pipeline when necessary it does this both to avoid resource conflicts and to wait for results of first instruction to be ready before attempting to use those results in second instruction this means that there are programming restrictions in order to obtain correct results from sequence of dual mac instructions howeverthemostefficientuseofthedualmachardwareisobtainedwhentheprogramavoidsthesestalls this can be done by scheduling the instructions properly the rest of this section presents the information necessary to perform this scheduling in addition several instruction sequences are presented that represent the most efficient use of the dual mac for the inner loop of some common dsp algorithms typically these make use of the multiple accumulators in the dual mac table20indicatesthenumberofcyclesthatmustbeinsertedbetweenthefirstindicatedmacinstructionand thesecondindicatedinstructiontoavoidpipelinestallsthenumber0zeromeansthatthetwoinstructions can be issued back to back the nonzero numbers can be interpreted in two ways if the instructions are issued back to back the dual mac will stall the pipeline for the indicated number of cycles alternatively nondual mac instructions can be issued to occupy those cycles or other dual mac instructions can be issued in those cycles such as those using nonconflicting accumulatorsdual round rnda2 mt mth mtl n the accumulator register mth or mtl is rounded then updated if mt the accumulator register pair mthmtl are each rounded then updated the rounding mode is selected in mmd field rnd the least significant bit of precision in the accumulatorregisterafterroundingis16nbits15n00arezeroedtherangen 0 8 is permitted for the output alignment shift amount in the case of n 0 the field may be omitted rs rt r0 r31 md mdh mdl also for mt mdh m0h m3h also for msh mth mdl m0l m3l also for msh mth hi m0h3100 m0l3100instruction syntax and descriptionapril 19 2001 lx5180 lexra proprietary confidential 43 release 19 table 20 cycles required between dual mac instructions nomenclature the following code sequences indicate the most efficient use of the dual mac for coding the inner loop of somecommondspalgorithmsthealgorithmsarepresentedfor16bitoperandswith16bitresultsaswell as32bitoperandswith32bitresultsthealgorithmsassumethatfractionalarithmeticisusedthereforefor the 32bit results of 32x32 multiply only the hi half of the target accumulator pair is retrieved or used in these examples only the dual mac instructions are shown the other pipe is used to fetch and store operands and take care of loop housekeeping functions the loops may need to be unrolled to take full advantage of the multiple dual mac accumulators case 1 16bit inner product sum sum aibimultaumaddau msubau cmulta divaumadda2s msuba2s addmas submas multa2 mulna2 rnda2 mta2 mfa multau maddau msubau1u 1u 1u 19t divau 3t 4t 1t 19u cmulta madda2s msuba2s multa2 mulna2 mta23u 4u 1u 19t addmas submas rnda2lo 2s 2thi 3s 3t4u1s 1t19s 19t mfa 4shi 5slo 5shi 6s 3s 19s 2s the two ops can be issued backtoback xu unconditional delay of the indicated number of cycles xs delayonlyifany2ndopsourceisthesameasany1stoptar get producerconsumer dependency xt delay only if any 2nd op target is the same as any 1s op tar get preserve write after write order items in parenthesis are unlikely to occur in any useful program which would probably have an intervening mfa lohi for the 72bit result of 32x32 mult or madda the 32bits m0l m1l etc are available one cycle earlier delay of x cycles means that if the 1st op issues in cycle n then the 2nd op may issue in cycle nx12nd op1st opapril 19 2001 lx5180 lexra proprietary confidential 44 release 19 assuming packed operands two multiplyadds per cycle madda2 m0r1r2 madda2 m0r3r4 madda2 m0r5r6 madda2 m0r7r8 case 2 16bit vector product loop ci aibi assuming packed fractional operands two multiplies per two cycles using two accumulator pairs multa2 m0r1r2 mfa2 m1r8 multa2 m1r3r4 mfa2 m0r7 case 3 16bit complex vector product ci ai complex bi assuming fractional operands packed as 16bit real 16bit imaginary one complex multiply every two cycles using two accumulator pairs cmulta m0r1r2 mfa2 m1r8 cmulta m1r3r4 mfa2 m0r7 case 4 32bit inner product loop sum sum aibi achieves multiplyaccumulate every other cycle using one accumulator madda m0 r1 r2 nondualmac op madda m0 r3 r4 nondualmac op case 5 32bit vector product loop ci aibi assuming fractional 32bit operands so that the mfa waits for the hi result of the multa achieves one multiply per two cycles using all the accumulators multa m0 r1 r2 mfa r9 m1h multa m1 r3 r4 mfa r10m2h multa m2 r5 r6 mfa r11m3h multa m3 r7 r8 mfa r12m0h case 6 32bit complex vector product ci ai complex biapril 19 2001 lx5180 lexra proprietary confidential 45 release 19 assuming fractional 32bit operands so that the addmasubma waits for the hi result of the second multa achieves one complex multiply per ten cycles using all the accumulators with two inserted instructions this is good example of the cycles needed from multa to submaaddma 5 cycles for hi and from submaaddma to mfa 2 cycles multa m0 r1 r4 a2i b2i1 mfa rimag m1h multa m1 r2 r3 a2i1 b2i subma m3hm2hm3h c2i2 a2i2b2i2 a2i1b2i1 nondualmac op multa m2 r1 r3 a2i b2i mfa rreal m3h multa m3 r2 r4 a2i1 b2i1 addma m1hm0hm1h c2i1 a2i1b2i a2ib2i1 nondualmac op 513 vector addressing instructions table 21 vector addressing instructions instruction syntax and description load word pointer increment optional circular bufferlwpcn rt pointerstride load contents of word addressed by register pointer into register rt the stride in bytes is signed 10bit quantity that must be divisible by 4 since it occupies only 8 bits of the instruction word signextend the stride to 32bits and add to contents of registerpointertoformnextaddressupdate pointerwiththecalculatednextaddress cn selects circular buffer n 0 2 see note 2 load halfword pointer increment optional circular bufferlhpcn rt pointerstride load contents of signextended halfword addressed by register pointer into register rt the stride in bytes is signed 9bit quantity that must be divisible by 2 since it occupiesonly8bitsoftheinstructionwordsignextendthestrideto32bitsandadd to contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 load halfword unsigned pointer increment optional circular bufferlhpucn rt pointerstride load contents of zeroextended halfword addressed by register pointer into register rt the stride in bytes is signed 9bit quantity that must be divisible by 2 since it occupiesonly8bitsoftheinstructionwordsignextendthestrideto32bitsandadd to contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 load byte pointer increment optional circular bufferlbpcn rt pointerstride load contents of signextended byte addressed by register pointer into register rt the stride in bytes is signed 8bit quantity signextend the stride to 32bits and add to contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 load byte unsigned pointer increment optional circular bufferlbpucn rt pointerstride load contents of zeroextended byte addressed by register pointer into register rt the stride in bytes is signed 8bit quantity signextend the stride to 32bits and add to contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 store word pointer increment optional circular bufferswpcn rt pointerstride store contents of register rt into word addressed by register pointer the stride in bytes is signed 10bit quantity that must be divisible by 4 since it occupies only 8 bits of the instruction word signextend the stride to 32bits and add to contents of registerpointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2april 19 2001 lx5180 lexra proprietary confidential 46 release 19 nomenclature notes 1 for ltpcn lwpcn lhpucn lbpucn rt pointer is unsupported 2 when circular buffer is selected the update of the pointer register is performed according to the following algorithm which depends on the sign of the stride and the granularity of the access stride exactly equal to 0 is not supported lbpucn and sbpcn if stride 0 pointer20 111 pointer313 cben tpointer cbsn313 3b000 else if stride 0 pointer20 000 pointer313 cbsn pointer cben313 3b111 else pointer pointer stride lhpucn and shpcn if stride 0 pointer20 11x pointer313 cben pointer cbsn313 3b000 else if stride 0 pointer20 00x pointer313 cbsn pointer cben313 3b110 else pointer pointer stridestore halfword pointer increment optional circular buffershpcn rt pointerstride storecontentsofregisterrt1500into16bithalfwordaddressedbyregister pointer the stride in bytes is signed 9bit quantity that must be divisible by 2 since it occupiesonly8bitsoftheinstructionwordsignextendthestrideto32bitsandadd to contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 store byte pointer increment optional circular buffersbpcn rt pointerstride store contents of register rt0700 into byte addressed by register pointer the strideinbytesisasigned8bitquantitysignextendthestrideto32bitsandaddto contents of register pointer to form next address update pointer with the calculated next address cn selects circular buffer n 0 2 see note 2 move to radiax user mtru rt radreg move the contents of register rt to one of the user radiax registers cbs0 cbs2 cbe0cbe2mmdlpc0lpe0lps0thisinstructionhasasingledelayslotbeforethe mmd register takes effect all other registers have delay slot move from radiax user mfru rt radreg movethecontentsofthedesignateduserradiaxregistercbs0cbs2cbe0cbe2 mmd lpc0 lps0 lpe0 to register rt rt r0 r31 and must be even for lt st ltpcn stpcn base pointer r0 r31 stride 891011bit signed value in bytes for bytehalfword wordtwinword ops displacement 14bit signed value in bytes radreg cbs0 cbs2 cbe0 cbe2 mmd lpc0 lps0 lpe0instruction syntax and descriptionapril 19 2001 lx5180 lexra proprietary confidential 47 release 19 lwpcn and swpcn if stride 0 pointer20 1xx pointer313 cben pointer cbsn313 3b 000 else if stride 0 pointer20 0xx pointer313 cbsn pointer cben313 3b100 else pointer pointer stride ltpcn and stpcn if stride 0 pointer313 cben pointer cbsn313 3b000 else if stride 0 pointer313 cbsn pointer cben313 3b000 else pointer pointer stride 514 radiax alu operations theradiaxaluoperationsincludebothdual16bitandsaturatingversionsofthemips1aluoperations and several new alu operations which are useful for common dsp algorithms table 22 radiax alu operations instruction syntax and description dual shift left logical variablesllv2 rd rt rs thecontentsofrt3116andthecontentsofrt1500areindependentlyshiftedleft by the number of bits specified by the low order four bits of the contents of general register rs inserting zeros into the low order bits of rt3116 and rt1500 for sllv2 the high and low results are concatenated and placed in register rd note that s option is not provided because this is logical rather than arithmetic shift and thus the concept of arithmetic overflow is not relevant dual shift right logical variablesrlv2 rd rt rs the contents of rt3116 and the contents of rt1500 are independently shifted right by the number of bits specified by the low order four bits of the contents of generalregisterrsinsertingzerosintothehighorderbitsofrt3116andrt1500 thehighandlowresultsareconcatenatedandplacedinregisterrdnotethatas option is not provided because this is logical rather than arithmetic shift and thus the concept of arithmetic overflow is not relevant dual shift right arithmetic variablesrav2 rd rt rs the contents of rt3116 and the contents of rt1500 are independently shifted right by the number of bits specified by the low order four bits of the contents of generalregisterrssignextendingthehighorderbitsofrt3116andrt1500the high and low results are concatenated and placed in register rd note that s option is not provided because arithmetic overflowunderflow is not possible add optional saturationaddrs rd rs rt 32bit addition considering both quantities as signed 32bit integers add the contents of register rs to rt for addr the result is placed in register rd ignoring anyoverfloworunderflowforaddrstheresultissaturatedto0131ifoverflow or1031ifunderflowthenplacedinrdaddrswillnotcauseanoverflowtrapapril 19 2001 lx5180 lexra proprietary confidential 48 release 19 dual add optional saturationaddr2srd rs rt dual 16bit addition considering all quantities as signed 16bit integers add the contents of register rs1500 to rt1500 and independently add the contents of register rs3116 to rt3116 for addr2 the high and low results are concatenated and placed in register rd ignoring any overflow or underflow for addr2s the two results are independently saturated to 0 115 if overflow or 1 015 if underflow then placed in rd addr2s will not cause an overflow trap subtract optional saturationsubrs rd rs rt 32bitsubtractionconsideringbothquantitiesassigned32bitintegerssubtractthe contentsofregisterrtfromthecontentsofregisterrsforsubrtheresultisplaced inregisterrdignoringanyoverfloworunderflowforsubrstheresultissaturated to 0 131 if overflow or 1 031 if underflow then placed in rd subrs will not cause an overflow trap dual subtract optional saturationsubr2srd rs rt dual 16bit subtraction considering all quantities as signed 16bit integers subtract the contents of register rt1500 from rs1500 and independently subtract the contents of register rt3116 from rs3116 for subr2 the high and low results are concatenated and placed in register rd ignoring any overflow or underflow for subr2s the two results are independently saturated to 0 115 if overflow or 1 015 if underflow then placed in rd subr2s will not cause an overflow trap dual set on less than sltr2 rd rs rt dual 16bit comparison considering both quantities as signed 16bit integers if rs1500 is less than rt1500 then set rd1500 to 015 1 else to zero independently considering both quantities as signed 16bit integers if rs3116 is less than rt3116 then set rd3116 to 015 1 else to zero minimum min rd rs rt the contents of the general register rt are compared with rs considering both quantities as signed 32bit integers if rs rt or rs rt rs is placed into rd if rs rt rt is placed into rd dual minimum min2 rd rs rt thecontentsofrt3116arecomparedwithrs3116consideringbothquantitiesas signed 16bit integers if rs3116 rt3116 or rs3116 rt3116 rs3116 is placed into rd3116 if rs3116 rt3116 rt3116 is placed into rd3116 similar independent operation is performed on rt1500 and rs1500 to determine rd1500 maximum max rd rs rt the contents of the general register rt are compared with rs considering both quantities as signed 32bit integers if rs rt or rs rt rs is placed into rd if rs rt rt is placed into rd dual maximum max2 rd rs rt thecontentsofrt3116arecomparedwithrs3116consideringbothquantitiesas signed 16bit integers if rs3116 rt3116 or rs3116 rt3116 rs3116 is placed into rd3116 if rs3116 rt3116 rt3116 is placed into rd3116 similar independent operation is performed on rt1500 and rs1500 to determine rd1500 absolute optional saturationabsrs rd rt consideringrtasasigned32bitintegerifrt0rtisplacedintordifrt0rtis placed into rd if absrs and rt 1 031 the smallest negative number then 0 131 the largest positive number is placed into rd otherwise if absr and rt 1 031 rt is placed into rd dual absolute optional saturationabsr2s rd rt abss operations are performed independently on rt3116 and rt1500 considering each to be 16bit signed integers rd is updated with the absolute value of rt3116 concatenated with the absolute value of rt1500instruction syntax and descriptionapril 19 2001 lx5180 lexra proprietary confidential 49 release 19 515 conditional operations the lx5180 provides conditional move instructions that reduce the need for program branches resulting in greater program efficiency table 23 conditional operations usage note when combined with the slt or sltr2 instructions the conditional move instructions can be used to construct complete set of conditional move macrooperations for exampledual mux mux2hh hl lh ll rd rs rt rd3116 is updated with rs3116 for mux2hh or mux2hl rd3116 is updated with rs1500 for mux2lh or mux2ll rd1500 is updated with rt3116 for mux2hh or mux2lh rd1500 is updated with rt1500 for mux2hl or mux2ll count leading sign bits cls rd rt the binaryencoded number of redundant sign bits of general register rt is placed into rd if rt3130 10 or 01 rd is updated with 0 if rt 0 or if rt 132 rd is updated with 027 15 decimal 31 bit reverse bitrev rd rt rs bitreversal of the contents of general register rt is performed the result is then shifted right logically by the amount specified in the lower 5bits of the contents of general register rs then stored in rd instruction syntax and description conditional move on equal zerocmveqzh lrd rs rt if the general register rt is equal to 0 the general register rd is updated with rs otherwise rd is unchanged for h if rt3116 is equal to 0 the full 32bit general register rd3100 is updated with rs otherwise rd is unchanged for l if rt1500 isequalto0the full32bitgeneralregisterrd3100isupdatedwithrsotherwiserd is unchanged conditional move on not equal zerocmvnezh lrd rs rt if the general register rt is not equal to 0 the general register rd is updated with rs otherwise rd is unchanged for h if rt3116 is not equal to 0 the full 32bit general register rd3100 is updated with rs otherwise rd is unchanged for l if rt1500isnotequalto0the full32bitgeneralregisterrd3100isupdatedwithrs otherwise rd is unchanged if r3 r4 r1 r2 cmvlt r1r2r3r4 slt atr3r4 cmvnez r1r2at if r3 r4 r1 r2 cmvge r1r2r3r4 slt atr3r4 cmveqz r1r2at if r3 r4 r1 r2 cmvle r1r2r3r4 slt atr4r3 cmveqz r1r2atinstruction syntax and descriptionapril 19 2001 lx5180 lexra proprietary confidential 50 release 19 52 instruction encoding 521 lexra formats the lexra formats are introduced into the mips instruction set by designating single iformat as lexopthenusingtheinst50subopfieldtopermitupto64newlexraopcodesthusthenewdsp opcodesmodelthemipsspecialopcodesencodedinrformatthediagramsbelowillustratethelexop codes using iformat 011_111 which is unused in the mips iiv isa thefollowingprinciplesareusedtoresolvepotentialambiguityofencodingbetweenthenewlx5180dsp extensions and mips instructions lx5180instructionswithsimilaroperationstoexistingmipsinstructionsbutwithadditionaloperands permitted are programmed with new assembler mnemonics and encoded as lexop for instance b if mips instruction is extended with new functionality it is programmed with new assembler mnemonics and encoded as lexop lexra mnemonics which end in r indicate general register file targets mnemonics which end in indicate accumulator register targets this convention removes ambiguity between the lexra op and similar mips op for example the mips addand the lexop addrare both signed 32bit additions however on overflow the mips instruction triggers the overflow exception while the lexop does not alternatively the result of the lexop will saturate if the s option is selected addrsif r3 r4 r1 r2 cmvgt r1r2r3r4 slt atr4r3 cmvnez r1r2at multa m1 r1 r2 is encoded as lexop instruction mult r1 r2 is encoded as mips instruction multa m0 r1 r2 isencodedasalexopinstruction m0isanaliasforhilo addr r3 r1 r2 is encoded as lexop instruction add r3 r1 r2 is encoded as mips instructionapril 19 2001 lx5180 lexra proprietary confidential 51 release 19 522 loadstore formats 31 26 25 21 20 16 15 6 5 0 assembler mnemoniclexop 011 111 base rt immediatelexra subop lt lexop base rteven displacement8 lt st lexop base rteven displacement8 st 65 5 1 0 6 31 26 25 21 20 16 15 8 7 6 5 0 assembler mnemoniclexop 011 111 base rt immediate cclexra subop lbpcn lexop pointer rt stride cc lbp lbpucn lexop pointer rt stride cc lbpu lhpcn lexop pointer rt stride2 cc lhp lhpucn lexop pointer rt stride2 cc lhpu lwpcn lexop pointer rt stride4 cc lwp ltpcn lexop pointer rt stride8 cc ltp sbpcn lexop pointer rt stride cc sbp shpcn lexop pointer rt stride2 cc shp swpcn lexop pointer rt stride4 cc swp stpcn lexop pointer rt stride8 cc stp 65 5 8 2 6 base pointer rt selects general register r0 r31 rteven selects general register evenodd pair r0r1 r2r3 r30r31 stride signed 2scomplement number in bytes must be an integral number of halfwordswordstwinwords for the corresponding instructions displacement signed 2scomplement number in bytes must be an integral number of twinwords cc 00 select circular buffer 0 cbs0 cbe0 01 select circular buffer 1 cbs1 cbe1 10 select circular buffer 2 cbs2 cbe2 11 circular buffer selectedapril 19 2001 lx5180 lexra proprietary confidential 52 release 19 523 arithmetic format 31 26 25 21 20 16 15 11 10 9 8 7 6 5 0 assembler mnemoniclexop 011 111 rs rt rd hl 0 s dlexra subop addrsaddr2s lexop rs rt rd 0 0 s d addr subrs subr2s lexop rs rt rd 0 0 s d subr sltr2 lexop rs rt rd 0 0 0 1 sltr sllv2 lexop rs rt rd 0 0 0 1 sllv srlv2 lexop rs rt rd 0 0 0 1 srlv srav2 lexop rs rt rd 0 0 0 1 srav min min2 lexop rs rt rd 0 0 0 d min max max2 lexop rs rt rd 0 0 0 d max absrs absr2s lexop 0 rt rd 0 0 s d absr mux2lllhhlhh lexop rs rt rd hl 0 0 1 mux cls lexop 0 rt rd 0 0 0 0 cls bitrev lexop rs rt rd 0 0 0 0 bitrev 65 5 5 2 111 6 rs rt rd selects general register r0 r31 s selects saturation of result s1 indicates that saturation is performed d d1 indicates that dual operations on 16bit data are performed hl for mux2 00 ll rd rs1500 rt1500 01 lh rd rs1500 rt3116 10 hl rd rs3116 rt1500 11 hh rd rs3116 rt3116april 19 2001 lx5180 lexra proprietary confidential 53 release 19 524 mac format 31 26 25 21 20 16 15 11 10 9 8 5 6 5 0 assembler mnemoniclexop 011 111 rs rt md 0 u gz s dlexra subop cmulta lexop rs rt md 0 0 0 0 0 cmulta divau lexop rs rt md 0 u 0 0 0 diva multau lexop rs rt md 0 u 1 0 0 madda multa2 lexop rs rt md 0 0 1 0 1 madda maddau lexop rs rt md 0 u 0 0 0 madda madda2s lexop rs rt md 0 0 0 s 1 madda msubau lexop rs rt md 0 u 0 0 0 msuba msuba2s lexop rs rt md 0 0 0 s 1 msuba mulna2 lexop rs rt md 0 0 1 0 1 msuba mta2g lexop rs rt md 0 0 g 0 1 mta 65 5 5 11111 6 base pointer rtselects general register r0 r31 rs rt selects general register r0 r31 md selects accumulator 0nnhl where nn m0 m3 hl 00 reserved 01 mnl 10 mnh 11 mn s selects saturation of result s1 indicates that saturation is performed d d1 indicates that dual operations on 16bit data are performed gz for mta2 used as guard bit if g1 bits 3932 of the accumulator pair are loaded and bits 3100 are unchanged if g0 all 40 bits 3900 of the accumulator or pair are updated for madda msuba used as zero bit if z 1 the result is added to subtracted from zero rather than the previous accumulator value this performs multa multa2 or mulna2 if z 0 performs madda msuba madda2 or msuba2 u treat operands as unsigned values 0 signed 1 unsignedapril 19 2001 lx5180 lexra proprietary confidential 54 release 19 525 mac format b 31 26 25 21 20 16 15 11 10 7 6 5 0 assembler mnemoniclexop 011 111 00000 mt rd so dlexra subop mfa mfa2 lexop 000000 mt rd so d mfa rnda2 lexop 000000 mt 0 so 1 rnda 65 5 5 4 1 6 rd selects general register r0 r31 mt selects accumulator 0nnhl where nn m0 m3 hl 00 reserved 01 mnl 10 mnh 11 mn d d1 indicates that dual operations on 16bit data are performed so encoded output shift amount n 0 8 for rnda2 mfa mfa2 instructionsapril 19 2001 lx5180 lexra proprietary confidential 55 release 19 526 mac format c 527 radiax move format and lexracop0 mtlxc0mflxc031 26 25 21 20 16 15 11 10 8 7 6 5 0 assembler mnemoniclexop 011 111 ms mt md 000 s 0lexra subop addmas lexop ms mt md 000 s 0 addma submas lexop ms mt md 000 s 0 subma 65 5 5 3 11 6 mt ms md selects accumulator 0nnhl where nn m0 m3 hl 00 reserved 01 mnl 10 mnh 11 reserved s selects saturation of result s1 indicates that saturation is performed 31 26 25 21 20 16 15 11 10 8 7 6 5 0 assembler mnemoniclexop 011 111 00000 rt rurk 000 k 0lexra subop mfru lexop 00000 rt ru 000 0 0 mfrad mtru lexop 00000 rt ru 000 0 0 mtrad mfrk lexop 00000 rt rk 000 1 0 mfrad mtrk lexop 00000 rt rk 000 1 0 mtrad 65 5 5 3 11 6 rt selects general register r0 r31 rk selectsradiaxkernelregisterinmfrkmtrkinstructions currently all reserved however coprocessor unusable exception is taken in user mode if the cu0 bit is 0 in the cp0 status register when mfrk or mtrk is executed ru selects radiax user register in mfru mtru instructions 00000 bs0 00001 bs1 00010 cbs2 00011 reserved 00100 cbe0 00101 cbe1 00110 cbe2 00111 reserved 01xxx reserved 10000 lps0 10001 lpe0 10010 lpc0april 19 2001 lx5180 lexra proprietary confidential 56 release 19 these are notlexop instructions they are variants of the standard mtc0 and mfc0 instructions that allow access to the lexra coprocessor0 registers listed below as with any cop0 instruction coprocessor unusable exception is taken in user mode if the cu0 bit is 0 in the cp0 status register when these instructions are executed 1001 reserved 101xx reserved 11000 mmd 11001 reserved 111xx reserved 31 26 25 21 20 16 15 11 10 0 assembler mnemoniccop0 010 000 copz rs rt rd 000 0000 0000 mflx cop0 00011 rt rd 000 0000 0000 mtlx cop0 00111 rt rd 000 0000 0000 65 5 5 1 1 rt selects general register r0 r31 rd selects lexra coprocessor0 register 00000 estatus 00001 ecause 00010 intvec 00011 reserved 001xx reserved 01xxx reserved 1xxxx reservedapril 19 2001 lx5180 lexra proprietary confidential 57 release 19 528 cmove format 529 lexra subop bit encodings indicates instructions which are implemented only in the lx5280 and not the lx5180 product31 26 25 21 20 16 15 11 10 9 8 6 5 0 assembler mnemoniclexop 011 111 rs rt rd 00 condlexra subop cmveqzhl lexop rs rt rd 00 cond cmove cmvnezhl lexop rs rt rd 00 cond cmove 6555 2 3 6 rs rt rd selects general register r0 r31 cond condition code for rt operand referenced by the conditional move 000 eqz 001 nez 010 eqzh 011 nezh 100 eqzl 101 nezl 11x reserved inst20 inst53 01234567 0 cmove sllv srlv srav 1 bitrev mux cls absr 2 madda msuba rnda 3 diva cmulta mfa mta addma subma 4 addr subr mfrad mtrad 5 min max sltr 6 lbp lhp ltp lwp lbpu lhpu lt 7 sbp shp stp swp stapril 19 2001 lx5180 lexra proprietary confidential 58 release 19 april 19 2001 lx5180 lexra proprietary confidential 59 release 19 6 lx5180 local memory 61 local memory overview thischapterdescribeshowmemoriesareconfiguredandconnectedtothelx5180usingthelocalmemory interfaces lmis this section provides brief summary of the conventions and supported memories section62 describes the control register that allows software control over certain aspects of the lmis the subsequent sections cover each of the lmis in detail this chapter also discusses configuration options and the ports that customers must access to connect application specific ram and rom devices that are used by the lx5180 lmis all of the signals between the processor core the lmis rams and the system bus controller are automatically configured by lconfig the lx5180 configuration tool lconfigalso produces documentation of the exact rams required for the chosen configuration settings and writes ram models used for rtl simulation thelmisconnecttoramsthatservicethelx5180processorslocalinstructionanddatabussesthelmis alsoprovidethepathwaysfromtheprocessortothesystembusthelx5180includesanlmiforeachofthe localmemorytypesthesizesoftheramsandromsarecustomerselectablethelx5180lmisdirectly support synchronous rams that register the address write data and control signals at the ram inputs the lmisalsosupplyredundantreadenableandchipselectlinesforeachramwhichmayberequiredforsome ram types roms may also be connected but may require customer supplied address register at the address inputs lexra supplies an integration layer for the lmis and the memory devices connected to them in this layer memory devices are instanced as generic modules satisfying the depth and width requirements for each specific memory instance the lconfigutility supplies summary of the memory devices required for the chosen configuration in most cases customers simply need to write wrapper that connects the generic module port list to technology specific ram instance inside the ram wrapper thelx5180isconfigurablefora163264or128bytecachelinesizethetagstoreramsizesshownin the tables of this chapter assume 16byte line size the documentation produced by lconfigindicates the required tag rams for the selected configuration options including the line size as general rule doubling of the line size results in halving the tag store depth thevalidbitswithintagstoresareautomaticallyclearedbythelmisuponresetthedatacacheimplements writethrough protocol caches do not snoop the system bus the lx5180 is configurable to work with rams with write granularity of 8 bits byte or 32 bits word byte write granularity results in more efficient operation of store byte and store halfword instructions table24 summarizes the lmis that can be integrated on the local busses table 24 local memory interface modules name description icache direct mapped or twoway set associative instruction cache imem instruction ram irom instruction rom dcache direct mapped data cache dmem data ram or romapril 19 2001 lx5180 lexra proprietary confidential 60 release 19 62 cache control register cctl cctl cp0 general register address 20 when reading this register the contents of the reserved bits are undefined when writing this register the contents of the reserved bits should be preserved changes in the contents of the cctl register are observed in the w stage however these changes affect instruction fetches currently in progress in the i stage and data load or store operations in progress in the m stage the iromon and iromoff bits of the cctl register control the and use of the optional local irom memory configured into the lx5180 when irom is present and the lx5180 is reset the lmi enables accesstotheiromatransitionfrom0to1oniromoffdisablestheiromallowinginstructionreferences to be serviced imem icache or the system bus transition from 0 to 1 on iromon enables the irom the imemfill and imemoff bits of the cctl register control the contents and use of any local imem memory configured into the lx5180 when the lx5180 is reset the lmi clears an internal register to indicate that the entire imem lmi contents are invalid when imem is invalid all cacheable fetches from the imem region will be serviced by the instruction cache if an instruction cache is present transition from 0 to 1 on imemfill causes the lmi to initiate series of line read operations to fill the imemcontentstheaddressesusedforthesereadsaredefinedbytheconfiguredbaseandtopaddresses oftheimemdescribedinsection64theprocessorstallswhiletheentireimemcontentsarefilledbythe lmi thereafter the lmi sets its internal imem valid bit and will service any access to the imem range from the local imem memory the time that an imem fill takes to complete is the number of line reads needed to fill the imem range multiplied by the latency of one line read assuming there is other system bus traffic transition from 0 to 1 on imemoff causes the lmi to clear its internal imem valid bit subsequent cacheable fetches from the imem region will be serviced by the instruction cache to use the imem again an application must reinitialize the imem contents through the imemfill bit of the cctl register theilockfieldcontrolssetlockinginthetwosetassociativeinstructioncachewhenilockis00or01the instructioncacheoperatesnormallywhenilockis10allcachedinstructionreferencesareforcedtooccupy set1thehardwarewillinvalidatelinesinset0ifnecessarytoaccomplishthiswhenilockis11linesinset 1 are never displaced ie they are locked in the cache set 0 is used to hold other lines as needed toutilizethecachelockingfeaturesoftwareshouldexecuteatleastonepassofcriticalsubroutinesorloops with ilock set to 10 after this has been done ilock should be set to 11 to lock the critical code into set 1 and use set 0 for other code the iinval and dinval fields control hardware invalidation of the instruction cache and data cache transition from 0 to 1 on iinval will initiate hardware invalidation sequence of the entire instruction cache likewisea0to1transitionondinvalwillinitiateahardwareinvalidationsequenceoftheentiredatacache the dmem if present is unaffected by this operation the hardware invalidation sequence for the instruction and data caches requires one cycle per cache line to complete depending on the circumstances software may be able to employ an alternative to full invalidation of the datacacheifasmallnumberoflinesmustbeinvalidatedsoftwaremayperformcachedreadsfromaliasesof318 7 6 5 4 32 1 0 reserved iromoff iromon imemoff imemfill ilock iinval dinvalapril 19 2001 lx5180 lexra proprietary confidential 61 release 19 thememorylocationsofconcernthisdisplacesdataintheaddressedlocationsofthedatacacheevenifthey do not encache the affected memory location anotheralternativeiftheaffectedmemorylocationhasanaliasinuncacheablekseg1spaceistosimply performanuncachedreadoftheaffectedmemorylocationsifthelocationisresidentinthedatacacheitwill be invalidated this method has the advantage of not displacing data in the cache unless it is absolutely necessary to maintain coherency note that write to kseg1 address has affect on the contents of the data cache with either of these two alternatives it is only necessary to reference one word of each affected cache line 63 instruction cache icache lmi the icache lmi supplies the interface for direct mapped or twoway set associative instruction cache attachedtothelx5180localbusthedegreeofassociativityisspecifiedthroughlconfigtheicachelmi participatesincacheableinstructionfetchesbutonlyiftheaddressisnotclaimedbytheimemmodulethe configurations supported by icache and the synchronous rams required for each are summarized in table25 theinstructionstoreforthetwowayicacheconsistsoftwo32bitwidebankswithseparatewriteenable controlsthetagstoreconsistsofonerambankwithtagandvalidbitsforset0andasecondramforset 1 that holds the tag valid lru least recently used and lock bits when miss occurs in the twoway icache the lru bit is examined to determine which element of the set to replace with element 0 being replacediflruis0andelement1beingreplacediflruis1thestateofthelrubitistheninvertedto optimize the timing of cache reads the twoway icache uses the state of the lru bit to determine which elementshouldbereturnedtothecpuinthefollowingcycletheicachedeterminesifthecorrectelement wasreturnedifnottheicachetakesanextracycletoreturnthecorrectelementtothecpuandinvertsthe lru bit table 25 icache conﬁgurations conﬁguration icache_inst ram icache_tag ram instruction cache ram required ram required 1k bytes 2way 2 x 128 x 32 bits 32 x 24 and 32 x 26 bits 2k bytes 2way 2 x 256 x 32 bits 64 x 23 and 64 x 25 bits 4k bytes 2way 2 x 512 x 32 bits 128 x 22 and 128 x 24 bits 8k bytes 2way 2 x 1024 x 32 bits 256 x 21 and 256 x 23 bits 16k bytes 2way 2 x 2048 x 32 bits 512 x 20 and 512 x 22 bits 32k bytes 2way 2 x 4096 x 32 bits 1024x19and1024x21bits 64k bytes 2way 2 x 8192 x 32 bits 2048x18and2048x20bits 1k bytes direct mapped 256 x 32 bits 64 x 23 bits 2k bytes direct mapped 512 x 32 bits 128 x22 bits 4k bytes direct mapped 1024 x 32 bits 256 x 21 bits 8k bytes direct mapped 2048 x 32 bits 512 x 20 bits 16k bytes direct mapped 4096 x 32 bits 1024 x 19 bits 32k bytes direct mapped 8192 x 32 bits 2048 x 18 bitsapril 19 2001 lx5180 lexra proprietary confidential 62 release 19 table26 lists the icache signals that are connected to application specific modules the ic_ prefix indicates signals that are driven by the icache lmi module and received by the rams the icr_ prefix indicates signals that are driven by the icache rams and received by the icache lmi lexra supplies the verilog module that makes all required connections to these wires the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from the table25 table 26 icache ram interfaces note n designates an available activelow version of signal 64 instruction memory imem lmi theimemlmisuppliestheinterfaceforanoptionallocalinstructionstoretheimemservesafixedrange of the physical address space determined by configuration settings in lconfig the imem contents are filled64k bytes direct mapped 16384 x 32 bits 4096 x 17 bits signal description ic_tagindex tag and state ram address line icr_tagrd0 tag and state ram element 0 read path ic_tagwr0 tag and state ram element 0 write path icr_tagrd1 tag and state ram element 1 read path ic_tagwr1 tag and state ram element 1 write path ic_tag0wen tag 0 ram write enable ic_tag0ren tag 0 ram read enable ic_tag0csn tag 0 ram chip select ic_tag1wen tag 1 ram write enable ic_tag1ren tag 1 ram read enable ic_tag1csn tag 1 ram chip select ic_instindex instruction ram address word icr_inst0rd instruction ram element 0 read path icr_inst1rd instruction ram element 1 read path ic_instwr instruction ram write path to both elements ic_inst0wen10 instruction ram 0 write enable ic_inst0ren instruction ram 0 read enable ic_inst0csn instruction ram 0 chip select ic_inst1wen10 instruction ram 1 write enable ic_inst1ren instruction ram 1 read enable ic_inst1csn instruction ram 1 chip selectconﬁguration icache_inst ram icache_tag ramapril 19 2001 lx5180 lexra proprietary confidential 63 release 19 and invalidated under the control of the cp0 cctl register described in section62 cache control register cctl the imem module services instruction fetches that falls within its configured range the imemisaconvenientlowcostalternativetoacachethatmakesinstructionmemoryavailabletothecorefor highspeed access the configurations supported by imem and the synchronous rams required for each are summarized in table27 table 27 imem conﬁgurations table28liststheimemsignalsthatareconnectedtoapplicationspecificmodulesthe iw_prefixindicates signalsthataredrivenbytheimemlmimoduleandreceivedbyramsthe iwr_prefixindicatessignals thataredrivenbyramsandreceivedbytheimemlmithe cfg_prefixidentifiesconfigurationportson the imem lmi that are typically wired to constant values the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table27 thecfg_wires define where the imem is mapped into the physical address space this configuration information defines the local bus address region of the imem it also determines the address of the external resources which are accessed when an imem miss occurs the lconfigutility supplied by lexra will verify that the configured address range does not interfere with other regions defined for lx5180 the size of the memory region must be power of two and must be naturally aligned table 28 imem ram interfacesconﬁguration imem_inst ram local instruction ram ram required 1k bytes 256 x 32 bits 2k bytes 512 x 32 bits 4k bytes 1024 x 32 bits 8k bytes 2048 x 32 bits 16k bytes 4096 x 32 bits 32k bytes 8192 x 32 bits 64k bytes 16384 x 32 bits 128k bytes 32768 x 32 bits 256k bytes 65536 x 32 bits signal description iw_instindex imem index iwr_instrd instruction read data iw_instwr instruction write data iw_instwen10 instruction ram write enable iw_instren instruction ram read enable iw_instcsn instruction ram chip selectapril 19 2001 lx5180 lexra proprietary confidential 64 release 19 note n designates an available activelow version of signal 65 instruction rom irom lmi the irom lmi supplies the interface for an optional readonly local instruction store the irom serves fixed range of the physical address space determined by configuration settings in lconfig irom may be disabled via hardware configuration pin cfg_iroff irom may also be enabled and disabled under software control as described in section62 cache control register cctl the irom is convenient lowcost alternative to cache that makes readonly instruction memory available to the core for highspeed access the configurations supported by irom and the synchronous roms required for each are summarized in table29 table 29 irom conﬁgurations table30 lists the irom signals that are connected to application specific modules the ir_ prefix indicates signals that are driven by the irom lmi module and received by the rom the irr_ prefix indicates signals that are driven by rom and received by the irom lmi the cfg_ prefix identifies configuration ports on the irom lmi that are typically wired to constant values lexra supplies the verilog module that makesallrequiredconnectionstothesewiresthewidthoftheindexanddatalinesdependsupontherom connected to the lmi and can be inferred from table28 the cfg_ wires define where irom is mapped into the physical address space this configuration information defines the local bus address region of the irom it also determines the address of the external resources which are accessed when an irom miss occurs the lconfig utility supplied by lexra will verify that the configured address range does not interfere with other regions defined by the lx5180 note that the size of the memory region must be power of two and must be naturally alignedcfg_iwbase3110 conﬁgured base address modulo 1k bytes cfg_iwtop1710 conﬁgured top address bits that may differ from base conﬁguration irom_data local instruction ram rom required 1k bytes direct mapped 256 x 32 bits 2k bytes direct mapped 512 x 32 bits 4k bytes direct mapped 1024 x 32 bits 8k bytes direct mapped 2048 x 32 bits 16k bytes direct mapped 4096 x 32 bits 32k bytes direct mapped 8192 x 32 bits 64k bytes direct mapped 16384 x 32 bits 128k bytes direct mapped 32768 x 32 bits 256k bytes direct mapped 65536 x 32 bitssignal descriptionapril 19 2001 lx5180 lexra proprietary confidential 65 release 19 table 30 irom rom interfaces note n designates an available activelow version of signal 66 direct mapped write through data cache dcache lmi the dcache lmi supplies the interface for direct mapped write through data cache attached to the lx5180localbusthedcachelmiparticipatesincacheabledatareadsandwritesbutonlyiftheaddress isnotclaimedbythedmemlmi theconfigurationssupportedbydcacheandthesynchronousrams required for each are summarized in table31 the direct mapped dcache module services word or twinword read requests from the core in one cycle when the request hits the cache byte or halfword reads that hit the data cache require an extra cycle for alignmentthedatacachecanstreamwordandtwinwordreadsorwritesthathitthecacheattherateofone per cycle if the lx5180 is configured to work with rams that have word write granularity byte or half wordwritesthatfollowanywritebyonecycleandhitthecacherequireanextracycletomergethedatawith the current cache contents alternatively the lx5180 can be configured to work with rams support byte write granularity which eliminates the extra cycle writesthatareservicedbythedatacachemayrequireextratimetobeservicedbythelbcifitswritebuffer isfullalsowhenacachewriteoperationisimmediatelyfollowedbyacachereadthecachemustdelaythe read for one cycle while the write completes when miss occurs the cache obtains cache line 4 8 16 or 32 words of data from the lexra bus controller lbc write operations that hit the data cache are simultaneously written into the cache and forwarded to the write buffer of the lbc thus if the core subsequently reads the data it will likely be available from the cache for main memory systems that support byte writes all data writes that miss the cache are forwarded to the write buffer of the lbc without disturbing any data currently in the cache for main memory systems that can only write with word granularity byte or halfword write that misses the cachecausesthecachetoperformalinefillfrommainmemorythecachethenmergesthepartialwritedata with the full word data obtained from memory and writes the word to the system bus table 31 dcache conﬁgurationssignal description ir_instindex irom index irr_instrd instruction read data ir_instren instruction rom read enable ir_instcsn instruction rom chip select cfg_irbase3110 conﬁgured base address modulo 1k bytes cfg_irtop1710 conﬁgured top address bits that may differ from base conﬁguration dcache_data ram dcache_tag ram data cache ram required ram required 1k bytes direct mapped 256 x 32 bits 64 x 23 bits 2k bytes direct mapped 512 x 32 bits 128 x 22 bits 4k bytes direct mapped 1024 x 32 bits 256 x 21 bitsapril 19 2001 lx5180 lexra proprietary confidential 66 release 19 table32 lists the dcache signals that are connected to application specific modules the dc_ prefix indicatessignalsthataredrivenbythedcachelmimoduleandreceivedbytheramsthedcr_prefix indicatessignalsthataredrivenbythedcacheramsandreceivedbythedcachelmilexrasupplies the verilog module that makes all required connections to these wires the width of the index and data lines depends upon the ram connected to the lmi and can be inferred from table31 table 32 dcache ram interfaces note n designates an available activelow version of signal 67 scratch pad data memory dmem lmi the dmem lmi supplies the interface for scratch pad data ram attached to the lx5180 local bus the dmem module services in any cacheable or uncacheable data read or write operation that falls within its configured range byte or halfword reads that hit the dmem require an extra cycle for alignment dmem can stream word and twinword reads or writes that hit dmem at the rate of one per cycle if the lx5180 is configured to work with rams that have word write granularity byte or halfword writes that follow any write by one cycleandhitdmemrequireanextracycletomergethedatawiththecurrentdmemcontentsalternatively thelx5180canbeconfiguredtoworkwithramssupportbytewritegranularitywhicheliminatestheextra cycle also because write operation to the dmem is never sent to the lbc writes to dmem will not cause the lbc to stall the processor due to full write buffer condition8k bytes direct mapped 2048 x 32 bits 512 x 20 bits 16k bytes direct mapped 4096 x 32 bits 1024 x 19 bits 32k bytes direct mapped 8192 x 32 bits 2048 x 18 bits 64k bytes direct mapped 16384 x 32 bits 4096 x 17 bits signal description dc_tagindex tag and state ram address dcr_tagrd tag and state ram read path dc_tagwr tag and state ram write path dc_tagwen tag and state ram write enable dc_tagren tag and state ram read enable dc_tagcsn tag and state ram chip select dc_dataindex data ram address word dcr_datard data ram read path dc_datawr data ram write path dc_datawen10 data ram write enable dc_dataren data ram read enable dc_datacsn data ram chip selectconﬁguration dcache_data ram dcache_tag ramapril 19 2001 lx5180 lexra proprietary confidential 67 release 19 the dmem configurations and the synchronous rams required for each are summarized in the table33 table 33dmem conﬁgurations table34 lists the dmem signals that are connected to application specific modules the dw_prefix indicates signals that are driven by the dmem lmi module and received by rams the dwr_prefix indicates signals that are driven by rams and received by the dmem lmi the cfg_prefix identifies configurationportsonthedmemlmithataretypicallywiredtoconstantvaluesthewidthoftheindexand data lines depends upon the ram connected to the lmi and can be inferred from table33 thecfg_wires define where dmem is mapped into the physical address space it is not possible for any dmemreferencetoresultinanoperationonthesystembusthe lconfigutilitysuppliedbylexrawillverify that the configured address range does not interfere with other regions defined for lx5180 the size of the memory region must be power of two and must be naturally aligned the dmem lmi can also be used as rom controller simply by tying off the write enable and data input lines in the ram wrapper and instancing rom in the ram wrapper table 34dmem ram interfaces note n designates an available activelow version of signalconﬁguration dmem_data ram 64bit dmem_data ram 128bit local data ram ram required ram required 1k bytes 256 x 32 bits 256 x 32 bits 2k bytes 512 x 32 bits 512 x 32 bits 4k bytes 1024 x 32 bits 512 x 32 bits 8k bytes 2048 x 32 bits 1024 x 32 bits 16k bytes 4096 x 32 bits 2048 x 32 bits 32k bytes 8192 x 32 bits 4096 x 32 bits 64k bytes 16384 x 32 bits 8192 x 32 bits 128k bytes 32768 x 32 bits 16384 x 32 bits 256k bytes 65536 x 32 bits 32768 x 32 bits signal description dw_dataindex decoded data ram index dwr_datard data ram read data dw_datawr data ram write data dw_datawen data ram write enable dw_dataren data ram read enable dw_datacsn data ram chip select cfg_dwbase3110 conﬁgured base address modulo 1k bytes cfg_dwtop1710 conﬁgured top address bits that may differ from baseapril 19 2001 lx5180 lexra proprietary confidential 68 release 19 april 19 2001 lx5180 lexra proprietary confidential 69 release 19 7 lx5180 system bus 71 connecting the lx5180 to internal devices the lexra system bus lbus is the connection between the lx5180 and other internal devices such as systemmemoryusbieee1394firewireandanexternalbusinterfacethelbcusesaprotocolsimilar to that of the peripheral component interface pci bus this is wellknown and proven architecture addingnewdevicestothelexrabusisstraightforwardandtheperformanceapproachesthehighestthatcan be achieved without adding great deal of complexity to the protocol figure 5 lexra system bus diagram thelexrabussupportsmultiplemastersthisallowsformasteringiocontrollerswithdmaenginestobe connected to the bus the bus has pended architecture in which master holds the bus until all the data is transferred this simplifies the design of usersupplied bus agents and reduces latency for cache miss servicing thelexrabusisasynchronousbussignalsareregisteredandsampledatthepositiveedgeofthebusclock certain logical operations may be made to the sampled signals and then new signals can be driven immediately such as for address decoding this allows for samecycle turnaround the lbc provides an optionalasynchronousinterfacebetweenthecpuandthelexrabusallowingthelexrabusspeedcanbeset to be any speed equal to or less than the cpu clock frequency thelexrabusdatapathforthelx5180is32bitswidethereforethebuscantransferonewordhalfword or byte in one bus clock the bus supports line and burst transfers in which several words of data are transferred the lexra bus accomplishes this by transferring words of data from incremental addresses on successive clock cycles thelbccontainsawritebufferwhenthecpuissuesawriterequesttoalexrabusdevicetheaddressand data are saved in the buffer and sent to the device sometime later the cpu can continue processing having safely assumed that the write will eventually happen this is described more thoroughly in section772 thelbcdrivesenablingsignalstocontrolmuxesortristatebuffersthisallowsthelexrabustohaveeither bidirectional or pointtopoint topology 72 terminology thelexrabusborrowsterminologyfromthepcibusspecificationonwhichthelexrabusispartiallybased bus transactions take place between two bus agents one bus agent requests the bus and initiates transfer the second responds to the transferlexra bus controller lbcbus bridge usb firewirebus to cpu and local memory interfaceslexra system bus external bus eg pciapril 19 2001 lx5180 lexra proprietary confidential 70 release 19 theagentinitiatingatransferiscalledthe businitiator itisalsoreferredtoasthe busmaster bothtermsare used interchangeably in this document therespondingagentisknownasthebus targetitsamplestheaddresswhenitisvalidanddeterminesifthe address is within the domain of the device if so indicates as such to the initiator and becomes the target aread transfer is bus operation whereby the master requests data from the target awrite transfer is bus operation whereby the master requests to send data to the target asinglecycle busoperationisusedtotransferonewordhalfwordorbyteofdatathisamountofdatacan be transferred in one bus cycle not including the address cycle and device latencies aline transfer is read or write operation where an entire cache line of data is transferred in successive cycles as fast as the initiator and target can sendreceive the data aburst transfer is read or write operation where large amount of data needs to be sent the initiator presents starting address and data is transferred starting at that address in successive cycles for each word transferred the address is incremented by the devices internally some signals on the lexra bus are active low that is they are considered logically true when they are electrically low and logically false when electrically high device assertsa signal when it drives it to its logical true electrical state 73 bus operations the purpose of the lexra bus is to connect together the various components of the system including the lx5180 cpu main system memory io devices and external bus bridges different devices have different transfer requirements for example the lx5180 cpu will request the bus to fetch cache line of data from memoryiodeviceswillrequestlargeblocksofdatatobesenttoandfrommemorythelexrabussupports the various types of transfers needed by both io and the processor the six types of bus operations are singlecycle read line read burst read singlecycle write line write though this wont be used by the lx5180 core and burst write 731 singlecycle read thesinglecyclereadoperationreadsasinglewordhalfwordorbytefromthetargetdevicethisoperation isusuallyusedbythecputoreaddatafromuncachableaddressspaceifthereadaddresswasincacheable address space either hit would occur resulting in bus activity or miss would occur resulting in read line transaction 732 read line thereadlineoperationreadsasequenceofdatafrommemorycorrespondingtothesizeofacachelinethe cache line size affects how many cycles are required to transfer the full line the lx5180 and the lexra bus support configurable line size specified through lconfig the default line size of four words 16 bytes is assumed here there are two ways that the target could transfer the data back to the initiator the conventional way is to transferfourwordsofdatainsequencestartingatthenearest16bytealignedaddresssmallerorequaltothe address that the initiator drives in other words the target starts the transfer at the beginning of the line containing the requested address somememorydevicesmayimplementaperformanceoptimizationcalled desiredwordfirst iftheaddressisapril 19 2001 lx5180 lexra proprietary confidential 71 release 19 notaligned to 16byte boundary then the first data returned by the target is the word corresponding to the addressinsteadofthefirstwordofthelinethesecondwordisthenextsequentialwordofdataandsoonat the end of the line the target wraps around and returns the first word of line thelx5180supportstwowaysofincrementingtheaddressofalinerefilloneisby linearwrap wherethe addressissimplyincrementedbyonetheotherisby interleavedwrap wherethenextaddressisdetermined bythelogicalxorofthecyclecountandthefirstwordaddresstheinterleavesequenceisshowninthetable belowtheloworderaddressbits32forthefirstdatabeataretheobtainedfromtheaddressofthelineread request the low order address bits for the subsequent data indicate the corresponding interleave order table 35 line read interleave order 733 burst read theburstreadoperationtransfersanarbitraryamountofdatafromthetargettotheinitiatortheinitiatorfirst presents starting address to the target the target responds by providing multiple cycles of data words in sequence starting at the initial address the initiator indicates to the target when to stop providing data burstreadoperationsareusedbyiodevicesforblockdmatransfersthelx5180willneverissueaburst read operation note that there is difference between 4cycles burst and line read line read may use desiredword first increment and wrap burst will always increment and will never wrap 734 singlecycle write the singlecycle write operation writes single word halfword or byte to the target thelx5180usesacachewithawritethroughpolicyallcpuinstructionsthatwritetomemorygeneratea singlecycle write operation unless the address is in the local scratchpad memory in which case the write operation will not make it out to the lexra bus 735 line write the line write operation is not used by the lx5180 this operation could be used by processor that has data cache that implements writeback policy 736 burst write burst write is an operation where the initiator sends an address and then an indefinite sequence of data to thetargettheinitiatorwillinformthetargetwhenithasfinishedsendingdatathisoperationisusedbyio devices for dma transfers it is not used by the processorinterleaved address32 1st data beat 00 01 10 11 2nd data beat 01 00 11 10 3rd data beat 10 11 00 01 4th data beat 11 10 01 00april 19 2001 lx5180 lexra proprietary confidential 72 release 19 74 signal descriptions table 36 lbus signal description 75 lbus commands the initiator drives bcmd during the cycle that bframe is asserted bcmd6 0read 1write bcmd54 54 00 burst fixed length1 01 burst unlimited number of words 10 line interleaved wrap2 11 line linear wrapsignal namesource initiatortargetctrldescription bclock ctrl bus clock bcmd60 initiator encoded command active during ﬁrst cycle that bframe is asserted baddr310 initiator address target indicates valid address by asserting bframe bframe initiator asserted by initiator beginning of operation with address and command signals deasserted when initiator is ready to accept or send last piece of data otherbusmasterssamplethisandbirdytoindicate that the bus will be available on the next cycle birdy initiator forwritesindicatesthatinitiatorisdrivingvaliddata on reads indicates that initiator is ready to accept data bdata310 initiator on writetarget on readdata if driven by initiator birdy indicates valid data onbusifdrivenbytargetbtrdyindicatesvaliddata on bus btrdy target for writes indicates that target is ready to accept data on reads indicates that target is driving valid data bsel target asserted by selected target after initiator asserts bframeindicatesthattargethasdecodedaddress and will respond to the transaction ie has been selected 1 the number of words comes from bcmd20 2 length is determined by the line size not bcmd30april 19 2001 lx5180 lexra proprietary confidential 73 release 19 bcmd30 3210 1000 1 byte 1001 2 bytes 1010 3 bytes 1011 1 word 1100 2 words 1101 reserved 111x reserved 0000 4 words 0001 8 words 0010 16 words 0011 32 words 01xx reserved 76 byte alignment the lexrabus isa big endian bus transactionsmust havetheir data driven to theappropriate busrails the bus mapping is as shown in table37 table 37 lbus byte lane assignment the lexra bus does not define unaligned data transfers such as halfword transfer that starts at addr1001 or transfers that would need to wrap to the next word 77 lexra bus controller thelexrabuscontrollerlbcistheelementofthelx5180thatconnectstothelexrabusitforwardsall transaction requests from the lx5180 cpu to the lexra bus it is an initiator and will never respond to requests from other lexra bus initiators 771 lbc commands the lbc issues the only the lbus commands listed in the table belowlexra bus data byte lanes used bcmd10 addr10 3124 2316 158 70 00 00 x 00 01 x 00 10 x 00 11 x 01 00 x x 01 10 x x 10 00 x x x 10 01 x x x 11 00 x x x xapril 19 2001 lx5180 lexra proprietary confidential 74 release 19 table 38 lbus commands issued by the lbc 772 lbc write buffer and outoforder processing the lbc contains write buffer with depth that is configurable with lconfig all write requests from the cpu are posted in the write buffer the cpu will not wait for the write to complete write operations completeintheordertheyareenteredintothequeueifthequeuefillsthenthecpumustwaituntilanentry becomes available whenthecpu issuesareadoperationthelbcwillattempttoforwardthatrequesttothelexrabus ahead ofanypendingwriteoperationsthissignificantlyimprovesperformancesincethecpuneedstowaitforthe readoperationtocompleteandwouldwastetimeifithadtoalsowaitforunnecessaryorirrelevantwritesto complete there are few cases when the lbc will not allow the read operation to pass pending writes 1 theaddressofapendingwriteiswithinthesamecachelineasthereadthelbcwillholdthe read operation until the matching write operation and all write operations ahead of it com plete if the read is for an instruction fetch it can still pass pending write that is inside the same cache line 2 the read is to uncacheable address space all writes will complete before the read is issued this avoids any problems with io devices and their associated controlstatus registers 3 apendingwriteistouncachableaddressspacethelbcwillholdthereadoperationuntilall writesuptoandincludingthewritetouncacheableaddressspacecompletethisfurtheravoids io device problems the write buffer bypass feature can be disabled so that reads will never pass writes 773 lbc read buffer the lbc contains read buffer with depth that is configurable with lconfig all incoming read data from the system bus passes through the read buffer this allows the lbc to accept incoming data as result of cache line fill operation without having to hold the bus when the lbc is configured with an asynchronous interface larger read buffer improves system and processorperformanceintheeventofcachemisswhenthelbcisconfiguredwithasynchronousinterface thecachecanacceptthedataasfastasthelbccanreaditthereforethereisnoneedforalargereadbuffer customers may reduce the size of the read buffer to minimum size of two 32bit entriescommand bcmd54 bcmd30 circumstances read line 10 or 11 dependingon conﬁguration0000 cache miss during read by the cpu read single wordhalfwordbyte00 10xx read by the cpu from an address in uncachable address space write single wordhalfwordbyte00 10xx write by the cpu into cacheable or uncachable address spaceapril 19 2001 lx5180 lexra proprietary confidential 75 release 19 insomecasesthereisaneedtominimizethenumberofgatesthereadbuffersizemaybereducedtotwoor fourentriesfortheasynchronouscasethiscausesapenaltyintermsoflbusutilizationsincenowthelbc may have to deassert irdy if it cannot hold part of the line of data when the read buffer is the size of cache line this will be relatively rare since simultaneous instruction cache and data cache misses are relatively rare for smaller read buffer irdy deassertion is almost certainty 774 transfer descriptions this section describes the various types of read and write transfers in detail these operations follow certain patterns and rules the rules for driving and sampling the bus are as follows 1 agentsthatdrivethebusdosoasearlyaspossibleaftertherisingedgeofthebusclockthere is some time to perform some combinational logic after the bus clock goes high but the amount of time is determined by the speed of the bus clock and the number of devices on the bus 2 agents sample signals on the bus at the rising edge of the bus clock 3 all bus signals must be driven at all times if the bus is not owned and external device must drive the bus to legal level 4 change in signal ownership requires one dead cycle if an initiator gives up the bus another initiatorneedstowaitforonedeadcyclebeforeitcandrivethebusifthesameinitiatorissues areadoperationandthenneedstoissueawriteoperationitalsomustwaitoneextracyclefor the data bus to turn around 5 agentsthatownsignalsmustdrivethesignalstoalogicaltrueorlogicalfalseallotheragents must disable tristate their output buffers thelexrabusprotocolisbasedonthepcibusprotocol1thelexrabussignalsbframebtrybirdy and bsel have similar function to the pci signals frame trdy irdy and devsel respectively in general the protocol for the lexra bus is as follows 1 the initiator gains control of the bus through arbitration described later in this chapter 2 during the ﬁrst bus cycle of its ownership before the ﬁrst rising clock edge the initiator drivestheaddressforthebustransactionontobaddratthesametimeitassertsbframe to indicate that the bus is in use it will deassert bframe before it send or accepts the last word of data in most cases the initiator will asserts birdy to indicate that it is ready to receivedataorreadoperationsorisdrivingvaliddataforwriteoperationsiftheoperation is write the initiator will drive valid data onto bdata 3 at the rising edge of the ﬁrst clock all agents sample baddr and decode it to determine which agent will be the target 4 the agent that determines that the address is within its address space asserts bsel sometime after the ﬁrst rising edge of the bus clock bsel stays asserted until the transaction is com plete 5 the initiator and the target transfer data either in one cycle or in successive cycles the agent driving data the initiator for write the target for read indicates valid data by asserting its readysignalirdyortrdyforwritesandreadsrespectivelytheagentreceivingdatatar getforawriteinitiatorforareadindicatesitsabilitytoreceivethedatabyassertingitsready 1 the lexra bus is not pci compatible it merely borrows concepts from the pci bus speciﬁcationapril 19 2001 lx5180 lexra proprietary confidential 76 release 19 signal either agent may deassert its ready signal to indicate that it cannot source or accept data on this particular clock edge 6 when the initiator is ready to send or receive the last word of data that is when it asserts birdy for the last time it also deasserts bframe it will deassert birdy when the last word of data is transferred 7 the arbiter grants the bus to the next initiator and may do so during bus transfer by differ ent initiator the new initiator must sample bframe and birdy when both birdy and bframe is sampled deasserted and the new initiator has been given grant it can assert bframe the next cycle to start new transaction note in the examples below the signals baddr and bdata are often shown to be in highimpedance state in reality internal bus signals should always be driven even if they are not being sampled the hiz states are shown for conceptual purposes only 775 single cycle read with waits this operation is used to read word halfword or byte from memory usually in uncachable address space thisisasimplereadoperationwherethetargetrespondsimmediatelywithdatathisisunlikelysincemost bus memory will require one or more cycles to fetch data this example illustrates the most basic read operation without waits 1 initiator asserts bframe and drives baddr 2 targetassertsbseltoindicatetoinitiatorthatatargetisrespondinginthisexamplethereis animmediatefetchofdatasotargetdrivesdataandassertsbtrdytoindicatetotargetthatit is driving data the initiator deasserts bframe and asserts birdy to indicate that the next piece of data received will be the last 3 initiatordeassertsibirdyandthetargetdeassertsbselandbtrdytoindicatetheendof the transaction the initiator that has been given grant owns the bus this cycleclock bframe baddr bdata birdy btrdy bsel d0000april 19 2001 lx5180 lexra proprietary confidential 77 release 19 776 single cycle read with target wait this is the same as the singlecycle read except that the target needs time to fetch the data from memory this is common singlecycle read operation 1 initiator asserts bframe and drives baddr 2 target asserts bsel to indicate that it has decoded the address and is acknowledging that it is the target device however it is not ready to send data so it does not assert btrdy initiator deassertsbframeandassertsbirdytoindicatethatthenextpieceofdatawillbethelastit wants 3 target has not asserted btrdy so data is transferred 4 after second wait cycle target drives data and asserts btrdy to indicate that data is on the bus 5 target deasserts bsel and btrdy initiator deasserts birdy another initiator may drive the bus this cycle 777 line read with waits this operation is used to service cache miss four words of data are transferred in sequence in this example the target is supplying four words of data without any waits 1 initiator drives baddr and asserts bframe to indicate beginning of transactionclock bframe baddr bdata birdy btrdy bsel d0001 clock bframe baddr bdata birdy btrdy bsel d0002april 19 2001 lx5180 lexra proprietary confidential 78 release 19 2 target asserts bsel to indicate that it had decoded the address and will send data when it is ready initiator asserts birdy to indicate that it is ready to receive data 3 target drives data and asserts btrdy 4 target drives second word of data and continues to assert btrdy 5 target drives third word of data and continues to assert btrdy 6 target drives last word of data initiator deasserts bframe to indicate that the next word of data it receives will be the last it needs 7 target deasserts btrdy and bsel initiator deasserts birdy another master may gain ownership of the bus this cycle 778 line read with target waits this illustrates what happens when target needs extra time to fetch data it needs to service cache miss 1 initiator asserts bframe and drives baddr 2 targetassertsbseltoindicatethatitisacknowledgingtheoperationinitiatorassertsbirdy to indicate that it is ready to receive data 3 target waits until it has the data 4 target drives ﬁrst word of data and asserts btdry 5 target drives second word of data and asserts btrdy 6 target cannot get third word of data so it deasserts btrdy 7 target drives third word of data and asserts btrdy 8 target cannot get fourth word of data so it deasserts btrdy 9 target drives fourth word of data and asserts btrdy 779 line read with initiator waits this occurs when line of data is requested from the target and the initiator cannot accept all of the data inclock bframe baddr bdata birdy btrdy bsel d0003april 19 2001 lx5180 lexra proprietary confidential 79 release 19 successive cycles 1 initiator drives address and asserts bframe 2 targetassertsbselitdoesnthavedatasoitdoesnotassertbtrdyinitiatorassertsbirdy to indicate that it can accept data 3 target now has data so it drives the data and asserts btrdy 4 target drives second word of data initiator cannot accept it so it deasserts birdy 5 target holds second word of data initiator can accept it and asserts birdy 6 target drives third word of data initiator accepts it 7 targetdrivesfourthwordofdatainitiatorcannotacceptitanddeassertsbirdyinitiatorhold bframe until it can assert birdy 8 initiatorassertsbirdytoacceptfourthwordofdataitdeassertsbframetoindicatethisis the last word of data 7710 burst read this is identical to the read line 7711 singlecycle write with waits singlecycle write operation occurs almost every time the lx5180 processor executes store instruction thisisbecausethecacheusedintheprocessorusesawritethroughpolicyofcoursewritestouncacheable address space and to an io device will also generate singleword write singleword write operations are used to write words halfwords and bytesclock bframe baddr bdata birdy btrdy bsel d0004april 19 2001 lx5180 lexra proprietary confidential 80 release 19 singleword write without waits requires two cycles 1 initiator asserts bframe and drives address 2 targetsamplesaddressandassertsbselinitiatordrivesdataandassertsbirdyinthiscase target is also able to accept data so it asserts btrdy initiator also deasserts bframe to indicate that it is ready to send the last and only word of data 3 target accepts data deasserts btrdy and bsel initiator deasserts birdy 7712 singlecycle write with waits this is an example of singlecycle write operation where the target cannot immediately accept data and must insert wait states thisisthesamedescriptionastheaboveexampleexceptthatthetargetinsertstwowaitstatesuntilitasserts birdy to indicate acceptance of data 7713 burst write with waits aburstwriteoperationisgenerallyusedtotransferlargeamountsofdatafromaniodevicetomemoryviaclock bframe baddr bdata birdy btrdy bsel d0005 clock bframe baddr bdata birdy btrdy bsel d0006april 19 2001 lx5180 lexra proprietary confidential 81 release 19 dma transfer the following illustrates bestcase scenario with wait states 1 initiator drives address and asserts bframe 2 targetassertsbselandbtrdytoindicateitwillacceptdatainitiatordrivedataandasserts birdy 3 initiator drives next word of data target continues to accept data and indicates as such by tinuing to assert btrdy 4 initiator drives third word of data target continues to accept 5 initiatordrivesfourthwordofdataanddeassertsbframetoindicatethatthiswillbeitslast word sent target accepts data 6 target deasserts btrdy and bsel initiator gives up control of the bus by deasserting birdy 7714 burst write with target waits this example is similar to the above example except that during the third and fourth data word transfer the target cannot accept the data quickly enough so it deasserts btrdy which indicates to the initiator that it should hold the data for an additional cycle 7715 burst write with initiator waits the example illustrates what happens when the initiator cannot supply data fast enough and has to insertclock bframe baddr bdata birdy btrdy bsel d0007 clock bframe baddr bdata birdy btrdy bsel d0008april 19 2001 lx5180 lexra proprietary confidential 82 release 19 waits 78 lbc signals thetablebelowsummarizesthelx5180lbcportsthelbcportcolumnindicatesthenameoftheport suppliedbythelbcthebussignalcolumnindicatesthecorrespondinglexrabussignalthelbcports are strictly unidirectional while the bus signals at least conceptually include multiple sources and sinks the manner in which lbc ports are connected to bus signals is technology dependent and may employ tri state drivers or logic gating in conjunction with the lbcs lcoe ldoe and ltoe outputs table 39 lbc interface signals io lbc port bus signal description output laddro310 baddr310 lbc address output ldatao310 bdata310 lbc data input ldatai310 bdata310 system data output lirdy birdy lbc initiator ready input lirdyi birdy system initiator ready output lframe brame lbc transaction frame input lframei bframe system transaction frame input lsel bsel system slave select input ltrdy btrdy system target ready output lcmd60 bcmd60 lbc command output lreq lbc bus request input lgnt system bus grant output lcoe90 lbc command output enable terms output ldoe70 lbc data output enable terms output ltoe lbc transaction output enable termsclock bframe baddr bdata birdy btrdy bsel d0009april 19 2001 lx5180 lexra proprietary confidential 83 release 19 79 arbitration 791 rules the following are the rules for arbitration gntgrant reqrequest 1 masterassertsreqatthebeginningofacycleandmaystartsamplingforassertedgntinthe same cycle in case gnt is already asserting in the case of park 2 if bus is idle or it is the last data phase of the previous transaction when master samples asserted gnt master may assert frame on next cycle 3 ifthebusisbusywhenthemastersamplesgntismustalsosnoopframeirdyandtrdy onecycleafterframeisnotassertedandbothirdyandtrdyareassertedindicatingthe last data phase if gnt is still asserted master may now drive frame ie gnt frame_r irdy_r trdy_r 792 lbc behavior the lbc when it need access to the bus asserts req and in the same cycle samples gnt frame and either irdy or irdy trdy if these are true then the lbc will on the next cycle take ownership of the bus req is deasserted on the cycle after lbc asserts frame if the bus is busy lbc continues to snoop these four signals for this condition all other lbus arbitration rules can be based on this behavior of the lbc 710 connecting devices to the bus there are three sets of output enables toevalid for the length of the transaction coe valid for only the first cycle of transaction and doe valid for data transfers asserted by the master for writes and by the slave for reads toe is intended to qualify frame irdy coe is intended to qualify cmd addr doe is intended to qualify data there is output enable to qualify trdy and sel these are defined by customer logic for slave devices insteadofusingtoeitmaybedesirabletoinsteadoralloftheframesignalseithercentrallyoroneor gate for each target and master the same holds true for irdy trdy and sel this simplifies the connections when relatively few number of devices are used and there are offchip devices connected directly to the lexra bus therefore it is defined that masters and slaves not taking part in transaction always keep frame irdy trdy and sel driven and deassertedapril 19 2001 lx5180 lexra proprietary confidential 84 release 19 april 19 2001 lx5180 lexra proprietary confidential 85 release 19 8 lx5180 coprocessor interface thelx5180processorprovidescustomeraccesspointsforthecoprocessorinterfacesthissectionprovides description of these access points attachment of memory devices to the lmis the system bus and the ejtag interface are described in separate chapters 81 attaching coprocessor using the coprocessor interface ci acoprocessormaycontainupto32generalregistersandupto32controlregisterseachoftheseregistersis up to 32 bits wide typically programs use the general registers for loading and storing data on which the coprocessor operates data is moved to the coprocessors general registers from the cores general registers with the mtcz instruction data is moved from the coprocessors general registers to the cores general registers with the mfcz instruction main memory data is loaded into or stored from the coprocessors general registers with the lwcz and swcz instructions programs may load and store the coprocessors control registers from the cores general registers with the ctczandcfczinstructionsrespectivelyprogramsmaynotloadorstorethecontrolregistersdirectlyfrom main memory the coprocessor may also provide condition flag to the core the condition flag can be bit of control registeroralogicalfunctionofseveralcontrolregistervaluestheconditionflagistestedwiththebcztand bczfinstructionstheseinstructionsindicatethattheprogramshouldbranchiftheconditionistruebczt or false bczf 82 coprocessor interface ci signals the ci provides the mechanism to attach the custom coprocessor to the core the ci snoops the instruction bus for coprocessor instructions and then gives the coprocessor the signals necessary for reading or writing the general and control registers table 40 coprocessor interface signals signal io description czcondin input cop branch ﬂag czrd_addr40 output cop read address czrhold output cop hold condition one stalls coprocessor czrd_gen output cop general register read command czrd_con output cop control register read command czrd_data310 input cop read data czwr_addr40 output cop write address czwr_gen output cop general register write command czwr_con output cop control write address command czwr_data310 output cop write data czinvld_m output cop invalid instruction ﬂag one indicates invalid instruction in m stageapril 19 2001 lx5180 lexra proprietary confidential 86 release 19 theaddressesoutputdataandcontrolsignalsaresuppliedtotheuserscoprocessorontherisingedgeofthe system clock in the case of read cycle the coprocessor must supply the data from either the control or generalregisteronczrd_databytheendofthesamecyclesimilarlythewriteofdatafromczwr_data to the addressed control or general register must be complete by the end of the cycle the ci incorporates forwarding path so that data which is written in instruction n can be read in instruction n 2 the coprocessor registers should be implemented as positiveedge flipflops using the lx5180 system clock 83 coprocessor write operations duringacoprocessorwritethecisendsczwr_addrandczwr_dataandassertseitherczwr_genor czwr_con the coprocessor must ensure that the coprocessor completes the write to the appropriate register on the subsequent rising edge of the clock the target register is decoding of czwr_addr czwr_gen and czwr_con use these instructions to cause coprocessor write lwcz mtcz and ctcz 84 coprocessor read operations during coprocessor read the ci sends czrd_addr and asserts either czrd_gen or czrd_con the coprocessor must return valid data through czrd_data in the following clock cycle if the core asserts czrhold indicating that it is not ready to accept the coprocessor data the coprocessor must hold the previous value of czrd_data the target register for the read is decoding of czrd_addr czrd_gen and czrd_con the instructions causing coprocessor read are swcz mfcz and cfcz the cpu stalls the pipeline so that the program can access data read by coprocessor instruction in the immediatelyfollowinginstructionforexampleifanmfczinstructionreadsdatafromthecoprocessorand stores it in the cores general register 4 the program can get access to that data in the following instruction when the core initiates coprocessor read the coprocessor must return valid data in the following clock cycle the coprocessor cannot stall the cpu applications must ensure that the source code does not access invalid coprocessor data if the coprocessor operations take several clock cycles to complete this is done in one of three ways ensure that code does not access data from the coprocessor until n instructions after the coprocessor operation has stared this is the least desirable method as it depends on the relative execution of the core and coprocessor it can also complicate software debug have the coprocessor send an interrupt to the core and the service routine for that interrupt accesses the appropriate coprocessor registers havethecoprocessorsettheczcondinflagwhenitsoperationiscompletethesourceczxcpn_m output copexceptionﬂagoneindicatesexception in m stage mfc2 4 3 move from cop2 to cpu register 4 subu 5 4 2 subtract r2 from r4 and store in 5signal io descriptionapril 19 2001 lx5180 lexra proprietary confidential 87 release 19 code can poll the flag as shown in the example below 85 coprocessor interface and pipeline stages coprocessorwritesoccurinthewstageoftheinstructionpipelineforcoprocessorreadsthecoregenerates address rd_gen and rd_con signals during the s stage and the coprocessor returns data during the stage whichispassedbythecitothecoreinthemstagethecoreintroducesapipelinebubbleaftercoprocessor instructions to ensure that the result of mtcz instruction can be used by the immediately following instruction in particular if there are backtoback mtcz and mfcz instructions that access the same coprocessor register the pipeline bubble still does not allow cycle between the w stage write and stage read as required in this case special forwarding path within the ci is used that is the true data from the coprocessor is ignored instead the exact data from the mtcz is used mtc2 i d s m w bubble i d mfc2 i d s m w data forwarded by ci from mtc2 wr_gen w x rd_gen s x rd_datae x theforwardingpathcancausesideeffectsifthecoprocessordoesnotimplementallofthebitsofaregister contains readonly bits or updates the register value upon reading the register in such cases the mfc2 instructionreturnsdifferentdatafromwhatitwouldifthecoredidnotactivatetheforwardingpathtoavoid the forwarding path another instruction must be inserted between the mtc2 and mfc2 mtc2 i d s m w bubble i d foo i d s m w mfc2 i d s m w read data from coprocessor wr_gen w x rd_datae x 851 pipeline holds thecoprocessormustregisterthereadaddressandthecontrolsignalsrd_genandrd_conitmustholdthee stage registered values of these signals when cz_rhold is active high and should make the read data output function of the stage registered read address and control signals thewr_addrwr_datawr_genandwr_consignalsneednotberegisteredthecoprocessormaydecodethese w stage signals directly to the appropriate register 852 pipeline invalidation under certain circumstances the instruction pipeline can contain an instruction that must be discarded this can be due to mispredicted branches cache misses exceptions inserted pipeline bubbles etc in such casesmtc2 2 3 store data to cop2 general register 3 ctc2 3 5 set cop2 control register 5 to start nop loop bc2f loop branch back to loop if czcondin bit off nop branch delay slot mfc2 4 7 get results from cop2 general register 7april 19 2001 lx5180 lexra proprietary confidential 88 release 19 the ci may decode an instruction that must actually be discarded for the coprocessor writetype instructions the ci will only issue the w stage control signals wr_gen and wr_con for valid instructions the coprocessor does not need to qualify these controls forthecoprocessorreadtypeinstructionsthecimayissuethesstagecontrolsignalsrd_genandrd_confor instructions that must be discarded if the coprocessor can tolerate speculative reads then it need not qualify those signals however if the coprocessor performs destructive reads such as updating fifo pointer upon read then it must use the qualifying signals cz_xcpn_m and cz_invld_m as follows thesignalcz_xcpn_msignalisusedtodiscardanysstagefromcird_genorrd_consignalandanye stage registered in the coprocessor rd_gen or rd_con signal it indicates that preceding instruction in the pipe has taken an exception and that subsequent instructions in the pipe must be discarded the signal cz_invld_m signal is used to invalidate the operation of the current instruction in the m stage this can be for various reasons not limited to an exception on preceding instruction if the coprocessor cannot tolerate speculative reads it must register an m stage version of rd_gen and rd_con the coprocessor must use the cz_rhold signal to hold this m stage version as well as the stage version if cz_invld_m is asserted then any such m stage signals must be discarded to summarize rd_gen or rd_con instruction can retire only if it reaches the m stage and neither cz_rhold nor cz_invld_m is assertedapril 19 2001 lx5180 lexra proprietary confidential 89 release 19 9 lx5180 ejtag 91 introduction given the increasing complexity of soc designs the nature of embedded processordesign debug hardware and software and the timetomarket requirements of embedded systems debug solution is needed which allows onchip processor visibility in costeffect io constrained manner lexrasejtagsolutionmeetsallsuchrequirementsitusesexistingieeejtagpinsaswellasfastbringup on new designs it provides way of debugging all devices accessible to the processor in the same way the processor would access those devices itself using ejtag debug probe can access all the processor internalregistersandcachesitcanalsoaccessdevicesconnectedtothelexrabusbypassinginternalcaches and memories software debug is enhanced by ejtag features that allow singlestepping through code and halting on breakpoints hardware and software address and data with masking for debugging problems that are artifacts of realtime interactions ejtag gives realtime program counter trace capabilities from which an accurate program execution history is derived for the codesystem perspective pc profiling provides statistical analysis of code usage to aim code optimization 92 overview adebughostcomputercommunicatestotheejtagprobethrougheitheraserialorparallelportorethernet connectiontheprobeinturncommunicatestothelx5180ejtaghardwareviatheincludedieee11491 jtaginterfacethroughtheuseofthejtagtapcontrollerprobedataisshiftedintototheejtagdataand control registers in the lx5180 to respond to processor requests dma into system memory configure the ejtag control logic enable singlestep mode or configure the ejtag breakpointregistersthroughtheuse of the ejtag control registers the user can set hardware breakpoints on the instruction cache address data cache address or data cache data values physical address range 0xff20_0000 to 0xff3f_ffff is reserved for ejtag use only and should not be mapped to any other device currentlyembeddedperformanceincepiandgreenhillsincprovideejtagdebuggersandprobesfor the lx5180 information on these products is available at the following web sites epi inc httpwwwepitoolscom green hills inc httpwwwghscom lx5180 ejtag implements all required features of version 200 of the ejtag specification and includes support for the following features processor access of host via addressing of probe memory space host probe can dma directly into system memory or io devices hardware breakpoints on internal instruction and data busses singlestep execution mode realtime program counter trace debug exception and two new debug instructions one for raising debug exception via software and one for returning from debug exceptionapril 19 2001 lx5180 lexra proprietary confidential 90 release 19 921 ieee jtagspeciﬁc pinout ieee jtag pins used by ejtag are shown below these are required for all ejtag implementations jtag_trst_n is an optional pin table 41 ejtag pinout table 42 ejtag ac characteristics1 table 43 ejtag synthesis constraints2 93 single processor pc trace the lx5180 ejtag includes support for realtime program counter trace pc trace when in pc tracesignal name io description jtag_tdo_nr output serial output of ejtag tap scan chain jtag_tdi input serial input to ejtag tap scan chain jtag_tms input test mode select connected to each ejtag tap controller jtag_clock input jtag clock connected to each ejtag tap controller jtag_trst_n input tap controller reset connected to each ejtag tap controllera this pin is optional in multiprocessor conﬁgurations signal parameter condition min max unit jtag_clock frequency 1 40 mhz duty cycle 4060 6040 jtag_tms setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdi setup to tck rising edge 18v 5 ns hold after tck rising edge 18v 5 ns jtag_tdo_nr outputdelaytckfallingedgetotdo 18v 0 7 ns 1 based on epi interface speciﬁcations for majictm and majicplus tmsignal name probe budget core budget slack remaining for other logic jtag_tdo_nr 0 to 7ns 115ns 135 to 205ns jtag_tdi 5ns 135ns 65ns jtag_tms 5ns 135ns 65ns 2 based on 25ns jtag clock periodapril 19 2001 lx5180 lexra proprietary confidential 91 release 19 mode the lx5180 will serially output new value of the program counter whenever change in program control occurs ie branch or jump instruction or an exception when the pc trace option is set to export in lconfig the following signals will be output from the lx5180 dclk pcst and tpc these are described in more detail in the following subsections the dclk output is used to synchronize the probe with the lx5180s sysclk the pcst pc trace status signals are used to indicate the status of program execution example status indications are sequential instruction pipeline stall branch or exception the tpc pins output the value of the pc every time there is change of program control 931 pc trace dclk debug clock the maximum speed allowed for the debug clock dclk output is 100mhz as an epi probe requirement as cores typically run in excess of this speed dclk can be set to divided down value of sysclk this is set by the dclk n parameter in lconfig which indicates the ratio of sysclk frequency to dclk 1 2 3 or 4 932 pc trace pcst program counter status trace theprogramcounterstatuspcstoutputcomprisesnsetsof3bitpcstvalueswherenisconfigurable as123or4via lconfigapcstvalueisgeneratedeverysysclkcyclewhendclkisslowerthanthe lx5180s sysclk up to n pcst values are output simultaneously 933 pc trace tpc target program counter the bus width of the target program counter tpc output is user configured in lconfig via the m parametertobeoneof124or8bitswhenchangeinprogramflowoccursthecurrentpcvalueissentout oftpcasthepcis32bitswidethenumberoftpcpinsaffectshowquicklythepcissentforexample if the tpc is 4 bits wide the pc will take 8 dclk cycles to be sent if another change in flow occurs while thepcofthepreviouschangeisbeingtransmittedthenewpcwillbesentandtheremainderoftheprevious pc will be lost the tpc bus also outputs the exception type when an exception occurs the exception type fieldwidth is either3or4bitsdependingonwhetherornotvectoredinterruptsarepresentthisiscoveredinmoredetail below toreducepinoutthetdooutputisusedfortheleastsignificantbitoftpcortheonlybitifmissetto1 934 singleprocessor pc trace pinout table 44 singleprocessor pc trace pinout signal name io description jpt_tpc_dr m bitsopthe pc value is output on these pins when pcdiscontinuity occursa jpt_pcst_dr n3 bitsop pc trace status outputs current instruction type every dclk jpt_dclk op pcst and tpc clock frequency determined as fraction of sysclk via the n parameter maximum frequency of dclk is 100mhzapril 19 2001 lx5180 lexra proprietary confidential 92 release 19 table 45 singleprocessor pc trace ac characteristics1 935 vectored interrupts and pc trace the ejtag pc trace facility specifies 3bit code be output on the tpc output when an exception occurs thepcstpinsgivetheexpcodeinordertodistinguishtheeightvectoredinterruptsinthelx5180from all other exceptions 4bit code is used instead for all exceptions otherthan vectored interrupts the most significant bit of the 4bit code is zero and the remaining 3bits are the standard 3bit code note that this includes the standard software and hardware interrupts numbered 0 through 7 for vectored interrupts the most significant bit is always 1 the 4bit code is simply the number of the vectored interrupt from 8 through 15 being taken since the target of the vectored interrupt is determined by the contents of the intvec register the debug softwarewhichmonitorstheejtagpctracecodesmustbeawareofthecontentsofthisregisterinorderto trace the code after the vectored interrupt is taken for probes that do not support 4bit exception code the lx5180 can be configured via the ejtag_xv_bits lconfig option to use only the 3bit standard codes in that case if vectored interrupt is taken the 3bit code for reset will be presented 936 demultiplexing of tdo and tdi during pc trace in normal ejtag pc trace tdi and tdo are multiplexed with the debug interrupt dint and the lsb of the tpc tpc0 when in pc trace mode this reduces the number of pins required by pc trace but has the unfortunate sideaffect of preventing any access to ejtag registers during pc trace in order to allow access to ejtag registers during pc trace and to facilitate pc trace in multiprocessor environments the lconfig option jtag_trst_is_tpcyes causes tdi and tdo to be demultiplexed suchthattrstisusedastpc0anddintisgeneratedviaejtagregistersnotesettingthisoptionmay require changes in ejtag probe hardware check with probe manufacturer for detailsa tpc0 is multiplexed with tdo in the singleprocessor pc trace solution signal parameter min max unit jtag_dclk frequency dc 100 mhz dclk high time 4 ns low time 4 ns tpc setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns pcst setup to dclk falling edge at probe 0 ns hold after dclk falling edge 4 ns 1 based on epi interface speciﬁcations for majictm and majicplus tmapril 19 2001 lx5180 lexra proprietary confidential 93 release 19 appendix lx5180 lconﬁg forms a1 conﬁguration options for the lx5180 processor this section provides summary of the configuration options available with lconfig refer to lconfigforms for detailed description of these form options product lexra processor name product_type indicates product type technology identifies target technology testbed_env identifies simulation testbed environment type reset_type flipflop reset method reset_dist reset distribution method sleep include clock sleep support reset_buffers reset buffers at toplevel module clock_buffers clock buffers at toplevel module ram_clock_buffers lmi ram clock distribution method cop1 coprocessor interface 1 cop2 coprocessor interface 2 cop3 coprocessor interface 3 ce0 custom engine 0 ce1 custom engine 1 m16_support 16bit opcode support mem_line_order cache line fill beat ordering mem_first_word cache line fill first word mem_granularity main memory system partial word write support system_interface system bus interface type lbc_wbuf lexra bus controller write buffer depth lbc_rbuf lexra bus controller read buffer depth lbc_rdbypass lexra bus controller read bypass enable lbc_sync_mode lbc synchronousasynchronous selection line_size cache line size in words icache instruction cache size dcache data cache size imem local instruction ram with line valid bits irom local instruction rom dmem local scratch pad data ram lmi_data_granularity dcache and dmem write granularity lmi_range_source source of lmi address ranges lmi_ram_arb allow external agents to arbitrate for lmi rams jtag internal jtag tap controller with ejtag support ejtag ejtag debug support ejtag_inst_break number of instruction breaks to be compiled ejtag_data_break number of data breaks to be compiled jtag_trst_is_tpc trst pin is tpc out instead of tdotpc mux pc_trace ejtag pc trace pins ejtag_dclk_n ejtag pctrace dclk n parameter ejtag_tpc_m ejtag pctrace tpc m parameter ejtag_xv_bits ejtag pctrace number of exception vector bits ejtag_pc_isabit ejtag pctrace include isa as pc bit0 scan_insert controls scan insertion and synthesis scan_mix_clocks scan chains can cross clock boundaries with lockup latches scan_num_chains number of scan chainsapril 19 2001 lx5180 lexra proprietary confidential 94 release 19 scan_scl scan collar insertion on ram interfaces sen_dist scan enable distribution method sen_buffers scan enable buffering ram_bist_mux include test ram mux and portsapril 19 2001 lx5180 lexra proprietary confidential 95 release 19 appendix b lx5180 port descriptions all ports must be connected to valid logiclevel sources the timing information indicates the point within cycle when the signal is stable in terms of percent the timing information also includes parenthetical references to these notes 1 clocked in the jtag_clock domain 2 clocked in the busclk domain if crossbar or lbc are asynchronous otherwise clocked in the sysclk domain 3 does not require constraint eg clock 4 constant that is treated as false path for timing analysis these inputs must not change after the processor is taken out of reset 5 timing is speciﬁed with symbol in techvarsscr script eg ram timing 6 atestrelatedinputoroutputthatistreatedasfalsepathfortiminganalysissuchinputsmust not change during normal atspeed operation 7 an asynchronous input if clock domain is specified the signal is clocked in the sysclk domain the table below shows the possible port connections for the top level module of the lx5180 processor known as lx2 the actual ports that are present depends upon lconfigsettings the timing information and notes have the same meaning as for the previous table names that include _n indicate active low signals all other signals are active high unless otherwise indicated forsinglebitsignalsthesignalnameandsignaldescriptionindicatetheactionorfunctionwhenthesignalis in the active state table 46 lx5180 processor port summary port name io timing description clocking reset interrupts and control sysclk input 3 processor clock sysclkf input 3 freerunningprocessorclockifproces sor is conﬁgured with sleep support sl_sleepsys_r output 30 clock gating term for sysclk if pro cessorisconﬁguredwithsleepsupport busclk input 3 bus clock if processor is conﬁgured with async lbc busclkf input 3 free running bus clock if processor is conﬁgured with async lbc sleep sup portapril 19 2001 lx5180 lexra proprietary confidential 96 release 19 sl_sleepbus_br output 30 clock gating term for busclk if pro cessor is conﬁgured with async lbc and sleep support resetn input 10 warm reset or reset button active low cresetn input 10 cold reset or power on active low reset_d1_r_n input 30 sysclk domain reset combination of resetn cresetn ejtag reset_d1_br_n input 30 busclk domain reset combination of resetn cresetn ejtag reset_pwron_c1_n input 30 power on reset copy for jtag reset_pwron_d1_lr_n input 30 sysclk domain power on reset for ejtag reset_d1_r_n_o output 30 sysclk domain reset combination of resetn cresetn ejtag reset_d1_br_n_o output 30 2 busclk domain reset combination of resetn cresetn ejtag reset_pwron_c1_n_o output 30 power on reset copy for jtag reset_pwron_d1_lr_n_o output 30 sysclk domain power on reset for ejtag intreq_n152 input 7 interrupt requests ext_halt_p input 50 external stall line ext_sleepreq_r input 30 external sleep request conﬁguration cfg_tlb_disable input 4 disable tlb mappings even if tlb is present cfg_sleepenable input 4 sleep enable conﬁguration cfg_rad_lexop50 input 4 lexop encoding must be 011111 for lx5180 cfg_rad_disable input 4 lexop disable conﬁguration must be one for lx5180 cfg_singleissue input 4 forcessingleinstructionissuemustbe zero for lx5180 which issues at most one instruciton per clock cfg_hlenable input 4 strap to one to enable internal hilo registers cfg_macenable input 4 strap to one to enable internal mac if present cfg_memsequential input 4 strap to one if line reads return words in sequential order zero if interleave orderport name io timing descriptionapril 19 2001 lx5180 lexra proprietary confidential 97 release 19 cfg_memzerofirst input 4 strap to one if line reads return word zero ﬁrst zero if desired word ﬁrst cfg_memfullword input 4 strap to one if main memory must be written with 32bit words zero if byte and halfword writes are allowed cfg_lbcwbdisable input 4 strap to one to disable read bypass of lbc write buffer zero to allow read bypass cfg_ejtnminus110 input 4 strap with ejtag dclk n minus 1 conﬁguration 0314 cfg_ejtmlog210 input 4 strap with ejtag m log2 031248 conﬁguration cfg_ejt3bitxvtpc input 4 strap with etjag 3bit tpc conﬁgura tion cfg_ejtbit0m16 input 4 strap with ejtag pc bit0 in tpc ﬁguration cfg_dwbase3110 input 30 strapped with dmem base address conﬁguration value cfg_dwtop2310 input 30 strapped with dmem top address ﬁguration value cfg_iwbase3110 input 30 strappedwithimembaseaddresscon ﬁguration value cfg_iwtop2310 input 30 strapped with imem top address ﬁguration value cfg_iwrom input 4 straptoonetotreatimemlikearom note new applications should use irom instead of romlike imem cfg_iroff input 4 strap to one to disable irom cfg_dwdisw input 4 strap to one to disable processor dmem writes must be zero for lx5180 cfg_ejdis input 4 must be strapped to zero test and debug jtag_reset_o output 20 1 jtag is in testlogicreset state active low jtag_reset input 6 jtag is in testlogicreset state active low tap_reset_n_o output 20 1 tap controller reset tap_reset_n input 6 tap controller reset jtag_tdo_nr output 50 1 test data out active low jtag_tdi input 60 1 test data inport name io timing descriptionapril 19 2001 lx5180 lexra proprietary confidential 98 release 19 jtag_tms input 60 1 test mode select jtag_clock input 3 test clock jtag_trst_n input 6 test reset jtag_capture output 20 1 jtag is in data register cap ture state jtag_scanin output 50 1 scan input to chain jtag_scanout input 50 1 scan output from chain jtag_ir40 output 20 1 contents of instruction regis ter jtag_shift_ir output 20 1 jtagisinshiftinstructionreg ister state jtag_shift_dr output 20 1 jtag is in shift data register state jtag_runtest output 20 1 jtag is in runtest state jtag_update output 20 1 jtag is in data register update state ejc_ecrprobeen_r output 30 one indicates ejtag probe is active jpt_pcst_drm10 output 30 ejtagpctracestatusm124or8 jpt_tpc_drn310 output 30 ejtag pc trace value n 1 2 3 or 4 jpt_dclk output 3 ejtag pc trace clock sen input 6 scan enable active high tmode input 6 test mode active high sink0 input 6 scan input k can range from 7 to 0 soutk0 output 6 scan output k can range from 7 to 0 rbc_sel70 input 6 ram bist ram select code 10000000 instruction mem 01000000 data mem 00100000 dcache data store 00010000 dcache tag store 00001000 icache tag store set 1 00000100 icache inst store set 1 00000010 icache tag store set 0 00000001 icache inst store set 0 rbc_wek0 input 6 rambistwriteenablewherekis0 for word write granularity 3 for byte write granularity rbc_re input 6 ram bist read enable rbc_cs input 6 ram bist select rbc_addr150 input 6 ram bist addressport name io timing descriptionapril 19 2001 lx5180 lexra proprietary confidential 99 release 19 rbc_datawr310 input 6 ram bist write data rbm_datard310 output 6 ram bist read data lbc interface to lbus laddro310 output 2 20 address lcmdo60 output 2 20 lbc command ldatao310 output 2 20 lbc data ldatai310 input 2 50 system data lirdyo output 2 20 lbc initiator ready lirdyi input 2 30 system initiator ready lframeo output 2 20 lbc transaction frame lframei input 2 30 system transaction frame lsel input 2 30 system slave select ltrdyi input 2 30 system target ready xbrdvld input 2 30 crossbar read data valid xbrdsize input 2 30 split read data size spltrdfull output 2 30 read data queue full lid output 2 20 instructiondata luc output 2 20 bus request lcoe90 output 2 20 command output enable ltoe output 2 20 transaction output enable ldoe70 output 2 20 data output enable lreq output 2 50 bus request lgnt input 2 30 bus grant shared ram requestgrant interface ext_iwreqram_r input 30 external hardware drives to one to request access to imem iw_gntram_r output 30 cpu drives to one to grant external imem access request ext_dwreqram_r input 30 external hardware drives to one to request access to dmem dw_gntram_r output 30 cpu drives to one to grant external dmem access request ext_icreqram_r input 30 external hardware drives to one to request access to icache ic_gntram_r output 30 cpu drives to one to grant external icache access requestport name io timing descriptionapril 19 2001 lx5180 lexra proprietary confidential 100 release 19 ext_dcreqram_r input 30 external hardware drive to one to request access to dcache dc_gntram_r output 30 cpu drives to one to grant external dcache access request coprocessor interface czcondin input 80 cop branch ﬂag czrd_addr40 output 50 cop read address czrhold output 45 cop hold condition one stalls copro cessor czrd_gen output 50 cop general register read command czrd_con output 50 cop control register read command czrd_data310 input 80 cop read data czwr_addr40 output 20 cop write address czwr_gen output 20 cop general register write command czwr_con output 20 cop control write address command czwr_data310 output 30 cop write data czinvld_m output 60 cop invalid instruction ﬂag one indi cates invalid instruction in m stage czxcpn_m output 60 cop exception ﬂag one indicates exception in m stage c3cnt_iparet output 20 count instructions retired pipe c3cnt_ipbret output 20 count instructions retired pipe b c3cnt_ifetch output 20 count instruction fetches c3cnt_imiss output 20 count icache misses c3cnt_istall output 20 count icache stalls c3cnt_dmiss output 20 count dcache misses c3cnt_dstall output 20 count dcache stalls c3cnt_dload output 20 count data load operations c3cnt_dstore output 20 count data store operations custom engine interface cei_ce1hold output 45 cpu is halting custom engine cei_ce1invld_m output 40 instruction is not valid m stage cei_ce1invldp_s_r output 30 instruction is not valid s stage cei_xcpn_m_c1 output 40 cpu reports exception cei_ce1op_s_r110 output 30 custom engine op codeport name io timing descriptionapril 19 2001 lx5180 lexra proprietary confidential 101 release 19 cei_instm32_s_r_c1_n output 30 one indicates 32bit instruction mode zero indicates 16bit instruction mode cei_ce1aop_e_r310 output 35 operand cei_ce1bop_e_r310 output 35 b operand ce1_res_e310 input 45 result from custom engine ce1_sel_e_r input 30 one indicates custom engine opcode is present in stage ce1_halt_e_r20 input 20 custom engine stalls processor by drivingtoonesallowsprocessortorun by driving to zeros copies must be suppliedfrommultipleregisterstomeet timing requirementsport name io timing descriptionapril 19 2001 lx5180 lexra proprietary confidential 102 release 19 april 19 2001 lx5180 lexra proprietary confidential 103 release 19 appendix c lx5180 pipeline stalls this section documents stall conditions that may arise in the lx5180 c1 stall deﬁnitions issue stall an invalid instruction enters the pipe while any other valid instructions in the pipe advance pipeline stall all instructions in either pipe stay in the same stage and do not advance stall if not otherwise qualified means pipeline stall c2 instruction groupings these instruction groupings are used to describe stall conditions that are based on the type of instructions in the pipeline table 47 instruction groupings for stall deﬁnition c3 nonsequential program flow issue stall jr jalr two issue stalls after the delay slot instruction j jal and taken branches stall cycles after the delay slot instruction nottaken branches two issue stalls after the delay slot instruction the branch rules are consequence of the fact that all branches are predicted to be takengroup name instructions in group miloadstore lb lh lw lbu lhu lwc1 lwc2 lwc3 sb sh sw swc1 swc2 swc3 micontrol j jalx jr jalr bltzal bgezal linked branches syscall break all copz mfcz cfcz mtcz ctcz bcfz bctz rfe lwcz swcz also in loadstore group miunlinkedbranch beq bne blez bgtz bltz bgez migeneral all remaining instructions mivcmove movz movn ejtagcontrol deret sdbbp m16sdbbpapril 19 2001 lx5180 lexra proprietary confidential 104 release 19 94 loaduse single cycle issue stall after load instruction to target register an instruction which follows the load by one cycle and uses the target register of the load will issue stall for one cycle note the architectural loaddelay slot has been eliminated this issue stall applies even to the instruction immediately following the load c4 load subword stall load instructions which have byte or halfword operands always cause onecycle stall c5 storeload stall load instruction which follows store instruction by one cycle causes onecycle stall if the store instruction hits in the dcache or has byte or halfword operand c6 storeany storesubword stall if the lx5180 is configured to work with rams that have word write granularity store instruction which has byte or halfword operand and which follows any store instruction by one cycle always causes onecycle stall alternatively the lx5180 can be configured to work with rams support byte write granularity which eliminates the stall c7 loadstore ops stall matrix thefollowingtablesummarizesthestallrulesrelatedtoloadandstoreinstructionsdescribedaboveinthis table the 2nd op refers to an instruction which issues in the cycle after the 1st op table 48 loadstore ops stall matrix notes means stalls xu indicates unconditional stall for the indicated number of cycles xs indicates stall only if 2ndop source 1stop loadtarget xw indicates stall if data rams have wordwrite granularity c8 mvcz stall the coprocessor move instructions lwcz mtcz mfcz and mtlxc0 mflxc0 are always followed by single cycle issue stall1st op 2nd op lw lt milbulhu sb sh sw non loadstore 1u lw lbu lhu 1u 1w 1u sb sh 1u 1w 1u sw 1u april 19 2001 lx5180 lexra proprietary confidential 105 release 19 c9 immu stall whentheprogramjumpsbranchesorincrementsbetweenthetwomostrecentlyusedpagesasinglecycle stall is incurred when the program jumps branches or increments to third page twocycle stall is incurred c10 immu issue stall whenanimmustalloccursduetoincrementingacrossapageboundaryandthereisanyofthefollowing instructionsfoundanywhereinthelastdoublewordofthepagethenthereisoneissuestallinadditiontothe immu stalls branch of any kind j jal ejtag dret c11 icache miss stall when an instruction cache miss occurs the processor is stalled for the duration of the cache line fill operation the number of cycles required to complete the line fill is system dependent c12 dcache miss stall when data cache miss occurs as the result of load instruction the processor stalls while it waits for the data the data cache releases the stall condition after the required word is supplied to the processor even if additionalwordsmuststillbefilledintothedatacachehoweveriftheprocessorissuesanotherloadorstore operation to the data cache while the remainder of the line fill is in progress the cache will again stall the processor until the line fill operation is completed whenadatacachemissoccursasaresultofaloadbyteorloadhalfwordtheprocessorstallsfortheduration of the cache line fill operation the number of cycles required to complete the line fill is system dependent c13 pipeline timing diagrams for stalls c131 nonsequential program flow issue stalls jrjalr jr i d s m w delayslot i d s m w notvld i notvld i target i d s j jal and taken branches j i d s m w delayslot i d s m w target i d s mapril 19 2001 lx5180 lexra proprietary confidential 106 release 19 nottaken branches bntkn i d s m w delayslot i d s m w notvld i notvld i delay4 i d s c132 load subword stall lb i d s m m w foo2 i d s m w foo4 i d s s m w rhold x c133 storeload stall sw s04a0 i d s m w lw s20a0 i d s m m w foo3 i d s m w rhold x c134 storeany store subword stall sw s04a0 i d s m w sb s20a0 i d s m m w foo3 i d s m w rhold x sh s04a0 i d s m m w sb s20a0 i d s m m w foo2 i d s s m w rhold x x c135 mvcz stall mtc0 i d s m w foo i d d s m w foo1 i d s m wapril 19 2001 lx5180 lexra proprietary confidential 107 release 19 c136 lwcz stall lwc0 i d s m w foo i d d s m w foo1 i d s m w c137 icache miss stall foo0 i d s m m m m m m w foo2 i d s m w foo4 i d i d s m w rhold x x x x x c138 dcache miss stall lw i d s m w foo2 i d s m m m m m w foo4 i d s m w rhold x x x xapril 19 2001 lx5180 lexra proprietary confidential 108 release 19